[
    {
        "path": "frontend/src/mocks/features.ts",
        "summary": "This code defines a module for managing available product features in a frontend application. It uses a `features` array to store a list of `AvailableFeature` types. The `useAvailableFeatures` function allows updating this list, and the `getAvailableProductFeatures` function transforms the stored features into a list of `BillingFeatureType` objects, where each object contains the feature's key and name (both set to the feature itself).\n\nHere's a list of high-level product features:\n\n*   **Feature Management:** Allows setting and updating the list of available features.\n*   **Feature Retrieval:** Provides a way to retrieve the available features in a format suitable for billing or display purposes.\n*   **Feature Transformation:** Converts the internal representation of features (`AvailableFeature`) to a billing-specific type (`BillingFeatureType`).\n"
    },
    {
        "path": "frontend/src/mocks/utils.ts",
        "summary": "This code defines utility functions for mocking API endpoints using the `msw` (Mock Service Worker) library. It provides a way to define mock responses for different HTTP methods (GET, POST, etc.) and paths. The `mocksToHandlers` function takes a configuration object (`mocks`) that maps HTTP methods and paths to mock handlers. These handlers can be functions that return a status code and body, or a simple JSON serializable object. The function then converts these mock definitions into `msw` request handlers, which can be used to intercept and mock API requests during testing or development.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **API Mocking:** Allows developers to mock API endpoints for testing and development purposes.\n*   **Flexible Mock Definitions:** Supports various ways to define mock responses, including functions and JSON objects.\n*   **MSW Integration:** Seamlessly integrates with the `msw` library for request interception and response mocking.\n*   **HTTP Method Support:** Supports mocking different HTTP methods (GET, POST, etc.).\n*   **Customizable Responses:** Allows developers to define custom status codes and response bodies for mock endpoints.\n*   **Network Error Simulation:** Enables simulating network errors by returning `undefined` from a mock handler.\n"
    },
    {
        "path": "frontend/src/mocks/handlers.ts",
        "summary": "This code defines a comprehensive set of mock API endpoints and data used for testing the PostHog frontend. It covers various aspects of the application, including organizations, projects, users, insights, feature flags, cohorts, dashboards, plugins, billing, and session recordings. The mocks are designed to simulate different scenarios and responses from the backend, allowing developers to test the frontend's behavior in a controlled environment.\n\nHere's a list of high-level product features that are mocked in this file:\n\n*   **Organizations and Teams:** Management of organizations, teams, members, and invites.\n*   **User Management:** User profiles, authentication (including two-factor), and personal API keys.\n*   **Feature Flags and Experiments:** Definition and management of feature flags and experiments.\n*   **Cohorts:** Creation and management of user cohorts.\n*   **Dashboards and Insights:** Creation, sharing, and viewing of dashboards and insights.\n*   **Plugins:** Installation, configuration, and management of plugins.\n*   **Billing and Invoices:** Display of billing information and invoices.\n*   **Session Recordings:** Playlists and management of session recordings.\n*   **Data Management:** Property definitions, event definitions, and group analytics.\n*   **Hog Functions:** Templates and management of Hog Functions.\n*   **Notebooks:** Creation and management of notebooks.\n*   **External Data Sources:** Management of external data sources.\n*   **Warehouse Integration:** Integration with data warehouses.\n*   **Alerts:** Management of alerts.\n*   **Comments:** Management of comments.\n*   **Activity Log:** Viewing activity logs.\n*   **Status Page:** Display of system status.\n*   **Early Access Features:** Management of early access features.\n*   **Data Color Themes:** Management of data color themes.\n*   **Domains:** Management of domains.\n"
    },
    {
        "path": "frontend/src/mocks/fixtures/_billing.tsx",
        "summary": "This code defines a mock billing data structure for a PostHog customer. It includes details about the customer's subscription, billing period, current charges, and the \"Product analytics\" product they are subscribed to. The product has both free and paid plans, each with different features and usage tiers. The data also includes information about current and projected usage, as well as the features available in each plan, such as dashboards, funnels, graphs, user paths, and data retention.\n\nHere's a list of high-level product features based on the billing data:\n\n*   **Billing Management:** Displays billing information, including customer ID, subscription status, billing period, and total amount due.\n*   **Subscription Management:** Shows the current billing plan (Free or Paid) and allows users to manage their subscription.\n*   **Product Analytics:** Provides a comprehensive product analytics platform with autocapture.\n*   **Feature Access Control:** Controls access to features based on the selected billing plan.\n*   **Usage Tracking:** Tracks current and projected usage of resources (e.g., events).\n*   **Dashboards:** Allows users to save and share insights.\n*   **Funnels:** Enables visualization of user dropoff between events.\n*   **Graphs & Trends:** Provides tools for plotting events and actions over time.\n*   **User Paths:** Visualizes user navigation paths.\n*   **Data Retention:** Specifies the duration of data retention based on the plan.\n*   **Insight & Dashboard Subscriptions:** Allows users to subscribe to regular reports.\n*   **Advanced Paths:** Enables customization of user path insights.\n*   **Correlation Analysis:** Highlights factors affecting funnel conversion rates.\n*   **Lifecycle Analysis:** Discovers active user segments.\n"
    },
    {
        "path": "frontend/src/mocks/fixtures",
        "summary": "The provided code defines mock billing data for a PostHog customer, outlining their subscription details, billing period, current charges, and usage of the \"Product analytics\" product. This product offers both free and paid plans with varying features and usage tiers. The data includes current and projected usage, along with details on available features like dashboards, funnels, graphs, user paths, and data retention policies, all dependent on the chosen plan.\n\nHere's a list of high-level product features:\n\n*   Billing Management\n*   Subscription Management\n*   Product Analytics\n*   Feature Access Control\n*   Usage Tracking\n*   Dashboards\n*   Funnels\n*   Graphs & Trends\n*   User Paths\n*   Data Retention\n*   Insight & Dashboard Subscriptions\n*   Advanced Paths\n*   Correlation Analysis\n*   Lifecycle Analysis\n"
    },
    {
        "path": "frontend/src/mocks/jest.ts",
        "summary": "This code configures a Mock Service Worker (MSW) server for testing purposes in a frontend application. It sets up the server with predefined handlers, provides a utility function `useMocks` to dynamically override handlers during tests, and mocks the `window.confirm` function. The code also includes setup and teardown steps to start the server before all tests, reset handlers after each test, and close the server after all tests have completed. It also disables all available features before running tests.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Mock API Responses:** Intercept and mock API requests during testing.\n*   **Dynamic Mock Configuration:** Override default mock handlers for specific test scenarios.\n*   **Browser API Mocking:** Mock browser APIs like `window.confirm`.\n*   **Test Environment Setup:** Provides a consistent and isolated testing environment.\n*   **Feature Flag Control:** Disable features during tests.\n"
    },
    {
        "path": "frontend/src/mocks/browser.tsx",
        "summary": "This code sets up a Mock Service Worker (MSW) for mocking API requests in a Storybook environment. It initializes the MSW worker with predefined handlers and provides utilities for dynamically overriding these handlers at the story level. The `useStorybookMocks` function allows applying custom mocks, while the `mswDecorator` enables merging default mocks with story-specific mocks, giving stories the ability to override default behaviors. Additionally, a `setFeatureFlags` function is provided to simulate different feature flag configurations within the application.\n\nHere's a list of high-level product features:\n\n*   **API Request Mocking:** Intercept and mock API requests during development and testing.\n*   **Dynamic Mock Overrides:** Override default API mocks at the Storybook story level.\n*   **Mock Handler Merging:** Merge default and story-specific mock handlers, allowing stories to customize API responses.\n*   **Feature Flag Simulation:** Simulate different application states based on feature flag configurations.\n*   **Storybook Integration:** Seamless integration with Storybook for UI component testing and development.\n"
    },
    {
        "path": "frontend/src/mocks",
        "summary": "This collection of code files establishes a comprehensive mocking framework for the PostHog frontend, enabling robust testing and development workflows. It leverages Mock Service Worker (MSW) to intercept and mock API requests, providing flexible mechanisms for defining mock responses, simulating various scenarios, and controlling feature flag configurations. The framework supports dynamic mock overrides at the test and story levels, allowing developers to tailor mock behavior to specific use cases. Furthermore, the mocks cover a wide range of product features, including user and organization management, feature flags, cohorts, dashboards, billing, session recordings, and data management, ensuring thorough testing of the frontend's interactions with the backend.\n\nHere's a list of high-level product features enabled by the code:\n\n*   API Mocking and Interception\n*   Dynamic Mock Configuration and Overrides\n*   Feature Flag Simulation and Control\n*   Comprehensive Mock Data for Core Product Features\n*   Testing Environment Setup and Management\n*   Storybook Integration for UI Component Testing\n*   Billing and Subscription Management\n*   Product Analytics and Usage Tracking\n*   User and Organization Management\n*   Feature Flags and Experimentation\n*   Dashboards and Insights\n*   Session Recordings\n*   Data Management and Governance\n"
    },
    {
        "path": "frontend/src/@types/chartjs.d.ts",
        "summary": "This code snippet extends the Chart.js library by adding a new tooltip positioner named \"cursor\". This allows developers to position tooltips relative to the user's cursor location within the chart.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Customizable Tooltip Positioning:** Allows tooltips to be positioned based on the cursor location.\n*   **Enhanced User Interaction:** Provides a more interactive chart experience by dynamically positioning tooltips.\n*   **Improved Data Exploration:** Makes it easier for users to explore data points by providing immediate information at the cursor's location.\n"
    },
    {
        "path": "frontend/src/@types/surveys-preview.d.ts",
        "summary": "The provided code declares a module for survey previews from the PostHog JavaScript library. This declaration likely serves to inform the TypeScript compiler that the `posthog-js/dist/surveys-preview` module exists and can be imported, even if its type definitions are not explicitly provided. This allows the frontend application to utilize survey preview functionality from PostHog without encountering TypeScript errors related to missing module declarations.\n\nHere's a list of high-level product features that this code snippet implies:\n\n*   **Survey Preview:** Allows users to preview surveys before they are deployed or sent to users.\n*   **PostHog Integration:** Integrates with the PostHog analytics platform to leverage its survey capabilities.\n*   **Frontend Survey Rendering:** Enables the frontend application to render and display survey previews.\n*   **TypeScript Support:** Provides TypeScript definitions or declarations for the survey preview module, ensuring type safety and improved developer experience.\n"
    },
    {
        "path": "frontend/src/index.tsx",
        "summary": "The code initializes and renders the main PostHog application within a React environment. It includes setting up Kea for state management, PostHog for analytics, and an error boundary for resilience. The application also incorporates a polyfill for country flag emojis to ensure consistent rendering across different platforms. Additionally, it exposes a function to access the Redux state in development environments for easier debugging and snapshotting.\n\nHere's a list of high-level product features based on the code:\n\n*   **Core Application Rendering:** Renders the main PostHog application UI.\n*   **State Management:** Utilizes Kea for managing application state.\n*   **Analytics Integration:** Integrates with PostHog for tracking user behavior and application performance.\n*   **Error Handling:** Implements an error boundary to catch and handle runtime errors gracefully.\n*   **Emoji Polyfill:** Provides a polyfill for rendering country flag emojis consistently across different platforms.\n*   **Development Tooling:** Exposes a function to access the Redux state for debugging and snapshotting in development environments.\n"
    },
    {
        "path": "frontend/src/@types",
        "summary": "The provided code snippets introduce features related to survey previews and enhanced chart tooltips. The survey preview declaration enables integration with PostHog for previewing surveys within the frontend application, while the Chart.js extension allows for dynamic tooltip positioning based on the user's cursor location within charts.\n\nHere's a list of high-level product features:\n\n*   Survey Preview: Allows users to preview surveys before deployment, integrating with PostHog.\n*   PostHog Integration: Leverages PostHog's survey capabilities within the application.\n*   Frontend Survey Rendering: Enables the frontend to display survey previews.\n*   TypeScript Support: Provides type definitions for survey previews.\n*   Customizable Tooltip Positioning: Positions chart tooltips based on cursor location.\n*   Enhanced User Interaction: Improves chart interaction with dynamic tooltips.\n*   Improved Data Exploration: Facilitates data exploration with immediate information at the cursor.\n"
    },
    {
        "path": "frontend/src/scenes/organization/CreateOrganizationModal.tsx",
        "summary": "This React component, `CreateOrganizationModal`, provides a modal interface for users to create new organizations within the PostHog application. It includes input validation, a link to the documentation, and utilizes the `organizationLogic` to handle the creation process. The modal is displayed based on the `isVisible` prop and can be closed using the close button or by submitting the form.\n\nHere's a list of high-level product features:\n\n*   **Organization Creation:** Allows users to create new organizations.\n*   **Modal Interface:** Provides a modal for a focused creation experience.\n*   **Input Validation:** Ensures the organization name is not empty before submission.\n*   **Documentation Link:** Offers a direct link to the PostHog documentation for more information on organizations.\n*   **Form Submission:** Enables organization creation via form submission (button click or pressing Enter).\n*   **Cancel Action:** Allows users to cancel the organization creation process.\n"
    },
    {
        "path": "frontend/src/globals.d.ts",
        "summary": "This code defines global variables accessible within the JavaScript environment of a web application. These variables configure the PostHog analytics integration, including API keys, host addresses, self-capture settings, and feature flag information. Additionally, it exposes functions for dynamically loading JavaScript modules and managing loaded chunks, along with variables to manage exported data and impersonated sessions.\n\nHere's a list of high-level product features enabled by these global variables:\n\n*   **Analytics Tracking:** Integration with PostHog for tracking user behavior and application usage.\n*   **Feature Flag Management:** Control and rollout of new features using feature flags.\n*   **Dynamic Module Loading:** Ability to load JavaScript modules on demand.\n*   **Data Export:** Mechanism for exporting data from the application.\n*   **User Impersonation:** Functionality to impersonate user sessions for debugging or support purposes.\n*   **Configuration Management:** Centralized configuration of various application settings.\n"
    },
    {
        "path": "frontend/src/scenes/organization/ConfirmOrganization/confirmOrganizationLogic.ts",
        "summary": "This code defines the logic for a form used to confirm and create a new organization during a social signup process. It manages form state, validation, submission, and URL-based initialization. The logic handles setting the user's email, displaying a warning about creating a new organization, and submitting the organization name, user's first name, and role to the backend to create the organization. Upon successful creation, the user is redirected to a success URL.\n\nHere's a list of high-level product features:\n\n*   **Organization Name Input:** Allows users to enter the name of their organization.\n*   **First Name Input:** Allows users to enter their first name.\n*   **Role Input:** Allows users to enter their role at the organization.\n*   **Form Validation:** Validates that the organization name and first name fields are not empty.\n*   **Social Signup API Integration:** Submits the form data to a backend API endpoint for social signup.\n*   **Success Redirection:** Redirects the user to a success URL after successful organization creation.\n*   **Error Handling:** Displays an error message if organization creation fails.\n*   **URL-Based Form Initialization:** Initializes the form with data passed in the URL (email, organization name, first name).\n*   **New Organization Warning:** Displays a warning message to the user when creating a new organization.\n"
    },
    {
        "path": "frontend/src/scenes/organization/ConfirmOrganization/ConfirmOrganization.tsx",
        "summary": "This component, `ConfirmOrganization`, is a page that allows a user to create a new organization within the PostHog platform. It includes a form for the user to input their name, organization name, and select their role. It also displays the user's email (disabled) and allows them to select a signup referral source. The page includes a warning message to prevent users from accidentally creating a new organization when they should be joining an existing one. The page also provides links to the terms of service, privacy policy, support, and documentation.\n\nHere's a list of the high-level product features:\n\n*   **Organization Creation:** Allows users to create a new organization.\n*   **User Information Input:** Collects user's name and organization name.\n*   **Email Display:** Displays the user's email address (disabled).\n*   **Role Selection:** Allows users to select their role within the organization.\n*   **Signup Referral Source Tracking:** Tracks how the user found PostHog.\n*   **New Organization Warning:** Warns users about accidentally creating a new organization.\n*   **Links to Legal and Support Resources:** Provides links to terms of service, privacy policy, support, and documentation.\n*   **Form Submission:** Submits the organization creation form.\n"
    },
    {
        "path": "frontend/src/scenes/organization/ConfirmOrganization",
        "summary": "The Confirm Organization feature allows new users, typically those signing up through social authentication, to create a new organization within the PostHog platform. This involves collecting necessary information such as the organization name, user's first name, and their role within the organization. The feature includes form validation, integration with a social signup API, and redirection to a success page upon completion. It also displays a warning to prevent accidental organization creation and provides links to legal and support resources.\n\nHere's a list of high-level product features:\n\n*   Organization Creation\n*   User Information Input (Name, Organization Name, Role)\n*   Email Display (Read-only)\n*   Signup Referral Source Tracking\n*   Form Validation\n*   Social Signup API Integration\n*   Success Redirection\n*   Error Handling\n*   URL-Based Form Initialization\n*   New Organization Warning\n*   Links to Legal and Support Resources\n*   Form Submission\n"
    },
    {
        "path": "frontend/src/scenes/organization/Create/index.tsx",
        "summary": "The `OrganizationCreate` component, defined in `frontend/src/scenes/organization/Create/index.tsx`, renders the `CreateOrganizationModal` directly within the scene. This modal is always visible and displayed inline, suggesting a dedicated page or section for creating a new organization. The component is connected to `organizationLogic`, implying the modal's functionality is managed by this logic.\n\n**Features:**\n\n*   **Organization Creation:** Provides a user interface for creating new organizations.\n*   **Inline Modal Display:** The creation form is displayed directly on the page, rather than as a pop-up.\n*   **State Management:** Utilizes `organizationLogic` for managing the state and logic related to organization creation.\n"
    },
    {
        "path": "frontend/src/scenes/organization/Create",
        "summary": "The `OrganizationCreate` component provides a dedicated interface for users to create new organizations. It achieves this by rendering the `CreateOrganizationModal` directly within the scene, ensuring the creation form is always visible and displayed inline. The component leverages `organizationLogic` for state management, handling the complexities of organization creation behind the scenes.\n\n**Features:**\n\n*   Organization Creation\n*   Inline Modal Display\n*   State Management with `organizationLogic`\n"
    },
    {
        "path": "frontend/src/scenes/organization/membersLogic.tsx",
        "summary": "This code defines the `membersLogic` Kea logic for managing organization members in a PostHog application. It handles loading, searching, filtering, updating, and removing members. The logic fetches members from the API, provides real-time updates, and uses Fuse.js for efficient searching. It also manages the UI state for displaying members, prioritizing the current user in the list, and displaying member counts.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Organization Member Management:** Allows administrators to view, add, remove, and modify the roles of members within their PostHog organization.\n*   **Member Search:** Enables users to quickly find specific members within the organization based on name or email.\n*   **Real-time Member Updates:** Reflects changes to organization membership in real-time, ensuring users always see the most up-to-date information.\n*   **Role-Based Access Control:** Supports different membership levels (e.g., owner, member) with varying permissions.\n*   **User Interface for Member List:** Provides a sorted and filtered list of organization members, prioritizing the current user for easy access.\n*   **Automatic Task Completion:** Marks the \"Invite Team Member\" task as completed in the activation flow when multiple members exist.\n"
    },
    {
        "path": "frontend/src/scenes/organization",
        "summary": "The provided code snippets detail features related to organization and member management within the PostHog application. These features encompass the creation of new organizations through modal and inline interfaces, including input validation and documentation links. Furthermore, the system allows for comprehensive management of organization members, including searching, filtering, updating roles, and real-time updates to reflect membership changes.\n\nHere's a consolidated list of high-level product features:\n\n*   Organization Creation (via modal and inline interfaces)\n*   Input Validation for Organization Creation\n*   Documentation Link for Organization Information\n*   Organization Member Management (view, add, remove, modify roles)\n*   Member Search\n*   Real-time Member Updates\n*   Role-Based Access Control\n*   User Interface for Member List\n*   Automated Task Completion for Activation Flow\n*   Social Signup Integration for Organization Creation\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/saved_queries/dataWarehouseViewsLogic.tsx",
        "summary": "This code defines the logic for managing data warehouse views within the PostHog application. It handles loading, creating, updating, and deleting saved queries (views) in the data warehouse. The logic also includes features for running materializations, displaying appropriate notifications, and automatically refreshing the view list. It connects to other parts of the application, such as user management and database table listing, to provide a seamless user experience.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **View Management:**\n    *   Create, read, update, and delete data warehouse views (saved queries).\n    *   List existing data warehouse views.\n*   **Materialization:**\n    *   Run materializations of data warehouse views.\n    *   Schedule materialized views with configurable sync frequency.\n*   **Real-time Updates:**\n    *   Automatic refresh of the data warehouse view list.\n*   **User Notifications:**\n    *   Display success and error messages for view creation, updates, and materialization.\n*   **Empty State Handling:**\n    *   Display a specific UI when no views exist.\n*   **Data Tracking:**\n    *   Track creation and updates of materialized views.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/saved_queries",
        "summary": "This code provides the logic for managing data warehouse views (saved queries) within PostHog, enabling users to create, read, update, and delete views, as well as run and schedule materializations. The system provides real-time updates to the view list and displays user notifications for various actions. It also includes specific UI for empty states and tracks user interactions with materialized views.\n\nHere's a list of high-level product features:\n\n*   View Management (CRUD operations)\n*   Materialization (Run and schedule)\n*   Real-time Updates\n*   User Notifications\n*   Empty State Handling\n*   Data Tracking\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/settings/source/SourceConfiguration.tsx",
        "summary": "This code defines the `SourceConfiguration` component, which allows users to update the configuration of a data warehouse source. It fetches the existing source configuration and displays a form (`SourceFormComponent`) populated with the current values. Users can modify the configuration and save the changes. The component uses Kea logic for state management and form handling. A skeleton loader is displayed while the source configuration is being fetched.\n\nHere's a list of high-level product features:\n\n*   **Display Existing Source Configuration:** Fetches and displays the current configuration settings for a selected data warehouse source.\n*   **Update Source Configuration:** Provides a form to modify and update the configuration parameters of a data warehouse source.\n*   **Form Validation and Submission:** Handles form submission and validation to ensure data integrity.\n*   **Loading State:** Displays a loading indicator while fetching the source configuration.\n*   **Save Changes:** Allows users to save the updated source configuration.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/settings/source/dataWarehouseSourceSettingsLogic.ts",
        "summary": "This code defines the logic for managing settings related to a specific data warehouse source within a PostHog application. It handles fetching, updating, and displaying details about the source, its schemas, and related jobs. The logic includes features for reloading and resyncing schemas, updating source configurations, and loading/displaying a paginated list of jobs associated with the source. It also incorporates optimistic UI updates and error handling with toast notifications.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Data Source Configuration:** Allows users to view and modify settings for a specific data warehouse source, including job inputs.\n*   **Schema Management:** Enables users to view, reload, and resync schemas associated with a data warehouse source.\n*   **Job Monitoring:** Provides a paginated list of jobs related to the data warehouse source, with the ability to load more jobs.\n*   **Real-time Updates:** Automatically refreshes source and job data at a set interval.\n*   **Error Handling:** Displays user-friendly error messages using toast notifications.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/settings/source/Syncs.tsx",
        "summary": "This component, `Syncs.tsx`, displays a table of data warehouse sync jobs for a given data source. It fetches job data, including schema name, status, rows synced, and synced at timestamp, using the `dataWarehouseSourceSettingsLogic`. The table provides visual cues for job status using LemonTags and displays error messages as tooltips when a job has failed. Users can expand each row to view logs associated with the job. The component also includes a \"Load older jobs\" button that allows users to paginate through the list of sync jobs.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Display of Data Warehouse Sync Jobs:** Shows a list of sync jobs associated with a data source.\n*   **Job Status Monitoring:** Displays the status of each sync job (Running, Completed, Failed, etc.) with corresponding visual indicators.\n*   **Error Display:** Shows error messages associated with failed sync jobs.\n*   **Job Details (Rows Synced, Synced At):** Provides information about the number of rows synced and the timestamp of the sync.\n*   **Job Logs:** Allows users to view logs associated with each sync job for debugging and troubleshooting.\n*   **Pagination:** Enables users to load and view older sync jobs.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/settings/source/Logs.tsx",
        "summary": "This code defines a `LogsView` component that displays logs associated with an external data job in a table format. It fetches logs, allows loading newer and older log entries in batches, and presents them with timestamp, level, run ID, and message. The component uses Lemon UI components for the table and buttons, and Kea for state management.\n\n**Features:**\n\n*   **Log Display:** Displays logs in a tabular format with columns for timestamp, level, run ID, and message.\n*   **Log Loading:** Fetches and displays logs associated with a specific external data job.\n*   **Pagination:** Implements pagination to handle large log datasets, displaying logs in pages.\n*   **Incremental Loading:** Allows users to load newer and older log entries in batches.\n*   **Loading Indicators:** Provides visual feedback during log loading operations.\n*   **Empty State Handling:** Displays appropriate messages when there are no new or older log entries to load.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/settings/dataWarehouseSettingsLogic.ts",
        "summary": "This code defines the logic for the Data Warehouse settings page in PostHog. It manages the loading, updating, and deletion of external data sources and their schemas. It also handles reloading sources, refreshing self-managed table schemas, and deleting self-managed tables. The logic includes optimistic UI updates, error handling, and automatic refreshing of data sources.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Data Source Management:**\n    *   Listing external data sources with pagination.\n    *   Deleting external data sources.\n    *   Reloading external data sources to sync data.\n    *   Updating external data source configurations.\n*   **Schema Management:**\n    *   Updating schemas of external data sources.\n    *   Refreshing schemas of self-managed tables.\n*   **Self-Managed Table Management:**\n    *   Deleting self-managed tables.\n*   **Real-time Updates:**\n    *   Automatic refreshing of data sources at a set interval.\n    *   Displaying loading states for sources and schemas.\n*   **User Feedback:**\n    *   Displaying success and error messages using lemonToast.\n*   **Analytics:**\n    *   Tracking user actions like deleting and reloading sources, and updating schemas using PostHog's analytics."
    },
    {
        "path": "frontend/src/scenes/data-warehouse/settings/DataWarehouseManagedSourcesTable.tsx",
        "summary": "This code defines a React component, `DataWarehouseManagedSourcesTable`, which displays a table of data warehouse sources. It fetches data about these sources using the `dataWarehouseSettingsLogic` Kea logic hook. The table displays information such as the source name, last successful run time, total rows synced, and status. It also provides actions to reload a source (triggering a new data import) and delete a source, with a confirmation dialog for the deletion action. The table uses Lemon UI components for styling and functionality, including tooltips, tags, buttons, and a dialog.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Display of Data Warehouse Sources:** Shows a list of configured data warehouse sources.\n*   **Source Details:** Displays key information about each source, including name, last successful run, total rows synced, and status.\n*   **Source Status Monitoring:** Shows the current status of each source (e.g., Running, Completed, Error) with appropriate visual indicators.\n*   **Data Import Reload:** Allows users to manually trigger a data import for a specific source.\n*   **Source Deletion:** Enables users to delete a data warehouse source, including a confirmation step to prevent accidental deletion.\n*   **Error Display:** Shows the latest error message for sources in an error state.\n*   **Links to Pipeline Node:** Provides a link to the pipeline node for each source, allowing users to view schemas.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/settings/source/schemaLogLogic.ts",
        "summary": "This code defines a Kea logic module named `schemaLogLogic` for managing and displaying logs related to external data source schemas. It fetches logs from an API, filters them based on log level and search terms, and handles pagination for loading more logs. The logic also supports background polling to fetch new logs and displays them in real-time. The component differentiates between staff and non-staff users, showing different log levels based on the user's staff status.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Log Retrieval and Display:** Fetches and displays logs associated with a specific external data job schema.\n*   **Log Filtering:** Allows filtering logs based on log level (e.g., ERROR, WARNING, INFO).\n*   **Log Searching:** Enables searching for specific terms within the logs.\n*   **Real-time Log Updates:** Periodically polls for new logs and updates the display in real-time.\n*   **Pagination:** Supports loading more logs as the user scrolls or requests additional data.\n*   **User-Specific Log Levels:** Displays different log levels based on the user's staff status.\n*   **Background Log Polling:** Fetches new logs in the background without interrupting the user.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/settings/source/Schemas.tsx",
        "summary": "This code defines a React component called `Schemas` that displays a table of schemas for a data warehouse source. It allows users to configure various aspects of each schema's synchronization process, including the anchor time, sync frequency, sync method (incremental or full refresh), and whether the schema is enabled for syncing. The table also displays the status of the last sync, the number of rows synced, and provides a link to query the synced table in the data warehouse. Users can also trigger a manual reload of a schema.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Schema Configuration:** Allows users to configure individual schemas within a data warehouse source.\n*   **Anchor Time Setting:** Enables users to set a specific time of day for the first sync to run, with timezone considerations.\n*   **Sync Frequency Selection:** Provides a dropdown to select the frequency of data synchronization for each schema (e.g., 5 minutes, hourly, daily).\n*   **Sync Method Selection:** Allows users to choose between incremental and full refresh sync methods.\n*   **Schema Enable/Disable:** Provides a toggle to enable or disable data synchronization for each schema.\n*   **Sync Status Monitoring:** Displays the status of the last sync for each schema (e.g., Running, Completed, Error).\n*   **Data Preview:** Links to the data warehouse query interface to preview the synced data.\n*   **Row Count Display:** Shows the number of rows synced for each schema.\n*   **Manual Schema Reload:** Allows users to manually trigger a reload of a schema.\n*   **Error Display:** Shows the latest error message for schemas that have failed to sync.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/settings/source",
        "summary": "The provided code collectively implements a comprehensive data warehouse source management interface within PostHog. This interface empowers users to configure, monitor, and troubleshoot data ingestion from external sources. Users can define connection settings, manage schemas, monitor sync jobs, view detailed logs, and adjust synchronization parameters to optimize data flow and ensure data quality.\n\nHere's a list of high-level product features:\n\n*   Data Source Configuration: View and modify settings for a specific data warehouse source.\n*   Schema Management: View, reload, resync, and configure schemas associated with a data warehouse source, including anchor time, sync frequency, and sync method.\n*   Job Monitoring: View a paginated list of sync jobs related to the data warehouse source, including status, rows synced, and synced at timestamp.\n*   Log Management: View, filter, and search logs associated with schema syncs and other data warehouse operations.\n*   Real-time Updates: Automatically refresh source, job, and log data.\n*   Error Handling: Display user-friendly error messages and detailed error logs.\n*   Data Preview: Link to the data warehouse query interface to preview synced data.\n*   User-Specific Log Levels: Display different log levels based on the user's staff status.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/settings/dataWarehouseSourcesTableSyncMethodModalLogic.ts",
        "summary": "This code defines the logic for a modal that allows users to configure the sync method for a specific table (schema) within a data warehouse source. It handles opening and closing the modal, loading incremental fields for the schema, updating the schema with the selected sync method, and managing loading states during the update process. Upon successful update, it reloads the data warehouse sources and closes the modal.\n\n**Features:**\n\n*   **Sync Method Configuration Modal:** Provides a user interface for configuring the synchronization method of a data warehouse table.\n*   **Schema-Specific Settings:** Allows configuration of sync settings on a per-table (schema) basis.\n*   **Incremental Field Loading:** Fetches and displays available incremental fields for a given schema to aid in sync method configuration.\n*   **Loading State Management:** Manages and displays loading states during schema updates.\n*   **Data Refresh on Success:** Automatically refreshes the data warehouse sources list after a successful schema update.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/settings/DataWarehouseSelfManagedSourcesTable.tsx",
        "summary": "This component renders a table displaying self-managed data warehouse sources. Each row represents a source and includes an icon representing the source type, the source name as a link to the source configuration, and action buttons to update the schema from the source or delete the source. Deleting a source prompts a confirmation dialog warning about the irreversible nature of the action and the deletion of related views and joins.\n\nHere's a list of high-level product features:\n\n*   **Display Self-Managed Data Warehouse Sources:** Shows a list of configured self-managed data warehouse sources in a table format.\n*   **Source Type Identification:** Displays an icon indicating the type of data warehouse source (e.g., Postgres, MySQL).\n*   **Navigation to Source Configuration:** Provides a link from the source name to the source's configuration page.\n*   **Schema Refresh:** Allows users to manually trigger a schema update for a specific data warehouse source.\n*   **Source Deletion:** Enables users to delete a data warehouse source, with a confirmation dialog to prevent accidental data loss.\n*   **Pagination:** Paginate the list of sources to improve performance and usability."
    },
    {
        "path": "frontend/src/scenes/data-warehouse/settings/dataWarehouseSceneLogic.ts",
        "summary": "This code defines the logic for the Data Warehouse scene in PostHog, managing the display and modification of database tables and views. It handles selecting rows, editing schema, saving schema changes, deleting tables and views, and managing the state of the schema modal. The logic connects to other kea logics for database table lists and data warehouse views, allowing it to load, update, and delete data warehouse tables and views. It also integrates with the router to handle navigation to specific data warehouse views.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Displaying Data Warehouse Tables and Views:** Fetches and displays a list of available tables and views in the data warehouse, categorized by source type.\n*   **Schema Editing:** Allows users to edit the schema of a selected table, including updating column types.\n*   **Saving Schema Changes:** Persists schema modifications to the backend.\n*   **Deleting Tables and Views:** Enables users to delete tables and views from the data warehouse.\n*   **Managing Materialized Views:** Supports the display and management of materialized views, including their status and last run time.\n*   **Editing Data Warehouse Views:** Allows users to edit the query and types of a selected view.\n*   **Navigation to Data Warehouse Views:** Provides routing and navigation to specific data warehouse views.\n*   **Data Warehouse View Creation and Updates:** Supports creation and updates of data warehouse views.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/settings/DataWarehouseSourceIcon.tsx",
        "summary": "This code defines a React component, `DataWarehouseSourceIcon`, which displays an icon representing a data warehouse source. The component takes a `type` prop to determine which icon to display, and a `size` prop to control the icon's size. It also includes a heuristic function `mapUrlToProvider` that attempts to determine the provider based on a URL. The component renders the appropriate icon with an optional tooltip that links to the data warehouse source documentation. If the `disableTooltip` prop is set to true, the tooltip and link are omitted.\n\nHere's a list of high-level product features related to this component:\n\n*   **Data Source Icon Display:** Visually represents different data warehouse sources using recognizable icons.\n*   **Automatic Provider Detection:** Attempts to automatically identify the data source provider based on the URL.\n*   **Configurable Icon Size:** Allows adjusting the size of the data source icons for different display contexts.\n*   **Tooltip with Documentation Link:** Provides a tooltip on hover that displays the data source type and a link to its documentation.\n*   **Tooltip Enable/Disable:** Allows disabling the tooltip and link for specific use cases.\n*   **Fallback Icon:** Displays a default icon when the data source type is unknown or unsupported.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/settings",
        "summary": "The provided code collectively implements a comprehensive data warehouse management interface within PostHog, empowering users to configure, monitor, and troubleshoot data ingestion from external sources and manage the resulting data structures. This includes features for connecting to various data sources, defining and managing schemas, monitoring sync jobs, viewing detailed logs, and adjusting synchronization parameters. Users can also manage self-managed tables, edit schemas, and create/delete tables and views. The interface provides real-time updates, user-friendly error messages, and links to documentation and data previews, enhancing the overall data warehouse management experience.\n\nHere's a list of high-level product features:\n\n*   **Data Source Management:** Add, configure, update, reload, and delete external data sources.\n*   **Schema Management:** View, edit, refresh, and resync schemas associated with data warehouse sources, including setting sync methods and incremental fields.\n*   **Self-Managed Table Management:** Create, view, and delete self-managed tables.\n*   **Data Warehouse View Management:** Create, edit, and delete data warehouse views.\n*   **Job Monitoring:** View a paginated list of sync jobs, including status, rows synced, and timestamps.\n*   **Log Management:** View, filter, and search logs associated with schema syncs and other data warehouse operations.\n*   **Real-time Updates:** Automatically refresh source, job, and log data.\n*   **Error Handling:** Display user-friendly error messages and detailed error logs.\n*   **Data Preview:** Link to the data warehouse query interface to preview synced data.\n*   **Visual Representation:** Display data source icons with tooltips linking to documentation.\n*   **User Interface:** Provides a user-friendly interface for managing data warehouse settings, tables, and views.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/DataWarehouseInitialBillingLimitNotice.tsx",
        "summary": "This React component, `DataWarehouseInitialBillingLimitNotice`, conditionally renders the `InitialBillingLimitNotice` component based on whether the user has configured any data warehouse sources or self-managed tables. It uses the `dataWarehouseSettingsLogic` to determine if any sources or tables exist. If sources or tables are present, the `InitialBillingLimitNotice` component is displayed, indicating a billing limit notice for the data warehouse product.\n\n**Features:**\n\n*   **Conditional Billing Limit Notice:** Displays a billing limit notice specifically for the data warehouse product.\n*   **Data Source Detection:** Detects the presence of data warehouse sources and self-managed tables.\n*   **Integration with Data Warehouse Settings:** Uses data from the data warehouse settings to determine if the notice should be displayed.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/utils.ts",
        "summary": "This code provides utility functions for the data warehouse feature. It includes a function to generate a default HogQL query based on a table name and its columns, which is used to visualize data. Additionally, it offers a function to convert a sync anchor time and frequency into a human-readable sentence describing when data warehouse syncs occur, handling various sync intervals and formatting the time in a user-friendly manner.\n\nHere's a list of high-level product features:\n\n*   **Default Query Generation:** Automatically generates a basic HogQL query for a given table and columns.\n*   **Data Visualization:** Supports visualizing data using the generated HogQL queries.\n*   **Sync Schedule Description:** Provides human-readable descriptions of data warehouse sync schedules.\n*   **Sync Interval Support:** Handles various sync intervals (5min, 30min, 1hour, 6hour, 12hour, 24hour, 7day, 30day).\n*   **Time Formatting:** Formats time in a user-friendly AM/PM format.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/types.ts",
        "summary": "This code defines a TypeScript type `DataWarehouseTableForInsight` that extends the `DatabaseSchemaDataWarehouseTable` type and adds three optional string fields: `id_field`, `timestamp_field`, and `distinct_id_field`. This type is likely used to represent a data warehouse table with additional metadata relevant for generating insights, such as identifying the primary key, timestamp column, and distinct ID column.\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **Data Warehouse Table Integration:** The product can connect to and retrieve schema information from data warehouses.\n*   **Schema Exploration:** Users can explore the schema of data warehouse tables.\n*   **Insight Generation:** The product uses data warehouse tables to generate insights.\n*   **Field Identification:** The product allows users or automatically identifies key fields within a data warehouse table, such as ID, timestamp, and distinct ID fields.\n*   **Data Warehouse Configuration:** The product allows configuration of data warehouse tables for insight generation, including specifying key fields.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/ViewLinkModal.tsx",
        "summary": "This code defines a modal for creating joins between two tables or views in a data warehouse. The modal allows users to select a source table and a joining table, specify the keys to join on, and customize the field name for accessing the joined table's fields. It also includes an option to optimize the join for experiments by limiting it to the most recent matching event based on a timestamp. The modal displays a SQL code snippet representing the join and allows users to customize the field name for accessing the joined table's fields.\n\nHere's a list of high-level product features:\n\n*   **Table Selection:** Allows users to select a source table and a joining table from a list of available tables/views.\n*   **Key Selection:** Enables users to specify the keys from both tables to use for the join, including the option to use SQL expressions.\n*   **Experiment Optimization:** Provides an option to optimize the join for experiment analysis by limiting the join to the most recent matching event based on a timestamp.\n*   **Custom Field Naming:** Allows users to customize the field name used to access the joined table's fields in queries.\n*   **SQL Code Snippet Preview:** Displays a SQL code snippet representing the join for review and understanding.\n*   **Error Handling:** Displays error messages to guide users in resolving issues with the join configuration.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/new/DataWarehouseTableForm.tsx",
        "summary": "This code defines a React component, `DatawarehouseTableForm`, which is a form used to configure a data warehouse table. It allows users to input the table name, the URL pattern for the files to be ingested, the file format (Parquet, CSV, JSON, Delta), and the necessary credentials (access key and secret) for accessing the data, depending on the cloud provider (AWS, Google Cloud, Cloudflare R2, or Azure). The form dynamically adjusts the input fields and placeholders based on the selected cloud provider, offering specific instructions and links for Google Cloud HMAC key generation. The form is built using Lemon UI components and Kea logic for state management and form handling.\n\nHere's a list of high-level product features:\n\n*   **Data Warehouse Table Configuration:** Allows users to define and configure tables within a data warehouse.\n*   **Manual Data Linking:** Supports manual linking of data sources to tables.\n*   **Cloud Provider Integration:** Integrates with multiple cloud storage providers (AWS, Google Cloud, Cloudflare R2, Azure).\n*   **Dynamic Form Fields:** Adapts form fields based on the selected cloud provider.\n*   **File Format Selection:** Supports various file formats (Parquet, CSV, JSON, Delta).\n*   **Credential Management:** Securely manages access keys and secrets for cloud storage.\n*   **URL Pattern Input:** Allows users to specify URL patterns for file selection.\n*   **Form Validation and Submission:** Provides form validation and submission functionality.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/new/NewSourceWizard.tsx",
        "summary": "The `NewSourceWizard.tsx` file defines a wizard interface for connecting data sources to PostHog. It allows users to link both PostHog-managed and self-managed data sources. The wizard guides users through a multi-step process: selecting a source, configuring the source, defining the schema, and monitoring the sync progress. The wizard uses Lemon UI components for a consistent user experience and leverages Kea logic for state management and actions.\n\nHere's a list of high-level product features implemented by the code:\n\n*   **Data Source Selection:** Allows users to choose from a list of PostHog-managed and self-managed data sources.\n*   **Managed Data Source Linking:** Guides users through the process of linking data sources managed by PostHog.\n*   **Self-Managed Data Source Linking:** Enables users to connect data sources they manage themselves.\n*   **Source Configuration:** Provides a form for configuring the selected data source.\n*   **Schema Definition:** Allows users to define the schema for the data being imported.\n*   **Sync Progress Monitoring:** Displays the progress of the data synchronization process.\n*   **Wizard Interface:** Provides a step-by-step wizard interface for a guided user experience.\n*   **Cancel Functionality:** Allows users to cancel the data source linking process.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/viewLinkLogic.tsx",
        "summary": "This code defines the logic for managing view links in a data warehouse, allowing users to create and edit joins between tables. It handles the selection of source and joining tables, keys for the join, and other configuration options like optimizing for experiments and selecting a timestamp key. The logic includes reducers to manage the state of the modal, selected tables and keys, and form handling for creating and updating view links via API calls. It also provides selectors to derive data like table options, key options, and SQL code snippets for the join.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Create New View Links:** Allows users to define new joins between tables in the data warehouse.\n*   **Edit Existing View Links:** Enables users to modify existing joins, including changing tables, keys, and configurations.\n*   **Table and Key Selection:** Provides UI elements for selecting source and joining tables, as well as the keys to join on.\n*   **Experiments Optimization:** Supports configuring joins to optimize for experiment analysis, including selecting a timestamp key.\n*   **SQL Code Snippet Generation:** Generates a basic SQL code snippet representing the join for easy reference.\n*   **Form Validation:** Validates required fields before submitting the view link.\n*   **Error Handling:** Displays error messages if API calls fail during view link creation or update.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/new/sourceWizardLogic.tsx",
        "summary": "This code defines the frontend logic for a source wizard in PostHog's data warehouse feature. It uses Kea for state management and defines the configuration for connecting to various external data sources like Stripe, Hubspot, Postgres, MySQL, and MSSQL. The configuration includes fields for connection details, authentication, and SSH tunneling options. The wizard guides users through the process of setting up these data sources to automatically pull data into the PostHog data warehouse.\n\nHere's a list of high-level product features based on the code:\n\n*   **Data Source Connection Wizard:** Guides users through connecting external data sources to PostHog's data warehouse.\n*   **Stripe Integration:** Allows users to connect their Stripe account to import data.\n*   **Hubspot Integration:** Enables connection to Hubspot for data import.\n*   **Postgres Integration:** Supports connecting to Postgres databases.\n*   **MySQL Integration:** Supports connecting to MySQL/MariaDB databases.\n*   **MSSQL Integration:** Supports connecting to MS SQL Server/Azure SQL Server databases.\n*   **SSH Tunneling:** Provides options for secure connections to databases using SSH tunnels.\n*   **Data Source Configuration:** Defines the necessary fields and authentication methods for each data source.\n*   **OAuth Support:** Implements OAuth flow for Hubspot integration.\n*   **Secure Credential Input:** Uses password fields for sensitive information like API keys and database passwords."
    },
    {
        "path": "frontend/src/scenes/data-warehouse/new/dataWarehouseTableLogic.tsx",
        "summary": "This code defines the logic for managing data warehouse tables within the PostHog application. It handles creating, updating, and loading table configurations, including validation of input data such as table names and URL patterns. The logic also manages the UI state for editing tables and integrates with the PostHog API to persist changes. Upon successful creation or update, a toast notification is displayed, and the user is redirected to the data warehouse list.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Data Warehouse Table Management:** Allows users to create, edit, and manage data warehouse table configurations.\n*   **Table Configuration:** Defines the structure and properties of a data warehouse table, including name, URL pattern, format, and credentials.\n*   **Input Validation:** Validates user input for table configurations, ensuring data integrity and preventing errors.\n*   **API Integration:** Interacts with the PostHog API to persist table configurations and retrieve existing tables.\n*   **User Interface State Management:** Manages the UI state for editing tables, including displaying forms and handling user interactions.\n*   **Notifications:** Provides feedback to the user through toast notifications upon successful creation or update of a table.\n*   **Navigation:** Redirects the user to the data warehouse list after creating or updating a table.\n*   **Data Querying:** Supports setting a data table query, likely for previewing or validating the table's data.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/new",
        "summary": "The provided code collectively implements a comprehensive data warehouse integration feature within PostHog. It enables users to connect to and manage data from various sources, including cloud storage providers and external databases, through a user-friendly wizard interface. The system supports configuration of data sources, schema definition, and monitoring of data synchronization progress, while also providing tools for managing data warehouse tables, including defining their structure, URL patterns, and access credentials.\n\nHere's a list of high-level product features:\n\n*   Data Warehouse Table Management: Create, edit, and manage data warehouse table configurations.\n*   Data Source Connection Wizard: Guides users through connecting external data sources (Stripe, Hubspot, Postgres, MySQL, MSSQL) to PostHog's data warehouse.\n*   Cloud Provider Integration: Connect to data stored in AWS, Google Cloud, Cloudflare R2, and Azure.\n*   Data Source Selection: Choose from a list of PostHog-managed and self-managed data sources.\n*   Schema Definition: Define the schema for the data being imported.\n*   Sync Progress Monitoring: Displays the progress of the data synchronization process.\n*   Input Validation: Validates user input for table configurations, ensuring data integrity.\n*   SSH Tunneling: Provides options for secure connections to databases using SSH tunnels.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/redirect/DataWarehouseRedirectScene.tsx",
        "summary": "The `DataWarehouseRedirectScene` is a simple scene in the PostHog frontend that displays a spinner. It's likely a temporary loading screen or redirect page within the data warehouse feature. It utilizes the `sourceWizardLogic` which suggests it's part of a flow for setting up or connecting to a data source.\n\nHere's a list of high-level product features:\n\n*   **Data Warehouse Integration:** The scene is part of a larger feature set that allows users to connect PostHog to their data warehouse.\n*   **Data Source Setup Wizard:** The `sourceWizardLogic` suggests a guided process for configuring data sources.\n*   **Loading/Redirect Screen:** The spinner indicates a loading state, likely while connecting to a data source or redirecting the user to a different part of the setup process.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/redirect",
        "summary": "The `DataWarehouseRedirectScene` component serves as a temporary loading screen within the data warehouse integration feature of PostHog. It leverages a source wizard logic, indicating a guided setup process for connecting to external data sources. The scene displays a spinner to inform the user that a connection or redirection is in progress.\n\nHere's a list of high-level product features:\n\n*   Data Warehouse Integration\n*   Data Source Setup Wizard\n*   Loading/Redirect Screen\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/external/DataWarehouseExternalScene.tsx",
        "summary": "The `DataWarehouseExternalScene` component provides a user interface for exploring data from external sources within PostHog using HogQL. It allows users to connect their own tables from S3 and query data from outside PostHog. The scene includes a page header with options to save explorations as insights and manage data sources. It also displays a notice about initial billing limits and a table view for exploring the data, which is wrapped in a spinner while loading.\n\nHere's a list of high-level product features:\n\n*   **Data Exploration with HogQL:** Allows users to explore data from external sources using HogQL.\n*   **S3 Data Connection:** Enables users to connect their own tables from S3.\n*   **Save as Insight:** Provides functionality to save data explorations as insights.\n*   **Manage Data Sources:** Allows users to manage connected data sources.\n*   **Billing Limit Notice:** Displays a notice about initial billing limits.\n*   **Loading State:** Shows a spinner while data is loading.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/external/forms/DataWarehouseIntegrationChoice.tsx",
        "summary": "This code defines a React component called `DataWarehouseIntegrationChoice` that renders a choice for configuring a data warehouse integration. It leverages the `IntegrationChoice` component from the pipeline feature, passing in the integration name (derived from the `sourceConfig`) and a redirect URL that points to the data warehouse creation page with the integration kind pre-selected. This component allows users to select and configure a specific data warehouse integration.\n\n**Features:**\n\n*   **Integration Selection:** Presents users with a choice of available data warehouse integrations.\n*   **Dynamic Redirection:** Redirects users to the data warehouse creation page with the selected integration kind pre-filled.\n*   **Configuration UI:** Provides a user interface for configuring the selected data warehouse integration.\n*   **Integration with Pipeline Feature:** Reuses the `IntegrationChoice` component from the pipeline feature for a consistent user experience.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/external/forms/parseConnectionString.ts",
        "summary": "This code provides a function, `parseConnectionString`, that parses a PostgreSQL connection string into a configuration object. It handles various connection string formats, including those with and without a host, and extracts information such as host, database, port, user, and password. The function also attempts to handle invalid URLs by using a dummy host and encodes spaces in the connection string. The function returns a configuration object containing the parsed connection details and a flag indicating whether the connection string is valid.\n\nHere's a list of high-level product features based on the code:\n\n*   **Connection String Parsing:** Parses PostgreSQL connection strings to extract connection parameters.\n*   **URL Handling:** Handles both valid and potentially invalid URLs within the connection string.\n*   **Parameter Extraction:** Extracts host, database, port, user, and password from the connection string.\n*   **Encoding Support:** Supports decoding of URI-encoded components within the connection string.\n*   **Validation:** Validates the connection string to ensure essential parameters (user, database, host) are present.\n*   **Socket Connection Support:** Handles connection strings using the \"socket:\" protocol.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/external/forms/SyncProgressStep.tsx",
        "summary": "The `SyncProgressStep` component displays the synchronization status of external data source schemas in a table. It fetches data source information and schemas using kea logics (`sourceWizardLogic` and `dataWarehouseSettingsLogic`). The table shows the name of each table and its current sync status (Not synced, Syncing, Completed, or Error) using LemonTags to visually represent the status. If the component is not wrapped and a schema has completed syncing, a \"Query\" button is displayed, allowing the user to navigate to a new insight with a pre-filled query for the synced table.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Display Sync Status:** Shows the current synchronization status of each external data source schema.\n*   **Visual Status Indicators:** Uses LemonTags to visually represent the sync status (e.g., syncing, completed, error).\n*   **Table View:** Presents the schemas and their statuses in a structured table format.\n*   **Direct Querying:** Provides a button to directly query a synced table, pre-filling the query interface with the table's schema.\n*   **Loading State:** Displays a loading indicator while fetching data source information.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/external/TableData.tsx",
        "summary": "This code defines the UI components for displaying and managing data warehouse table details within a PostHog application. It includes components for viewing table metadata (name, last synced time, URL pattern, file format), displaying the table schema (columns), and editing the schema for manually linked tables. It also provides a modal for deleting tables or views with a confirmation step and a warning about the consequences of deletion.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Table Details Display:** Shows key information about a selected data warehouse table, including its name, type, source, and schema.\n*   **Last Synced At Indicator:** Displays the last time a table's schema was synchronized, providing insight into data freshness.\n*   **Manual Schema Editing:** Allows users to manually edit the schema of tables that are not automatically synced, enabling customization and correction.\n*   **Schema Visualization:** Presents the table's columns and their data types in a clear, tabular format.\n*   **Table Deletion:** Provides a mechanism to delete tables or views from the data warehouse, with a confirmation modal to prevent accidental data loss.\n*   **Edit Mode Toggle:** Allows users to switch between viewing and editing the table schema.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/external/forms/SyncMethodForm.tsx",
        "summary": "The `SyncMethodForm` component allows users to configure the synchronization method for an external data source table. It provides options for \"Incremental replication\" (syncing only updated rows based on a selected field) and \"Full table replication\" (syncing the entire table on every sync). The form dynamically adjusts based on the schema of the external data source, disabling incremental replication if it's not supported or if no suitable incremental fields are available. Users can select an incremental field from a dropdown if incremental replication is enabled. The component includes validation to ensure a sync method is selected and an incremental field is chosen when using incremental replication.\n\nHere's a list of high-level product features:\n\n*   **Sync Method Selection:** Allows users to choose between incremental and full table replication for external data source tables.\n*   **Incremental Replication Configuration:** Enables users to select a specific field to use for incremental replication, ensuring only updated rows are synced.\n*   **Dynamic UI based on Schema:** Adapts the UI based on the external data source schema, disabling options that are not supported.\n*   **Validation:** Validates user input to ensure a sync method is selected and an incremental field is chosen when using incremental replication.\n*   **User Feedback:** Provides feedback to the user via LemonToast when there are errors.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/external/forms/SourceForm.tsx",
        "summary": "This code defines a `SourceForm` component in React for configuring data warehouse sources. It dynamically renders form fields based on a `sourceConfig` object, supporting various input types like text, selects, switches, textareas, file uploads, and OAuth integrations. The form handles connection string parsing, switchable groups of fields, and conditional rendering based on selected options. It leverages the `kea-forms` library for form management and `Lemon UI` components for styling. The form is used in both creation and update modes, with some fields like the connection string hidden during updates.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Dynamic Form Generation:** Renders form fields based on source configuration, allowing for flexible data input.\n*   **Connection String Parsing:** Parses connection strings to pre-populate form fields.\n*   **Conditional Field Rendering:** Shows or hides fields based on switch states and select options.\n*   **OAuth Integration:** Supports OAuth authentication for data sources.\n*   **File Upload:** Allows users to upload files as part of the source configuration.\n*   **Table Prefix Configuration:** Enables users to define a table prefix for the data source.\n*   **Form Management:** Uses `kea-forms` for form state management and submission.\n*   **Update Mode Handling:** Adapts the form for updating existing source configurations.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/external/forms/SchemaForm.tsx",
        "summary": "The `SchemaForm` component provides a user interface for configuring data synchronization settings for database schemas. It displays a table of schemas with options to enable/disable syncing, view the table name and number of rows, set the anchor time for synchronization, and configure the sync method (full refresh or incremental). A modal (`SyncMethodModal`) allows users to select the sync method and specify incremental sync settings. The component uses Lemon UI components for the table, checkboxes, inputs, modals, and tooltips, and leverages kea-logic for state management and actions.\n\nHere's a list of high-level product features implemented by the code:\n\n*   **Schema Synchronization Control:** Enables/disables synchronization for individual database schemas.\n*   **Table Information Display:** Shows the table name and number of rows for each schema.\n*   **Anchor Time Configuration:** Allows users to set the time of day for the first sync, with timezone considerations.\n*   **Sync Method Selection:** Provides options for full refresh or incremental synchronization methods.\n*   **Incremental Sync Configuration:** Allows users to specify the incremental field and its type for incremental synchronization.\n*   **UI using Lemon Design System:** Utilizes Lemon UI components for a consistent and user-friendly interface.\n*   **Timezone Handling:** Supports different timezones for anchor time configuration.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/external/forms",
        "summary": "The provided code snippets detail various components and functionalities related to data warehouse integration and configuration within a larger application. These components collectively enable users to connect to external data sources, configure synchronization settings, and manage the flow of data into the data warehouse. Key functionalities include dynamic form generation for source configuration, connection string parsing, schema selection and synchronization control, sync method configuration (full vs. incremental), and visual monitoring of sync progress.\n\nHere's a list of high-level product features:\n\n*   **Data Source Connection:** Enables users to connect to various external data sources using dynamic forms and connection string parsing.\n*   **Schema Management:** Allows users to select and configure which schemas to synchronize from external data sources.\n*   **Synchronization Configuration:** Provides options for full table replication or incremental replication based on a selected field.\n*   **Sync Status Monitoring:** Displays the synchronization status of each schema with visual indicators and direct querying capabilities upon completion.\n*   **Dynamic Form Generation:** Renders forms dynamically based on source configuration, supporting various input types and conditional rendering.\n*   **Integration Selection:** Presents users with a choice of available data warehouse integrations and redirects to the configuration page.\n*   **Anchor Time Configuration:** Allows users to set the time of day for the first sync, with timezone considerations.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/external/dataWarehouseJoinsLogic.ts",
        "summary": "This code defines a Kea logic module named `dataWarehouseJoinsLogic` responsible for managing and processing data warehouse view links (joins), specifically those related to the 'persons' table. It fetches a list of joins from the API, connects to the `databaseTableListLogic` to access table metadata, and provides selectors to filter joins related to the 'persons' table, identify tables joined to 'persons', and extract columns from those joined tables. The logic module loads joins after it mounts.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Data Warehouse Join Management:** Fetches and manages data warehouse view links (joins) from an API.\n*   **Person Table Join Filtering:** Filters joins specifically related to the 'persons' table.\n*   **Joined Table Identification:** Identifies tables that are joined to the 'persons' table.\n*   **Column Extraction from Joined Tables:** Extracts column definitions (name, type, etc.) from tables joined to the 'persons' table.\n*   **Metadata Enrichment:** Connects to database table metadata to enrich join information.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/external/dataWarehouseExternalSceneLogic.ts",
        "summary": "This code defines the logic for the Data Warehouse external scene in the PostHog frontend. It manages the loading and display of data warehouse views, integrates with the insight system to allow editing and visualization of data, and handles routing and state management for the `/data-warehouse` and `/data-warehouse/view/:id` URLs. It connects to other logic files to fetch database and table information, and uses lemonToast for displaying error messages.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Data Warehouse Exploration:** Allows users to explore data stored in external data warehouses.\n*   **View Loading and Display:** Enables loading and displaying pre-defined data warehouse views based on their ID.\n*   **SQL Query Editing:** Integrates with the insight system to provide an editor for SQL queries associated with data warehouse views.\n*   **Data Visualization:** Supports visualizing data retrieved from the data warehouse using PostHog's insight tools.\n*   **Error Handling:** Displays user-friendly error messages when views cannot be loaded.\n*   **Routing:** Manages navigation between the main data warehouse page and specific view pages.\n*   **Breadcrumbs:** Provides breadcrumb navigation for easy orientation within the data warehouse section."
    },
    {
        "path": "frontend/src/scenes/data-warehouse/external/DataWarehouseTables.tsx",
        "summary": "This code defines a React component, `DataWarehouseTables`, which integrates with an insight query editor and displays a tree view of database tables, views, and materialized views from various data sources, including external sources and PostHog. The component allows users to interact with these tables by copying their names, viewing their schemas, adding joins, editing view definitions, materializing views, and running materialized views. It also provides functionality to delete views and materialized views. The component uses feature flags to conditionally render certain features, such as materialized views and data modeling options.\n\nHere's a list of high-level product features:\n\n*   **Database Table Browsing:** Displays a hierarchical tree view of database tables, views, and materialized views, categorized by source (e.g., external, PostHog).\n*   **Table Schema Viewing:** Allows users to view the schema of a selected table in a modal.\n*   **Table Name Copying:** Provides a button to copy the table name to the clipboard.\n*   **Join Table Functionality:** Enables users to add joins to tables.\n*   **View Editing:** Allows users to edit the definition of a selected view.\n*   **Materialize View:** Enables users to materialize a view.\n*   **Run Materialized View:** Allows users to run a materialized view.\n*   **Table Deletion:** Provides functionality to delete views and materialized views.\n*   **Insight Query Integration:** Integrates with an insight query editor, allowing users to build queries against the displayed tables.\n*   **Data Modeling Feature Flag:** Conditionally renders features related to data modeling based on a feature flag.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/external",
        "summary": "The provided code collectively implements a comprehensive data warehouse integration within PostHog, enabling users to connect to external data sources like S3, explore and manage data through HogQL queries, and build insights based on this data. The system provides tools for managing data source connections, configuring synchronization settings, visualizing table schemas, and editing schemas for manually linked tables. Users can also create and manage data warehouse views, including materialized views, and leverage PostHog's insight tools for data visualization and analysis.\n\nHere's a list of high-level product features:\n\n*   Data Source Connection: Connect to external data sources (e.g., S3) with dynamic form generation and connection string parsing.\n*   Data Exploration with HogQL: Explore data from external sources using HogQL, with the ability to save explorations as insights.\n*   Schema Management: Select and configure schemas to synchronize, with options for full or incremental replication.\n*   Table Management: Browse, view schemas, edit schemas, add joins, and delete tables, views, and materialized views.\n*   View Management: Create, edit, materialize, and run materialized views.\n*   Insight Integration: Integrate with the insight system for SQL query editing and data visualization.\n*   Sync Status Monitoring: Monitor the synchronization status of schemas with visual indicators.\n*   Data Warehouse Join Management: Manage and filter data warehouse view links (joins), especially those related to the 'persons' table.\n*   Error Handling: Display user-friendly error messages.\n*   Billing Limit Notice: Display a notice about initial billing limits.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/sidebar/QueryDatabase.tsx",
        "summary": "This code defines a sidebar component for a SQL editor within a data warehouse application. The sidebar displays a tree view of database tables and schemas, allowing users to browse and select them. It provides functionality to copy the selected schema name to the clipboard and add a join based on the selected schema. The sidebar is implemented as an overlay that can be toggled open and closed.\n\nHere's a list of high-level product features:\n\n*   **Database Schema Browsing:** Allows users to explore the structure of their data warehouse through a tree-like representation of schemas and tables.\n*   **Schema Selection:** Enables users to select a specific schema for further actions.\n*   **Copy Schema Name:** Provides a convenient way to copy the name of the selected schema to the clipboard.\n*   **Add Join:** Facilitates the creation of joins between tables, likely by opening a modal or interface for defining the join conditions.\n*   **Collapsible Sidebar:** Implements the database browser as a sidebar that can be opened and closed, providing a focused view when needed.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/sidebar/QueryVariables.tsx",
        "summary": "This React component, `QueryVariables`, renders a UI for managing variables within a data warehouse query editor. It conditionally renders based on a feature flag, and if enabled, displays an \"Add Variable\" button and a list of existing variables. Each variable can be edited or removed. A modal is also included for creating new variables. The component utilizes various logics (Kea) to manage state and actions related to feature flags, variables, data visualization, and data nodes.\n\n**Features:**\n\n*   **Conditional Rendering:** Only displays the variable management UI if the `INSIGHT_VARIABLES` feature flag is enabled.\n*   **Add Variable:** Provides a button to add new variables to the query.\n*   **Variable List:** Displays a list of existing variables associated with the insight.\n*   **Variable Editing:** Allows users to modify the values of existing variables.\n*   **Variable Removal:** Enables users to remove variables from the query.\n*   **Variable Settings:** Opens a modal to edit the settings of an existing variable.\n*   **New Variable Modal:** Provides a modal interface for creating new variables.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/sidebar/infoTabLogic.ts",
        "summary": "This code defines a Kea logic module called `infoTabLogic` that manages the data displayed in the information tab of a data warehouse editor. It connects to other Kea logics, including `multitabEditorLogic`, `databaseTableListLogic`, and `dataWarehouseViewsLogic`, to retrieve metadata, database tables, and data warehouse views. The logic then transforms this data into a list of `InfoTableRow` objects, distinguishing between \"source\" tables and \"table\" views, and including information such as status and last run time for views. The `sourceTableItems` selector prepares the data for display in the UI.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Display of Data Warehouse Table Information:** Shows a list of tables available in the data warehouse.\n*   **Differentiation Between Sources and Views:** Distinguishes between raw data sources and saved query views.\n*   **View Status and Last Run Time:** Displays the status and last run time of data warehouse views.\n*   **Integration with Data Warehouse Editor:** Provides information within the context of a data warehouse editor.\n*   **Metadata Display:** Shows metadata associated with tables.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/sidebar/EditorSidebar.tsx",
        "summary": "The `EditorSidebar` component provides a sidebar interface for the data warehouse editor, offering different functionalities through tabs. It allows users to interact with the query database, manage query variables, and view query information such as materialization and properties. The sidebar's width is adjustable using a resizer, and the active tab determines which content is displayed. The component utilizes LemonTabs for tab management and displays icons with tooltips for each tab, enhancing the user experience.\n\nHere's a list of high-level product features:\n\n*   **Tabbed Interface:** Organizes functionalities into separate tabs for query database interaction, variable management, and query information display.\n*   **Query Database Interaction:** Allows users to interact with the data warehouse's query database.\n*   **Query Variable Management:** Enables users to manage variables used in queries, including displaying the number of variables.\n*   **Query Information Display:** Shows materialization and other properties related to the current query.\n*   **Adjustable Sidebar Width:** Provides a resizer to customize the sidebar's width.\n*   **Icon-based Navigation:** Uses icons with tooltips for each tab to improve usability and discoverability.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/sidebar/QueryInfo.tsx",
        "summary": "The `QueryInfo` component provides a sidebar interface for managing and viewing information about data warehouse saved queries (views) within a multi-tab editor. It allows users to configure materialization settings, including sync frequency, manually trigger a sync, and view the status of the last run. The component also displays information about the columns in the materialized view, including name, type, and schema validity, as well as dependencies (source tables) and their last run times.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Materialization Configuration:** Allows users to set the sync frequency for materialized views (e.g., never, 5 minutes, daily, weekly).\n*   **Manual Sync Trigger:** Enables users to manually trigger a data warehouse saved query to sync.\n*   **Status Display:** Shows the current status of a data warehouse saved query (e.g., running, failed, idle) and any associated error messages.\n*   **Column Information:** Displays a table of columns in the materialized view, including name, type, and schema validity.\n*   **Dependency Information:** Shows a table of dependencies (source tables) used by the query, including their type, status, and last run time.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/sidebar",
        "summary": "The data warehouse editor features a comprehensive sidebar designed to enhance the user experience and streamline query development. This sidebar provides tools for browsing the database schema, managing query variables, and viewing query information such as materialization settings and dependencies. The sidebar is implemented as a tabbed interface with adjustable width, allowing users to focus on specific functionalities as needed.\n\nHere's a list of high-level product features:\n\n*   **Database Schema Browsing:** Explore the data warehouse structure through a tree-like representation of schemas and tables.\n*   **Schema Selection:** Select a specific schema for further actions.\n*   **Copy Schema Name:** Copy the name of the selected schema to the clipboard.\n*   **Add Join:** Facilitate the creation of joins between tables.\n*   **Materialization Configuration:** Set the sync frequency for materialized views.\n*   **Manual Sync Trigger:** Manually trigger a data warehouse saved query to sync.\n*   **Status Display:** Show the current status of a data warehouse saved query.\n*   **Column Information:** Display a table of columns in the materialized view.\n*   **Dependency Information:** Show a table of dependencies (source tables) used by the query.\n*   **Variable Management:** Add, edit, and remove variables associated with the query.\n*   **Tabbed Interface:** Organize functionalities into separate tabs.\n*   **Adjustable Sidebar Width:** Customize the sidebar's width.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/TabScroller.tsx",
        "summary": "The `TabScroller` component is a simple wrapper that enables horizontal scrolling for its children. It uses a relative parent div with `overflow-auto` to allow horizontal scrolling when the content exceeds the available width. The children are positioned absolutely within this container to ensure they take up the full available space.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Horizontal Tab Scrolling:** Allows users to scroll horizontally through a set of tabs when the tabs exceed the available screen width.\n*   **Content Overflow Handling:** Manages content that overflows the container by enabling scrolling.\n*   **Flexible Layout:** Provides a flexible layout for tab elements, allowing them to adapt to different screen sizes and content lengths.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/outputPaneLogic.ts",
        "summary": "This code defines the logic for controlling the output pane in a data warehouse editor. It manages the active tab within the output pane, allowing users to switch between different views such as \"Results\" and \"Visualization\". The logic uses Kea for state management, defining actions to set the active tab and reducers to update the state accordingly.\n\n**Features:**\n\n*   **Tabbed Interface:** Supports multiple tabs within the output pane (e.g., Results, Visualization).\n*   **Tab Switching:** Allows users to switch between different tabs in the output pane.\n*   **State Management:** Uses Kea to manage the active tab state.\n*   **Results Tab:** Displays the raw results of a data warehouse query.\n*   **Visualization Tab:** Displays a visual representation of the data warehouse query results.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/SchemaSearch.tsx",
        "summary": "The `SchemaSearch.tsx` component provides a search input field for users to search for schemas within the data warehouse editor. It utilizes the `LemonInput` component from `@posthog/lemon-ui` to render a full-width search box with a placeholder text \"Search for schema\". The component is designed to be flexible and easily integrated into the data warehouse editor interface.\n\nHere's a list of high-level product features:\n\n*   **Schema Search:** Allows users to search for specific schemas within the data warehouse.\n*   **Input Field:** Provides a user-friendly input field for entering search queries.\n*   **Full-Width Display:** The search input spans the full width of its container for better visibility and usability.\n*   **Placeholder Text:** Guides users with the text \"Search for schema\" within the input field.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/ViewLoadingState.tsx",
        "summary": "The `ViewLoadingState.tsx` file defines a `ViewEmptyState` component that displays a series of loading messages in a rotating fashion. The component uses `useEffect` to set up an interval that cycles through a predefined list of messages related to data warehouse view creation, such as resolving joins, saving references, searching saved queries, fetching references, and constructing HOGQL expressions. The messages fade in and out to provide a visually engaging loading experience.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Loading State Indication:** Provides visual feedback to the user during the data warehouse view creation process.\n*   **Dynamic Loading Messages:** Displays a rotating set of messages to inform the user about the specific tasks being performed in the background.\n*   **Visual Transition Effects:** Uses fade-in and fade-out effects to create a smooth and engaging loading experience.\n*   **Randomized Message Display:** Randomly selects messages from a predefined list to provide a varied and informative loading experience.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/queryWindowLogic.ts",
        "summary": "This code defines the logic for managing tabs within a query window, likely for a data warehouse editor. It uses Kea to manage state and side effects related to tab selection, creation, and deletion. The logic initializes with a single \"Untitled\" tab on mount.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Tabbed Interface:** Allows users to work with multiple queries or data views simultaneously in separate tabs.\n*   **Tab Creation:** Enables users to add new, blank tabs for creating new queries.\n*   **Tab Selection:** Allows users to switch between open tabs to view and edit different queries.\n*   **Tab Deletion:** Enables users to close tabs they no longer need.\n*   **Automatic Tab Naming:** Automatically names new tabs \"Untitled\" upon creation.\n*   **Tab Persistence:** (Implicit) The framework is in place to persist tab state, such as query content, though this specific code only manages the tab structure.\n*   **Active Tab Tracking:** Keeps track of the currently selected tab.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/AutoTab.tsx",
        "summary": "The `AutoTab` component is a React component that provides an input field that automatically adjusts its width to fit its content. It uses a hidden span element to measure the width of the input's value and then sets the input field's width accordingly. The component takes props for value, onChange, onKeyDown, onBlur, autoFocus, and a handleRename function, allowing it to be used as a dynamic and responsive tab element within a larger application.\n\nHere's a list of high-level features provided by the `AutoTab` component:\n\n*   **Automatic Width Adjustment:** The input field dynamically resizes to fit the content.\n*   **Controlled Input:** The component accepts a `value` prop and an `onChange` handler for controlled input behavior.\n*   **Keyboard Event Handling:** Supports `onKeyDown` event handling for custom keyboard interactions.\n*   **Focus Event Handling:** Supports `onBlur` event handling.\n*   **Auto-Focus:** The input field can be automatically focused when the component mounts.\n*   **Rename Handling:** Includes a `handleRename` function to trigger rename operations on value change.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/QueryWindow.tsx",
        "summary": "The `QueryWindow` component provides a user interface for writing, running, and saving data warehouse queries. It features a tabbed interface for managing multiple queries, a Monaco editor for writing queries with syntax highlighting and autocompletion, and an output pane for displaying query results. Users can run queries, cancel running queries, save queries as views, and update existing views. The component also provides feedback on query performance, such as whether indices are being used optimally.\n\nHere's a list of high-level product features:\n\n*   **Tabbed Query Management:** Allows users to create, rename, delete, and switch between multiple query tabs.\n*   **SQL Editor:** Provides a Monaco-based SQL editor with syntax highlighting, autocompletion, and error checking.\n*   **Query Execution:** Enables users to run queries and view the results in an output pane.\n*   **Query Cancellation:** Allows users to cancel running queries.\n*   **Save as View:** Enables users to save queries as reusable views.\n*   **Update View:** Allows users to update existing views with modified queries.\n*   **Performance Hints:** Provides feedback on query performance, such as whether indices are being used.\n*   **Dynamic Sidebar:** Allows users to show/hide the sidebar.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/QueryPane.tsx",
        "summary": "The `QueryPane` component provides a code editor interface for writing and editing HogQL queries within a data warehouse environment. It utilizes the Monaco editor for syntax highlighting and autocompletion, and features a resizable pane to adjust the editor's height. The component dynamically adjusts the editor's size to fit its container using `AutoSizer` and includes options to customize the editor's behavior, such as disabling the minimap and enabling word wrap.\n\nHere's a list of high-level product features:\n\n*   **HogQL Code Editor:** Provides a dedicated code editor for writing and editing HogQL queries.\n*   **Syntax Highlighting:** Highlights HogQL syntax for improved readability.\n*   **Autocompletion:** Suggests code completions to speed up query writing.\n*   **Resizable Pane:** Allows users to adjust the height of the query editor.\n*   **Dynamic Sizing:** Automatically adjusts the editor's size to fit its container.\n*   **Editor Customization:** Offers options to customize the editor's behavior, such as disabling the minimap and enabling word wrap.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/editorSceneLogic.ts",
        "summary": "This code defines the logic for the data warehouse editor scene in PostHog. It manages the state and actions related to selecting a database schema (table or view), displaying its details in a sidebar overlay, and handling joins between tables. The logic connects to other kea logics for managing joins, database tables, and data warehouse views, allowing it to load and display relevant data. It also provides functionality for editing and deleting joins associated with the selected schema.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Schema Selection:** Allows users to select a database schema (table or view) to inspect.\n*   **Sidebar Overlay:** Displays details of the selected schema in a sidebar overlay.\n*   **Join Management:** Enables users to view, edit, and delete joins associated with the selected schema.\n*   **Data Warehouse Integration:** Integrates with data warehouse tables and views.\n*   **PostHog Table Integration:** Integrates with PostHog tables.\n*   **Context Menu for Fields:** Provides context menu options for fields in the schema, such as editing or deleting joins.\n*   **Real-time Updates:** Automatically updates the display when joins are modified or deleted.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/QueryTabs.tsx",
        "summary": "This code defines the `QueryTabs` component, which manages and displays tabs for different queries within a data warehouse editor. It allows users to switch between queries, rename them (except for views), and add new queries. Each tab displays the query name and provides a button to close the tab (if more than one tab exists). The active tab is visually highlighted.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Tabbed Interface for Queries:** Allows users to work with multiple queries simultaneously using a tabbed interface.\n*   **Query Switching:** Enables users to easily switch between different queries by clicking on their respective tabs.\n*   **Query Renaming:** Provides functionality to rename queries (excluding views) directly within the tab.\n*   **Adding New Queries:** Allows users to add new, blank queries to the editor.\n*   **Query Closing:** Enables users to close existing query tabs, with a safeguard to prevent closing the last remaining tab.\n*   **Visual Highlighting of Active Query:** Clearly indicates the currently active query tab.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/EditorScene.tsx",
        "summary": "The `EditorScene.tsx` file defines the main component for the data warehouse editor. It integrates various Kea logics to manage the editor's state, sizing, query input, data visualization, and variable handling. The component renders a layout with an editor sidebar and a query window, allowing users to write and execute HogQL queries, visualize the results, and manage variables. It also includes a modal for viewing links. The editor uses Monaco for code editing and supports multiple tabs.\n\nHere's a list of high-level product features based on the code:\n\n*   **HogQL Query Editor:** Provides a Monaco-based code editor for writing and editing HogQL queries.\n*   **Multi-Tab Support:** Allows users to work with multiple queries simultaneously using a tabbed interface.\n*   **Data Visualization:** Enables users to visualize query results in various chart types.\n*   **Variable Management:** Provides a UI for defining and managing variables within queries.\n*   **Editor Sidebar:** Offers a sidebar for additional editor-related functionalities (details not evident in the code snippet).\n*   **Query Execution:** Allows users to execute HogQL queries and view the results.\n*   **Layout Management:** Manages the sizing and positioning of the editor components (sidebar, query window).\n*   **View Link Modal:** Displays a modal for viewing relevant links.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/editorSizingLogic.tsx",
        "summary": "This code defines the `editorSizingLogic` using Kea, a state management library. It manages the sizing and resizing behavior of different panels within a data warehouse editor, including the source navigator, sidebar, and query pane. It defines minimum, default, and maximum widths/heights for these panels and uses resizerLogic to handle the actual resizing interactions. The logic also provides selectors to retrieve the current sizes and resizer properties, ensuring that the UI components can adapt to user-driven size changes.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Resizable Source Navigator:** Allows users to adjust the width of the source navigator panel.\n*   **Resizable Sidebar:** Enables users to change the width of the sidebar, with defined minimum, default, and maximum sizes.\n*   **Collapsible Sidebar:** Allows the sidebar to collapse completely, taking up no space.\n*   **Resizable Query Pane:** Provides the ability to adjust the height of the query pane.\n*   **Persistent Panel Sizes:** Remembers the user's preferred panel sizes.\n*   **Default Panel Sizes:** Provides sensible default sizes for each panel.\n*   **Minimum Panel Sizes:** Enforces minimum sizes to ensure usability.\n*   **Maximum Panel Sizes:** Enforces maximum sizes to prevent panels from taking up too much space.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/OutputPane.tsx",
        "summary": "The `OutputPane.tsx` file defines the `OutputPane` component, which is responsible for displaying the results and visualizations of data warehouse queries. It features a tabbed interface to switch between raw results and visualizations, supports exporting query results in CSV and XLSX formats, and allows users to save visualizations as insights. The component also includes features for displaying loading states, error messages, and query execution time, as well as a modal for viewing detailed information about individual rows in the result set.\n\nHere's a list of high-level product features:\n\n*   **Tabbed Output:** Displays query results in separate tabs for raw data and visualizations.\n*   **Data Grid Display:** Renders tabular data in an interactive data grid with column resizing and expandable cells for long content.\n*   **Data Visualization:** Supports various chart types (line graph, bar chart, etc.) and table visualizations of query results.\n*   **Export Functionality:** Allows exporting query results in CSV and XLSX formats.\n*   **Insight Creation:** Enables users to save visualizations as insights for future reference and analysis.\n*   **Row Details Modal:** Provides a modal to view detailed information about individual rows in the result set.\n*   **Loading and Error Handling:** Displays loading indicators and error messages to provide feedback on query execution status.\n*   **Query Execution Time:** Shows the time taken to execute the query.\n*   **Visualization Settings:** Provides a sidebar for adjusting visualization settings."
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/editorSidebarLogic.tsx",
        "summary": "This code defines the logic for the sidebar in the data warehouse editor. It manages the display of data warehouse sources (tables) and saved queries (views) in a categorized and searchable manner. The sidebar allows users to browse tables and views, add joins, copy table/view names, edit view definitions, and delete views. It also handles the display of an empty state with a call to action to add a data source when no sources are connected. The logic uses Fuse.js for searching and provides actions for selecting schemas, managing views, and navigating to data source creation.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Data Warehouse Source Browsing:** Allows users to explore available data warehouse tables, categorized by source type (e.g., Postgres, Stripe, PostHog).\n*   **Saved Query (View) Browsing:** Enables users to view and interact with saved queries, distinguishing between materialized and non-materialized views.\n*   **Search Functionality:** Provides a search bar to quickly find specific tables or views by name.\n*   **Schema Selection:** Allows users to select a table or view, triggering an action to display its schema in the editor.\n*   **Add Join Action:** Provides a context menu option to add a selected table or view as a join in the query editor.\n*   **Copy Table/View Name:** Enables users to easily copy the name of a table or view to the clipboard.\n*   **View Editing:** Allows users to edit the definition of a saved query (view) directly from the sidebar.\n*   **View Deletion:** Provides a context menu option to delete a saved query (view).\n*   **Empty State Guidance:** Displays a helpful message and a call-to-action button to add a data source when no sources are connected.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor/multitabEditorLogic.tsx",
        "summary": "This code defines the `multitabEditorLogic` Kea logic for managing a multi-tab editor in the data warehouse feature. It handles creating, deleting, renaming, and selecting tabs, each containing a query. The logic persists tab state, manages the active query, and integrates with the Monaco code editor for syntax highlighting and code completion. It also supports saving queries as views or insights and handles unsaved changes warnings. The logic interacts with the data warehouse views logic to load and manage saved queries.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Multi-Tab Query Editor:** Allows users to work on multiple queries simultaneously in separate tabs.\n*   **Query Management:** Enables users to create, delete, rename, and select queries within the editor.\n*   **Syntax Highlighting and Code Completion:** Provides a rich code editing experience with syntax highlighting and code completion (via Monaco editor).\n*   **Persistence of Tab State:** Saves and restores the state of the editor, including open tabs and their contents.\n*   **Save Query as View:** Allows users to save queries as reusable views in the data warehouse.\n*   **Save Query as Insight:** Enables users to save queries as insights for data visualization and analysis.\n*   **Unsaved Changes Warning:** Prompts users with a warning before closing a tab with unsaved changes.\n*   **Integration with Data Warehouse Views:** Loads and manages saved queries from the data warehouse.\n*   **Automatic Naming of New Queries:** Automatically names new queries with \"Untitled\" and an incrementing number.\n*   **Edit Existing Views:** Allows users to open existing views in a tab for editing.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse/editor",
        "summary": "The data warehouse editor provides a comprehensive suite of tools for querying, visualizing, and managing data within a data warehouse environment. It features a multi-tabbed interface for working on multiple queries simultaneously, a Monaco-based code editor with syntax highlighting and autocompletion for writing HogQL queries, and a dynamic sidebar for browsing schemas, managing joins, and configuring materialization settings. The editor also includes an output pane for displaying query results in both raw data and visual formats, with options for exporting data and saving visualizations as insights. The editor's layout is fully customizable with resizable panels and collapsible sections, ensuring a tailored user experience.\n\nHere's a list of high-level product features:\n\n*   **HogQL Query Editor:** Monaco-based code editor with syntax highlighting and autocompletion.\n*   **Multi-Tab Support:** Work with multiple queries simultaneously.\n*   **Data Visualization:** Visualize query results in various chart types and tables.\n*   **Schema Browsing:** Explore the data warehouse structure.\n*   **Join Management:** Add, edit, and delete joins between tables.\n*   **Materialization Configuration:** Set sync frequency and manually trigger syncs for materialized views.\n*   **Variable Management:** Add, edit, and remove query variables.\n*   **Resizable Panels:** Customize the layout with resizable source navigator, sidebar, and query pane.\n*   **Export Functionality:** Export query results in CSV and XLSX formats.\n*   **Insight Creation:** Save visualizations as insights.\n*   **Search Functionality:** Search for schemas, tables, and views.\n*   **Tab Management:** Create, delete, rename, and switch between query tabs.\n*   **Performance Hints:** Provides feedback on query performance.\n*   **Loading State Indication:** Provides visual feedback during view creation.\n*   **Automatic Width Adjustment:** Input fields dynamically resize to fit content.\n"
    },
    {
        "path": "frontend/src/scenes/data-warehouse",
        "summary": "The PostHog data warehouse integration provides a comprehensive suite of tools for connecting to, managing, and analyzing data from external sources. Users can seamlessly connect to various data sources, define and manage schemas, create and manage data warehouse tables and views, including materialized views with configurable sync schedules. The integration features a powerful HogQL query editor with syntax highlighting and autocompletion, enabling users to explore data, create joins, and visualize query results in various formats. The system also provides real-time updates, user-friendly error messages, and tools for monitoring sync jobs and managing logs, ensuring a smooth and efficient data warehouse management experience.\n\nHere's a list of high-level product features:\n\n*   Data Source Management (Connectors for various sources, including cloud storage and databases)\n*   Schema Management (View, edit, refresh, and resync schemas)\n*   Table and View Management (CRUD operations for tables, views, and materialized views)\n*   HogQL Query Editor (Syntax highlighting, autocompletion, multi-tab support)\n*   Data Visualization (Chart types and tables for query results)\n*   Join Management (Create and manage joins between tables)\n*   Materialization (Run and schedule materializations for views)\n*   Sync Monitoring (View sync job status and logs)\n*   Insight Integration (Save visualizations as insights)\n*   Billing Limit Notice (Display billing limit information)\n*   Data Source Connection Wizard (Guided setup for connecting external data sources)\n*   Experiment Optimization (Optimize joins for experiment analysis)\n*   Default Query Generation (Automatically generate basic HogQL queries)\n*   Data Warehouse Table Integration (Connect to and retrieve schema information from data warehouses)\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/PathCleaningFilter.tsx",
        "summary": "The `PathCleaningFilter` component allows users to configure and apply path cleaning rules to insights. It provides a UI for managing local path cleaning filters specific to the insight and a toggle to apply global path cleaning rules defined at the team level. The component also links to the path cleaning settings page, allowing users to manage global path cleaning rules.\n\n**Features:**\n\n*   **Local Path Cleaning Filters:** Allows users to define and manage path cleaning filters specific to the current insight.\n*   **Global Path Cleaning Toggle:** Enables or disables the application of global path cleaning rules defined at the team level.\n*   **Path Cleaning Settings Link:** Provides a direct link to the path cleaning settings page for managing global path cleaning rules.\n*   **Tooltip Explanation:** Explains the functionality and status of the global path cleaning toggle, indicating whether global filters are configured and active.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/RetentionCumulativeButton.tsx",
        "summary": "This React component, `RetentionCumulativeButton`, provides a toggle button to control whether retention calculations are cumulative or not. It leverages the `LemonSegmentedButton` component from `@posthog/lemon-ui` and utilizes `kea` logic for state management and actions related to insights. The button allows users to switch between \"on\" (specific period retention) and \"on or after\" (cumulative retention) modes, updating the insight filter accordingly. The component is only rendered if the user has editing permissions for the insight.\n\nHere's a list of high-level product features:\n\n*   **Cumulative Retention Toggle:** Allows users to switch between calculating retention for a specific period or cumulatively across periods.\n*   **Visual Toggle Interface:** Uses a segmented button to provide a clear and intuitive interface for switching between retention modes.\n*   **Tooltip Explanations:** Provides helpful tooltips to explain the difference between specific period and cumulative retention calculations.\n*   **Permission-Based Rendering:** Only displays the toggle if the user has editing permissions for the insight.\n"
    },
    {
        "path": "frontend/src/scenes/userLogic.ts",
        "summary": "This code defines the `userLogic` using Kea, a state management library. It handles user-related data and actions, including loading user information, updating user details, managing organization and team context, tracking product intro status, and handling user logout. The logic interacts with a backend API to persist user data and uses `posthog-js` for user identification and tracking. It also manages form state for user details and provides selectors for accessing user properties and available features.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **User Profile Management:** Loading, updating, and displaying user information (name, email, etc.).\n*   **Organization and Team Switching:** Allows users to switch between different organizations and teams they belong to.\n*   **Feature Availability Management:** Determines which product features are available to a user based on their organization's plan.\n*   **Product Intro Tracking:** Tracks whether a user has seen the product introduction for specific features.\n*   **User Preferences:** Persists and applies user preferences such as theme mode.\n*   **User Identification and Tracking:** Integrates with PostHog for user identification, tracking, and analytics.\n*   **Scene Personalization:** Allows users to personalize their experience for specific scenes/dashboards.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/ActionFilter/ActionFilterRow/ActionFilterRow.tsx",
        "summary": "This code defines the `ActionFilterRow` component, a key element in the PostHog insights interface for filtering and customizing data displayed in charts and graphs. It allows users to select events or actions, apply property filters, define mathematical operations on the data, and reorder or remove filters. The component is highly configurable, offering options to hide or show various controls, customize the appearance, and integrate with other PostHog features like data warehouses and HogQL. It leverages drag-and-drop functionality for reordering and provides visual cues like series indicators and nested arrows to enhance usability.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Event/Action Selection:** Allows users to choose specific events or actions to include in their insights.\n*   **Property Filtering:** Enables users to filter events/actions based on their properties.\n*   **Mathematical Operations:** Supports applying mathematical functions (e.g., count, sum) to event/action data.\n*   **Data Transformation with HogQL:** Allows users to use HogQL to transform the data.\n*   **Series Customization:** Provides options to rename, duplicate, and reorder data series in charts.\n*   **Drag and Drop Reordering:** Enables users to reorder filters using drag and drop.\n*   **Visual Indicators:** Uses series indicators (letters or numbers) to visually distinguish data series.\n*   **Data Warehouse Integration:** Allows filtering based on data from connected data warehouses.\n*   **Customizable UI:** Offers options to hide or show specific controls and customize the appearance of the filter row.\n*   **Math Type Warnings:** Warns users about potentially incorrect math types."
    },
    {
        "path": "frontend/src/scenes/insights/filters/ActionFilter/ActionFilterRow",
        "summary": "The `ActionFilterRow` component is a versatile tool within the PostHog insights interface, empowering users to precisely define and customize the data displayed in charts and graphs. It provides a rich set of features for selecting events/actions, applying property-based filters, performing mathematical operations, and leveraging HogQL for advanced data transformations. The component also supports series customization, drag-and-drop reordering, visual indicators, data warehouse integration, and UI customization options, making it a central hub for data exploration and analysis.\n\nHere's a list of high-level product features enabled by this component:\n\n*   Event/Action Selection\n*   Property Filtering\n*   Mathematical Operations\n*   Data Transformation with HogQL\n*   Series Customization\n*   Drag and Drop Reordering\n*   Visual Indicators\n*   Data Warehouse Integration\n*   Customizable UI\n*   Math Type Warnings\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/ActionFilter/renameModalLogic.ts",
        "summary": "This code defines a Kea logic module called `renameModalLogic` that manages the state and actions for a modal that allows users to rename an entity filter. It connects to the `entityFilterLogic` to access the currently selected filter and provides actions to set the name of the filter. The logic stores the current name in its state and updates it when the user types in the modal or when a new filter is selected.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Rename Entity Filters:** Allows users to change the display name of an entity filter (e.g., actions, events, properties) within the insights interface.\n*   **Dynamic Name Updates:** The modal's input field is automatically populated with the current name of the selected filter.\n*   **Real-time Name Editing:** As the user types in the modal, the name is updated in the logic's state.\n*   **Filter Selection Integration:** When a new filter is selected, the modal's input field is updated with the new filter's name.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/ActionFilter/RenameModal.tsx",
        "summary": "The `RenameModal.tsx` file defines a modal component that allows users to rename graph series or funnel steps within the insights interface. This modal provides a text input field where users can enter a new name for the selected filter. The modal also displays the current name of the filter as a suffix to the input field. Users can confirm the renaming by clicking a primary button, which triggers the `renameFilter` action, or cancel the operation. The modal is controlled by the `entityFilterLogic` and `renameModalLogic` kea logics.\n\nHere's a list of high-level product features:\n\n*   **Rename Graph Series/Funnel Steps:** Allows users to rename data series in graphs or steps in funnels for better clarity.\n*   **Modal Interface:** Provides a modal window for the renaming process, ensuring a focused user experience.\n*   **Input Field with Current Name Display:** Includes an input field for entering the new name, with the current name displayed for context.\n*   **Confirmation and Cancellation Options:** Offers buttons to confirm the renaming or cancel the operation.\n*   **Dashboard Integration:** Custom names are reflected on dashboards.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/ActionFilter/entityFilterLogic.ts",
        "summary": "This code defines the `entityFilterLogic` Kea logic for managing entity filters (actions, events, and data warehouse filters) within an insights dashboard. It handles the creation, modification, deletion, and reordering of these filters, as well as their visibility. The logic also manages a modal for renaming filters and persists changes to the parent component through a `setFilters` prop. It converts between local filter representations (with UUIDs and order) and the format expected by the parent component. The logic also tracks usage events for filter modifications.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Adding Filters:** Allows users to add new filters for actions, events, or data warehouse items to an insight.\n*   **Removing Filters:** Enables users to remove existing filters from an insight.\n*   **Editing Filters:** Provides functionality to modify filter properties, including name, ID, type, custom name, and data warehouse specific fields.\n*   **Reordering Filters:** Supports reordering the sequence of filters, affecting how they are applied.\n*   **Duplicating Filters:** Allows users to duplicate existing filters for faster configuration.\n*   **Renaming Filters:** Enables users to assign custom names to filters for better organization and clarity.\n*   **Setting Filter Visibility:** Allows users to toggle the visibility of individual filters.\n*   **Property Filtering:** Supports filtering entities based on properties.\n*   **Math Operations on Filters:** Allows users to perform mathematical operations on filter data.\n*   **Data Warehouse Integration:** Supports filtering based on data from a data warehouse, including dynamically handling fields.\n*   **Single Filter Mode:** Provides a simplified mode where only a single filter is allowed.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/ActionFilter/ActionFilter.tsx",
        "summary": "This code defines the `ActionFilter` React component, a versatile UI element for managing and displaying a list of actions or events used as filters within PostHog insights. It allows users to add, remove, reorder (via drag and drop), and rename these filters. Each filter row displays details and provides options for further configuration, such as property filters and math operations. The component is highly customizable with props to control its appearance, behavior, and available options, including disabling features, limiting the number of filters, and customizing the display of each row. It is used in various insight types, including trends and funnels, and integrates with other PostHog components and logic for data management and event tracking.\n\nHere's a list of high-level product features provided by the `ActionFilter` component:\n\n*   **Add/Remove Actions/Events:** Allows users to add and remove actions or events to be used as filters.\n*   **Reorder Actions/Events (Drag and Drop):** Enables users to reorder actions/events via drag and drop, primarily for funnel step reordering.\n*   **Rename Actions/Events:** Provides the ability to rename actions/events for clarity and organization.\n*   **Configure Property Filters:** Allows users to configure property filters for each action/event to refine the data being analyzed.\n*   **Math Operations:** Supports applying math operations to actions/events for advanced analysis.\n*   **Series Indicators:** Displays indicators (A, B, C or 1, 2, 3) to identify each graph series.\n*   **Customizable Display:** Offers various customization options for appearance and behavior, including disabling features, limiting the number of filters, and customizing row display.\n*   **Data Warehouse Integration:** Supports integration with data warehouses through popover fields.\n*   **Read-only Mode:** Provides a read-only mode to prevent modifications.\n*   **Duplicate Actions/Events:** Provides the ability to duplicate actions/events.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/ActionFilter",
        "summary": "The PostHog insights interface provides a comprehensive suite of features for data exploration and analysis, centered around the management and customization of event and action filters. Users can precisely define the data displayed in charts and graphs through a rich set of tools, including selection, filtering, renaming, reordering, and mathematical operations. The interface also supports advanced data transformations with HogQL, series customization, visual indicators, and data warehouse integration, all within a customizable UI. These features empower users to gain deeper insights from their data and tailor the analysis to their specific needs.\n\n*   Event/Action Selection\n*   Property Filtering\n*   Mathematical Operations\n*   Data Transformation with HogQL\n*   Series Customization\n*   Drag and Drop Reordering\n*   Visual Indicators\n*   Data Warehouse Integration\n*   Customizable UI\n*   Rename Graph Series/Funnel Steps\n*   Add/Remove Actions/Events\n*   Duplicate Actions/Events\n*   Configure Property Filters\n*   Rename Entity Filters\n*   Set Filter Visibility\n*   Single Filter Mode\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/TestAccountFilter/index.ts",
        "summary": "The code exports the `TestAccountFilter` component, making it available for use in other parts of the application. This suggests the existence of a feature that allows filtering data based on whether it originates from a test account.\n\nHere's a list of high-level product features:\n\n*   **Test Account Filtering:** Allows users to filter insights data to include or exclude data originating from test accounts.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/RetentionMeanDropdown.tsx",
        "summary": "This React component, `RetentionMeanDropdown`, provides a dropdown menu for selecting the method of calculating the mean retention rate in insights. It allows users with editing permissions to choose between \"simple\" (equal weight to each cohort) and \"weighted\" (weight based on cohort size) calculations. The selected method is then used to update the insight's filter settings. If the user does not have edit permissions, the component renders nothing.\n\n**Features:**\n\n*   **Mean Retention Calculation Selection:** Allows users to choose between different methods for calculating the mean retention rate.\n*   **Simple Mean Calculation:** Provides an option to calculate the mean retention rate by giving equal weight to each cohort.\n*   **Weighted Mean Calculation:** Provides an option to calculate the mean retention rate by giving more weight to larger cohorts.\n*   **Edit Permission Check:** Only displays the dropdown if the user has permission to edit the insight.\n*   **Tooltip Explanations:** Provides tooltips to explain the difference between the simple and weighted mean calculation methods.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/RetentionChartPicker.tsx",
        "summary": "The `RetentionChartPicker` component provides a user interface element for selecting the chart type used to display retention data in the insights dashboard. It uses a `LemonSelect` component to present the user with options for displaying retention data as either a line chart or a bar chart. The component utilizes kea logic to manage the state and update the insight filters based on the user's selection.\n\nHere's a list of high-level product features:\n\n*   **Chart Type Selection:** Allows users to choose between different chart types (line chart, bar chart) for visualizing retention data.\n*   **Visual Retention Data:** Displays retention data in a graphical format.\n*   **Insight Filter Update:** Updates the insight filters based on the selected chart type.\n*   **UI Component Integration:** Integrates with the `LemonSelect` UI component for a user-friendly selection experience.\n*   **Descriptive Labels:** Provides descriptive labels and descriptions for each chart type option.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/TestAccountFilter/TestAccountFilter.tsx",
        "summary": "This code defines a React component called `TestAccountFilter` that allows users to toggle the filtering of internal and test users from their analytics data. It utilizes a LemonSwitch component to provide a user-friendly on/off switch. The component checks if any test account filters are defined for the current team and enables/disables the switch accordingly. When the switch is toggled, it updates the filter settings and sets a local default. A gear icon button links to the internal user filtering settings page.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Toggle for Filtering Test Accounts:** Provides a simple switch to enable or disable the filtering of internal and test users.\n*   **Visual Indication of Filter Status:** Clearly shows whether test account filtering is currently active.\n*   **Link to Filter Settings:** Offers a direct link to the settings page where users can define their internal user filters.\n*   **Disabled State with Explanation:** Disables the filter if no test account filters are defined, providing a clear explanation to the user.\n*   **Persistence of Filter Preference:** Remembers the user's filter preference locally.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/RetentionReferencePicker.tsx",
        "summary": "This React component, `RetentionReferencePicker`, provides a dropdown menu for users to select the reference point for retention calculations in insights. It utilizes `LemonSelect` from `@posthog/lemon-ui` and leverages `kea` logic (`insightLogic`, `insightVizDataLogic`) to manage and update the retention reference filter. Users can choose between \"starting cohort size\" (total) and \"previous period\" as the reference, influencing how retention is calculated and displayed.\n\n**Features:**\n\n*   **Retention Reference Selection:** Allows users to choose the reference point for retention calculations.\n*   **Starting Cohort Size Reference:** Calculates retention based on the initial cohort size.\n*   **Previous Period Reference:** Calculates retention based on the previous period's user count.\n*   **Dropdown Menu Interface:** Provides a user-friendly dropdown menu for selecting the retention reference.\n*   **Tooltip Explanations:** Offers tooltips to explain the meaning of each reference option.\n*   **Dynamic Filter Updates:** Updates the insight filter in real-time based on the selected reference.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/TestAccountFilter",
        "summary": "The code implements a `TestAccountFilter` component that allows users to easily include or exclude data from test accounts in their analytics insights. This is achieved through a toggle switch that visually indicates the current filter status and provides a direct link to the settings page for defining internal user filters. The component also handles scenarios where no test account filters are defined, disabling the switch and providing an explanation to the user, while also persisting the user's filter preference locally.\n\nHere's a list of high-level product features:\n\n*   **Test Account Filtering:** Enables users to filter analytics data based on whether it originates from test accounts.\n*   **Toggle Control:** Provides a user-friendly switch to enable or disable test account filtering.\n*   **Visual Filter Status:** Clearly indicates whether test account filtering is currently active.\n*   **Settings Link:** Offers a direct link to the settings page for defining internal user filters.\n*   **Disabled State with Explanation:** Disables the filter if no test account filters are defined, providing a clear explanation.\n*   **Filter Preference Persistence:** Remembers the user's filter preference locally.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/RetentionDashboardDisplayPicker.tsx",
        "summary": "This React component, `RetentionDashboardDisplayPicker`, allows users with editing permissions to select how retention data is displayed on a dashboard. It uses a LemonSelect component to provide options for displaying the data as a table only, a graph only, or both. The selected display type is then saved as part of the insight's filter configuration.\n\n**Features:**\n\n*   **Display Type Selection:** Allows users to choose between displaying retention data as a table, a graph, or both.\n*   **Editable Insights Only:** The display picker is only visible to users who have permission to edit the insight.\n*   **Persisted Display Preference:** The selected display type is saved and persisted as part of the insight's filter configuration.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/FunnelExclusionsFilter/ExclusionRow.tsx",
        "summary": "The `ExclusionRow` component is a flexible layout component used to display a row of elements, primarily within the context of funnel exclusions. It accepts a series indicator, a filter element, and a suffix element, arranging them horizontally or vertically based on the `isVertical` prop. This component is designed to provide a structured way to present filter criteria and related information, likely within a larger interface for defining funnel exclusions.\n\nHere's a list of high-level product features that can be inferred from this component:\n\n*   **Funnel Exclusion Definition:** Allows users to define criteria to exclude specific events or users from a funnel analysis.\n*   **Customizable Filter Display:** Provides a way to display filter criteria with associated indicators and suffixes.\n*   **Flexible Layout Options:** Supports both horizontal and vertical layouts for displaying filter rows.\n*   **Visual Representation of Funnel Steps:** Uses series indicators to visually represent the steps in a funnel.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/FunnelExclusionsFilter/FunnelExclusionsFilter.tsx",
        "summary": "The `FunnelExclusionsFilter` component provides a user interface for defining event-based exclusions within a funnel insight. It leverages the `ActionFilter` component to manage a list of events that should be excluded from the funnel analysis. Users can add, configure, and remove exclusion filters, specifying the step range within the funnel to which each exclusion applies. The component dynamically adapts its layout based on available width, switching to a vertical layout on smaller screens. It integrates with the insight logic to persist the defined exclusions and update the funnel visualization accordingly.\n\nHere's a list of high-level product features:\n\n*   **Define Funnel Exclusions:** Allows users to specify events to exclude from funnel analysis.\n*   **Step-Specific Exclusions:** Enables users to define the step range within the funnel to which an exclusion applies.\n*   **Dynamic Layout:** Adapts the filter layout based on screen size for optimal usability.\n*   **Event Selection:** Provides a mechanism to select events to be used as exclusion criteria.\n*   **Persistence:** Saves and retrieves exclusion filters to maintain user configurations.\n*   **Visual Integration:** Updates the funnel visualization to reflect the defined exclusions.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/FunnelExclusionsFilter/ExclusionRowSuffix.tsx",
        "summary": "This component, `ExclusionRowSuffix`, is a part of the funnel insights feature, specifically dealing with defining exclusion criteria within a funnel analysis. It provides a UI for specifying a range of steps within the funnel to exclude from the results. The component allows users to select a \"from\" and \"to\" step, defining the range to exclude. It also includes a button to remove the exclusion rule. The component uses `LemonSelect` for step selection and `LemonButton` for deletion, and it dynamically adjusts the available step options based on the number of steps in the funnel and the currently selected \"from\" step.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Funnel Step Exclusion:** Allows users to exclude specific steps or ranges of steps from a funnel analysis.\n*   **Step Range Selection:** Provides a UI to define the start and end steps for exclusion.\n*   **Dynamic Step Options:** Dynamically adjusts the available step options based on the funnel's configuration.\n*   **Exclusion Removal:** Enables users to remove defined exclusion rules.\n*   **Visual Indication of Exclusion:** Provides a clear visual representation of the exclusion criteria within the funnel analysis interface.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/FunnelExclusionsFilter",
        "summary": "The funnel exclusions filter feature allows users to refine funnel insights by defining criteria to exclude specific events or users from the analysis. This includes the ability to specify a range of steps within the funnel to which the exclusion applies, with a dynamic UI that adapts to the funnel's configuration and screen size. Users can add, configure, and remove exclusion filters, and the funnel visualization updates to reflect the defined exclusions.\n\nHere's a list of high-level product features:\n\n*   Define Funnel Exclusions: Specify events to exclude from funnel analysis.\n*   Step-Specific Exclusions: Define the step range within the funnel to which an exclusion applies.\n*   Dynamic Step Options: Dynamically adjusts the available step options based on the funnel's configuration.\n*   Exclusion Removal: Remove defined exclusion rules.\n*   Dynamic Layout: Adapts the filter layout based on screen size for optimal usability.\n*   Visual Integration: Updates the funnel visualization to reflect the defined exclusions.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/BreakdownFilter/TaxonomicBreakdownButton.tsx",
        "summary": "The `TaxonomicBreakdownButton` component provides a button that, when clicked, opens a popover (`TaxonomicBreakdownPopover`) allowing the user to add a breakdown to an insight. The button's text dynamically changes between \"Add cohort\" and \"Add breakdown\" based on the currently selected taxonomic breakdown type. The button can also be disabled with a reason provided.\n\nHere's a list of high-level product features associated with this component:\n\n*   **Add Breakdown:** Allows users to break down insights by various taxonomic filters.\n*   **Add Cohort:** Specifically allows users to break down insights by cohorts.\n*   **Dynamic Button Text:** The button text adapts to reflect the type of breakdown being added (cohort or other).\n*   **Popover Interface:** Provides a popover interface for selecting breakdown options.\n*   **Disable Button:** Allows disabling the button with a descriptive reason.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/BreakdownFilter/taxonomicBreakdownFilterUtils.ts",
        "summary": "This code provides utility functions for handling breakdown filters in the PostHog insights frontend, specifically focusing on taxonomic breakdowns. It includes type guards to identify cohort breakdowns (either specific cohorts by ID or \"all\" cohorts), and functions to determine if a property name should be normalized for URLs and whether a breakdown type supports multiple breakdowns.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Cohort Breakdown Filtering:** Allows users to filter insights based on cohorts, including the ability to view data for all cohorts or specific cohorts.\n*   **URL Normalization for Breakdown Properties:** Ensures consistent URL handling for specific breakdown properties like `$current_url` and `$pathname`.\n*   **Multiple Breakdown Type Support:** Enables the selection of breakdown types that support multiple breakdowns, such as person, event, group, session, and hogql.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/BreakdownFilter/GlobalBreakdownOptionsMenu.tsx",
        "summary": "This component, `GlobalBreakdownOptionsMenu`, provides a set of options to configure how breakdowns are displayed in insights, specifically within the Trends visualization. It allows users to control whether to group smaller breakdown values under an \"Other\" category and to set a limit on the number of breakdown options displayed. These options help to manage the visual complexity of insights when dealing with a large number of breakdown values.\n\nHere's a list of the high-level features:\n\n*   **Toggle \"Other\" Category:** Allows users to show or hide the \"Other\" category, which aggregates smaller breakdown values when the number of breakdowns exceeds the defined limit.\n*   **Set Breakdown Limit:** Enables users to define the maximum number of breakdown options to display, improving readability and performance when dealing with numerous breakdown values.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/BreakdownFilter/TaxonomicBreakdownPopover.tsx",
        "summary": "This component, `TaxonomicBreakdownPopover`, provides a popover interface for selecting a breakdown dimension for insights. It leverages the `TaxonomicFilter` component to allow users to choose from various taxonomic groups like event properties, person properties, cohorts, HogQL expressions, and data warehouse properties. The selected breakdown is then applied to the insight, updating the visualization. The popover is triggered by a child element and closes when the user clicks outside of it or selects a breakdown.\n\nHere's a list of high-level product features:\n\n*   **Taxonomic Breakdown Selection:** Allows users to break down insights by various taxonomic groups (event properties, person properties, cohorts, etc.).\n*   **Popover Interface:** Presents the breakdown options in a popover for a clean and focused user experience.\n*   **Dynamic Taxonomic Groups:** Dynamically includes or excludes taxonomic groups like session properties based on configuration.\n*   **Integration with Insight Visualization:** Seamlessly applies the selected breakdown to update the insight visualization.\n*   **Data Warehouse Property Support:** Enables breakdown by properties from connected data warehouses.\n*   **HogQL Expression Support:** Enables breakdown by HogQL expressions.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/BreakdownFilter/BreakdownTagMenu.tsx",
        "summary": "The `BreakdownTagMenu` component provides a menu for configuring and managing breakdowns in insights. It allows users to normalize URL paths, control histogram binning for numeric breakdowns, and remove the breakdown. The menu dynamically displays options based on whether the breakdown is histogramable, normalizeable, and whether multiple breakdowns are enabled. It uses Lemon UI components for switches, buttons, inputs, and tooltips to provide a user-friendly interface.\n\nHere's a list of high-level product features:\n\n*   **URL Path Normalization:** Option to strip noise from URL paths (trailing slashes, question marks, and hashes) to group similar URLs together.\n*   **Histogram Binning:** Allows users to bin numeric breakdown values into a specified number of bins or disable binning.\n*   **Breakdown Removal:** Provides a button to remove the current breakdown from the insight.\n*   **Global Breakdown Options:** Integrates with a global options menu for breakdowns when multiple breakdowns are not enabled.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/BreakdownFilter/TaxonomicBreakdownFilter.tsx",
        "summary": "This code defines a `TaxonomicBreakdownFilter` component in a React application, likely for a product analytics platform. The component allows users to specify how they want to break down their data in insights, such as charts and graphs. It provides a user interface for adding, editing, and removing breakdowns based on taxonomic properties (e.g., event properties, user properties). The component also includes options for configuring global breakdown settings and handles the display of breakdown tags.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Breakdown Selection:** Allows users to select properties to break down data by.\n*   **Taxonomic Property Support:** Supports various property types for breakdowns (e.g., event properties, user properties).\n*   **Editable Breakdown Tags:** Displays selected breakdowns as editable tags for easy modification.\n*   **Multiple Breakdowns:** Supports the ability to break down data by multiple properties.\n*   **Global Breakdown Options:** Provides a menu for configuring global breakdown settings.\n*   **Visual Display Configuration:** Allows users to configure the visual display of the chart.\n*   **Disable Breakdown:** Allows the user to disable the breakdown based on a reason.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/BreakdownFilter/breakdownTagLogic.ts",
        "summary": "This code defines the `breakdownTagLogic` Kea logic, which manages the state and actions related to individual breakdown tags within the Insights interface. It handles the removal of breakdowns, and the configuration of histogram bin counts and URL normalization for breakdowns, both globally and individually when multiple breakdowns are enabled. The logic connects to other models and logics to access property definitions, cohorts, and the overall taxonomic breakdown filter configuration. It determines whether a breakdown is histogrammable or normalizeable based on its property definition and type, and provides selectors to derive the appropriate taxonomic filter type for the breakdown.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Breakdown Management:** Allows users to add, remove, and configure breakdowns in insights.\n*   **Histogram Configuration:** Enables users to configure the number of bins used in histograms for numerical breakdowns.\n*   **URL Normalization:** Provides the option to normalize URLs for breakdowns based on URL properties.\n*   **Multiple Breakdowns:** Supports the use of multiple breakdowns in insights, with individual configurations for each.\n*   **Taxonomic Filtering:** Integrates with the taxonomic filter component to provide a consistent filtering experience for breakdowns.\n*   **Cohort Breakdown:** Allows breakdowns by cohorts, including a special \"All Users\" cohort.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/BreakdownFilter/BreakdownTag.tsx",
        "summary": "This code defines a React component called `EditableBreakdownTag` that renders a tag representing a breakdown in PostHog insights. The tag displays the breakdown value (e.g., a property name or cohort) and allows users to interact with it. Depending on the breakdown type and insight settings, the tag may include a close button to remove the breakdown, a popover to edit the breakdown, and a menu for additional options. The component uses Lemon UI's `LemonTag` for styling and leverages Kea logic for state management and actions. It also utilizes context to manage popover interactions and display property information.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Breakdown Tag Display:** Renders a visual tag representing a breakdown value (property, cohort, etc.) in insights.\n*   **Breakdown Removal:** Allows users to remove a breakdown from the insight via a close button on the tag (conditionally enabled).\n*   **Breakdown Editing:** Provides a popover interface for editing the breakdown value or type.\n*   **Breakdown Menu:** Offers a menu with additional options related to the breakdown (e.g., histogram, normalization).\n*   **Property Information Display:** Shows information about the property being used as a breakdown, such as its type and description.\n*   **Cohort Name Resolution:** Displays the name of a cohort when the breakdown represents a cohort ID.\n*   **Dynamic Tag Behavior:** Adapts the tag's behavior (close button, edit popover) based on insight settings and breakdown type.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/BreakdownFilter/taxonomicBreakdownFilterLogic.ts",
        "summary": "This code defines a Kea logic module called `taxonomicBreakdownFilterLogic` that manages the breakdown filters for insights. It handles adding, replacing, and removing breakdowns, setting breakdown limits and histogram bin counts, and managing URL normalization for breakdowns. The logic connects to other Kea logics like `insightVizDataLogic`, `propertyDefinitionsModel`, and `featureFlagLogic` to access data and feature flags. It also includes selectors to derive values like `isMultipleBreakdownsEnabled`, `breakdownArray`, `histogramBinCount`, and `breakdownLimit` from the state and props. The logic updates the breakdown filter in the parent component via the `updateBreakdownFilter` prop.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Adding Breakdowns:** Allows users to add breakdowns to their insights, enabling them to segment data based on properties, cohorts, or other criteria.\n*   **Multiple Breakdowns:** Supports the ability to break down data by multiple dimensions simultaneously, providing deeper insights.\n*   **Replacing Breakdowns:** Enables users to easily swap one breakdown for another.\n*   **Removing Breakdowns:** Allows users to remove existing breakdowns from their insights.\n*   **Breakdown Limits:** Controls the number of breakdown values displayed, preventing overwhelming the user with too much data.\n*   **Histogram Bin Count:** Configures the number of bins used in histograms for numerical breakdowns.\n*   **URL Normalization:** Normalizes URLs used in breakdowns for better readability and consistency.\n*   **Hiding \"Other\" Aggregation:** Allows users to hide the \"Other\" category in breakdowns, focusing on the most relevant segments.\n*   **Cohort Breakdowns:** Supports breaking down data by cohort membership.\n*   **Data Warehouse Support:** Integrates with data warehouse schemas to enable breakdowns based on warehouse data.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/BreakdownFilter",
        "summary": "The code collectively implements a comprehensive breakdown filtering system for PostHog insights, enabling users to segment and analyze data based on various taxonomic properties, cohorts, and even custom HogQL expressions. The system provides a user-friendly interface for adding, editing, and removing breakdowns, with features like dynamic tag display, popover-based selection, and configurable options for URL normalization and histogram binning. It supports both single and multiple breakdowns, allowing for deeper and more nuanced data exploration, and integrates with data warehouse schemas for expanded data sources.\n\nHere's a list of high-level product features:\n\n*   **Breakdown Selection:** Allows users to select properties, cohorts, or HogQL expressions to break down data by.\n*   **Taxonomic Property Support:** Supports various property types for breakdowns (e.g., event properties, user properties, session properties).\n*   **Editable Breakdown Tags:** Displays selected breakdowns as editable tags for easy modification and removal.\n*   **Multiple Breakdowns:** Supports the ability to break down data by multiple properties simultaneously.\n*   **Global Breakdown Options:** Provides a menu for configuring global breakdown settings, such as breakdown limits and the \"Other\" category.\n*   **URL Normalization:** Option to strip noise from URL paths to group similar URLs together.\n*   **Histogram Binning:** Allows users to bin numeric breakdown values into a specified number of bins.\n*   **Cohort Breakdown Filtering:** Allows users to filter insights based on cohorts, including the ability to view data for all cohorts or specific cohorts.\n*   **Data Warehouse Support:** Integrates with data warehouse schemas to enable breakdowns based on warehouse data.\n*   **Dynamic Button Text:** The button text adapts to reflect the type of breakdown being added (cohort or other).\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/InsightDateFilter/index.ts",
        "summary": "The code exports the `InsightDateFilter` component, making it available for use in other parts of the application. This component likely provides functionality for filtering insights based on a date range or specific dates.\n\n**Features:**\n\n*   **Date-based Insight Filtering:** Allows users to filter insights based on a selected date or date range.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/FunnelStepReferencePicker.tsx",
        "summary": "This React component, `FunnelStepReferencePicker`, provides a dropdown menu for selecting how funnel steps are referenced in an insight. It utilizes `kea` for state management, specifically `insightLogic` and `funnelDataLogic`, to access and update the `funnelStepReference` filter within the insight. The component renders a `LemonSelect` dropdown with two options: \"Overall conversion\" and \"Relative to previous step\", corresponding to the `FunnelStepReference` enum values. Selecting an option updates the `funnelStepReference` in the insight filter.\n\n**Features:**\n\n*   **Funnel Step Reference Selection:** Allows users to choose how funnel steps are referenced (overall conversion or relative to the previous step).\n*   **Dropdown Menu:** Uses a `LemonSelect` dropdown for easy selection.\n*   **State Management:** Integrates with `kea` for managing and updating the insight filter.\n*   **Dynamic Options:** Provides options for \"Overall conversion\" and \"Relative to previous step\".\n*   **Data Attribute:** Includes a `data-attr` for testing purposes.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/InsightDateFilter/InsightDateFilter.tsx",
        "summary": "This React component, `InsightDateFilter`, provides a date range filter specifically tailored for insights within the PostHog application. It leverages the `DateFilter` component from the `lib/components` directory and connects to the `insightVizDataLogic` and `insightLogic` to manage and update the date range state for insight visualizations. The component allows users to select a date range, with options for predefined ranges (like \"Last 7 days\") and custom date selections. It also conditionally restricts rolling date options based on whether the insight is a trend analysis. A tooltip provides additional information for the \"All time\" option.\n\nHere's a list of high-level product features:\n\n*   **Date Range Selection:** Allows users to filter insight data by a specific date range.\n*   **Predefined Date Ranges:** Offers a selection of predefined date ranges (e.g., \"Last 7 days\", \"All time\") for quick filtering.\n*   **Custom Date Selection:** Enables users to define a custom date range using a date picker.\n*   **Rolling Date Options:** Provides rolling date options (hours, days, weeks, months, years) for trend analysis.\n*   **Date Range Persistence:** Saves and restores the selected date range for a given insight.\n*   **Informative Tooltips:** Displays tooltips to provide additional context and information about date range options.\n*   **Disable Date Range Selection:** Allows disabling the date range selection functionality.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/InsightDateFilter",
        "summary": "The `InsightDateFilter` component provides a user interface for filtering insight data by date range within the PostHog application. It offers predefined date ranges, custom date selection via a date picker, and rolling date options specifically for trend analysis. The selected date range is persisted, and tooltips provide additional context. The component is exported for use throughout the application, enabling date-based filtering of insights.\n\nHere's a list of high-level product features:\n\n*   Date Range Selection: Allows users to filter insight data by a specific date range.\n*   Predefined Date Ranges: Offers a selection of predefined date ranges (e.g., \"Last 7 days\", \"All time\") for quick filtering.\n*   Custom Date Selection: Enables users to define a custom date range using a date picker.\n*   Rolling Date Options: Provides rolling date options (hours, days, weeks, months, years) for trend analysis.\n*   Date Range Persistence: Saves and restores the selected date range for a given insight.\n*   Informative Tooltips: Displays tooltips to provide additional context and information about date range options.\n*   Disable Date Range Selection: Allows disabling the date range selection functionality.\n*   Date-based Insight Filtering: Allows users to filter insights based on a selected date or date range.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters/AggregationSelect.tsx",
        "summary": "This code defines the `AggregationSelect` component, a dropdown menu used in PostHog insights to select the aggregation method for event data. It allows users to choose between aggregating by unique users, unique groups (if group analytics are enabled), unique sessions (if HogQL is available), or a custom SQL expression using the HogQL editor. The component dynamically updates the insight query based on the selected aggregation method, supporting both standard aggregations and custom HogQL expressions for advanced analysis.\n\n**Features:**\n\n*   **Aggregation Method Selection:** Allows users to choose how events are aggregated (e.g., by unique users, groups, or sessions).\n*   **Dynamic Query Updates:** Updates the insight query in real-time based on the selected aggregation method.\n*   **Group Analytics Support:** Integrates with group analytics, allowing users to aggregate data by unique groups.\n*   **HogQL Integration:** Enables users to define custom SQL expressions for aggregation using the HogQL editor.\n*   **Conditional UI Elements:** Displays different options and UI elements based on feature flags (HogQL availability, group analytics access).\n*   **Introduction Footer:** Provides an introduction footer for group analytics if the user needs to upgrade or start using groups.\n"
    },
    {
        "path": "frontend/src/scenes/insights/filters",
        "summary": "The PostHog insights interface offers a wide array of features for in-depth data exploration and analysis, centered around customizable filters and visualizations. Users can precisely define the data displayed in charts and graphs through event and action selection, property filtering, mathematical operations, and data transformation with HogQL. The interface supports advanced features like path cleaning, retention analysis with cumulative options and various calculation methods, funnel exclusions, and breakdown filtering by properties, cohorts, or HogQL expressions. Visualizations are customizable with chart type selection and display options, while date range selection and test account filtering provide further refinement. These features empower users to gain deeper insights from their data and tailor the analysis to their specific needs.\n\n*   Event/Action Selection and Filtering\n*   Path Cleaning Configuration (Local and Global)\n*   Retention Analysis (Cumulative, Mean Calculation, Reference Point Selection, Chart Type Selection, Dashboard Display Options)\n*   Funnel Exclusions\n*   Breakdown Filtering (Properties, Cohorts, HogQL Expressions, Histogram Binning, URL Normalization)\n*   Date Range Selection\n*   Test Account Filtering\n*   Data Transformation with HogQL\n*   Series Customization\n*   Drag and Drop Reordering\n*   Visual Indicators\n*   Data Warehouse Integration\n*   Customizable UI\n*   Aggregation Method Selection (Unique Users, Groups, Sessions, HogQL)\n"
    },
    {
        "path": "frontend/src/scenes/insights/InsightNav/InsightsNav.tsx",
        "summary": "The `InsightsNav` component provides a navigation interface for different insight types within the PostHog application. It utilizes LemonTabs to display available insight types as tabs, allowing users to switch between them. Each tab links to a specific URL associated with the insight type and displays a tooltip with a description of the insight. The component also includes a FunnelsCue and an AlertDeletionWarning, likely related to specific insight features or potential data loss.\n\nHere's a list of high-level product features:\n\n*   **Insight Type Navigation:** Allows users to switch between different types of insights (e.g., Trends, Funnels, Retention).\n*   **Insight Type Descriptions:** Provides tooltips with descriptions for each insight type to help users understand their purpose.\n*   **Funnels Cue:** Displays a cue or prompt related to Funnels insights.\n*   **Deletion Warning:** Shows a warning message when deleting insights, potentially preventing accidental data loss.\n"
    },
    {
        "path": "frontend/src/scenes/insights/insightDataTimingLogic.ts",
        "summary": "This code defines the `insightDataTimingLogic` Kea logic, which is responsible for tracking and reporting the time it takes to load insight data in the PostHog application. It monitors the start and end times of data loading processes, capturing the duration from when a query is initiated until the data is successfully loaded, fails, or is cancelled. This timing information is then reported to the `eventUsageLogic` to track the performance of insight loading and identify potential bottlenecks.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Insight Loading Time Tracking:** Measures the time taken to load insight data, providing metrics for performance analysis.\n*   **Performance Monitoring:** Reports insight loading times to `eventUsageLogic` for tracking and analysis.\n*   **Success/Failure/Cancellation Reporting:** Distinguishes between successful, failed, and cancelled data loading attempts.\n*   **Caching Analysis:** Tracks whether the data was loaded from cache or a fresh request.\n*   **Query-Specific Timing:** Associates timing data with specific queries for granular performance analysis.\n*   **Data-Driven Optimization:** Provides data to optimize insight loading performance and improve user experience.\n"
    },
    {
        "path": "frontend/src/scenes/insights/InsightNav/insightNavLogic.tsx",
        "summary": "This code defines the `insightNavLogic` using Kea, a state management library. It manages the navigation and state for different insight types (Trends, Funnels, Retention, Paths, Stickiness, Lifecycle, SQL, and Hog). The logic handles switching between insight types, caching query properties, and merging cached properties when switching between insights. It also manages feature flags to conditionally display certain insight types like Hog. The logic ensures that the query is updated and relevant properties are cached when the active view changes.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Insight Type Switching:** Allows users to switch between different types of insights (Trends, Funnels, Retention, Paths, Stickiness, Lifecycle, SQL, Hog).\n*   **Query Persistence:** Caches and re-applies query properties (date range, properties, sampling factor, series, interval, breakdown filter, funnel paths filter, and insight-specific filters) when switching between insight types.\n*   **Feature Flag Management:** Conditionally displays insight types based on feature flags (e.g., Hog insight).\n*   **Default Query Generation:** Generates default queries for each insight type when a new insight is created or when switching between types.\n*   **Custom Query Support:** Supports custom queries, including HogQL and JSON-based queries.\n*   **Test Account Filtering:** Respects the filter test accounts default setting when generating default queries.\n*   **Math Property Cleaning:** Cleans math properties for series entities based on math availability.\n"
    },
    {
        "path": "frontend/src/scenes/insights/insightSceneLogic.tsx",
        "summary": "This code defines the `insightSceneLogic` using Kea, a state management library. It manages the state and behavior of the insight scene, including the current insight ID, mode (view, edit, etc.), item ID, alert ID, dashboard ID, and overrides for filters and variables. It handles URL routing to set the scene state based on URL parameters, and it connects to other logics like `insightLogic`, `dashboardLogic`, and `teamLogic` to access and manage related data. The logic also manages loading and unloading of `insightLogic` and `insightDataLogic` based on the current insight ID. It provides breadcrumbs for navigation and manages side panel context.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Insight Management:** Enables users to view, edit, and create insights.\n*   **URL-Based State Management:** Allows users to share and access specific insight states through URLs.\n*   **Dashboard Integration:** Supports embedding insights within dashboards and inheriting dashboard filters.\n*   **Alerting:** Manages alert configurations associated with insights.\n*   **Variable Overrides:** Allows overriding variables for insights, potentially for testing or specific scenarios.\n*   **Navigation Breadcrumbs:** Provides a clear navigation path for users to understand their location within the application.\n*   **Side Panel Context:** Provides context for the side panel based on the currently viewed insight.\n*   **Query Management:** Supports loading and managing queries associated with insights, including parsing from URLs.\n*   **Insight Sharing:** Supports different sharing modes for insights (e.g., subscriptions, alerts)."
    },
    {
        "path": "frontend/src/scenes/insights/InsightNav",
        "summary": "The provided code snippets detail the implementation of insight navigation within the PostHog application. This system enables users to seamlessly switch between different types of insights, such as Trends, Funnels, and Retention, while preserving their query configurations and displaying relevant information. The navigation interface utilizes tabs with descriptive tooltips, and incorporates features like Funnels cues and deletion warnings to enhance the user experience and prevent data loss.\n\nHere's a list of high-level product features:\n\n*   Insight Type Switching: Allows users to navigate between different insight types (Trends, Funnels, Retention, Paths, Stickiness, Lifecycle, SQL, Hog).\n*   Query Persistence: Caches and reapplies query properties when switching between insight types.\n*   Insight Type Descriptions: Provides tooltips with descriptions for each insight type.\n*   Feature Flag Management: Conditionally displays insight types based on feature flags.\n*   Default Query Generation: Generates default queries for each insight type.\n*   Custom Query Support: Supports custom queries, including HogQL and JSON-based queries.\n*   Funnels Cue: Displays a cue or prompt related to Funnels insights.\n*   Deletion Warning: Shows a warning message when deleting insights.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/PercentStackViewFilter.tsx",
        "summary": "This React component, `PercentStackViewFilter`, provides a checkbox to control whether a trend insight is displayed as a percentage of the total. It leverages Kea logic to connect to the insight's properties and update the `showPercentStackView` filter. When checked, the trend data is visualized as a percentage of the total, offering a normalized view of the data.\n\n**Features:**\n\n*   **Toggleable Percentage View:** Allows users to switch between absolute values and percentage-based representation of trend data.\n*   **Real-time Updates:** Changes to the checkbox immediately reflect in the insight visualization.\n*   **Integration with Insight Properties:** Persists the percentage view setting as part of the insight's configuration.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/ResultCustomizationByPicker.tsx",
        "summary": "This code defines a React component, `ResultCustomizationByPicker`, that allows users to select how results are customized in an insight visualization. It uses a segmented button to switch between customizing results \"By name\" or \"By rank\". The selected option is stored and managed within the `insightVizDataLogic` and updates the insight filter accordingly. The component defaults to customizing \"By name\" if no option is selected.\n\n**Features:**\n\n*   **Result Customization Selection:** Allows users to choose how insight results are customized.\n*   **\"By Name\" Customization:** Option to customize results based on their name.\n*   **\"By Rank\" Customization:** Option to customize results based on their rank or position.\n*   **Segmented Button UI:** Uses a segmented button for easy selection between customization options.\n*   **State Management:** Integrates with `insightVizDataLogic` to manage and persist the selected customization option.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/RetentionOptions.tsx",
        "summary": "The `RetentionOptions` component in `RetentionOptions.tsx` provides a set of controls for configuring retention analysis in the PostHog insights editor. It allows users to define the reference point for retention calculation, specify whether retention is cumulative, and select the mean calculation logic. The component also includes a link to the PostHog documentation for more information on retention analysis.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Retention Reference Point Selection:** Allows users to choose the event or property that defines the starting point for retention analysis.\n*   **Cumulative Retention Toggle:** Enables users to specify whether retention is calculated cumulatively over time.\n*   **Mean Calculation Logic Selection:** Provides options for how the mean retention rate is calculated.\n*   **Documentation Link:** Offers easy access to relevant documentation for understanding and using retention analysis features.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/ValueOnSeriesFilter.tsx",
        "summary": "This React component, `ValueOnSeriesFilter`, provides a checkbox that allows users to toggle the display of data values directly on the series lines within an insight visualization. It leverages Kea logic to manage state and actions, specifically using `insightLogic` to access insight properties and `insightVizDataLogic` to update the `showValuesOnSeries` filter. The component utilizes a `LemonCheckbox` from the Lemon UI library for the interactive checkbox element.\n\nHere's a list of high-level product features:\n\n*   **Toggleable Value Display:** Allows users to show or hide data values directly on the series lines of a chart.\n*   **Real-time Updates:** Changes to the \"Show values on series\" setting are immediately reflected in the insight visualization.\n*   **Integration with Insight Configuration:** The component integrates seamlessly with the insight configuration and data visualization logic.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/PathsHogQL.tsx",
        "summary": "This code defines a React component called `PathsHogQL` that allows users to filter paths data based on a HogQL expression. It utilizes the `TaxonomicPopover` component to provide a user-friendly interface for selecting and editing HogQL expressions. The component retrieves the current HogQL expression from the `pathsDataLogic` and updates it when the user makes changes, effectively filtering the paths data based on the specified expression.\n\nHere's a list of high-level product features:\n\n*   **Paths Data Filtering:** Enables users to filter paths data within the insights editor.\n*   **HogQL Expression Support:** Allows filtering based on custom HogQL expressions.\n*   **Taxonomic Popover Interface:** Provides a user-friendly interface for selecting and editing HogQL expressions.\n*   **Real-time Updates:** Updates the paths data in real-time as the user modifies the HogQL expression.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/PathsWildcardGroups.tsx",
        "summary": "This code defines a React component called `PathsWildcardGroups` that allows users to select and manage wildcard groups for paths within an insights editor. It utilizes the `kea` library for state management and actions, specifically interacting with the `pathsDataLogic`. The component renders a `LemonInputSelect` component, enabling users to choose from existing path groupings or define custom ones. The selected path groupings are then used to update the insight filter.\n\nHere's a list of high-level product features:\n\n*   **Path Grouping Selection:** Allows users to select pre-defined groups of paths.\n*   **Custom Path Grouping:** Enables users to define their own custom path groupings using wildcards.\n*   **Multiple Selection:** Supports the selection of multiple path groupings simultaneously.\n*   **Insight Filter Integration:** Integrates with the insight editor to filter data based on selected path groupings.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/samplingFilterLogic.ts",
        "summary": "The `samplingFilterLogic.ts` file defines a Kea logic module responsible for managing the sampling percentage applied to insight queries. It allows users to set a sampling percentage, suggests a sampling percentage based on the current value, and updates the query source with the corresponding sampling factor. The logic connects to `insightVizDataLogic` to access and update the query source. It also synchronizes the sampling percentage state with the query source's sampling factor.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Sampling Percentage Control:** Allows users to control the sampling percentage applied to insight queries.\n*   **Suggested Sampling Percentage:** Provides suggestions for optimal sampling percentages based on the current sampling rate.\n*   **Query Source Synchronization:** Automatically synchronizes the sampling percentage with the underlying query source, ensuring consistency.\n*   **Available Sampling Percentage Options:** Provides a predefined set of available sampling percentages for users to choose from.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/ScalePicker.tsx",
        "summary": "This code defines a `ScalePicker` component that allows users to select the scale type for the Y-axis of an insight visualization. It uses a segmented button to switch between \"Linear\" and \"Logarithmic\" scales. The selected scale type is then used to update the insight filters, affecting how the data is displayed.\n\nHere's a list of high-level product features:\n\n*   **Y-Axis Scale Selection:** Allows users to choose between linear and logarithmic scales for the Y-axis of insight visualizations.\n*   **Segmented Button Interface:** Provides a user-friendly segmented button for easy scale selection.\n*   **Real-time Updates:** Updates the insight visualization in real-time based on the selected scale.\n*   **Insight Filter Integration:** Integrates with the insight filter system to persist and apply the selected scale.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/ShowAlertThresholdLinesFilter.tsx",
        "summary": "This React component, `ShowAlertThresholdLinesFilter`, provides a toggle to control the visibility of alert threshold lines on an insight visualization. It utilizes Kea logic to manage the state of `showAlertThresholdLines` and update the insight filters accordingly. The component renders a LemonCheckbox that, when toggled, calls the `updateInsightFilter` action to either show or hide the alert threshold lines on the chart.\n\n**Features:**\n\n*   **Toggle Alert Threshold Lines:** Allows users to show or hide alert threshold lines on insight visualizations.\n*   **Persistent Setting:** Remembers the user's preference for showing or hiding alert threshold lines.\n*   **Integration with Insight Visualization:** Seamlessly integrates with the insight visualization to dynamically display or hide the threshold lines.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/ShowLegendFilter.tsx",
        "summary": "This code defines a React component called `ShowLegendFilter` that allows users to toggle the visibility of the legend in an insight visualization. It utilizes the `kea` library for state management and actions, connecting to `insightLogic` and `insightVizDataLogic` to access and update the `showLegend` property. The component renders a `LemonCheckbox` that, when toggled, dispatches an action to update the `showLegend` filter, thereby controlling whether the legend is displayed in the insight visualization.\n\nHere's a list of high-level product features:\n\n*   **Toggle Legend Visibility:** Allows users to show or hide the legend in insight visualizations.\n*   **Real-time Updates:** The visualization updates immediately when the legend visibility is toggled.\n*   **Integration with Insight Configuration:** The legend visibility setting is persisted as part of the insight's configuration.\n*   **Checkbox UI:** Provides a simple checkbox interface for toggling the legend.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/GoalLines.tsx",
        "summary": "This component, `GoalLines`, allows users to define and manage goal lines within an insight. Users can add multiple goal lines, each with a customizable label, value, and display setting. The component provides input fields for the label and value, a toggle to show or hide the label, and a delete button to remove the goal line. The component utilizes the `goalLinesLogic` kea logic to manage the state and actions related to goal lines.\n\nHere's a list of high-level product features:\n\n*   **Add Goal Lines:** Allows users to add horizontal lines to a chart to represent goals or targets.\n*   **Customize Goal Line Label:** Enables users to set a descriptive label for each goal line.\n*   **Set Goal Line Value:** Allows users to define the numerical value represented by the goal line.\n*   **Toggle Label Visibility:** Provides the option to show or hide the label of a goal line on the chart.\n*   **Delete Goal Lines:** Enables users to remove unwanted goal lines.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/ShowMultipleYAxesFilter.tsx",
        "summary": "This React component, `ShowMultipleYAxesFilter`, provides a checkbox within the PostHog insights editor that allows users to toggle the display of multiple Y-axes on a chart. It leverages Kea logic to connect to the insight's properties and update the filter settings when the checkbox is toggled. The component uses a LemonCheckbox from `@posthog/lemon-ui` for the UI element.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Toggleable Multiple Y-Axes:** Allows users to enable or disable the display of multiple Y-axes on insight charts.\n*   **Real-time Chart Updates:** Changes to the \"Show multiple Y-axes\" setting are reflected in the chart in real time.\n*   **Integration with Insights Editor:** Seamlessly integrates into the PostHog insights editor as a filter option.\n*   **Persistent Filter Settings:** The \"Show multiple Y-axes\" setting is saved as part of the insight's filter configuration.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/PoeFilter.tsx",
        "summary": "This code defines a React component called `PoeFilter` that allows users to toggle the \"person properties from query time\" (PoE) mode for a specific insight. This mode overrides the default behavior of using person properties at the time of the event, instead using properties available at query time. The component utilizes a LemonSwitch to enable or disable the PoE mode, and a LemonLabel provides information about the feature and its performance implications. The state and actions for managing the PoE mode are handled by the `poeFilterLogic` Kea logic.\n\nHere's a list of high-level product features:\n\n*   **Toggleable Person Properties Mode:** Allows users to switch between using person properties at the time of the event or at query time.\n*   **Informative Label:** Provides a description of the \"person properties from query time\" feature, including its use cases and performance considerations.\n*   **Integration with Insight Configuration:** Seamlessly integrates with the insight configuration to modify the query behavior.\n*   **Performance Warning:** Implicitly warns users about the potential performance impact of enabling the \"person properties from query time\" mode.\n"
    },
    {
        "path": "frontend/src/scenes/insights/sharedUtils.ts",
        "summary": "This code provides utility functions for the insights feature in PostHog. It includes functions for generating unique keys for insight components based on dashboard item IDs, filtering parameters for trends and stickiness insights, and type guards to determine the specific insight type based on the provided filters. Additionally, it handles display-specific logic, such as disabling comparison for area charts.\n\nHere's a list of high-level product features supported by this code:\n\n*   **Unique Key Generation for Insights:** Generates unique keys for insight components, especially when used within dashboards, ensuring proper component identification and state management.\n*   **Trends and Stickiness Insights Filtering:** Provides client-side filtering of parameters specific to trends and stickiness insights, optimizing data processing and visualization.\n*   **Insight Type Detection:** Offers type guards to identify the specific insight type (Trends, Funnels, Retention, Stickiness, Lifecycle, Paths) based on the provided filters, enabling type-safe handling of different insight configurations.\n*   **Chart Display Type Handling:** Manages display-specific logic for charts, such as disabling comparison for area charts, ensuring appropriate visualization behavior.\n*   **Dashboard Integration:** Supports the integration of insights within dashboards by providing mechanisms to identify insights based on their dashboard item ID and dashboard ID."
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/goalLinesLogic.ts",
        "summary": "This code defines the `goalLinesLogic` Kea logic for managing goal lines within an insights editor. It handles adding, updating, removing, and setting goal lines, which are visual representations of target values on a chart. The logic connects to the `insightVizDataLogic` to access and update the main query source, ensuring that changes to goal lines are reflected in the insight's query. It also subscribes to changes in the query source to initialize the goal lines when they are initially loaded from the query.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Adding Goal Lines:** Allows users to add new goal lines to a chart, representing target values or milestones.\n*   **Updating Goal Line Properties:** Enables users to modify the properties of existing goal lines, such as their label, value, and display status.\n*   **Removing Goal Lines:** Provides the ability to delete goal lines from a chart.\n*   **Persistence of Goal Lines:** Ensures that goal lines are saved and loaded as part of the insight's query configuration.\n*   **Real-time Updates:** Updates the chart in real-time as goal lines are added, modified, or removed.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/FunnelsAdvanced.tsx",
        "summary": "This component, `FunnelsAdvanced`, provides an interface for configuring advanced options for funnel insights. It allows users to define the step order (Sequential, Strict order, Any order), the conversion rate calculation method (funnel step reference), and exclusion steps. The component also includes a button to reset all advanced options to their default values. It utilizes the `funnelDataLogic` to manage the state and actions related to funnel insights.\n\nHere's a list of high-level product features:\n\n*   **Step Order Configuration:** Allows users to define the order in which funnel steps must occur (Sequential, Strict, or Any).\n*   **Conversion Rate Calculation Customization:** Enables users to specify the reference point for calculating the conversion rate between funnel steps.\n*   **Exclusion Steps:** Provides the ability to exclude users/groups from the entire funnel based on whether they performed a specific event between two other steps.\n*   **Reset Advanced Options:** A button to revert all advanced funnel settings to their default values.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/PathsExclusions.tsx",
        "summary": "This code defines a `PathsExclusions` component in a React application, specifically within the PostHog insights feature. This component allows users to define and manage a list of event paths to exclude from insights calculations. It leverages the `PathItemFilters` component to provide a user interface for adding, removing, and modifying these exclusions. The component retrieves existing exclusions and taxonomic group types from the `pathsDataLogic` and updates the insight filter with any changes made by the user. It also uses wildcard options based on path groupings.\n\n**Features:**\n\n*   **Exclusion Management:** Allows users to define and manage a list of event paths to exclude from insights calculations.\n*   **Path Filtering UI:** Provides a user-friendly interface (`PathItemFilters`) for adding, removing, and modifying path exclusions.\n*   **Dynamic Updates:** Updates the insight filter in real-time as the user modifies the exclusions.\n*   **Taxonomic Group Support:** Supports taxonomic group types for filtering.\n*   **Wildcard Options:** Offers wildcard options based on path groupings for more flexible exclusion rules.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/SamplingFilter.tsx",
        "summary": "This code defines a React component called `SamplingFilter` that allows users to enable or disable data sampling for insights, and to select a sampling percentage. The component uses Lemon UI components for the label, switch, segmented button, and tag. It integrates with PostHog for event tracking and displays a warning tag indicating that the feature is in beta. The component also disables sampling for data warehouse series.\n\nHere's a list of high-level product features:\n\n*   **Enable/Disable Data Sampling:** Allows users to toggle data sampling on or off for insights.\n*   **Sampling Percentage Selection:** Provides a segmented button to select from predefined sampling percentages (e.g., 10%, 25%, 50%).\n*   **Data Warehouse Series Restriction:** Disables sampling functionality for data warehouse series.\n*   **Informational Tooltip:** Displays a tooltip explaining the purpose and benefits of data sampling.\n*   **Beta Status Indication:** Shows a \"BETA\" tag to indicate that the feature is still in development.\n*   **Event Tracking:** Tracks user interactions with the sampling feature using PostHog.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/FunnelsQuerySteps.tsx",
        "summary": "This code defines the `FunnelsQuerySteps` component, which is a React component used in the PostHog insights editor for configuring the steps of a funnel analysis. It allows users to define and modify the sequence of events or actions that constitute a funnel, set conversion windows, and choose the visualization type. The component leverages Kea logic for state management and interacts with other components like `ActionFilter` for defining event filters, `AggregationSelect` for specifying aggregation, and `FunnelConversionWindowFilter` for setting the conversion window.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Funnel Step Definition:** Allows users to define the individual steps of a funnel using event and action filters.\n*   **Step Ordering:** Enables users to reorder the funnel steps through a sortable interface.\n*   **Step Management:** Provides the ability to add, delete, and modify funnel steps.\n*   **Funnel Visualization Type Selection:** Allows users to choose the type of visualization for the funnel.\n*   **Conversion Window Configuration:** Enables users to set the conversion window for the funnel.\n*   **Aggregation:** Allows users to aggregate the funnel results by a specific group.\n*   **Property Filtering:** Supports filtering events and actions based on properties, including event properties, person properties, feature flags, cohorts, elements, session properties, and HogQL expressions.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/poeFilterLogic.ts",
        "summary": "This code defines a Kea logic module called `poeFilterLogic` that manages the \"Persons on Events\" (PoE) mode for insight visualizations. It allows users to set and persist the PoE mode, which is a modifier for HogQL queries. The logic connects to `insightVizDataLogic` to access and update the query source, ensuring that changes to the PoE mode are reflected in the generated queries and visualizations. It also subscribes to changes in the query source to keep the internal `poeMode` state synchronized.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Control over Persons on Events (PoE) Mode:** Allows users to specify how persons and events are related in insights.\n*   **Persistence of PoE Mode:** Remembers the selected PoE mode for a given insight.\n*   **Integration with Query Generation:** Ensures that the selected PoE mode is applied to the HogQL queries used to generate insights.\n*   **Synchronization with Query Source:** Keeps the PoE mode consistent between the UI and the underlying query definition.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/PathsEventTypes.tsx",
        "summary": "This component, `PathsEventsTypes`, provides a user interface for filtering path insights based on event types. It utilizes a dropdown menu with checkboxes to allow users to select which event types (Page views, Screen views, Custom event, SQL expression) to include in their path analysis. The component displays a summary of the selected event types and prevents the user from deselecting the last remaining event type. It leverages the `pathsDataLogic` to manage the state and update the insight filters.\n\nHere's a list of high-level product features:\n\n*   **Event Type Filtering:** Allows users to filter path insights based on event types such as page views, screen views, custom events, and SQL expressions.\n*   **Dropdown Menu Interface:** Provides a user-friendly dropdown menu with checkboxes for selecting event types.\n*   **Summary Display:** Shows a summary of the selected event types in a readable format.\n*   **Minimum Selection Enforcement:** Prevents users from deselecting all event types, ensuring at least one type is always selected.\n*   **State Management:** Uses `pathsDataLogic` to manage the state of the selected event types and update the insight filters accordingly.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/RetentionCondition.tsx",
        "summary": "This code defines the `RetentionCondition` component, which is a part of the insights editor in PostHog. It allows users to define the conditions for a retention analysis, specifically focusing on what events or actions users perform initially and what events or actions they return to perform. The component provides controls for selecting the target event/action, the returning event/action, the type of retention (e.g., \"returned within\"), and the time window for the return behavior. It also handles updating the insight filters and date ranges based on user input.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Target Event/Action Selection:** Allows users to specify the initial event or action that defines a user cohort.\n*   **Returning Event/Action Selection:** Allows users to specify the event or action that defines a user's return behavior.\n*   **Retention Type Selection:** Allows users to choose the type of retention analysis (e.g., \"returned within\").\n*   **Time Window Configuration:** Allows users to define the time window within which the return behavior is considered.\n*   **Aggregation Control:** Allows users to specify the aggregation method (e.g., unique users, groups) for the retention analysis.\n*   **Dynamic Date Range Adjustment:** Automatically adjusts the date range based on the selected time window and retention period.\n"
    },
    {
        "path": "frontend/src/scenes/insights/insightDataLogic.tsx",
        "summary": "This code defines the `insightDataLogic` Kea logic, which manages the data and state related to insights within the PostHog application. It handles loading, saving, and updating insight queries, managing the query editor and debug panels, and persisting draft queries to local storage. The logic connects to other Kea logics like `insightLogic`, `insightSceneLogic`, `teamLogic`, and `dataNodeLogic` to access and manage related data and actions. It also handles exporting insight data and managing the query's state in the URL.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Insight Query Management:** Loading, saving, updating, and comparing insight queries.\n*   **Query Editor Panel:** Toggling the visibility of the query editor panel.\n*   **Debug Panel:** Toggling the visibility of a debug panel for insights.\n*   **Draft Query Persistence:** Saving and restoring draft queries to local storage.\n*   **Data Loading and Display:** Loading insight data and handling loading states and errors.\n*   **Query Export:** Exporting insight data in various formats.\n*   **URL-Based Query Sharing:** Persisting draft queries in the URL for sharing.\n*   **Data Warehouse Query Support:** Handling queries originating from the data warehouse editor.\n*   **Test Account Filtering:** Applying default test account filters to queries.\n*   **Insight Data Transformation:** Transforming raw query results into a format suitable for insights.\n*   **HogQL Query Extraction:** Extracting the HogQL query from the insight data or query definition."
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/AttributionFilter.tsx",
        "summary": "This code defines a React component called `Attribution` that provides a dropdown menu for selecting the attribution model used in funnel insights. It allows users to choose between \"First touchpoint\", \"Last touchpoint\", \"All steps\", \"Any step\", or a specific step in the funnel. The selected attribution model influences how conversions are attributed to different touchpoints in the user journey. The component uses the `LemonSelect` component from `@posthog/lemon-ui` for the dropdown and leverages `kea` logic for managing state and actions related to funnel data.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Attribution Model Selection:** Allows users to choose how conversions are attributed to different touchpoints in a funnel.\n*   **First Touch Attribution:** Attributes conversions to the first touchpoint in the funnel.\n*   **Last Touch Attribution:** Attributes conversions to the last touchpoint in the funnel.\n*   **All Steps Attribution:** Considers all steps in the funnel for attribution.\n*   **Any Step Attribution:** Attributes conversions to any step in the funnel (only available for unordered funnels).\n*   **Specific Step Attribution:** Allows users to attribute conversions to a specific step in the funnel (only available for unordered funnels).\n*   **Dynamic Step Options:** The list of specific steps adapts based on the number of steps defined in the funnel.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/PathsAdvanced.tsx",
        "summary": "This React component, `PathsAdvanced`, provides advanced filtering options for path insights within a PostHog application. It allows users to control the granularity and density of path visualizations by setting limits on the maximum number of paths displayed, as well as minimum and maximum weights (number of people) for each path. Additionally, it integrates a `PathCleaningFilter` component, enabling users to apply regex-based rules for normalizing URLs in path visualizations, either project-wide or specific to the current insight. The component is wrapped in a `PayGateMini` component, suggesting that these advanced features might be behind a paywall.\n\nHere's a list of high-level product features:\n\n*   **Maximum Path Limit:** Controls the maximum number of path nodes displayed in the visualization.\n*   **Minimum Path Weight:** Sets the minimum number of people required for a path to be displayed.\n*   **Maximum Path Weight:** Sets the maximum number of people allowed for a path to be displayed.\n*   **Path Cleaning Rules:** Allows users to define regex-based rules to normalize URLs for cleaner path visualizations.\n*   **Paywalled Feature:** Indicates that these advanced path settings are a premium feature.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters/PathsTarget.tsx",
        "summary": "This code defines React components `PathsTargetStart` and `PathsTargetEnd` that render a `PathItemSelector` for specifying the start and end points of paths in an insights query, particularly within the context of funnels. The component allows users to select a specific event or funnel step as the start or end point of a path, and it integrates with the `pathsDataLogic` to manage the state and actions related to paths and funnels filters. The component dynamically adjusts its behavior based on whether it's being used in a funnel context, allowing users to navigate to the funnel insight directly from the path target selector.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Path Start/End Point Selection:** Allows users to define the starting and ending points for path analysis.\n*   **Funnel Integration:** Integrates with funnel insights, allowing users to select funnel steps as path start/end points.\n*   **Dynamic Input Override:** Overrides start/end point inputs based on the selected funnel path type (e.g., \"between,\" \"before,\" \"after\").\n*   **Visual Indication of Funnel Step:** Displays a funnel icon and step name when a funnel step is selected as a path target.\n*   **Navigation to Funnel Insight:** Provides a button to navigate directly to the funnel insight that is being used to filter the paths.\n*   **Reset Path Target:** Allows users to clear the selected start or end point.\n*   **Wildcard Options:** Provides wildcard options for path groupings.\n"
    },
    {
        "path": "frontend/src/scenes/insights/InsightPageHeader.tsx",
        "summary": "This code defines the `InsightPageHeader` component, which is responsible for rendering the header section of an insight page in PostHog. It includes various functionalities such as editing the insight name, adding tags, saving, duplicating, favoriting, adding to a dashboard, sharing, subscribing, exporting data, viewing the source query, and debugging. The component utilizes several Kea logics for state management and actions, and it integrates with other components like `AddToDashboard`, `SharingModal`, `SubscribeButton`, and `ExportButton` to provide a comprehensive set of features for managing and interacting with insights.\n\nHere's a list of high-level product features implemented in this component:\n\n*   **Insight Metadata Editing:** Allows users to edit the insight name and tags.\n*   **Saving Insights:** Provides functionality to save changes to an insight or save a copy.\n*   **Duplicating Insights:** Enables users to create a copy of an existing insight.\n*   **Favoriting Insights:** Allows users to mark insights as favorites for easy access.\n*   **Adding to Dashboard:** Enables users to add the insight to a dashboard.\n*   **Sharing Insights:** Provides options to share or embed the insight.\n*   **Subscribing to Insights:** Allows users to subscribe to receive updates about the insight.\n*   **Exporting Insight Data:** Enables users to export the data from the insight in various formats (PNG, CSV, XLSX).\n*   **Viewing Source Query:** Allows users to view and edit the underlying query that generates the insight.\n*   **Debugging Insights:** Provides a debug panel for troubleshooting and analyzing the insight.\n*   **Alerting on Insights:** Allows users to set up and manage alerts based on insight data.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EditorFilters",
        "summary": "The provided code snippets detail various components and logic modules that enhance the PostHog insights editor, offering users granular control over data analysis and visualization. These features span across different insight types, including trends, funnels, retention, and paths, enabling users to tailor their analysis to specific needs and gain deeper insights from their data. The features range from basic UI elements like toggles and dropdowns to more complex configurations like HogQL filtering and advanced funnel settings.\n\nHere's a list of high-level product features:\n\n*   **Trend Analysis Customization:**\n    *   Toggleable value display on series lines.\n    *   Percentage stack view option for normalized data representation.\n    *   Alert threshold line visibility control.\n    *   Y-axis scale selection (linear/logarithmic).\n    *   Legend visibility control.\n    *   Multiple Y-axes display option.\n    *   Goal line management (add, customize, delete).\n*   **Funnel Analysis Configuration:**\n    *   Step order definition (Sequential, Strict, Any).\n    *   Conversion rate calculation customization.\n    *   Exclusion steps for filtering users/groups.\n    *   Attribution model selection (First touch, Last touch, All steps, Any step, Specific step).\n    *   Funnel step definition and reordering.\n    *   Conversion window configuration.\n*   **Retention Analysis Configuration:**\n    *   Retention reference point selection.\n    *   Cumulative retention toggle.\n    *   Mean calculation logic selection.\n    *   Target and returning event/action selection.\n    *   Time window configuration.\n*   **Path Analysis Filtering:**\n    *   Path start/end point selection.\n    *   Funnel integration for path target selection.\n    *   Path exclusion management.\n    *   Event type filtering (Page views, Screen views, Custom events, SQL expressions).\n    *   Wildcard path grouping.\n    *   HogQL expression filtering.\n    *   Maximum path limit.\n    *   Minimum and maximum path weight.\n    *   Path cleaning rules (regex-based URL normalization).\n*   **Data Sampling Control:**\n    *   Enable/disable data sampling.\n    *   Sampling percentage selection.\n*   **Query Optimization:**\n    *   Persons on Events (PoE) mode control.\n*   **Result Customization:**\n    *   Customization by name or rank.\n*   **General Enhancements:**\n    *   Documentation links for feature guidance.\n    *   Real-time updates to visualizations based on filter changes.\n    *   Persistence of filter settings.\n    *   Beta status indication for features under development.\n    *   Event tracking for user interactions.\n"
    },
    {
        "path": "frontend/src/scenes/insights/utils/api.ts",
        "summary": "This code defines an API client for interacting with insights, providing methods to create, update, retrieve, and duplicate insights. It leverages the existing `api` client and transforms legacy insight data into a `QueryBasedInsightModel`. The API supports fetching insights by short ID or numeric ID, with options to override filters and variables during retrieval.\n\n**Features:**\n\n*   **Create Insight:** Creates a new insight.\n*   **Update Insight:** Updates an existing insight by ID.\n*   **Get Insight by Short ID:** Retrieves an insight using its short ID, with optional parameters for basic data, refresh type, filter overrides, and variable overrides.\n*   **Get Insight by Numeric ID:** Retrieves an insight using its numeric ID.\n*   **Duplicate Insight:** Creates a copy of an existing insight.\n"
    },
    {
        "path": "frontend/src/scenes/insights/InsightScene.tsx",
        "summary": "The `InsightScene` component in `InsightScene.tsx` is responsible for rendering different views based on the current insight ID and loading state. It uses the `insightSceneLogic` to manage the state and determine which component to display. If the insight ID is \"new\" or a valid existing insight ID, it renders the `Insight` component. While the insight data is loading, it displays an `InsightSkeleton` component. If the insight ID is not found or invalid, it renders a `NotFound` component.\n\nHere's a list of high-level product features:\n\n*   **Insight Display:** Renders and displays individual insights based on their ID.\n*   **New Insight Creation:** Supports the creation of new insights.\n*   **Loading State Handling:** Displays a skeleton UI while insight data is loading.\n*   **\"Not Found\" Handling:** Displays a \"Not Found\" message when an insight ID is invalid.\n"
    },
    {
        "path": "frontend/src/scenes/insights/insightUsageLogic.ts",
        "summary": "This code defines the `insightUsageLogic` Kea logic, responsible for tracking and reporting insight usage. It connects to other logics like `projectLogic`, `insightLogic`, and `dataNodeLogic` to access insight data and the current project. The logic listens for changes in the insight query and reports insight views to both a `/viewed` endpoint (for recently viewed insights) and the `eventUsageLogic` for general usage tracking. It debounces these reports to avoid excessive events and tracks whether it's the first load of the insight.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Insight Usage Tracking:** Tracks how often insights are viewed and used.\n*   **Recently Viewed Insights:** Records insight views to populate a \"recently viewed insights\" list.\n*   **Usage Reporting:** Reports insight views to a central event tracking system for analysis.\n*   **Debounced Reporting:** Prevents excessive reporting of insight views when the query changes rapidly.\n"
    },
    {
        "path": "frontend/src/scenes/insights/utils/queryUtils.ts",
        "summary": "This code provides utility functions for working with insight queries in the PostHog frontend. It includes functions for extracting variables from a query string, comparing queries for equality (with options to ignore visualization-only changes), detecting changes in variables or filters, validating queries, and cleaning insight queries to ensure semantic equality for preventing redundant data fetching. The cleaning process involves removing empty values, normalizing default values, and optionally stripping visualization-related properties to focus on the core query logic.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Query Variable Extraction:** Allows identifying and extracting variables used within a query string.\n*   **Query Comparison:** Enables comparing two queries to determine if they are semantically equivalent, preventing duplicate data fetching.\n*   **Change Detection:** Detects changes in query variables or filters, triggering necessary updates or re-evaluation.\n*   **Query Validation:** Validates queries to ensure they meet minimum requirements (e.g., a funnel query has at least two steps) before execution.\n*   **Query Normalization:** Cleans and normalizes insight queries by removing irrelevant data and standardizing default values for accurate comparison.\n*   **Visualization-Agnostic Query Comparison:** Compares queries based on their core data requirements, ignoring differences in visualization settings.\n"
    },
    {
        "path": "frontend/src/scenes/insights/summarizeInsight.ts",
        "summary": "This code provides functionality to summarize different types of insight queries in PostHog, generating human-readable descriptions. It handles Trends, Funnels, Retention, Paths, Stickiness, Lifecycle, and HogQL queries, extracting relevant information like events, properties, breakdowns, and formulas to create concise summaries. The code uses context-aware information such as aggregation labels, cohort definitions, and math definitions to provide more meaningful descriptions. It also includes logic for summarizing data table queries and extracting comments from expressions.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Insight Summarization:** Automatically generate concise descriptions of insights for better understanding and communication.\n*   **Trends Query Summarization:** Summarize trends queries, including event names, math operations, breakdowns, and formulas.\n*   **Funnels Query Summarization:** Summarize funnel queries, including step sequences, conversion metrics, and breakdowns.\n*   **Retention Query Summarization:** Summarize retention queries, including target and returning events, and retention type.\n*   **Paths Query Summarization:** Summarize user path queries, including event types, start and end points.\n*   **Stickiness Query Summarization:** Summarize stickiness queries, including event names and stickiness metrics.\n*   **Lifecycle Query Summarization:** Summarize lifecycle queries, including event names and lifecycle stages.\n*   **HogQL Query Summarization:** Provide a basic summary for HogQL (SQL) queries.\n*   **Data Table Query Summarization:** Summarize data table queries, including selected columns and source tables.\n*   **Contextual Summarization:** Utilize aggregation labels, cohort definitions, and math definitions to provide more informative summaries.\n"
    },
    {
        "path": "frontend/src/scenes/insights/utils/cleanFilters.ts",
        "summary": "This code provides utility functions for cleaning and preparing filter parameters used in PostHog's insights feature. It includes functions for handling funnel exclusions, clamping step ranges, determining the most relevant breakdown type, cleaning breakdown parameters, autocorrecting intervals, and setting default test account filters for new insights. The code also defines default entities and checks for undefined steps in funnels. The main function, `cleanFilters`, takes a set of filters and applies various cleaning and transformation steps based on the insight type (Retention, Funnels, Trends, Paths, Stickiness, Lifecycle) to ensure the filters are valid and consistent.\n\nHere's a list of high-level product features related to this code:\n\n*   **Insight Filtering and Cleaning:** Cleans and prepares filter parameters for different insight types (Trends, Funnels, Retention, Paths, Stickiness, and Lifecycle).\n*   **Funnel Analysis:** Supports funnel exclusions, step range clamping, and various funnel visualization types (Steps, Trends).\n*   **Breakdown Analysis:** Determines and applies the most relevant breakdown type (event, person, group) based on the data and insight type.\n*   **Interval Autocorrection:** Automatically adjusts the interval (minute, hour, day) based on the selected date range and insight type.\n*   **Test Account Filtering:** Provides options to filter out test accounts from insights, with default settings based on team and user preferences.\n*   **Data Visualization:** Supports different chart display types, including world maps, and ensures appropriate breakdown settings for each type.\n*   **Retention Analysis:** Configures default entities and parameters specific to retention analysis.\n*   **Paths Analysis:** (Inferred from the presence of `isPathsFilter`) Supports filtering and configuration options specific to analyzing user paths.\n*   **Stickiness Analysis:** (Inferred from the presence of `isStickinessFilter`) Supports filtering and configuration options specific to analyzing user stickiness.\n*   **Lifecycle Analysis:** (Inferred from the presence of `isLifecycleFilter`) Supports filtering and configuration options specific to analyzing user lifecycles.\n"
    },
    {
        "path": "frontend/src/scenes/insights/utils",
        "summary": "This collection of code files focuses on providing a robust and flexible API and utility functions for creating, managing, and analyzing insights within PostHog. The code enables users to define complex queries, filter data, and visualize results in various formats. It ensures data consistency and accuracy through query validation, normalization, and cleaning of filter parameters, while also optimizing performance by preventing redundant data fetching. The system supports a variety of insight types, including trends, funnels, retention, paths, stickiness, and lifecycle analysis, each with tailored filtering and configuration options.\n\n**Features:**\n\n*   **Insight Creation and Management:** Create, update, duplicate, and retrieve insights via API.\n*   **Query Building and Validation:** Construct complex queries with variable extraction, validation, and normalization.\n*   **Data Filtering and Cleaning:** Clean and prepare filter parameters for various insight types, including funnel exclusions, breakdown analysis, and interval autocorrection.\n*   **Insight Type Support:** Analyze trends, funnels, retention, paths, stickiness, and lifecycle data with tailored configurations.\n*   **Visualization Options:** Support different chart display types, including world maps, and ensure appropriate breakdown settings.\n*   **Performance Optimization:** Prevent redundant data fetching through query comparison and normalization.\n*   **Test Account Filtering:** Filter out test accounts from insights for cleaner data analysis.\n"
    },
    {
        "path": "frontend/src/scenes/insights/EmptyStates/index.ts",
        "summary": "The code exports all components and functionalities from the `./EmptyStates` module, essentially making them available for use in other parts of the application. This suggests the `EmptyStates` module likely contains various UI components designed to be displayed when a particular section or feature within the insights page has no data to show.\n\n**Features:**\n\n*   Provides reusable UI components for displaying empty states.\n*   Offers a consistent and user-friendly way to handle scenarios where data is unavailable.\n*   Likely includes different variations of empty state components to suit various contexts within the insights page.\n"
    },
    {
        "path": "frontend/src/scenes/insights/insightCommandLogic.ts",
        "summary": "This code defines a Kea logic module called `insightCommandLogic` that integrates with a command palette to provide quick actions related to insights, specifically for graphs. It registers commands to toggle the \"Compare Previous\" feature on a graph and to set the time range of the graph to predefined values. The logic connects to `commandPaletteLogic` to register and deregister commands based on the component's lifecycle and to `insightVizDataLogic` to access and modify the insight's visualization data.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Command Palette Integration for Insights:** Allows users to execute actions related to insights via a command palette.\n*   **Toggle \"Compare Previous\" on Graph:** Provides a command to quickly enable or disable the comparison of data with a previous period on a graph.\n*   **Quick Time Range Selection:** Offers commands to set the time range of an insight graph to predefined values (e.g., \"Last 7 Days\", \"Last 30 Days\").\n"
    },
    {
        "path": "frontend/src/scenes/insights/EmptyStates/EmptyStates.tsx",
        "summary": "This code defines React components for displaying empty states, loading states, and slow query suggestions within the PostHog insights interface. It provides visual cues and helpful tips to users when data is not available, queries are taking a long time, or the system is still processing information. The components handle various scenarios, including initial loading, delayed loading, and situations where the query might be inefficient. The code also incorporates features like sampling to speed up query processing and provides links to debugging tools.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Empty State Display:** Shows a user-friendly message when no data matches the current query.\n*   **Loading State Indicators:** Provides visual feedback during data loading, including animated messages and progress bars.\n*   **Sampling Suggestions:** Recommends enabling or adjusting data sampling to improve query performance.\n*   **Slow Query Optimization Tips:** Offers suggestions for optimizing slow-running queries, such as reducing the date range or avoiding certain event types.\n*   **Query Debugging Link:** Provides a direct link to the query debugger for troubleshooting.\n*   **Real-time Query Progress:** Displays the number of rows and bytes read during query execution.\n"
    },
    {
        "path": "frontend/src/scenes/insights/insightLogic.tsx",
        "summary": "This code defines the `insightLogic` Kea logic, which manages the state and actions related to a single insight within the PostHog application. It handles loading, saving, updating, and managing metadata for insights, as well as determining user permissions and tracking changes. The logic connects to other parts of the application, such as dashboard management, cohort handling, and feature flag evaluation, to provide a comprehensive insight management experience.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Insight Creation and Editing:** Allows users to create new insights and modify existing ones, including name, description, tags, and underlying queries.\n*   **Insight Saving and Persistence:** Enables users to save insights to the database for later access and reuse.\n*   **Insight Loading:** Fetches insights from the backend based on their short ID, with support for overriding filters and variables.\n*   **Insight Metadata Management:** Provides functionality to update insight metadata such as name, description, tags, and favorited status.\n*   **Access Control:** Manages user permissions for insights, ensuring that only authorized users can edit or view them.\n*   **Dashboard Integration:** Supports adding insights to dashboards and managing their presence on multiple dashboards.\n*   **Change Tracking:** Detects changes made to insights compared to their saved state.\n*   **Experiment Context Awareness:** Determines if an insight is being viewed within the context of an experiment.\n*   **Series Highlighting:** Allows highlighting specific series within an insight's visualization.\n"
    },
    {
        "path": "frontend/src/scenes/insights/insightVizDataLogic.ts",
        "summary": "This code defines the `insightVizDataLogic` Kea logic, which manages the state and logic for configuring and updating insight visualizations in the PostHog frontend. It handles various aspects of the insight query, including filters, display settings, and data sources. The logic connects to other Kea logics like `insightDataLogic`, `filterTestAccountsDefaultsLogic`, `databaseTableListLogic`, and `dataThemeLogic` to access and update relevant data. It provides selectors to derive various properties from the query source, such as date range, breakdown filter, display type, series, and more. The logic also includes actions for updating the query source, insight filters, and other settings, as well as reducers for managing the state of the visualization.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Insight Configuration:** Allows users to configure various aspects of an insight visualization, including date ranges, breakdowns, and display types.\n*   **Query Management:** Manages the state of the insight query, including filters, series, and other parameters.\n*   **Data Source Integration:** Integrates with different data sources, such as events, actions, and data warehouse tables.\n*   **Visualization Options:** Provides options for customizing the visualization, such as showing or hiding the legend, displaying values on series, and using a percent stack view.\n*   **Session Analysis Support:** Detects and handles session analysis, providing warnings when necessary.\n*   **Real-time Updates:** Enables real-time updates to the visualization as the user modifies the query and settings.\n*   **Formula Support:** Allows users to define custom formulas for calculating metrics.\n*   **Data Warehouse Integration:** Supports querying data from data warehouses, including schema discovery and column selection.\n*   **Chart Display Customization:** Allows users to customize the chart display type, including line graphs, pie charts, and world maps.\n*   **Alert Threshold Lines:** Allows users to display alert threshold lines on the chart.\n*   **Multiple Y-Axes:** Allows users to display multiple Y-axes on the chart.\n*   **Goal Lines:** Allows users to display goal lines on the chart.\n*   **Compare Functionality:** Allows users to compare data across different time periods.\n*   **Filter Test Accounts:** Allows users to filter out test accounts from the data.\n*   **Data Themeing:** Applies a consistent data theme to the visualization.\n*   **Detailed Results Table:** Shows a detailed results table for the visualization."
    },
    {
        "path": "frontend/src/scenes/insights/EmptyStates",
        "summary": "The code provides a suite of React components designed to enhance the user experience within the PostHog insights interface by providing informative and helpful feedback during data loading, when no data is available, or when queries are running slowly. These components offer visual cues, optimization suggestions, and debugging tools to guide users towards efficient data exploration and analysis.\n\nHere's a list of high-level product features:\n\n*   Empty State Display: Shows user-friendly messages when no data matches the current query.\n*   Loading State Indicators: Provides visual feedback during data loading.\n*   Sampling Suggestions: Recommends enabling or adjusting data sampling to improve query performance.\n*   Slow Query Optimization Tips: Offers suggestions for optimizing slow-running queries.\n*   Query Debugging Link: Provides a direct link to the query debugger for troubleshooting.\n*   Real-time Query Progress: Displays the number of rows and bytes read during query execution.\n*   Reusable UI components: Offers a consistent and user-friendly way to handle scenarios where data is unavailable.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/InsightsTable/DashboardInsightsTable.tsx",
        "summary": "This code defines a `DashboardInsightsTable` component, which is a specialized version of the `InsightsTable` component designed for use within a dashboard context. It leverages the `insightLogic` to retrieve `insightProps` and passes a modified `filterKey` to the underlying `InsightsTable`. The component is configured to be embedded, and disables the ability to check/uncheck series within the table.\n\nHere's a list of high-level product features:\n\n*   **Dashboard Integration:** The table is specifically designed to be embedded within a dashboard.\n*   **Data Filtering:** The table uses a unique filter key based on the dashboard item ID to isolate data relevant to that specific dashboard item.\n*   **Embedded Mode:** The table operates in an embedded mode, likely with a more compact or streamlined presentation.\n*   **Series Selection Restriction:** The ability to check or uncheck series within the table is disabled, suggesting a pre-defined or fixed set of series displayed.\n"
    },
    {
        "path": "frontend/src/scenes/insights/InsightSkeleton.tsx",
        "summary": "The `InsightSkeleton` component in `InsightSkeleton.tsx` provides a loading state representation for an insight page. It uses `LemonSkeleton` components from the `lib/lemon-ui` library to display placeholder elements, simulating the layout of an insight with a title, description, data rows, and a chart area. This allows the user to understand the structure of the page while the actual data is being fetched and rendered.\n\nHere's a list of high-level product features that can be inferred from this component:\n\n*   **Loading State Visualization:** Provides a visual representation of the insight page's structure during data loading.\n*   **Placeholder Content:** Displays placeholder elements for titles, descriptions, data rows, and charts.\n*   **Structured Layout:** Mimics the layout of a typical insight page, including sections for key metrics and visualizations.\n*   **Improved User Experience:** Enhances the user experience by providing feedback during data loading, preventing a blank or unresponsive screen.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/InsightsTable/columns/SeriesCheckColumn.tsx",
        "summary": "This code defines two React components, `SeriesCheckColumnTitle` and `SeriesCheckColumnItem`, which are used to display and manage the visibility of series in a table, likely within an insights or trends visualization. `SeriesCheckColumnTitle` renders a checkbox in the column header that allows the user to check/uncheck all series at once. `SeriesCheckColumnItem` renders a checkbox for each individual series, allowing the user to toggle its visibility. Both components use a `LemonCheckbox` component and receive props to manage the state of hidden series and control user interaction.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Series Visibility Control:** Allows users to show or hide individual series in a chart or table.\n*   **Bulk Series Selection:** Enables users to quickly show or hide all series at once using a master checkbox.\n*   **Indeterminate State for Master Checkbox:** The master checkbox reflects the mixed state when some, but not all, series are visible.\n*   **Disabled State for Series Selection:** Provides a mechanism to disable series selection based on certain conditions.\n*   **Customizable Series Labels:** Supports the display of custom labels alongside the series checkboxes.\n"
    },
    {
        "path": "frontend/src/scenes/insights/RetentionDatePicker.tsx",
        "summary": "The `RetentionDatePicker` component provides a date range selection interface specifically tailored for retention insights. It leverages the `DateFilter` component, allowing users to define a custom date range for analyzing retention data. The component integrates with `retentionLogic` to manage the selected date range and available date options, and it uses `insightLogic` to access insight properties. It also displays a tooltip to inform users about the data limitations for \"All time\" date range.\n\nHere's a list of high-level product features:\n\n*   **Date Range Selection:** Allows users to specify a custom date range for retention analysis.\n*   **Predefined Date Options:** Offers a set of predefined date ranges (e.g., \"All time\", \"Last 7 days\") for quick selection.\n*   **Date Range Persistence:** Stores and retrieves the selected date range using `retentionLogic`.\n*   **Data Limitation Information:** Provides a tooltip to inform users about data limitations when selecting the \"All time\" date range.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/InsightsTable/columns/AggregationColumn.tsx",
        "summary": "This code defines the `AggregationColumn` component for an Insights table, allowing users to choose how numerical data is aggregated and displayed. The column header provides a dropdown menu to select between \"Total Sum\", \"Average\", and \"Median\" aggregations for time series data, while defaulting to \"Total Sum\" for non-time series data. The column items display the calculated aggregation value based on the selected method, formatting the value appropriately based on the data type and properties.\n\nHere's a list of high-level product features:\n\n*   **Aggregation Selection:** Allows users to choose the aggregation method (Total Sum, Average, Median) for numerical data in the Insights table.\n*   **Dynamic Aggregation:** Calculates and displays the aggregated value based on the selected method.\n*   **Data Formatting:** Formats the aggregated value based on the data type and properties.\n*   **Non-Time Series Support:** Defaults to \"Total Sum\" aggregation for non-time series data.\n*   **Event Tracking:** Tracks user interactions with the aggregation selection feature.\n"
    },
    {
        "path": "frontend/src/scenes/insights/aggregationAxisFormat.ts",
        "summary": "This code defines functionality for formatting the values displayed on the aggregation axis of insights charts. It provides a set of predefined formats (numeric, duration, percentage) and a function to apply these formats to numeric values based on the selected format and other configurations like prefixes, postfixes, and decimal places. The code also handles formatting specifically for percentage stack views and determines the appropriate label for the axis based on the chart display type.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Customizable Aggregation Axis Formatting:** Allows users to choose the format of values displayed on the aggregation axis (e.g., numeric, duration, percentage).\n*   **Unit Selection:** Provides options for different units of measurement (e.g., seconds, milliseconds for duration).\n*   **Prefix and Postfix Support:** Enables users to add custom prefixes and postfixes to axis values.\n*   **Decimal Place Control:** Allows users to specify the number of decimal places to display.\n*   **Percentage Stack View Formatting:** Provides specific formatting for percentage values in stacked charts.\n*   **Dynamic Axis Labeling:** Automatically determines the appropriate label for the axis based on the chart type.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/InsightsTable/insightsTableDataLogic.ts",
        "summary": "This code defines a Kea logic module called `insightsTableDataLogic` responsible for managing the aggregation type and related logic for data displayed in an insights table. It determines whether aggregation is allowed based on the chart type and the mathematical operations applied to the data series. The logic also selects a default aggregation type (Average or Total) based on the presence of unique math filters in the series.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Data Aggregation Control:** Allows users to select the type of aggregation (Total, Average, Median) to apply to the data displayed in the insights table.\n*   **Intelligent Default Aggregation:** Automatically selects a sensible default aggregation type (Average for unique counts, Total otherwise) if the user hasn't explicitly chosen one.\n*   **Contextual Aggregation Availability:** Enables or disables aggregation options based on the chart type and the mathematical operations used in the data series to prevent double counting and ensure data integrity.\n*   **Table View Support:** Ensures aggregation is always available when the view type is a table.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/InsightsTable/columns/ColorCustomizationColumn.tsx",
        "summary": "This code defines a column for an insights table that allows users to customize the color of individual trend results. It utilizes Lemon UI's `LemonColorButton` to display the current color and provides an `onClick` handler that opens a modal for further customization. The component uses kea logics (`insightLogic`, `trendsDataLogic`, and `resultCustomizationsModalLogic`) to manage state and actions related to insights, trend data, and the customization modal.\n\n**Features:**\n\n*   **Color Customization:** Allows users to change the color associated with a specific trend result in an insights table.\n*   **Color Display:** Shows the current color of a trend result using a color button.\n*   **Modal Interface:** Opens a modal when the color button is clicked, providing a dedicated interface for color customization.\n*   **Integration with Insights:** Integrates with the insights system to apply color customizations to the relevant data.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/InsightsTable/columns/BreakdownColumn.tsx",
        "summary": "This code defines React components for displaying breakdown information in a table, specifically within an insights context. It includes components for rendering the title of a breakdown column, handling both single and multiple breakdown scenarios, and for displaying individual breakdown items. The `BreakdownColumnItem` component intelligently renders breakdown labels, handling URLs by creating clickable links and other values by displaying them as text with optional word break opportunities. The `PropertyKeyInfo` component is used to display the breakdown title, and the `formatBreakdownType` function is used to format the breakdown type.\n\nHere's a list of high-level product features:\n\n*   **Breakdown Column Title Display:** Renders the title of a breakdown column in an insights table.\n*   **Multiple Breakdown Support:** Handles scenarios where there are multiple breakdowns in a table.\n*   **Breakdown Item Display:** Renders individual breakdown values within a table cell.\n*   **URL Handling:** Automatically converts URL breakdown values into clickable links.\n*   **Text Formatting:** Formats breakdown labels for readability, including adding word break opportunities.\n*   **Property Information Display:** Uses a common component to display property key information for breakdown titles.\n"
    },
    {
        "path": "frontend/src/scenes/insights/Insight.tsx",
        "summary": "The `Insight.tsx` file defines the main component for displaying and interacting with insights within the PostHog application. It handles fetching insight data, managing the query, displaying the insight visualization, and providing editing capabilities. The component also integrates with other parts of the application, such as the insight header, navigation, and debugging tools. It supports overriding filters and variables from dashboards and displays a warning banner when these overrides are active. Access control is also implemented, preventing users without permission from viewing insights.\n\nHere's a list of high-level product features implemented in the code:\n\n*   **Insight Visualization:** Displays the visual representation of the insight data based on the defined query.\n*   **Query Editor:** Allows users to modify the underlying query that generates the insight.\n*   **Insight Editing:** Enables users to switch between view and edit modes for insights.\n*   **Dashboard Filter/Variable Overrides:** Supports applying filters and variables from a dashboard to an insight, with a warning banner to indicate this.\n*   **Insight Navigation:** Provides navigation elements for exploring related insights.\n*   **Access Control:** Restricts access to insights based on user permissions.\n*   **Query Debugging:** Offers debugging tools for analyzing the generated ClickHouse queries.\n*   **Insight Reload:** Allows reloading the insight data.\n"
    },
    {
        "path": "frontend/src/scenes/insights/InsightSaveButton.tsx",
        "summary": "The `InsightSaveButton` component provides a user interface element for saving insights within a dashboard or analytics application. It offers multiple save options, including a primary \"Save\" action that redirects to view mode, a \"Save & continue editing\" option, and a \"Save as...\" option for creating a new insight based on the current one. The button's state (enabled/disabled, loading) reflects the insight's saved status, changes made, and whether it's being added to a dashboard.\n\nHere's a list of high-level product features provided by the component:\n\n*   **Save Insight:** Saves the current insight and redirects the user to view mode.\n*   **Save & Continue Editing:** Saves the current insight and allows the user to continue editing.\n*   **Save As:** Creates a new insight based on the current one, allowing users to duplicate and modify existing insights.\n*   **Dynamic Button State:** The button's label and enabled/disabled state dynamically update based on whether the insight has changes, is already saved, or is being added to a dashboard.\n*   **Loading Indicator:** Displays a loading indicator while the insight is being saved.\n*   **Dashboard Integration:** Provides specific save options when adding an insight to a dashboard.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/InsightsTable/columns/SeriesColumn.tsx",
        "summary": "This code defines a React component, `SeriesColumnItem`, which is responsible for rendering a single item within a series column in an insights table. It displays an `InsightLabel` that represents a trend result, including its name, breakdown value, and comparison label (if applicable). The component also handles displaying tooltips, and allows for inline editing of the series name if enabled. The `formatCompareLabel` function formats the comparison label for display, ensuring backwards compatibility.\n\nHere's a list of high-level features provided by this code:\n\n*   **Series Name Display:** Renders the name of a series in an insights table, using an `InsightLabel` component.\n*   **Breakdown Value Display:** Shows the breakdown value associated with the series.\n*   **Comparison Label Display:** Displays a comparison label if the series is being compared to another.\n*   **Inline Series Name Editing:** Enables inline editing of the series name via click interaction.\n*   **Tooltip Support:** Provides tooltips for series names, offering additional context.\n*   **Customizable Label Appearance:** Styles the label based on whether there is a breakdown or not.\n*   **\"Counted By\" Tag Display:** Shows a tag indicating how the series is counted (e.g., total, average).\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/InsightsTable/columns/WorldMapColumn.tsx",
        "summary": "This code defines a column for a table in the PostHog insights feature, specifically designed to display geographical data related to countries. It utilizes the `$geoip_country_name` property to represent country names and maps country codes to their long names using the `COUNTRY_CODE_TO_LONG_NAME` utility. The column consists of a title component (`WorldMapColumnTitle`) that displays the property key and an item component (`WorldMapColumnItem`) that renders the long name of the country based on the `breakdown_value` from the data item. If a country code is not found, it defaults to displaying \"none\".\n\nHere's a list of high-level product features:\n\n*   **World Map Column Display:** Renders a column in a table to display country names based on geographical IP lookup.\n*   **Country Name Resolution:** Converts country codes (likely ISO 3166-1 alpha-2) to full country names.\n*   **Missing Data Handling:** Displays \"none\" when a country code cannot be resolved to a country name.\n*   **Property Key Information:** Displays the `$geoip_country_name` property key as the column title.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/InsightsTable/columns/ValueColumn.tsx",
        "summary": "This code defines two React components, `ValueColumnTitle` and `ValueColumnItem`, used for displaying data within a table, likely in an insights or trends analysis context. `ValueColumnTitle` renders a date or date range based on the interval and index provided, potentially comparing current and previous periods. `ValueColumnItem` displays a formatted value from the data, taking into account whether the insight is a stickiness analysis. If it is stickiness, it shows both a percentage and the raw formatted value. The formatting of the value is handled by `formatAggregationValue` and `formatAggregationAxisValue` which take into account the math property and trends filter.\n\nHere's a list of high-level product features this code supports:\n\n*   **Date-based data display:** Shows data associated with specific dates or date ranges.\n*   **Comparison of data across periods:** Enables comparison of data between current and previous periods.\n*   **Stickiness analysis support:** Displays stickiness metrics (percentage and raw value).\n*   **Data formatting:** Formats numerical data based on aggregation type and property definitions.\n*   **Trends and Insights Table:** Displaying data in a tabular format for trends and insights.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/InsightsTable/InsightsTable.tsx",
        "summary": "The `InsightsTable` component is a flexible table visualization for displaying insight data, particularly trends and event breakdowns. It leverages the `LemonTable` component and dynamically constructs columns based on the insight's configuration, including series labels, breakdown values, world map regions, aggregated values, and time-series data points. The table supports sorting, filtering, and customization of series appearance, and it integrates with various Kea logics for data fetching, filtering, and display options. It can be used as a standalone component or embedded within other components, such as a legend or a dashboard.\n\nHere's a list of high-level product features provided by the `InsightsTable` component:\n\n*   **Dynamic Column Generation:** Automatically creates table columns based on the insight's configuration, including series, breakdowns, aggregations, and time-series values.\n*   **Series Management:** Allows users to show/hide series, edit series names inline, and view tooltips for series information.\n*   **Breakdown Visualization:** Displays breakdown values, including support for multiple breakdowns and world map visualizations.\n*   **Aggregation Support:** Shows aggregated values (e.g., total, average, median) for non-time-series data.\n*   **Color Customization:** Enables users to customize the color of each series in the table.\n*   **Sorting and Filtering:** Supports sorting of data by various columns and filtering of data based on hidden series.\n*   **Loading State:** Displays a loading indicator while data is being fetched.\n*   **Embedding Support:** Can be embedded within other components, such as legends or dashboards.\n*   **Accessibility:** Uses semantic HTML and ARIA attributes to ensure accessibility for users with disabilities.\n*   **URL Sync:** Persists sorting state in the URL."
    },
    {
        "path": "frontend/src/scenes/insights/views/InsightsTable/columns",
        "summary": "The provided code snippets collectively define the structure and functionality of an interactive insights table within the PostHog platform. This table allows users to visualize and analyze trends data with a high degree of customization. The table supports displaying series names, breakdown values, and comparison labels, along with inline editing and tooltips for enhanced usability. Users can control the visibility of individual series and apply bulk selection actions. The table also handles date-based data, stickiness analysis, and data formatting based on aggregation types. Furthermore, the table supports breakdown columns with URL handling and text formatting, world map columns for geographical data, and color customization for individual trend results. Finally, users can select the aggregation method for numerical data, choosing between total sum, average, and median.\n\nHere's a list of high-level product features:\n\n*   **Interactive Insights Table:** A customizable table for visualizing and analyzing trends data.\n*   **Series Management:** Control series visibility, edit names, and display relevant labels.\n*   **Data Visualization:** Display data associated with dates, stickiness metrics, and geographical information.\n*   **Data Formatting and Aggregation:** Format numerical data and choose aggregation methods.\n*   **Customization Options:** Customize series colors and breakdown displays.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/InsightsTable",
        "summary": "The provided code collectively implements a highly customizable and interactive insights table within PostHog, designed for visualizing and analyzing trends data. The table offers dynamic column generation, allowing users to display series names, breakdown values, and aggregated data points. Users can manage series visibility, edit names, and customize colors, enhancing the analytical experience. The table also supports sorting, filtering, and embedding within dashboards, making it a versatile tool for data exploration and presentation.\n\nHere's a list of high-level product features:\n\n*   Data Aggregation Control (Total, Average, Median)\n*   Intelligent Default Aggregation\n*   Contextual Aggregation Availability\n*   Table View Support\n*   Dashboard Integration\n*   Data Filtering\n*   Embedded Mode\n*   Series Management (show/hide, edit names, tooltips)\n*   Breakdown Visualization (multiple breakdowns, world map)\n*   Color Customization\n*   Sorting and Filtering\n*   Loading State\n*   Accessibility\n*   URL Sync\n*   Data Visualization (dates, stickiness, geographical data)\n*   Data Formatting\n*   Customization Options\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/BoldNumber/index.ts",
        "summary": "The code exports the `BoldNumber` component from the `./BoldNumber` file, making it available for use in other parts of the application. This suggests the existence of a reusable UI component designed to display a number prominently, likely with styling to emphasize its importance.\n\n**Features:**\n\n*   **Bold Number Display:** Renders a numerical value with prominent styling (e.g., larger font size, bold weight) to draw attention to it.\n*   **Reusable Component:** Can be easily integrated into different parts of the application to display key metrics or values.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/BoldNumber/Textfit.tsx",
        "summary": "The `Textfit` component is a React component that dynamically adjusts the font size of its child text content to fit within the bounds of its parent container. It uses a binary search algorithm and a resize observer to efficiently determine the largest possible font size within a specified minimum and maximum range that allows the text to fit without overflowing. The component ensures the text remains on a single line and is centered within the parent.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Dynamic Font Size Adjustment:** Automatically adjusts the font size of text to fit within a container.\n*   **Resize Responsiveness:** Reacts to changes in the parent container's size, recalculating and updating the font size accordingly.\n*   **Font Size Limits:** Respects user-defined minimum and maximum font size constraints.\n*   **Single Line Text:** Ensures the text remains on a single line, preventing wrapping.\n*   **Text Centering:** Centers the text horizontally and vertically within the container.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/BoldNumber/BoldNumber.tsx",
        "summary": "This code defines a React component called `BoldNumber` that displays a prominent numerical value, typically representing an aggregated metric from insights data. It includes features for comparing the current value with a previous period, displaying a trend indicator (up, down, or flat), and providing a tooltip with detailed information. Users can click on the number or the comparison text to open a modal showing the underlying actors contributing to the metric. The component also handles empty states and loading states gracefully. A separate `HogQLBoldNumber` component is also defined to handle displaying a bold number from a HogQL query.\n\nHere's a list of high-level product features:\n\n*   **Prominent Number Display:** Showcases a key metric in a large, easily readable format.\n*   **Trend Comparison:** Compares the current value to a previous period, indicating whether the metric is trending up, down, or remaining flat.\n*   **Trend Indicators:** Uses visual cues (icons) to represent the trend direction.\n*   **Tooltip Information:** Provides a tooltip on hover with detailed information about the metric.\n*   **Actor-Level Drilldown:** Allows users to click on the number or comparison to view the underlying actors contributing to the metric in a modal.\n*   **Empty State Handling:** Displays a clear message when no data is available.\n*   **Loading State Handling:** Shows a loading indicator while data is being fetched.\n*   **HogQL Support:** Supports displaying bold numbers derived from HogQL queries.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/BoldNumber",
        "summary": "The provided code implements a `BoldNumber` component designed to prominently display key metrics within an insights dashboard. This component dynamically adjusts font sizes to fit within its container, compares current values to previous periods with trend indicators, and offers detailed tooltips. Users can drill down to see contributing actors, and the component gracefully handles loading and empty states. It also supports displaying numbers derived from HogQL queries.\n\n**Features:**\n\n*   Prominent Number Display with Dynamic Font Size Adjustment\n*   Trend Comparison with Visual Indicators (Up, Down, Flat)\n*   Detailed Tooltip Information on Hover\n*   Actor-Level Drilldown via Modal\n*   Empty and Loading State Handling\n*   HogQL Query Support\n*   Resize Responsiveness\n*   Font Size Limits\n*   Single Line Text\n*   Text Centering\n*   Reusable Component\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Paths/PathStepPicker.tsx",
        "summary": "The `PathStepPicker` component allows users to select the number of steps to include in a path analysis. It uses a `LemonSelect` component to display a dropdown menu with options ranging from a minimum of 2 steps to a maximum of 5 or 20 steps, depending on whether the user has the `PATHS_ADVANCED` feature enabled. The selected number of steps is then used to update the `stepLimit` filter in the path analysis.\n\nHere's a list of high-level product features:\n\n*   **Step Limit Selection:** Allows users to define the maximum number of steps to consider in path analysis.\n*   **Dynamic Step Range:** Adjusts the maximum number of steps available based on user feature flags (e.g., `PATHS_ADVANCED`).\n*   **Dropdown Interface:** Provides a user-friendly dropdown menu for selecting the desired number of steps.\n*   **Real-time Filter Update:** Updates the path analysis filter immediately upon step selection.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Paths",
        "summary": "The `PathStepPicker` component provides a user interface for selecting the number of steps to include in a path analysis, offering a dropdown menu with options ranging from 2 steps up to a maximum of 5 or 20 steps, depending on the user's feature flags. The selected number of steps is then used to update the `stepLimit` filter in the path analysis, allowing users to dynamically control the complexity of the paths being analyzed.\n\nHere's a list of high-level product features:\n\n*   Step Limit Selection: Allows users to define the maximum number of steps to consider in path analysis.\n*   Dynamic Step Range: Adjusts the maximum number of steps available based on user feature flags (e.g., `PATHS_ADVANCED`).\n*   Dropdown Interface: Provides a user-friendly dropdown menu for selecting the desired number of steps.\n*   Real-time Filter Update: Updates the path analysis filter immediately upon step selection.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Trends/FunnelsCue.tsx",
        "summary": "This code defines a React component called `FunnelsCue` that displays a banner suggesting the user visualize their insight as a funnel if multiple events are present. The banner is displayed conditionally based on the `shown` state managed by the `funnelsCueLogic`. The banner provides an action to convert the current insight to a funnel and an option to dismiss the banner, preventing it from showing again.\n\nHere's a list of high-level product features:\n\n*   **Funnel Suggestion:** Suggests converting a trend insight to a funnel insight when multiple events are present.\n*   **Non-Intrusive Banner:** Displays the suggestion in a non-intrusive banner.\n*   **One-Click Conversion:** Allows users to convert the insight to a funnel with a single click.\n*   **Opt-Out:** Provides an option to dismiss the banner and prevent future suggestions.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Trends/funnelsCueLogic.tsx",
        "summary": "This code defines the `funnelsCueLogic` Kea logic, which manages the display of a funnel conversion cue to users within the PostHog application. The logic determines when to show the cue based on user behavior, specifically when a user has created a trends insight with three or more series. It also handles user opt-out functionality, allowing users to permanently dismiss the cue. The logic tracks whether the cue has been shown, whether the user has opted out, and provides an action to convert the current trends insight into a funnel insight.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Funnel Conversion Cue:** Displays a cue to users suggesting they convert a trends insight into a funnel insight.\n*   **Smart Cue Triggering:** Determines when to show the cue based on the complexity of the user's trends insight (number of series).\n*   **User Opt-Out:** Allows users to permanently dismiss the funnel conversion cue.\n*   **Insight Type Conversion:** Provides an action to convert a trends insight into a funnel insight.\n*   **Usage Tracking:** Tracks when the cue is shown and when users opt-out to measure effectiveness.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Trends",
        "summary": "The provided code implements a feature within PostHog that intelligently suggests converting trend insights into funnel insights. This suggestion is presented as a non-intrusive banner that appears when a user's trend insight meets certain complexity criteria, indicating that a funnel visualization might be more appropriate. Users have the option to convert the insight with a single click or dismiss the banner permanently, preventing future suggestions. The system tracks cue display and opt-out actions to measure effectiveness.\n\n**Features:**\n\n*   Funnel Conversion Cue: Suggests converting trend insights to funnel insights.\n*   Smart Cue Triggering: Determines when to show the cue based on insight complexity.\n*   User Opt-Out: Allows users to dismiss the cue permanently.\n*   Insight Type Conversion: Provides a one-click action to convert the insight.\n*   Non-Intrusive Banner: Displays the suggestion in a non-intrusive manner.\n*   Usage Tracking: Tracks cue display and opt-out actions.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/LineGraph/tooltip-data.ts",
        "summary": "This code defines a function `createTooltipData` that processes data points from a chart tooltip to create a structured array of `SeriesDatum` objects. It extracts relevant information from the dataset associated with each data point, such as labels, colors, counts, and breakdown values, and enriches the data for display in a tooltip. The function also sorts the data by count in descending order and then alphabetically by label, and allows for filtering of the data based on a provided filter function. Finally, it re-assigns unique IDs to each element in the processed array.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Tooltip Data Extraction:** Extracts data from chart tooltips.\n*   **Data Enrichment:** Augments tooltip data with additional information like breakdown values and comparison labels.\n*   **Data Sorting:** Sorts tooltip data for better presentation.\n*   **Data Filtering:** Filters tooltip data based on custom criteria.\n*   **Structured Data Output:** Provides a structured array of data for use in tooltips.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/LineGraph/PieChart.tsx",
        "summary": "This code defines a `PieChart` component for displaying pie chart insights in a web application. It leverages the Chart.js library and its plugins to render interactive pie charts with customizable labels, tooltips, and hover effects. The component handles data processing, chart configuration, and tooltip management, providing a visually appealing and informative representation of data breakdowns.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Pie Chart Visualization:** Renders data as a pie chart for visualizing proportions and breakdowns.\n*   **Interactive Tooltips:** Displays detailed information about each pie slice on hover, including values, percentages, and breakdown details.\n*   **Customizable Labels:** Allows displaying labels on pie slices, including values, percentages, or custom text.\n*   **Data Highlighting:** Highlights the corresponding legend item when hovering over a pie slice.\n*   **Clickable Segments:** Enables users to click on pie slices to trigger actions, such as drilling down into more detailed data.\n*   **Legend Visibility Control:** Allows hiding specific legend items and their corresponding pie slices.\n*   **Percentage Stack View:** Supports displaying data as a percentage stack, showing the relative contribution of each slice.\n*   **Customizable Tooltip Content:** Allows customizing the content displayed in the tooltip, including hiding color columns, headers, and inspect actors sections.\n*   **Dynamic Tooltip Positioning:** Positions the tooltip dynamically based on the cursor location.\n*   **Responsive Design:** Adapts to different screen sizes and orientations.\n*   **Data Aggregation Support:** Formats data values based on the specified aggregation type.\n*   **Customizable Hover Offset:** Allows disabling the hover offset for pie slices."
    },
    {
        "path": "frontend/src/scenes/insights/views/LineGraph/LineGraph.tsx",
        "summary": "The `LineGraph.tsx` file defines a React component, `LineGraph`, responsible for rendering various types of charts, including line graphs, bar graphs, and pie charts, using Chart.js. It handles data processing, chart configuration, event handling (clicks and hovers), and tooltip display. The component supports features like annotations, stacked views, percentage views, logarithmic scales, and dynamic styling based on dark/light mode. It also integrates with other parts of the application, such as insight logic, trends data, and theme settings, to provide a rich and interactive visualization experience.\n\nHere's a list of high-level product features implemented by the code:\n\n*   **Chart Visualization:** Renders line, bar, and pie charts based on provided data.\n*   **Interactive Tooltips:** Displays detailed information on data points upon hover.\n*   **Clickable Data Points:** Supports click events on data points to trigger actions.\n*   **Stacked Views:** Allows displaying data in a stacked format, including 100% stacked views.\n*   **Percentage Views:** Transforms data to percentages for visualization.\n*   **Logarithmic Scale:** Supports logarithmic scales for the Y-axis.\n*   **Annotations:** Displays annotations on the chart for highlighting specific data points or regions.\n*   **Dynamic Styling:** Adapts chart styling based on dark/light mode and data status.\n*   **Goal Lines:** Displays goal lines on the chart to indicate target values.\n*   **Data Filtering:** Filters data based on hidden legend indexes.\n*   **Error Handling:** Includes error boundaries to prevent crashes.\n*   **Performance Monitoring:** Captures and logs chart-related events for debugging and performance analysis.\n*   **Customizable Legends:** Allows customization of chart legends.\n*   **Multiple Y-Axes:** Supports displaying data with multiple Y-axes."
    },
    {
        "path": "frontend/src/scenes/insights/views/LineGraph",
        "summary": "The provided code collectively implements a comprehensive charting solution with interactive visualizations and detailed data exploration capabilities. It supports various chart types, including line, bar, and pie charts, with features like interactive tooltips, clickable data points, stacked and percentage views, logarithmic scales, and annotations. The solution also offers dynamic styling, data filtering, and customizable legends, ensuring a visually appealing and informative user experience.\n\nHere's a list of high-level product features:\n\n*   Chart Visualization (Line, Bar, Pie)\n*   Interactive Tooltips with detailed data\n*   Clickable Data Points for drill-down actions\n*   Stacked and Percentage Views for data comparison\n*   Logarithmic Scale for handling large data ranges\n*   Annotations for highlighting specific data points\n*   Dynamic Styling based on themes and data status\n*   Data Filtering for focused analysis\n*   Customizable Legends for chart clarity\n*   Multiple Y-Axes for complex datasets\n*   Data Sorting for better presentation\n*   Data Enrichment with breakdown values and comparison labels\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Funnels/funnelStepTableUtils.tsx",
        "summary": "This code provides utility functions for working with funnel steps in a React-based frontend application. It includes functions to convert a `FunnelStep` object into an `ActionFilter` object, which is likely used for filtering actions within the funnel. Additionally, it provides a function to extract significance data from a `FlattenedFunnelStepByBreakdown` object for a specific step order, indicating the statistical significance of that step in the funnel breakdown.\n\n**Features:**\n\n*   **Funnel Step to Action Filter Conversion:** Converts a funnel step object into a filter object for actions.\n*   **Significance Data Extraction:** Retrieves statistical significance data for a specific step within a funnel breakdown.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Funnels/FunnelCorrelationSkewWarning.tsx",
        "summary": "This component, `FunnelCorrelationSkewWarning`, displays a warning message to the user when the funnel data is skewed, potentially affecting the accuracy of correlation analysis. It provides tips on how to adjust the funnel definition to improve the analysis. The warning includes an icon, a message explaining the issue, and a button to hide the warning. The component utilizes `kea` logic to determine if the data is skewed and to handle hiding the warning message.\n\nHere's a list of high-level product features:\n\n*   **Skewed Funnel Data Detection:** Detects when funnel data is skewed.\n*   **Warning Display:** Displays a warning message to the user when skewed data is detected.\n*   **Improve Correlation Analysis Guidance:** Provides tips on how to adjust the funnel definition to improve correlation analysis.\n*   **Hide Warning Functionality:** Allows the user to hide the warning message.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Funnels/FunnelCorrelation.tsx",
        "summary": "This code defines the `FunnelCorrelation` component, which is a feature within PostHog that provides correlation analysis for funnels. It checks if the funnel is a steps funnel with more than one step before rendering the correlation analysis. The component includes a skew warning, tables displaying correlations, and a feedback form. The entire feature is gated behind a paywall using the `PayGateMini` component, requiring users to have the `CORRELATION_ANALYSIS` feature enabled.\n\nHere's a list of high-level product features:\n\n*   **Funnel Correlation Analysis:** Provides insights into factors correlating with funnel conversion.\n*   **Skew Warning:** Alerts users to potential data skew that might affect correlation analysis.\n*   **Correlation Table:** Displays correlations between different factors and funnel conversion.\n*   **Property Correlation Table:** Shows correlations between user properties and funnel conversion.\n*   **Feedback Form:** Allows users to provide feedback on the correlation analysis feature.\n*   **Paywall:** Restricts access to the correlation analysis feature based on the user's subscription.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Funnels/FunnelDisplayLayoutPicker.tsx",
        "summary": "The `FunnelDisplayLayoutPicker` component allows users to select the layout of a funnel visualization. It uses a `LemonSelect` component to provide a dropdown menu with options for vertical (left to right) and horizontal (top to bottom) layouts. The selected layout is then used to update the funnel's filter settings, which in turn affects how the funnel is displayed. The component utilizes `kea` logic for managing state and actions related to funnel data and insights.\n\nHere's a list of high-level product features:\n\n*   **Funnel Layout Selection:** Allows users to choose between vertical and horizontal layouts for funnel visualizations.\n*   **Real-time Layout Update:** Changes to the layout are immediately reflected in the funnel display.\n*   **Integration with Funnel Filters:** The selected layout is stored as part of the funnel's filter settings.\n*   **Visual Representation of Layout Options:** Uses icons to visually represent the vertical and horizontal layout options in the dropdown menu.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Funnels/FunnelVizType.tsx",
        "summary": "This code defines a React component, `FunnelVizType`, that allows users to select the visualization type for a funnel insight. It uses the `LemonSelect` component to provide a dropdown menu with three options: \"Conversion steps\", \"Time to convert\", and \"Historical trends\". Each option has a label with an icon and a title, as well as a more detailed description displayed within the dropdown menu. The selected visualization type is stored in the `insightFilter` and can be updated using the `updateInsightFilter` action. The component utilizes the `funnelDataLogic` to access and manage the funnel's data and filter settings.\n\nHere's a list of high-level product features:\n\n*   **Funnel Visualization Type Selection:** Allows users to choose how funnel data is visualized.\n*   **Conversion Steps Visualization:** Displays the progress of users through the steps of the funnel.\n*   **Time to Convert Visualization:** Tracks the time it takes for users to convert within the funnel.\n*   **Historical Trends Visualization:** Shows how the funnel's conversion rate changes over time.\n*   **Dropdown Menu for Visualization Options:** Provides a user-friendly interface for selecting the desired visualization type.\n*   **Descriptive Labels for Visualization Options:** Offers clear explanations of each visualization type within the dropdown menu.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Funnels/CorrelationActionsCell.tsx",
        "summary": "This code defines React components for displaying actions related to funnel correlation results in PostHog. It provides options to view correlation details and exclude events or properties from future correlation analysis reports. The components use popovers to present the actions in a clean and organized manner, leveraging Kea logic for state management and actions. There are two main components: `EventCorrelationActionsCell` which handles actions for event correlations, and `PropertyCorrelationActionsCell` which handles actions for property correlations.\n\n**Features:**\n\n*   **View Correlation Details:** Allows users to open a modal with detailed information about a specific funnel correlation.\n*   **Exclude Event from Project:** Enables users to exclude specific events from being included in future funnel correlation analyses at the project level.\n*   **Exclude Property from Project:** Enables users to exclude specific properties from being included in future funnel correlation analyses at the project level.\n*   **Popover Menu:** Uses a popover to display available actions, providing a clean and organized user interface.\n*   **Dynamic Button Rendering:** Conditionally renders buttons based on the type of correlation result (event or property).\n*   **Disabled State for Exclude Actions:** Disables the \"Exclude\" actions if the event or property is already excluded.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Funnels/FunnelStepsPicker.tsx",
        "summary": "This code defines a `FunnelStepsPicker` component for PostHog's insights feature. It allows users to select a range of steps within a funnel to focus on, using two LemonSelect dropdowns for the \"from\" and \"to\" steps. The component dynamically generates the options for these dropdowns based on the available steps in the funnel and disables the dropdowns if the funnel doesn't have enough steps. It uses `kea` for state management and actions, and `insightVizDataLogic` to access funnel data and update filters. The component displays the step number and entity filter information for each step in the dropdown options.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Funnel Step Selection:** Allows users to select a specific range of steps within a funnel for analysis.\n*   **Dynamic Step Options:** The available steps in the dropdowns are dynamically updated based on the funnel's configuration.\n*   **Step Information Display:** Shows the step number and associated entity filter information in the dropdown options.\n*   **Disabled State:** Disables the step selection if the funnel doesn't have enough steps.\n*   **Integration with Insights:** Integrates with the insights feature to update the funnel's filter based on the selected steps.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Funnels/FunnelCorrelationFeedbackForm.tsx",
        "summary": "This component, `FunnelCorrelationFeedbackForm`, renders a feedback form for users to rate and provide detailed feedback on correlation analysis reports within the PostHog insights feature. The form allows users to rate the usefulness of the report using a range of emoticons, provide optional detailed feedback in a text area, and submit their feedback. The form is conditionally rendered based on whether it's hidden, and it includes actions to send feedback, hide the form, and manage the feedback rating and detailed feedback content.\n\nHere's a list of high-level product features:\n\n*   **Correlation Analysis Report Rating:** Allows users to rate the usefulness of a correlation analysis report using a 5-point emoticon scale.\n*   **Detailed Feedback Submission:** Provides a text area for users to submit optional detailed feedback about their experience with the correlation analysis.\n*   **Feedback Submission:** Enables users to submit their rating and detailed feedback to PostHog.\n*   **Form Visibility Control:** Allows users to hide the feedback form.\n*   **Keyboard Shortcut for Submission:** Supports submitting detailed feedback using a keyboard shortcut (Cmd+Enter).\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Funnels/FunnelStepsTable.tsx",
        "summary": "This code defines the `FunnelStepsTable` component, which is responsible for displaying a table of data for each step in a funnel, broken down by different categories (breakdowns). The table shows conversion rates, drop-off rates, and median conversion times for each step and breakdown. Users can toggle the visibility of breakdowns, inspect the users who converted or dropped off at each step, and customize the colors associated with each breakdown. The table also highlights significant differences in conversion rates between breakdowns.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Funnel Data Visualization:** Displays funnel data in a tabular format.\n*   **Breakdown Analysis:** Shows funnel performance broken down by different categories.\n*   **Conversion Rate Tracking:** Displays conversion rates for each step and breakdown.\n*   **Drop-off Rate Tracking:** Shows the number of users dropping off at each step.\n*   **Median Conversion Time:** Displays the median time it takes for users to convert at each step.\n*   **Breakdown Visibility Toggle:** Allows users to toggle the visibility of different breakdowns in the table.\n*   **User Inspection:** Enables users to inspect the list of users who converted or dropped off at each step for a specific breakdown.\n*   **Color Customization:** Allows users to customize the colors associated with each breakdown for visual differentiation.\n*   **Significance Highlighting:** Highlights significant differences in conversion rates between breakdowns."
    },
    {
        "path": "frontend/src/scenes/insights/views/Funnels/FunnelStepOrderPicker.tsx",
        "summary": "This code defines a React component, `FunnelStepOrderPicker`, which allows users to select the order in which steps must occur in a funnel. It uses a `LemonSelect` component (from `@posthog/lemon-ui`) to present the user with three options: \"Sequential\", \"Strict order\", and \"Any order\". The selected order type is then used to update the funnel's insight filter via `funnelDataLogic`. The component retrieves the current funnel order type from the insight filter and updates it when the user makes a selection.\n\nHere's a list of high-level product features:\n\n*   **Funnel Step Ordering:** Allows users to define the order in which steps must occur in a funnel analysis.\n*   **Sequential Ordering:** Steps must occur in the order defined, but not necessarily immediately after each other.\n*   **Strict Ordering:** Steps must occur in the exact order defined, with no intervening events.\n*   **Unordered:** Steps can occur in any order.\n*   **UI Integration:** Uses a LemonSelect component for a user-friendly selection experience.\n*   **Real-time Updates:** Updates the funnel analysis in real-time based on the selected step order.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Funnels/FunnelConversionWindowFilter.tsx",
        "summary": "This component, `FunnelConversionWindowFilter`, allows users to define a conversion window for funnels insights. It provides input fields for specifying the time interval and unit (seconds, minutes, hours, days, weeks, months) within which a user must convert to be considered successful in the funnel. The component uses debouncing to update the insight filter, preventing excessive updates while the user is typing. It also includes a tooltip explaining the importance of setting a conversion window and how it affects drop-off calculations.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Conversion Window Configuration:** Allows users to set a time limit for conversion within a funnel.\n*   **Time Unit Selection:** Supports various time units (seconds, minutes, hours, days, weeks, months) for the conversion window.\n*   **Input Validation:** Enforces minimum and maximum values for the time interval based on the selected time unit.\n*   **Debounced Updates:** Uses debouncing to prevent excessive updates to the insight filter.\n*   **Informative Tooltip:** Provides a tooltip explaining the purpose and impact of the conversion window.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Funnels/FunnelBinsPicker.tsx",
        "summary": "The `FunnelBinsPicker` component provides a user interface for selecting the number of bins to use when visualizing funnel data. It offers preset options like \"Auto bins\", 5, 15, 25, 50, and 90 bins, as well as a custom input field for specifying a number of bins between 1 and 90. The selected bin count is then used to update the funnel data and visualization.\n\nHere's a list of high-level product features:\n\n*   **Preset Bin Options:** Offers predefined bin counts (e.g., Auto, 5, 15, 25, 50, 90) for quick selection.\n*   **Custom Bin Count Input:** Allows users to specify a custom number of bins within a defined range (1-90).\n*   **Visual Indication of Selection:** Highlights the currently selected bin option.\n*   **Dynamic Update of Funnel Data:** Updates the funnel visualization based on the selected bin count.\n*   **Dropdown Interface:** Provides a clean and organized dropdown menu for selecting bin options.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Funnels/FunnelPropertyCorrelationTable.tsx",
        "summary": "This code defines the `FunnelPropertyCorrelationTable` component, which displays a table of properties correlated with funnel conversion rates. It allows users to select specific properties to analyze, filter correlations by success or drop-off, and view the number of users who completed or dropped off the funnel with each property. The table presents the odds ratio, indicating how much more or less likely users with a specific property are to convert. Users can also drill down to see the specific users associated with each correlation.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Property Correlation Analysis:** Identifies properties that are statistically correlated with funnel conversion rates.\n*   **Property Selection:** Allows users to choose which properties to include in the correlation analysis.\n*   **Correlation Type Filtering:** Enables users to filter the results to show only properties correlated with success or drop-off.\n*   **Odds Ratio Display:** Presents the odds ratio for each property, indicating the strength and direction of the correlation.\n*   **User Count Display:** Shows the number of users who completed or dropped off the funnel with each property.\n*   **User Drill-Down:** Provides the ability to view the specific users associated with each property correlation.\n*   **Data Loading and Refresh:** Automatically loads and refreshes correlation data based on funnel query changes.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Funnels/FunnelCorrelationTable.tsx",
        "summary": "This component, `FunnelCorrelationTable`, displays a table of correlated events within a funnel, helping users understand which events are most likely to influence conversion rates. It allows users to filter correlations by success or drop-off, view the odds ratio of each event, and inspect the users who completed or dropped off after performing the event. The component also supports nested tables to show correlations with event properties and tracks user interactions for usage analysis.\n\nHere's a list of the high-level features:\n\n*   **Correlated Event Display:** Shows a table of events correlated with funnel conversion.\n*   **Success/Drop-off Filtering:** Allows filtering of correlated events based on whether they led to success or drop-off in the funnel.\n*   **Odds Ratio Visualization:** Displays the odds ratio for each event, indicating how much more or less likely users are to convert after performing the event.\n*   **User Inspection:** Enables users to view lists of users who completed or dropped off after performing a specific event.\n*   **Nested Property Correlation:** Provides nested tables to show correlations between events and their properties.\n*   **Loading State:** Displays a loading indicator while correlations are being calculated.\n*   **Empty State Handling:** Shows a message when no correlated events are found, with an option to manually load results.\n*   **Pagination:** Implements pagination for large datasets of correlated events and properties.\n*   **Usage Tracking:** Tracks user interactions with the correlation table for usage analysis.\n*   **Correlation Matrix:** Displays a matrix of correlations between events."
    },
    {
        "path": "frontend/src/scenes/insights/views/Funnels/CorrelationMatrix.tsx",
        "summary": "This code defines a `CorrelationMatrix` component, which is a modal that displays detailed information about the correlation between a specific event or property and funnel conversion. It shows a matrix of true positives, false positives, true negatives, and false negatives, along with percentages and links to view the users in each category. The modal also displays a correlation score and its strength (strong, moderate, or weak) to indicate the significance of the correlation. The component uses several Kea logics to manage state and actions related to funnel correlations and user modals.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Correlation Details Modal:** Displays detailed information about a specific funnel correlation.\n*   **Correlation Matrix:** Presents a matrix of true positives, false positives, true negatives, and false negatives to visualize the correlation.\n*   **User Segmentation:** Allows users to view lists of users who fall into each category of the correlation matrix (e.g., users who performed the event and completed the funnel).\n*   **Correlation Score:** Calculates and displays a correlation score to quantify the strength and direction of the correlation.\n*   **Correlation Strength Indicator:** Visually indicates the strength of the correlation (strong, moderate, or weak) using icons and colors.\n*   **Positive/Negative Correlation Indication:** Indicates whether the correlation is positive (correlated with conversion) or negative (correlated with drop-off).\n*   **Error Handling:** Displays an error message if the correlation details cannot be loaded.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Funnels",
        "summary": "This collection of components enhances the funnel analysis capabilities within PostHog, providing users with a comprehensive suite of tools to understand and optimize their conversion funnels. These features range from visualizing funnel data in various formats and layouts to analyzing correlations between events, properties, and conversion rates. Users can customize the analysis by defining conversion windows, selecting specific funnel steps, and ordering steps based on different criteria. The system also incorporates feedback mechanisms and data quality checks to ensure accurate and insightful results.\n\nHere's a list of high-level product features:\n\n*   **Funnel Data Visualization:** Offers tabular and graphical representations of funnel data, including conversion rates, drop-off rates, and median conversion times.\n*   **Breakdown Analysis:** Enables users to analyze funnel performance by different categories and customize the visual representation of breakdowns.\n*   **Funnel Correlation Analysis:** Identifies factors correlating with funnel conversion, including events and properties, and provides detailed insights into these correlations.\n*   **Funnel Step Ordering:** Allows users to define the order in which steps must occur in a funnel analysis (sequential, strict, or unordered).\n*   **Funnel Layout Customization:** Enables users to select between vertical and horizontal layouts for funnel visualizations.\n*   **Funnel Visualization Type Selection:** Allows users to choose between different visualization types, such as conversion steps, time to convert, and historical trends.\n*   **Conversion Window Configuration:** Allows users to set a time limit for conversion within a funnel.\n*   **Funnel Step Selection:** Allows users to select a specific range of steps within a funnel for analysis.\n*   **Data Quality Checks:** Detects and warns users about skewed funnel data that might affect the accuracy of correlation analysis.\n*   **Feedback Collection:** Provides a mechanism for users to rate and provide feedback on correlation analysis reports.\n*   **User Inspection:** Enables users to inspect lists of users who converted or dropped off at each step for a specific breakdown or event/property correlation.\n*   **Funnel Bins Configuration:** Allows users to configure the number of bins to use when visualizing funnel data.\n*   **Event and Property Exclusion:** Enables users to exclude specific events or properties from future funnel correlation analyses.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/WorldMap/index.ts",
        "summary": "The code exports the `WorldMap` component from the `./WorldMap` file, making it available for use in other parts of the application. This suggests the existence of a world map visualization feature.\n\n**Features:**\n\n*   World Map Visualization: Displays data geographically on a world map.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/WorldMap/WorldMap.tsx",
        "summary": "This code defines a React component called `WorldMap` that visualizes data on a world map. It uses data from PostHog insights to color countries based on aggregated values. The component displays a tooltip on hover with detailed information about the country, including the flag, name, and aggregated value. Users can click on countries to open a modal with more detailed information about the actors in that country or to trigger a custom action. The component leverages D3 for styling and Kea for state management.\n\nHere's a list of high-level product features:\n\n*   **World Map Visualization:** Displays a world map with countries colored based on aggregated data.\n*   **Data-Driven Coloring:** Colors countries based on aggregated values from PostHog insights.\n*   **Interactive Tooltips:** Shows a tooltip on hover with country details (flag, name, value).\n*   **Clickable Countries:** Allows users to click on countries for further actions.\n*   **Persons Modal Integration:** Opens a modal with detailed information about actors in the selected country.\n*   **Custom Click Actions:** Supports custom actions when a country is clicked.\n*   **Dynamic Tooltip Positioning:** Adjusts tooltip position to fit within the SVG bounds.\n*   **Theming Support:** Adapts to the current theme for background color.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/WorldMap/worldMapLogic.tsx",
        "summary": "This code defines the `worldMapLogic` Kea logic for managing the state and interactions of a world map visualization within an insights dashboard. It connects to the `insightVizDataLogic` to fetch and process insight data, and manages the display of tooltips on the map, including showing/hiding the tooltip, updating its coordinates, and storing the data associated with the currently hovered country. It also calculates derived data such as a mapping of country codes to trend series and the maximum aggregated value across all series.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **World Map Visualization:** Displays data aggregated by country on a world map.\n*   **Data Integration:** Fetches and integrates insight data (likely trends) for visualization.\n*   **Tooltip Display:** Shows a tooltip when hovering over a country on the map.\n*   **Tooltip Data:** Displays relevant data (trend results) in the tooltip for the selected country.\n*   **Dynamic Tooltip Positioning:** Updates the tooltip position based on mouse coordinates.\n*   **Data Aggregation:** Calculates and displays aggregated values for each country.\n*   **Data Mapping:** Maps country codes to corresponding data series for efficient lookup.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/WorldMap/countryVectors.tsx",
        "summary": "This code defines a React component that renders a world map using SVG path elements for individual countries. The `countryVectors` object maps country codes (e.g., \"SD\" for Sudan, \"SS\" for South Sudan, \"GE\" for Georgia, \"PE\" for Peru, \"BF\" for Burkina Faso) to their corresponding SVG path elements. Each path element contains the geographical data necessary to draw the country's shape on the map. The component uses a Robinson projection, which is a specific type of map projection.\n\nHere's a list of high-level product features that can be derived from this code:\n\n*   **World Map Visualization:** Displays a world map using SVG elements.\n*   **Country-Specific Rendering:** Renders individual countries as distinct selectable or interactive elements.\n*   **Robinson Projection:** Utilizes the Robinson projection for the map.\n*   **Data-Driven Map:** Uses data to define the shapes and boundaries of countries.\n*   **Customizable Styling:** Allows for custom styling of individual countries (e.g., colors, borders).\n*   **Interactive Map Elements:** Supports interactive elements such as hover effects or click events on countries.\n*   **Country Identification:** Uses country codes to identify and render each country."
    },
    {
        "path": "frontend/src/scenes/insights/views/WorldMap",
        "summary": "The provided code collectively implements a world map visualization feature within an insights dashboard. This feature allows users to view data aggregated by country on an interactive world map, with countries colored based on aggregated values from PostHog insights. Users can hover over countries to view tooltips displaying detailed information, and click on countries to trigger actions such as opening a modal with actor details or initiating custom workflows. The map utilizes the Robinson projection and SVG elements for rendering, and integrates with Kea for state management and D3 for styling.\n\nHere's a list of high-level product features:\n\n*   World Map Visualization: Displays data geographically on a world map.\n*   Data-Driven Coloring: Colors countries based on aggregated values from PostHog insights.\n*   Interactive Tooltips: Shows a tooltip on hover with country details (flag, name, value).\n*   Clickable Countries: Allows users to click on countries for further actions.\n*   Persons Modal Integration: Opens a modal with detailed information about actors in the selected country.\n*   Custom Click Actions: Supports custom actions when a country is clicked.\n*   Dynamic Tooltip Positioning: Adjusts tooltip position to fit within the SVG bounds.\n*   Robinson Projection: Utilizes the Robinson projection for the map.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Histogram/index.js",
        "summary": "The code exports the `Histogram` component from the `./Histogram` file, making it available for use in other parts of the application. This suggests the existence of a histogram visualization feature.\n\n**Features:**\n\n*   Histogram visualization\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Histogram/histogramLogic.ts",
        "summary": "This code defines a Kea logic module named `histogramLogic` responsible for managing the configuration of a histogram visualization. It uses actions and reducers to handle the histogram's configuration, allowing updates to the configuration state. The initial configuration is obtained using `getConfig` with a default `FunnelLayout.vertical`.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Histogram Configuration:** Allows users to customize the appearance and behavior of histogram visualizations.\n*   **Configuration Persistence:** Manages and persists the histogram configuration state.\n*   **Layout Management:** Supports different layouts for the histogram, with a default vertical layout.\n*   **Dynamic Updates:** Enables real-time updates to the histogram based on configuration changes.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Histogram/histogramUtils.ts",
        "summary": "This code defines utilities for configuring and rendering histograms using D3.js. It provides a flexible configuration object (`HistogramConfig`) that controls various aspects of the histogram's appearance, including layout (vertical or horizontal), dimensions, margins, spacing, and axis functions. It also includes a function (`getConfig`) to generate a configuration object based on the desired layout and dimensions, and a function (`createRoundedRectPath`) to create rounded rectangle paths for the histogram bars. Additionally, it defines an interface `D3HistogramDatum` which extends `HistogramDatum` to include properties related to label dimensions and visibility within the bar.\n\nHere's a list of high-level product features that can be derived from this code:\n\n*   **Configurable Histogram Visualization:** Allows users to create histograms with customizable layouts (vertical/horizontal), dimensions, margins, and spacing.\n*   **Rounded Bar Support:** Enables the rendering of histogram bars with rounded corners for a visually appealing presentation.\n*   **Dynamic Axis Generation:** Provides dynamic axis generation based on the chosen layout (vertical/horizontal).\n*   **Customizable Bar Labels:** Supports customization of bar labels, including dimensions and visibility within the bar.\n*   **D3.js Integration:** Leverages D3.js for creating interactive and dynamic histogram visualizations.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Histogram/Histogram.tsx",
        "summary": "This code defines a `Histogram` component in React, utilizing D3.js for rendering a histogram visualization. It takes data, layout (vertical or horizontal), width, height, and formatting functions for the x and y-axis labels as props. The component dynamically adjusts its configuration based on the provided data and dimensions, rendering the histogram with animated transitions. It includes features such as axis generation, gridlines, rounded bars, and data labels, with the ability to customize the appearance and behavior of the chart.\n\nHere's a list of high-level product features:\n\n*   **Histogram Visualization:** Renders a histogram chart from provided data.\n*   **Layout Configuration:** Supports vertical and horizontal layouts.\n*   **Dynamic Resizing:** Adjusts the chart dimensions based on available space and data.\n*   **Customizable Axis Labels:** Allows formatting of x and y-axis tick labels.\n*   **Animated Transitions:** Provides smooth transitions for chart updates.\n*   **Rounded Bars:** Renders bars with rounded corners for a visually appealing design.\n*   **Data Labels:** Displays labels for each bar, with automatic positioning inside or outside the bar.\n*   **Theming:** Supports custom themes for chart styling.\n*   **Empty State Handling:** Gracefully handles cases with no data.\n*   **Outlier Handling:** Special formatting for outlier bins.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views/Histogram",
        "summary": "The provided code collectively implements a configurable and visually appealing histogram visualization feature. It includes logic for managing the histogram's configuration, a React component for rendering the histogram using D3.js, utility functions for generating configurations and rounded bars, and exports the component for use in other parts of the application. The histogram supports vertical and horizontal layouts, dynamic resizing, customizable axis labels, animated transitions, rounded bars, data labels, theming, empty state handling, and outlier formatting.\n\nHere's a list of high-level product features:\n\n*   Histogram Visualization: Renders a customizable histogram chart from provided data.\n*   Layout Configuration: Supports vertical and horizontal layouts.\n*   Dynamic Resizing: Adjusts the chart dimensions based on available space and data.\n*   Customizable Axis Labels: Allows formatting of x and y-axis tick labels.\n*   Animated Transitions: Provides smooth transitions for chart updates.\n*   Rounded Bars: Renders bars with rounded corners for a visually appealing design.\n*   Data Labels: Displays labels for each bar, with automatic positioning inside or outside the bar.\n*   Theming: Supports custom themes for chart styling.\n*   Empty State Handling: Gracefully handles cases with no data.\n*   Outlier Handling: Special formatting for outlier bins.\n*   Configuration Persistence: Manages and persists the histogram configuration state.\n"
    },
    {
        "path": "frontend/src/scenes/insights/views",
        "summary": "The PostHog insights dashboard provides a comprehensive suite of tools for data visualization and analysis, enabling users to explore trends, funnels, and other key metrics. The platform offers interactive charts, customizable tables, and geographical visualizations, allowing users to gain deep insights into their data. Key features include dynamic data aggregation, trend comparison, funnel conversion analysis, and the ability to drill down into individual actors.\n\n*   **Data Visualization:** Interactive charts (line, bar, pie, histogram), customizable tables, and geographical visualizations (world map).\n*   **Trend Analysis:** Dynamic data aggregation, trend comparison with visual indicators, and funnel conversion suggestions.\n*   **Funnel Analysis:** Funnel data visualization, breakdown analysis, correlation analysis, and step ordering.\n*   **Data Exploration:** Interactive tooltips, clickable data points, and actor-level drilldown.\n*   **Customization:** Customizable legends, dynamic styling, and configurable layouts.\n*   **User Interface:** User-friendly dropdown menus, non-intrusive banners, and interactive components.\n*   **Data Management:** Data filtering, sorting, and the ability to exclude specific events or properties.\n*   **Integration:** Dashboard integration, embedded mode, and URL sync.\n*   **Step Limit Selection:** Allows users to define the maximum number of steps to consider in path analysis.\n"
    },
    {
        "path": "frontend/src/scenes/insights/InsightTooltip/InsightTooltip.tsx",
        "summary": "The `InsightTooltip` component is a flexible tooltip designed for displaying insights data in PostHog. It leverages the `LemonTable` component to present data either with entities as columns or rows, adapting based on the complexity of the data (number of entities, breakdowns, comparisons). It formats and displays aggregated values, handles truncation for readability, and provides a \"Click to Inspect Actors\" section for further investigation. The component is customizable with props for date, timezone, series data, titles, rendering functions, and display options.\n\nHere's a list of high-level product features provided by the code:\n\n*   **Data Visualization:** Displays time series data in a tabular format within a tooltip.\n*   **Flexible Layout:** Adapts the table layout (entities as columns or rows) based on data complexity.\n*   **Data Formatting:** Formats aggregated values with customizable rendering.\n*   **Truncation Handling:** Truncates data for readability with a visual indicator.\n*   **Actor Inspection:** Provides a \"Click to Inspect Actors\" link for deeper analysis.\n*   **Customizable Appearance:** Offers props for customizing titles, colors, and display options.\n*   **Breakdown Support:** Handles data with breakdowns, comparisons, and multi-group scenarios.\n*   **Timezone Awareness:** Displays dates with timezone information.\n*   **Embedded Mode:** Supports an embedded mode for different styling."
    },
    {
        "path": "frontend/src/scenes/insights/InsightTooltip/insightTooltipUtils.tsx",
        "summary": "This code defines the data structures and utility functions necessary for rendering tooltips in the PostHog insights feature. It includes interfaces for `SeriesDatum`, `InvertedSeriesDatum`, and `TooltipConfig`, which describe the data format and configuration options for the tooltips. The code also provides functions for formatting dates, generating tooltip titles, and inverting the data source to display series data in a column-wise format. The `invertDataSource` function is particularly important as it transforms the data to be more easily displayed in a tooltip when series are itemized as columns.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Insight Tooltips:** Displaying interactive tooltips on insight graphs to show detailed data for specific data points.\n*   **Customizable Tooltip Content:** Allowing customization of tooltip titles, series rendering, and count rendering.\n*   **Data Aggregation and Formatting:** Aggregating and formatting data from different series to be displayed in a user-friendly format.\n*   **Breakdown Visualization:** Displaying breakdowns of data based on properties or cohorts within the tooltips.\n*   **Comparison Visualization:** Displaying comparisons between different data series within the tooltips.\n*   **Date Formatting:** Formatting dates in tooltips based on the interval type (e.g., day, week, month).\n*   **Embedded Tooltips:** Rendering tooltips as tables that can be embedded into existing popovers.\n*   **Data Inversion:** Transforming data to display series as columns instead of rows for better readability.\n"
    },
    {
        "path": "frontend/src/scenes/insights/utils.tsx",
        "summary": "This code provides utility functions and constants for the Insights feature in PostHog. It includes functions for manipulating and displaying data related to insights, such as formatting breakdown labels, extracting differences between objects, retrieving insight IDs, and humanizing event types for paths. It also defines constants for special breakdown values like \"Other\" and \"None,\" and provides URLs for different insight types. The code focuses on data presentation, manipulation, and retrieval, supporting the display and interaction with insights within the PostHog platform.\n\nHere's a list of high-level product features supported by this code:\n\n*   **Insight Data Formatting:** Functions to format and display insight data, including breakdown labels, aggregation values, and event types.\n*   **Insight Configuration Diffing:** Ability to extract the differences between insight configurations for tracking changes.\n*   **Insight Retrieval:** Functionality to retrieve insight IDs based on short IDs.\n*   **Paths Event Type Humanization:** Converts path event types into human-readable strings.\n*   **Special Breakdown Value Handling:** Defines and handles special breakdown values like \"Other\" and \"None\" for data aggregation.\n*   **Insight Type Navigation:** Provides URLs for creating different types of insights (Trends, Stickiness, Funnels, etc.).\n*   **Entity Name Handling:** Functions to extract and display entity names from filters and nodes, including custom names and handling of \"All events\".\n"
    },
    {
        "path": "frontend/src/scenes/insights/InsightTooltip",
        "summary": "The code provides the functionality to display interactive and customizable tooltips within the PostHog insights feature. These tooltips present detailed data for specific data points on insight graphs, offering a flexible layout that adapts based on data complexity, formatting aggregated values, and handling truncation for readability. Users can further investigate data through a \"Click to Inspect Actors\" link, and the tooltips support breakdowns, comparisons, multi-group scenarios, and timezone awareness.\n\nHere's a list of high-level product features:\n\n*   Data Visualization via interactive tooltips on insight graphs.\n*   Flexible Layout adapting to data complexity (entities as columns or rows).\n*   Customizable Tooltip Content with configurable titles, series rendering, and count rendering.\n*   Data Formatting of aggregated values with customizable rendering.\n*   Truncation Handling for readability.\n*   Actor Inspection via a \"Click to Inspect Actors\" link.\n*   Breakdown Visualization of data based on properties or cohorts.\n*   Comparison Visualization between different data series.\n*   Timezone Awareness in date displays.\n*   Embedded Mode for different styling options.\n*   Data Inversion to display series as columns for improved readability.\n"
    },
    {
        "path": "frontend/src/scenes/insights",
        "summary": "The PostHog insights interface provides a comprehensive suite of tools for data exploration, analysis, and visualization, empowering users to gain deeper understanding of their product usage and user behavior.  The platform supports a wide range of insight types, including trends, funnels, retention, paths, stickiness, and lifecycle analysis, each with customizable filters, breakdowns, and display options.  Users can create, save, share, and manage insights, track their performance, and integrate them into dashboards for a holistic view of their data.  The system also offers advanced features like HogQL support, data sampling, query optimization, and real-time updates, ensuring data consistency, accuracy, and performance.\n\nHere's a list of high-level product features:\n\n*   Insight Creation, Editing, Saving, and Sharing\n*   Support for Multiple Insight Types (Trends, Funnels, Retention, Paths, Stickiness, Lifecycle, SQL, HogQL)\n*   Customizable Filters and Breakdowns (Properties, Cohorts, HogQL Expressions)\n*   Data Visualization (Charts, Tables, World Maps)\n*   Real-time Updates and Interactive Exploration\n*   Dashboard Integration\n*   Query Management and Optimization\n*   Data Export and Sharing\n*   User Permissions and Access Control\n*   Insight Summarization and Documentation\n*   Command Palette Integration\n*   Data Sampling and Test Account Filtering\n*   Alerting and Subscriptions\n*   Data Warehouse Integration\n*   Performance Monitoring and Usage Tracking\n*   Loading State Indicators and Empty State Handling\n*   Customizable Aggregation Axis Formatting\n*   Date Range Selection and Persistence\n*   Insight Metadata Management (Name, Description, Tags, Favoriting)\n*   URL-Based State Management and Sharing\n*   Draft Query Persistence\n*   Experiment Context Awareness\n*   Insight Type Switching and Query Persistence\n*   Data Transformation with HogQL\n*   Series Customization and Highlighting\n*   Drag and Drop Reordering\n*   Visual Indicators\n*   Customizable UI\n*   Aggregation Method Selection (Unique Users, Groups, Sessions, HogQL)\n*   Funnel Analysis Configuration\n*   Retention Analysis Configuration\n*   Path Analysis Filtering\n*   Data Sampling Control\n*   Query Optimization\n*   Result Customization\n*   Insight Summarization\n*   Insight Usage Tracking\n*   Recently Viewed Insights\n*   Command Palette Integration for Insights\n*   Toggle \"Compare Previous\" on Graph\n*   Quick Time Range Selection\n*   Insight Configuration\n*   Query Management\n*   Data Source Integration\n*   Visualization Options\n*   Session Analysis Support\n*   Real-time Updates\n*   Formula Support\n*   Data Warehouse Integration\n*   Chart Display Customization\n*   Alert Threshold Lines\n*   Multiple Y-Axes\n*   Goal Lines\n*   Compare Functionality\n*   Filter Test Accounts\n*   Data Themeing\n*   Detailed Results Table\n*   Empty State Display\n*   Loading State Indicators\n*   Sampling Suggestions\n*   Slow Query Optimization Tips\n*   Query Debugging Link\n*   Real-time Query Progress\n*   Customizable Aggregation Axis Formatting\n*   Unit Selection\n*   Prefix and Postfix Support\n*   Decimal Place Control\n*   Percentage Stack View Formatting\n*   Dynamic Axis Labeling\n*   Date Range Selection\n*   Predefined Date Options\n*   Date Range Persistence\n*   Data Limitation Information\n*   Insight Visualization\n*   Query Editor\n*   Insight Editing\n*   Dashboard Filter/Variable Overrides\n*   Insight Navigation\n*   Access Control\n*   Query Debugging\n*   Insight Reload\n*   Save Insight\n*   Save & Continue Editing\n*   Save As\n*   Dynamic Button State\n*   Loading Indicator\n*   Dashboard Integration\n*   Loading State Visualization\n*   Placeholder Content\n*   Structured Layout\n*   Improved User Experience\n*   Data Visualization\n*   Trend Analysis\n*   Funnel Analysis\n*   Data Exploration\n*   Customization\n*   User Interface\n*   Data Management\n*   Integration\n*   Step Limit Selection\n*   Insight Data Formatting\n*   Insight Configuration Diffing\n*   Insight Retrieval\n*   Paths Event Type Humanization\n*   Special Breakdown Value Handling\n*   Insight Type Navigation\n*   Entity Name Handling\n*   Data Visualization via interactive tooltips on insight graphs.\n*   Flexible Layout adapting to data complexity (entities as columns or rows).\n*   Customizable Tooltip Content with configurable titles, series rendering, and count rendering.\n*   Data Formatting of aggregated values with customizable rendering.\n*   Truncation Handling for readability.\n*   Actor Inspection via a \"Click to Inspect Actors\" link.\n*   Breakdown Visualization of data based on properties or cohorts.\n*   Comparison Visualization between different data series.\n*   Timezone Awareness in date displays.\n*   Embedded Mode for different styling options.\n*   Data Inversion to display series as columns for improved readability.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/OrgLogo.tsx",
        "summary": "This component allows organization administrators to upload and save a custom logo for their organization. It provides a file input for uploading image files, displays a preview of the uploaded logo, and includes a button to save the logo to the organization settings. The component also handles error states during upload and provides feedback to the user. It restricts access to this functionality to organization administrators.\n\nHere's a list of high-level features:\n\n*   **Logo Upload:** Allows users to upload an image file to be used as the organization logo.\n*   **Logo Preview:** Displays a preview of the currently selected or uploaded logo.\n*   **Logo Reset:** Allows users to revert to the default lettermark logo.\n*   **Save Logo:** Saves the uploaded logo to the organization settings.\n*   **Admin Restriction:** Restricts logo management functionality to organization administrators.\n*   **Error Handling:** Displays error messages for failed logo uploads.\n*   **Loading State:** Indicates when the logo is being uploaded or saved.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/VerifiedDomains/VerifyDomainModal.tsx",
        "summary": "This React component, `VerifyDomainModal`, provides a user interface for verifying a domain by guiding the user through the process of adding a TXT record to their DNS zone. The modal displays the necessary TXT record name and value, along with instructions and copy-to-clipboard functionality for easy transfer to the DNS provider. It also includes buttons to verify the domain or postpone the verification process. The modal is triggered by the `verifiedDomainsLogic` and displays information about the domain being verified.\n\nHere's a list of high-level product features:\n\n*   **Domain Verification Modal:** Displays instructions and information for verifying a domain.\n*   **TXT Record Information Display:** Shows the required TXT record name and value for domain verification.\n*   **Copy to Clipboard:** Allows users to easily copy the TXT record name and value.\n*   **Verification Status Indication:** Indicates whether the domain verification process is in progress.\n*   **Verification Action:** Provides a button to initiate the domain verification process.\n*   **Postpone Verification:** Allows users to postpone the domain verification process.\n*   **Instructions for DNS Configuration:** Guides users on how to add the TXT record to their DNS zone.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/VerifiedDomains/AddDomainModal.tsx",
        "summary": "This React component, `AddDomainModal`, is a modal window that allows users to add a new domain to a list of verified domains. It includes an input field for the user to enter the domain, validation to ensure the input is a valid domain format, and a button to submit the new domain. The modal also handles loading states and displays error messages if the submitted domain is invalid. The component uses the `verifiedDomainsLogic` kea logic to manage the modal's visibility, loading state, and the addition of the domain.\n\nHere's a list of high-level product features:\n\n*   **Domain Input Field:** Allows users to enter a domain name.\n*   **Real-time Validation:** Validates the domain format as the user types.\n*   **Submission Handling:** Handles the submission of the new domain.\n*   **Loading State:** Disables the submit button and potentially shows a loading indicator while the domain is being added.\n*   **Error Messaging:** Displays an error message if the submitted domain is invalid.\n*   **Modal Presentation:** Presents the domain input and submission process within a modal window.\n*   **Modal Closure:** Allows users to close the modal, clearing the input field and resetting the submission state.\n"
    },
    {
        "path": "frontend/src/scenes/settings/Settings.tsx",
        "summary": "This code defines the Settings scene in the PostHog frontend, providing a structured way to manage various settings at different levels (project, environment, etc.). It uses a hierarchical navigation system with sections and individual settings, adapting to different screen sizes with a compact navigation mode for smaller screens. The settings are rendered dynamically based on the selected level, section, and setting, and some settings may require re-authentication for security.\n\nHere's a list of high-level product features implemented in this code:\n\n*   **Hierarchical Settings Navigation:** Allows users to navigate settings organized by level (e.g., project, environment) and sections.\n*   **Dynamic Settings Rendering:** Renders settings components based on the selected level, section, and individual setting.\n*   **Compact Navigation:** Adapts the settings navigation to smaller screens with a compact mode.\n*   **Re-authentication for Sensitive Settings:** Requires users to re-authenticate before modifying certain settings.\n*   **External Links in Settings:** Supports linking to external resources from settings options.\n*   **Project-Specific Settings Banner:** Displays a banner indicating that certain settings apply only to the current project.\n*   **Settings Search/Linking:** Provides a way to link directly to a specific setting within the settings page.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/VerifiedDomains/VerifiedDomains.tsx",
        "summary": "This code implements the Verified Domains settings page within a PostHog organization. It allows organization administrators to manage domains associated with their organization for the purpose of automatic user provisioning and enforcing SSO. The page displays a table of verified domains, their verification status, automatic provisioning settings, SSO enforcement settings, and SAML configuration status. Admins can add new domains, verify existing ones, configure SAML, enable/disable automatic provisioning, enforce SSO, and remove domains. The page also integrates with billing to indicate when SSO enforcement or SAML is only available on upgraded plans.\n\nHere's a list of high-level product features:\n\n*   **Domain Verification:** Allows administrators to verify ownership of a domain through DNS records.\n*   **Automatic User Provisioning (JIT):** Enables automatic account creation for users who log in with SSO using an email address on a verified domain.\n*   **SSO Enforcement:**  Requires users with email addresses on a verified domain to log in using a specific SSO provider.\n*   **SAML Configuration:**  Enables configuration of SAML settings for a verified domain.\n*   **Domain Management:**  Allows administrators to add, remove, and view verified domains.\n*   **Billing Integration:**  Indicates when SSO enforcement and SAML features require a plan upgrade.\n*   **Restricted Access:** Limits access to domain management features to organization administrators.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/VerifiedDomains/verifiedDomainsLogic.ts",
        "summary": "This code defines the logic for managing verified domains within an organization. It handles fetching, adding, deleting, updating, and verifying domains. It also manages the SAML configuration for each domain, including handling the SAML ACS URL, entity ID, and X.509 certificate. The logic includes modals for adding domains, configuring SAML, and verifying domains. It also checks for available features like SSO enforcement and SAML support.\n\nHere's a list of high-level product features:\n\n*   **Domain Verification:** Allows organization administrators to verify ownership of domains.\n*   **Domain Management:** Enables adding, deleting, and listing verified domains.\n*   **SSO Enforcement:** Provides the ability to enforce Single Sign-On (SSO) for verified domains.\n*   **JIT Provisioning:** Supports Just-In-Time (JIT) provisioning for users on verified domains.\n*   **SAML Configuration:** Allows configuring SAML settings (ACS URL, Entity ID, X.509 Certificate) for verified domains.\n*   **Domain Verification Status:** Displays the verification status of each domain.\n*   **SAML Configuration UI:** Provides a user interface for configuring SAML settings.\n*   **Feature Availability Checks:** Checks if SSO Enforcement and SAML features are available for the organization."
    },
    {
        "path": "frontend/src/scenes/settings/organization/VerifiedDomains/SSOSelect.tsx",
        "summary": "This code defines a React component, `SSOSelect`, which is a dropdown select element used for choosing an SSO (Single Sign-On) provider for an organization. It dynamically generates options based on available social auth providers fetched from a preflight check and includes SAML as an option if available. Each option displays an icon and can be disabled with a reason if the provider isn't configured. The component uses LemonSelect from `@posthog/lemon-ui` and allows the user to select an SSO provider or choose to not enforce SSO.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **SSO Provider Selection:** Allows administrators to select an SSO provider to enforce for their organization.\n*   **Dynamic Provider List:** The list of available SSO providers is dynamically generated based on server-side configuration.\n*   **SAML Support:** Includes SAML as a potential SSO provider option.\n*   **Provider Status Indication:** Indicates whether an SSO provider is configured and available for use.\n*   **Disabled States with Reasons:** Disables unavailable providers and provides a reason for why they are disabled.\n*   **Loading State:** Indicates when the list of providers is loading.\n*   **Visual Representation:** Uses icons to visually represent each SSO provider.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/VerifiedDomains/ConfigureSAMLModal.tsx",
        "summary": "This code defines a modal for configuring SAML (Security Assertion Markup Language) authentication and provisioning within the PostHog application. The modal provides fields for users to input SAML configuration details, such as the ACS URL, Entity ID, and X.509 certificate, obtained from their Identity Provider (IdP). It also displays pre-filled ACS Consumer URL, RelayState and Audience/Entity ID based on the PostHog instance's URL. The modal includes links to the PostHog documentation for SAML setup and provides feedback on whether the entered configuration is sufficient to enable SAML.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **SAML Configuration Modal:** A user interface element that allows administrators to configure SAML settings for their PostHog organization.\n*   **Input Fields for SAML Parameters:** Dedicated input fields for entering the SAML ACS URL, Entity ID, and X.509 certificate.\n*   **Pre-filled URLs:** Automatically populates ACS Consumer URL, RelayState and Audience/Entity ID based on the PostHog instance's URL.\n*   **Copy-to-Clipboard Functionality:** Provides easy copying of the ACS Consumer URL, RelayState and Audience/Entity ID.\n*   **Form Validation and Submission:** Handles form submission and validation of the SAML configuration.\n*   **Link to Documentation:** Provides a direct link to the PostHog documentation for SAML setup.\n*   **Status Indicator:** Displays a banner indicating whether the entered SAML configuration is complete and valid.\n*   **Save Settings Functionality:** Allows users to save the entered SAML configuration.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/VerifiedDomains",
        "summary": "The provided code implements a comprehensive suite of features for managing verified domains within an organization, primarily focused on enhancing security and user management through Single Sign-On (SSO) and Just-In-Time (JIT) provisioning. These features empower organization administrators to control which domains are associated with their PostHog instance, enforce SSO for users within those domains, and automate user account creation. The system includes modals for adding and verifying domains, configuring SAML settings, and selecting SSO providers, along with real-time validation, error messaging, and clear instructions to guide users through the configuration process.\n\nHere's a list of high-level product features:\n\n*   **Domain Verification:** Allows administrators to verify ownership of a domain through DNS records.\n*   **Domain Management:** Enables adding, deleting, and listing verified domains.\n*   **Automatic User Provisioning (JIT):** Enables automatic account creation for users who log in with SSO using an email address on a verified domain.\n*   **SSO Enforcement:** Requires users with email addresses on a verified domain to log in using a specific SSO provider.\n*   **SAML Configuration:** Enables configuration of SAML settings (ACS URL, Entity ID, X.509 Certificate) for verified domains.\n*   **SSO Provider Selection:** Allows administrators to select an SSO provider to enforce for their organization.\n*   **Billing Integration:** Indicates when SSO enforcement and SAML features require a plan upgrade.\n*   **Real-time Validation:** Validates the domain format as the user types.\n*   **Error Messaging:** Displays an error message if the submitted domain is invalid.\n*   **Copy-to-Clipboard Functionality:** Provides easy copying of the ACS Consumer URL, RelayState and Audience/Entity ID.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/OrgEmailPreferences.tsx",
        "summary": "The `OrgEmailPreferences` component in the PostHog frontend allows organization administrators to toggle whether or not all current members of the organization receive an email notification when a new member joins. This setting is persisted via the `organizationLogic` and the component uses `LemonSwitch` to provide a user-friendly toggle. Access to this feature is restricted to organization administrators.\n\nHere's a list of high-level product features:\n\n*   **Email Notifications for New Member Joins:** Allows admins to enable/disable email notifications to all members when a new member joins the organization.\n*   **Admin-Restricted Access:** Only organization administrators can modify the email notification setting.\n*   **Real-time Setting Updates:** Changes to the email notification setting are persisted immediately.\n*   **Clear UI Indication:** The LemonSwitch component provides a clear visual indication of whether the email notification setting is enabled or disabled.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/Permissions/utils.ts",
        "summary": "This code provides a utility function `getSingularType` that takes a `Resource` type as input and returns a singular string representation of that resource. Currently, it handles the `FEATURE_FLAGS` resource, returning \"flag\". For any other resource type, it defaults to returning \"resource\". This function is likely used to dynamically generate user-friendly labels or messages related to different resource types within the application's settings or permissions management sections.\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **Feature Flag Management:** The application allows managing feature flags, implying the ability to enable or disable features for specific users or groups.\n*   **Resource-Based Permissions:** The application uses a resource-based permission system, where access control is defined based on different types of resources.\n*   **Settings/Permissions Management UI:** The code is part of the frontend, suggesting a user interface for managing settings and permissions related to these resources.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/OrgAI.tsx",
        "summary": "This code defines a component called `OrganizationAI` that allows organization administrators to enable or disable PostHog AI data analysis features for their organization. It uses a LemonSwitch component to provide a toggle, and the state of the toggle is persisted by updating the `is_ai_data_processing_approved` field on the organization object via the `organizationLogic`. The component also restricts access to only organization administrators and disables the toggle while the organization data is loading.\n\n**Features:**\n\n*   **Enable/Disable AI Features:** Allows organization administrators to toggle PostHog AI data analysis features on or off for their organization.\n*   **Admin-Only Access:** Restricts access to the AI feature toggle to users with organization administrator privileges.\n*   **Loading State Handling:** Disables the toggle while the organization data is loading to prevent accidental changes.\n*   **Persistence:** Saves the AI feature setting (`is_ai_data_processing_approved`) to the organization object.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/AIConsentPopoverWrapper.tsx",
        "summary": "The `AIConsentPopoverWrapper` component is a wrapper around a Lemon UI Popover that displays information about the use of external AI services (OpenAI and Perplexity) for data analysis within the organization. It prompts the user to consent to this data processing, explaining that while user data may be analyzed, it will not be used for training AI models. The popover includes a button to accept data processing, which is disabled if the user is not an organization admin. The component uses Kea logic to manage the consent state and actions.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **AI Data Processing Consent:** Allows organization admins to consent to the use of external AI services for data analysis.\n*   **Informational Popover:** Displays a popover explaining the use of AI services, including which services are used and how data is handled.\n*   **Admin-Restricted Action:** Restricts the ability to consent to data processing to organization admins.\n*   **Consent State Management:** Tracks and manages the user's consent status using Kea logic.\n*   **Tooltip Explanation:** Provides additional context about the AI services used and the user's role in approving the consent.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/Permissions/PermissionsGrid.tsx",
        "summary": "The `PermissionsGrid` component provides a user interface for managing organization-level permissions in PostHog. It displays a table that allows administrators and owners to configure default access levels (view and edit) for various PostHog resources for all users and for specific roles. The component fetches existing roles and resource permissions, and provides functionality to update these permissions via checkboxes. It also includes a button to open a modal for creating new roles, gated behind a feature flag.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Role-Based Access Control (RBAC):** Allows defining and managing permissions based on roles.\n*   **Organization-Level Permissions:** Enables setting default permissions for all users at the organization level.\n*   **Resource-Specific Permissions:** Provides granular control over access to different PostHog resources (e.g., events, cohorts).\n*   **View/Edit Access Levels:** Supports defining separate view and edit permissions for each resource.\n*   **Role Creation:** Allows administrators to create new roles with custom permission sets.\n*   **Permission Management UI:** Provides a user-friendly table interface for viewing and modifying permissions.\n*   **Feature Gating:** Restricts access to RBAC features based on the user's plan.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/Permissions/Roles/rolesLogic.tsx",
        "summary": "This code defines the logic for managing roles and permissions within an organization settings page. It handles the creation, deletion, and updating of roles, as well as managing the members associated with each role. The logic also manages the UI state for a modal that allows users to create and edit roles. It fetches data from the API, updates the store, and reports usage events.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Role Creation:** Allows administrators to create new roles with specific permissions.\n*   **Role Deletion:** Enables administrators to delete existing roles.\n*   **Role Editing:** Supports modifying the properties of existing roles.\n*   **Role Member Management:** Allows administrators to add and remove members from roles.\n*   **Permission Assignment:** Enables assigning specific permissions to roles, such as access levels for feature flags.\n*   **User Interface for Role Management:** Provides a modal interface for creating and editing roles.\n*   **Listing Roles:** Displays a list of available roles.\n*   **Listing Role Members:** Displays a list of members associated with a specific role.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/Permissions/Roles/CreateRoleModal.tsx",
        "summary": "This code implements a modal for creating and editing roles within an organization settings page. The modal allows administrators to define a role name, add members to the role from a searchable list of users, and remove existing members. For existing roles, administrators can also delete the entire role. Non-admin users can view the role details, including the members, but cannot modify them. The modal provides loading states for asynchronous operations like fetching members and saving changes.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Role Creation:** Allows administrators to create new roles with a specified name.\n*   **Role Editing:** Enables administrators to modify existing roles, including adding and removing members.\n*   **Role Deletion:** Provides a way for administrators to delete roles.\n*   **Member Management:** Facilitates adding users to roles via a searchable select input.\n*   **Role Member Display:** Shows a list of users who are members of a specific role.\n*   **Access Control:** Restricts role modification and deletion to administrators.\n*   **Loading States:** Displays loading indicators during asynchronous operations.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/Members.tsx",
        "summary": "The `Members.tsx` file implements the organization members management interface within the PostHog settings. It allows administrators to view, search, and manage organization members, including their access levels and 2FA status. The component displays a table of members with details like name, email, membership level, 2FA status, join date, and last login. Actions such as changing access levels and removing members are available through a dropdown menu, with restrictions based on user roles and permissions. Additionally, it includes a feature to enforce two-factor authentication for all organization members, gated behind a paywall.\n\nHere's a list of high-level product features implemented in the code:\n\n*   **Member Listing:** Displays a table of organization members with key details.\n*   **Member Search:** Allows filtering members by name or email.\n*   **Access Level Management:** Enables administrators to change member access levels (e.g., owner, admin, member).\n*   **Member Removal:** Allows administrators to remove members from the organization.\n*   **Self-Service Leave:** Allows users to leave the organization themselves (with restrictions for owners).\n*   **Two-Factor Authentication (2FA) Status:** Displays the 2FA status of each member.\n*   **2FA Enforcement:** Allows administrators to enforce 2FA for all organization members (paid feature).\n*   **Sorting:** Allows sorting of members by name, email, level, join date, and last login.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/Permissions/Roles",
        "summary": "This code manages the creation, modification, and deletion of roles within an organization, along with the assignment of users to those roles. It provides a user interface, specifically a modal, for administrators to define role names, manage role members through a searchable list, and assign permissions. The system also restricts modification and deletion actions to administrators while allowing non-admin users to view role details.\n\n*   Role Creation\n*   Role Deletion\n*   Role Editing\n*   Role Member Management\n*   Permission Assignment\n*   User Interface for Role Management (Modal)\n*   Listing Roles\n*   Listing Role Members\n*   Access Control (Admin vs. Non-Admin)\n*   Loading States\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/Permissions/RoleBasedAccess.tsx",
        "summary": "The `RoleBasedAccess` component conditionally renders either the new Roles and Resource Access Controls UI or the old Permissions Grid based on the `ROLE_BASED_ACCESS_CONTROL` feature flag. This allows for A/B testing and gradual rollout of the new role-based access control system.\n\nHere's a list of high-level product features:\n\n*   **Role-Based Access Control (RBAC):** Manages user permissions based on assigned roles.\n*   **Resource Access Controls:** Controls access to specific resources within the application.\n*   **Permissions Grid:** (Legacy) A grid-based interface for managing user permissions.\n*   **Feature Flagging:** Uses feature flags to enable/disable the new RBAC system for testing and gradual rollout.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/Permissions/permissionsLogic.tsx",
        "summary": "This code defines the logic for managing organization-level and role-based resource permissions within PostHog. It fetches, updates, and displays permissions for resources like feature flags, allowing administrators to control access levels (read or write) for both individual roles and the entire organization. The logic uses Kea for state management, API calls to persist changes, and Lemon Toast for user notifications. It also reports usage events related to permission updates.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Role-Based Access Control (RBAC):** Define and manage permissions for different roles within the organization.\n*   **Organization-Wide Default Permissions:** Set default access levels for resources across the entire organization.\n*   **Resource-Specific Permissions:** Control access to individual resources like feature flags.\n*   **Granular Access Levels:** Define read or write access for each resource and role.\n*   **Centralized Permission Management:** Provide a single interface for managing all resource permissions.\n*   **Audit Logging:** Track changes to resource access levels.\n*   **User Notifications:** Notify users when their resource access levels are updated.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/Permissions",
        "summary": "The provided code collectively implements a comprehensive Role-Based Access Control (RBAC) system for PostHog, enabling granular permission management at both the organization and role levels. This system allows administrators to define roles, assign users to those roles, and configure access levels (view/edit or read/write) for various PostHog resources such as feature flags and cohorts. The implementation includes a user-friendly interface for managing permissions, feature flags for controlled rollout of new RBAC features, and utilities for displaying resource-specific information.\n\nHere's a list of high-level product features:\n\n*   Role-Based Access Control (RBAC)\n*   Organization-Level Permissions\n*   Resource-Specific Permissions\n*   View/Edit (or Read/Write) Access Levels\n*   Role Creation, Editing, and Deletion\n*   Role Member Management\n*   User Interface for Role and Permission Management\n*   Feature Flag Management\n*   Audit Logging\n*   User Notifications\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/OrganizationDangerZone.tsx",
        "summary": "This code defines a \"Danger Zone\" component within the organization settings of a PostHog application. This component allows organization owners to delete their entire organization, but requires confirmation by typing the organization's name to prevent accidental deletion. The component includes a modal that warns the user about the irreversible nature of the action and prompts for the confirmation. The deletion process is restricted to organization owners.\n\nHere's a list of high-level product features:\n\n*   **Organization Deletion:** Allows organization owners to delete their entire organization and all associated data.\n*   **Deletion Confirmation:** Requires users to type the organization's name to confirm the deletion, preventing accidental data loss.\n*   **Restricted Access:** Limits the deletion functionality to organization owners only.\n*   **Warning Message:** Displays a clear warning message about the irreversible nature of the deletion process.\n*   **Deletion Status Indication:** Provides visual feedback on whether the deletion is in progress.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/OrgDisplayName.tsx",
        "summary": "This React component, `OrganizationDisplayName`, allows organization administrators to update the display name of their organization. It uses Lemon UI components for input and button elements, and leverages the `organizationLogic` to fetch the current organization and update its name. The component includes input validation and restricts access to administrators. The update functionality is disabled while the organization data is loading or if the name hasn't been changed.\n\nHere's a list of the high-level product features:\n\n*   **Display Organization Name:** Shows the current organization's name in an input field.\n*   **Update Organization Name:** Allows administrators to change the organization's display name.\n*   **Input Validation:** Prevents updating the organization name with an empty string or the same name.\n*   **Access Control:** Restricts the ability to update the organization name to organization administrators.\n*   **Loading State:** Disables the update button while the organization data is loading.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/Invites.tsx",
        "summary": "This code defines the `Invites` component within the PostHog application, specifically for managing organization invitations. It displays a table of outstanding invitations, including invitee email, membership level, creator, creation date, and a link to accept the invite. Administrators can cancel existing invites, which prompts a confirmation dialog before deletion. The component also handles displaying a message if email services are unavailable and provides a button to trigger the invite teammate modal.\n\n**High-Level Product Features:**\n\n*   **Invite Management:** Allows organization administrators to view, create, and cancel invitations to join their PostHog organization.\n*   **Role-Based Access Control:** Displays the membership level (e.g., admin, member) assigned to each invite.\n*   **Invite Link Generation:** Generates unique, trackable invitation links for new users.\n*   **Invite Cancellation:** Enables administrators to revoke outstanding invitations.\n*   **Email Service Status:** Displays a warning message if email services are unavailable, preventing invites from being sent.\n*   **Audit Trail:** Displays who created the invite and when.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/InviteModal.tsx",
        "summary": "The `InviteModal.tsx` file defines a modal component that allows users to invite new members to their PostHog organization. It handles adding multiple invitees at once, specifying their email, optional name, and membership level. The modal adapts based on whether the PostHog instance is configured to send emails, providing either an email-based invitation flow or a link-based one. It also includes validation, confirmation for owner-level invites, and displays relevant warnings based on license limits and email configuration.\n\nHere's a list of high-level product features implemented in the code:\n\n*   **Invite Team Members:** Allows users to invite new members to their PostHog organization.\n*   **Multiple Invites:** Supports inviting multiple users simultaneously.\n*   **Role-Based Access Control (RBAC):** Enables setting the organization membership level (role) for each invitee.\n*   **Email or Link-Based Invites:** Adapts the invitation method based on email configuration.\n*   **Input Validation:** Validates email addresses before sending invites.\n*   **Optional Name Field:** Allows specifying the invitee's name for convenience.\n*   **Customizable Invitation Message:** Provides a field to add a personalized message to the invitation.\n*   **Confirmation for Owner Invites:** Requires confirmation when inviting users with owner-level permissions.\n*   **License Limit Warning:** Displays a warning when the organization has reached its user license limit.\n*   **Email Configuration Warning:** Informs users if the PostHog instance is not configured to send emails.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization/inviteLogic.ts",
        "summary": "This code defines the logic for managing organization invites within a PostHog application. It handles displaying an invite modal, managing a list of invites to send, sending the invites to the backend, and displaying success or error messages. The logic also fetches existing invites and allows for their deletion. It integrates with preflight checks to determine email service availability and updates the organization and activation tasks upon successful invites.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Invite Team Members:** Allows organization administrators to invite new members to their PostHog organization.\n*   **Bulk Invite Creation:** Supports creating multiple invites simultaneously with individual first names and roles.\n*   **Role-Based Access Control:** Enables assigning different membership levels (e.g., Member, Owner) to invited users.\n*   **Customizable Invite Message:** Allows adding a personalized message to the invite email.\n*   **Invite Management:** Provides a list of pending invites and the ability to cancel them.\n*   **Email Service Integration:** Leverages preflight checks to determine if an email service is available and adjusts the invite process accordingly (sending emails vs. generating invite links).\n*   **Activation Task Completion:** Automatically marks the \"Invite Team Member\" activation task as completed upon successful invites.\n*   **Real-time Organization Updates:** Refreshes the organization data after sending invites to reflect the changes.\n"
    },
    {
        "path": "frontend/src/scenes/settings/organization",
        "summary": "The organization settings section of the PostHog application provides a comprehensive suite of tools for administrators to manage their organization, encompassing everything from visual branding and domain verification to member management and access control. These features ensure a secure, customizable, and well-governed environment for teams collaborating on data analysis and product development within PostHog.\n\nHere's a list of high-level product features:\n\n*   **Organization Branding:**\n    *   Logo Upload and Management\n    *   Display Name Customization\n*   **Domain Management:**\n    *   Domain Verification\n    *   SSO Enforcement\n    *   Automatic User Provisioning (JIT)\n    *   SAML Configuration\n*   **Member Management:**\n    *   Member Listing and Search\n    *   Access Level Management (RBAC)\n    *   Member Removal\n    *   Self-Service Leave\n    *   Two-Factor Authentication (2FA) Management and Enforcement\n    *   Invite Management (Creation, Cancellation, Role Assignment)\n*   **Access Control:**\n    *   Role-Based Access Control (RBAC)\n    *   Organization-Level Permissions\n    *   Resource-Specific Permissions\n    *   View/Edit (or Read/Write) Access Levels\n*   **AI Feature Management:**\n    *   Enable/Disable AI Data Processing\n    *   AI Data Processing Consent\n*   **Notifications:**\n    *   Email Notifications for New Member Joins\n*   **Organization Deletion:**\n    *   Organization Deletion (with Confirmation)\n"
    },
    {
        "path": "frontend/src/scenes/settings/user/UpdateEmailPreferences.tsx",
        "summary": "The `UpdateEmailPreferences` component allows users to manage their email notification settings within PostHog. It provides controls to enable or disable notifications for data pipeline errors and to manage weekly digest emails. Users can opt-out of all weekly digests across all organizations or configure digest preferences for individual projects within the current organization.\n\nHere's a list of high-level features:\n\n*   **Data Pipeline Error Notifications:** Toggle to receive notifications about data pipeline errors.\n*   **Global Weekly Digest Control:** Master switch to enable or disable weekly digest emails for all organizations.\n*   **Individual Project Digest Control:** Fine-grained control to enable or disable weekly digest emails for specific projects within the current organization.\n"
    },
    {
        "path": "frontend/src/scenes/settings/user/UserDetails.tsx",
        "summary": "The `UserDetails` component provides a form for users to update their first name, last name, and email address. It leverages the `kea-forms` library for form management and the `userLogic` to handle data fetching and submission. The form includes input fields for each attribute, disabled during loading, and a submit button that is enabled only when changes are detected. A tag is displayed if the user has a pending email verification.\n\nHere's a list of high-level product features:\n\n*   **Update User Profile:** Allows users to modify their first name, last name, and email address.\n*   **Form Validation:** Enables form submission only when changes have been made.\n*   **Loading State:** Disables form inputs and displays a loading indicator during data fetching and submission.\n*   **Pending Email Verification Indication:** Displays a tag indicating a pending email verification, if applicable.\n"
    },
    {
        "path": "frontend/src/scenes/settings/user/HedgehogModeSettings.tsx",
        "summary": "The `HedgehogModeSettings` component provides a user interface for configuring \"Hedgehog Mode.\" This mode appears to involve a hedgehog-themed buddy or avatar within the application. The settings allow users to enable or disable the mode, choose whether to use the hedgehog as their profile picture, and further customize the hedgehog's appearance or behavior through the `HedgehogOptions` component.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Enable/Disable Hedgehog Mode:** Toggles the hedgehog-themed features on or off.\n*   **Hedgehog Profile Picture:** Allows users to use the hedgehog as their profile picture.\n*   **Hedgehog Customization:** Provides options to customize the appearance or behavior of the hedgehog.\n"
    },
    {
        "path": "frontend/src/scenes/settings/user/changePasswordLogic.ts",
        "summary": "This code defines a Kea logic module for handling the \"Change Password\" functionality within a user settings section. It manages a form with fields for the current password and the new password, including validation and submission. Upon successful password change, a success message is displayed. Errors from the API are mapped to the corresponding form fields. The logic also includes password strength validation.\n\nHere's a list of high-level product features:\n\n*   **Change Password Form:** Allows users to change their account password.\n*   **Current Password Verification:** Requires users to enter their current password for security.\n*   **Password Validation:** Validates the new password for strength and complexity.\n*   **API Integration:** Communicates with the backend API to update the user's password.\n*   **Success/Error Messaging:** Provides feedback to the user upon successful password change or in case of errors.\n*   **Form Reset:** Resets the password form after a successful password change.\n"
    },
    {
        "path": "frontend/src/scenes/settings/user/OptOutCapture.tsx",
        "summary": "This React component, `OptOutCapture`, provides users with the ability to opt-out of PostHog's product usage data collection. It displays explanatory text about the purpose of data collection and offers a toggle switch labeled \"Anonymize my data\". When toggled, the component calls the `updateUser` action from the `userLogic` to update the user's `anonymize_data` preference. The component also handles loading states by disabling the switch while the user data is loading.\n\nHere's a list of high-level product features:\n\n*   **Data Anonymization:** Allows users to anonymize their personal usage data.\n*   **Opt-Out Mechanism:** Provides a clear and accessible way for users to opt-out of product usage data collection.\n*   **User Preference Persistence:** Saves the user's data anonymization preference.\n*   **Loading State Handling:** Disables the opt-out control while user data is loading.\n*   **Informative UI:** Displays explanatory text about data collection practices.\n"
    },
    {
        "path": "frontend/src/scenes/settings/user/ThemeSwitcher.tsx",
        "summary": "The `ThemeSwitcher` component provides a user interface element for selecting the application's theme. It offers options for light mode, dark mode, syncing with the system's theme, and, if custom CSS is enabled, an option to edit custom CSS. The component uses a `LemonSelect` dropdown to present these options. When a user selects a theme, the component updates the user's preferences via `userLogic` or navigates to the custom CSS editor if the \"Edit custom CSS\" option is selected.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Theme Selection:** Allows users to choose between different color themes (light, dark, system).\n*   **System Theme Sync:** Enables the application to automatically adapt to the user's operating system's theme.\n*   **Custom CSS Support:** Provides an option to enable and edit custom CSS for advanced theme customization.\n*   **User Preference Persistence:** Saves the selected theme preference for future sessions.\n"
    },
    {
        "path": "frontend/src/scenes/settings/user/ChangePassword.tsx",
        "summary": "This React component, `ChangePassword`, provides a form for users to change their password. It leverages the `kea-forms` library for form management and includes fields for the current password and the new password. The component also integrates a `PasswordStrength` component to provide real-time feedback on the strength of the new password. A submit button initiates the password change process, with a loading state to indicate when the change is in progress.\n\nHere's a list of high-level product features:\n\n*   **Current Password Input:** Allows users to enter their existing password for authentication.\n*   **New Password Input:** Enables users to specify their desired new password.\n*   **Password Strength Indicator:** Provides visual feedback on the strength of the entered password.\n*   **Form Validation:** Ensures that the password change form is properly validated before submission.\n*   **Submit Button:** Triggers the password change process.\n*   **Loading State:** Indicates when the password change process is in progress.\n"
    },
    {
        "path": "frontend/src/scenes/settings/user/TwoFactorSettings.tsx",
        "summary": "The `TwoFactorSettings` component provides a user interface for managing two-factor authentication (2FA) settings. It allows users to enable or disable 2FA, view and generate backup codes, and provides modals for confirming disabling 2FA and displaying backup codes. The component uses Lemon UI components for buttons and modals, and leverages kea-logic for state management and actions related to user and 2FA settings.\n\nHere's a list of high-level product features:\n\n*   **Enable/Disable 2FA:** Allows users to enable or disable two-factor authentication for their account.\n*   **Backup Code Generation:** Enables users to generate a set of one-time use backup codes for use when they lose access to their primary 2FA method.\n*   **Backup Code Display:** Displays the generated backup codes to the user.\n*   **Backup Code Copying:** Allows users to copy the backup codes to their clipboard.\n*   **Confirmation Modal for Disabling 2FA:** Requires users to confirm their decision to disable 2FA via a modal.\n*   **Status Indication:** Displays whether 2FA is currently enabled or disabled for the user's account.\n"
    },
    {
        "path": "frontend/src/scenes/settings/user/PersonalAPIKeys.tsx",
        "summary": "This code implements the \"Personal API Keys\" feature within a settings panel. It allows users to create, edit, and manage API keys that grant access to PostHog's API. The component provides a modal form for creating and editing keys, allowing users to define the key's label, scope (permissions), and the organizations or projects the key has access to. It includes UI elements for selecting API key scopes, with warnings and information to guide users in granting appropriate permissions. The component also handles form submission, validation, and display of existing API keys.\n\n**Features:**\n\n*   **API Key Creation:** Allows users to create new personal API keys with customizable labels.\n*   **API Key Editing:** Enables users to modify existing API keys, including their label, scope, and access permissions.\n*   **Scope Management:** Provides a UI for defining the API key's scope, limiting the actions it can perform.\n*   **Organization/Project Access Control:** Allows users to restrict the API key's access to specific organizations or projects.\n*   **Scope Presets:** Offers pre-defined scope configurations for common use cases.\n*   **Form Validation:** Validates user input to ensure the API key configuration is valid.\n*   **UI Warnings and Information:** Displays warnings and information to guide users in granting appropriate permissions.\n*   **API Key Listing:** Displays a list of the user's existing API keys (implementation not included in the provided snippet).\n"
    },
    {
        "path": "frontend/src/scenes/settings/settingsLogic.ts",
        "summary": "This code defines the logic for the settings page in PostHog, managing the selection and display of settings based on feature flags, user permissions, and the current environment (cloud vs. self-hosted). It handles the navigation between different levels (project, environment), sections within those levels, and individual settings. The logic also filters settings based on feature flags and whether they should be hidden in cloud or self-hosted environments. It uses Kea to manage state, actions, reducers, and selectors, connecting to other logics like `featureFlagLogic`, `userLogic`, `preflightLogic`, and `teamLogic` to determine the visibility and behavior of settings.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Settings Navigation:** Allows users to navigate through different levels (e.g., project, environment) and sections of settings.\n*   **Feature Flag-Based Settings:** Dynamically shows or hides settings based on enabled feature flags.\n*   **Environment-Aware Settings:** Adapts the settings displayed based on whether the PostHog instance is running in the cloud or self-hosted.\n*   **User Permission-Based Settings:** Controls the visibility of settings based on user permissions and team configurations.\n*   **Compact Navigation:** Provides a compact navigation mode for settings.\n*   **Dynamic Settings Titles:** Dynamically updates settings titles based on the selected level (e.g., replacing \"environment\" with \"project\").\n"
    },
    {
        "path": "frontend/src/scenes/settings/user/personalAPIKeysLogic.tsx",
        "summary": "This code defines the `personalAPIKeysLogic` Kea logic, which manages the creation, updating, deletion, and display of personal API keys for users. It handles loading existing keys, managing a form for editing key details (label, scopes, associated organizations/teams), and displaying the newly created key in a modal. The logic also includes predefined scope presets for common use cases like local feature flag evaluation, Zapier integration, and analytics queries. It also manages the UI state for editing API keys, including handling scope selection and displaying warnings related to specific scopes.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Personal API Key Management:** Allows users to create, view, edit, and delete their personal API keys.\n*   **Scoped API Keys:** Enables users to define granular permissions (scopes) for each API key, limiting access to specific resources and actions.\n*   **Predefined Scope Presets:** Offers pre-configured scope sets for common use cases, simplifying the key creation process.\n*   **Organization/Team Scoping:** Allows API keys to be restricted to specific organizations or teams, further limiting access.\n*   **Secure Key Display:** Displays the API key value only once upon creation, ensuring security.\n*   **UI for Scope Selection:** Provides a user interface for selecting and managing API key scopes.\n*   **Warnings for Sensitive Scopes:** Displays warnings to users when selecting scopes that grant broad or potentially dangerous permissions.\n*   **URL-based Preset Selection:** Allows pre-selecting a scope preset via URL parameters.\n"
    },
    {
        "path": "frontend/src/scenes/settings/SettingsMap.tsx",
        "summary": "This code defines the settings map for the PostHog frontend, organizing various settings into sections based on their scope (environment, organization, project, user). Each section contains individual settings with titles, descriptions, and React components that allow users to configure different aspects of the PostHog platform, such as autocapture behavior, data governance, session replay, feature flags, error tracking, integrations, and user preferences. The settings are grouped logically to provide a structured and manageable interface for configuring PostHog.\n\nHere's a list of high-level product features configurable through these settings:\n\n*   **General Environment Settings:** Display name, web snippet, authorized URLs, project ID.\n*   **Autocapture & Heatmaps:** Autocapture configuration, data attributes, heatmap settings, web vitals autocapture, dead clicks autocapture.\n*   **Product Analytics:** Date & time, internal user filtering, chart color themes, person properties mode, correlation analysis exclusions, person display name, path cleaning rules, IP data capture, human-friendly comparison periods, group analytics, persons join mode, sessions table version.\n*   **Web Analytics:** Web analytics domains, custom channel type, revenue base currency, cookieless server hash mode, bounce rate duration, bounce rate page view mode, session join mode.\n*   **Session Replay:** Session replay configuration, network capture, masking, authorized domains, replay triggers, ingestion controls, AI recording summary.\n*   **Surveys:** Surveys web interface.\n*   **Feature Flags:** Feature flag settings.\n*   **Error Tracking:** Exception autocapture, user groups, symbol sets, alerting.\n*   **Max AI:** Memory settings.\n*   **Integrations:** Webhooks, Slack integration, other integrations, managed reverse proxy, IP allow list.\n*   **Team Settings:** Team timezone, team variables, team authorized URLs.\n*   **Team Access Control:** Access control settings.\n*   **Team Danger Zone:** Options for deleting or exporting team data.\n*   **Organization Settings:** Organization display name, logo, email preferences, verified domains, invites, members, AI settings, role-based access control, danger zone.\n*   **Project Settings:** Project display name, project move, project danger zone.\n*   **User Settings:** Change password, hedgehog mode, opt-out capture, personal API keys, theme switcher, two-factor authentication, update email preferences, user details."
    },
    {
        "path": "frontend/src/scenes/settings/user",
        "summary": "The user settings section provides a comprehensive suite of features for users to manage their account and preferences. These features range from basic profile information updates and password management to more advanced options like theme customization, two-factor authentication, API key management, and email notification preferences. Users can also control their data privacy by opting out of product usage data collection and enabling a \"Hedgehog Mode\" for a personalized experience.\n\nHere's a list of high-level product features:\n\n*   **User Profile Management:** Update first name, last name, and email address.\n*   **Password Management:** Change password with strength validation and current password verification.\n*   **Theme Customization:** Select application theme (light, dark, system) and enable custom CSS.\n*   **Two-Factor Authentication (2FA):** Enable/disable 2FA, generate and manage backup codes.\n*   **Personal API Key Management:** Create, edit, and manage API keys with scoped permissions and organization/project access control.\n*   **Email Notification Preferences:** Manage data pipeline error notifications and weekly digest emails.\n*   **Data Anonymization:** Opt-out of product usage data collection.\n*   **Hedgehog Mode:** Enable/disable hedgehog-themed features and customize the hedgehog.\n*   **System Theme Sync:** Automatically adapt to the user's operating system's theme.\n"
    },
    {
        "path": "frontend/src/scenes/settings/project/ProjectDangerZone.tsx",
        "summary": "This code defines a \"Danger Zone\" section within the project settings of a web application, specifically for handling project deletion. It includes a modal that prompts the user to confirm the deletion by typing the project's name, emphasizing the irreversible nature of the action and the loss of all associated data. The deletion process is restricted to organization administrators.\n\nHere's a list of high-level product features:\n\n*   **Project Deletion:** Allows organization administrators to delete a project and all its associated data (environments, events, etc.).\n*   **Confirmation Mechanism:** Requires users to type the project name to confirm the deletion, preventing accidental data loss.\n*   **Admin Restriction:** Limits project deletion functionality to users with administrator privileges within the organization.\n*   **Deletion Warning:** Displays a clear warning about the irreversible nature of project deletion and the data loss involved.\n*   **Loading State:** Disables the delete button and shows a loading indicator while the deletion process is in progress.\n"
    },
    {
        "path": "frontend/src/scenes/settings/project/ProjectSettings.tsx",
        "summary": "This code defines a React component called `ProjectDisplayName` that allows users to rename their current project. It uses the `kea` library for state management and actions, specifically `projectLogic` to access the current project's data and update it. The component includes an input field where the user can enter the new project name and a button to trigger the renaming process. The button is disabled when the input field is empty, when the project is loading, or when the new name is the same as the current name.\n\nHere's a list of high-level product features:\n\n*   **Display Current Project Name:** Shows the current name of the project in an input field.\n*   **Rename Project:** Allows users to change the name of their project.\n*   **Input Validation:** Prevents users from submitting an empty project name.\n*   **Loading State:** Disables the input and button while the project data is loading or being updated.\n*   **Change Detection:** Disables the rename button if the new name is identical to the existing name.\n"
    },
    {
        "path": "frontend/src/scenes/settings/project/ProjectMove.tsx",
        "summary": "This code implements a feature to move a PostHog project from one organization to another. It includes a `ProjectMove` component that allows users to select a target organization and initiate the move. A modal (`MoveProjectModal`) prompts the user for confirmation by typing the project's name before proceeding with the move. The move operation requires admin privileges and displays loading states and confirmation prompts to ensure data integrity and prevent accidental moves.\n\nHere's a list of high-level product features:\n\n*   **Project Move Initiation:** Allows users with admin privileges to initiate the process of moving a project to a different organization.\n*   **Target Organization Selection:** Provides a dropdown to select the target organization for the project move.\n*   **Confirmation Modal:** Presents a modal to confirm the project move, requiring the user to type the project's name for verification.\n*   **Access Restriction:** Restricts the project move functionality to users with admin privileges within the project.\n*   **Loading State:** Displays a loading state during the project move operation to indicate progress and prevent further actions.\n*   **Warning Message:** Displays a warning message to inform users about the implications of moving a project, such as loss of access for original organization members.\n"
    },
    {
        "path": "frontend/src/scenes/settings/project",
        "summary": "The provided code snippets detail features for managing PostHog projects, including moving projects between organizations, renaming projects, and deleting projects. These features are designed with data integrity and user safety in mind, incorporating confirmation steps, access restrictions, and loading states to prevent accidental actions and ensure a smooth user experience.\n\nHere's a list of high-level product features:\n\n*   Project Move Initiation and Target Organization Selection\n*   Project Rename\n*   Project Deletion\n*   Confirmation Mechanisms (Typing Project Name)\n*   Admin Access Restriction\n*   Loading States\n*   Warning Messages\n*   Input Validation\n*   Change Detection\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/FeatureFlagSettings.tsx",
        "summary": "The `FeatureFlagSettings.tsx` component provides a settings interface for configuring default behavior of feature flags. It includes a link to the main feature flags management page and renders the `BasicFeatureFlagSettings` component, which likely contains the actual settings controls.\n\nHere's a list of high-level product features:\n\n*   **Feature Flag Configuration:** Allows users to configure the default behavior of feature flags.\n*   **Link to Feature Flags Page:** Provides a direct link to the main feature flags management interface.\n*   **Settings Interface:** Renders a settings interface (likely via the `BasicFeatureFlagSettings` component) for managing feature flag behavior.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/RevenueBaseCurrencySettings.tsx",
        "summary": "This React component, `RevenueBaseCurrencySettings`, allows users to configure the base currency used for revenue calculations within PostHog. It displays a description explaining the purpose of the setting and provides a dropdown menu (`CurrencyDropdown`) to select the desired base currency. Upon selection, the component updates the `baseCurrency` setting and triggers a save action to persist the changes.\n\n**Features:**\n\n*   **Base Currency Selection:** Allows users to choose a base currency from a dropdown list.\n*   **Currency Conversion:** Informs users that revenue values will be converted to the selected base currency for display.\n*   **Default Currency Assumption:** Explains that the base currency will be assumed if the currency of revenue events cannot be detected.\n*   **Persistence:** Saves the selected base currency setting.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/SessionsTableVersion.tsx",
        "summary": "This React component, `SessionsTableVersion`, allows users to select the version of the session table used in PostHog. It provides a radio button group with options for \"Auto\", \"Version 1\", and \"Version 2\". The component persists the selected version to the current team's settings and reports usage events. It also displays a save button that is disabled when no changes have been made.\n\nHere's a list of the high-level product features:\n\n*   **Session Table Version Selection:** Allows users to choose between different versions of the session table.\n*   **Persistence of Selection:** Saves the selected session table version to the team's settings.\n*   **Usage Reporting:** Tracks and reports when the session table version is updated.\n*   **UI for Selection:** Provides a radio button group for easy selection of the desired version.\n*   **Save Button:** Includes a button to save the selected version, with disabled state based on changes.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/WebhookIntegration.tsx",
        "summary": "This component, `WebhookIntegration`, manages the integration of webhooks with PostHog, allowing users to receive notifications when specific actions are performed. It provides an input field for the webhook URL, along with buttons to test and save the webhook, or to clear and disable the integration. The component checks for feature flags that might disallow webhooks and redirects users to the new Pipeline Destinations feature if no webhook is currently configured. It also provides links to documentation for integrating with Slack and Microsoft Teams.\n\nHere's a list of high-level product features:\n\n*   **Webhook Configuration:** Allows users to input and save a webhook URL for receiving notifications.\n*   **Webhook Testing:** Enables users to test the configured webhook to ensure it's working correctly.\n*   **Webhook Disabling:** Provides a way to clear and disable the existing webhook integration.\n*   **Integration with Pipeline Destinations:** Guides users to the new Pipeline Destinations feature as a replacement for the webhook integration.\n*   **Documentation Links:** Offers links to documentation for integrating with popular platforms like Slack and Microsoft Teams.\n*   **Feature Flag Check:** Checks for feature flags that might restrict webhook usage.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/IPCapture.tsx",
        "summary": "This code defines a React component called `IPCapture` that allows users to toggle the anonymization of IP addresses for their team. It uses the `kea` library for state management and actions, specifically interacting with the `teamLogic` to fetch the current team's settings and update them. The component renders a `LemonSwitch` (a toggle switch) that, when toggled, calls an action to update the `anonymize_ips` setting for the current team. The switch is disabled while the team settings are loading.\n\nHere's a list of high-level product features:\n\n*   **IP Address Anonymization Toggle:** Allows users to enable or disable the anonymization of IP addresses collected by PostHog.\n*   **Real-time Setting Update:** Changes to the IP anonymization setting are applied immediately.\n*   **Loading State Indication:** Provides visual feedback (disabling the switch) while the team settings are being loaded.\n*   **Team-Specific Configuration:** The IP anonymization setting is configured on a per-team basis.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/sessionReplayIngestionControlLogic.ts",
        "summary": "This code defines a Kea logic module named `sessionReplayIngestionControlLogic` that manages the selection and retrieval of a feature flag linked to session replay ingestion control. It fetches the feature flag based on the `session_recording_linked_flag` ID stored in the current team's settings. The logic allows selecting a feature flag, loading its details from the API, and determining if the flag has variants. It connects to the `teamLogic` to access and update the current team's data.\n\n**Features:**\n\n*   **Feature Flag Selection:** Allows users to select a feature flag to link to session replay ingestion control.\n*   **Feature Flag Loading:** Fetches the details of the linked feature flag from the API.\n*   **Linked Feature Flag Display:** Displays the currently linked feature flag.\n*   **Variant Detection:** Determines if the linked feature flag has variants (multivariate).\n*   **Team Context:** Integrates with team settings to manage the linked feature flag on a per-team basis.\n*   **Data Persistence:** Updates the current team's settings with the selected feature flag.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/BounceRatePageViewMode.tsx",
        "summary": "This code defines a settings component, `BounceRatePageViewModeSetting`, that allows users to configure how pageviews are counted when calculating bounce rate within PostHog. It provides three options: counting all pageviews, counting unique URLs visited, or using a `uniqUpTo` function to count unique pageviews, screen events, and autocaptures. The selected mode is saved to the current team's modifiers and an event is reported for usage tracking.\n\nHere's a list of high-level product features:\n\n*   **Bounce Rate Calculation Configuration:** Allows users to customize how pageviews are counted when calculating bounce rate.\n*   **Three Pageview Counting Modes:** Offers options to count all pageviews, unique URLs, or use a `uniqUpTo` function for a combined count of pageviews, screen events, and autocaptures.\n*   **Team-Specific Settings:** Saves the selected bounce rate calculation mode to the current team's settings.\n*   **Usage Tracking:** Reports the selected bounce rate calculation mode for usage analysis.\n*   **UI for Selection and Saving:** Provides a radio button group to select the mode and a button to save the changes.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/OtherIntegrations.tsx",
        "summary": "The `OtherIntegrations` component in the PostHog frontend displays a list of connected integrations (excluding Slack) and allows users to disconnect them. It fetches the integrations data using the `integrationsLogic` Kea logic and renders each integration using the `IntegrationView` component. A confirmation dialog is shown before disconnecting an integration to prevent accidental data loss. The component also handles loading and empty states, displaying a skeleton loader while data is being fetched and a \"No integrations\" message when no integrations are connected.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Display Connected Integrations:** Shows a list of integrations connected to the PostHog instance.\n*   **Integration Disconnection:** Allows users to disconnect existing integrations.\n*   **Confirmation Dialog:** Prompts users with a confirmation dialog before disconnecting an integration.\n*   **Loading State:** Displays a loading indicator while fetching integration data.\n*   **Empty State:** Shows a message when no integrations are connected.\n*   **Excludes Slack Integrations:** Filters out Slack integrations from the list.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/PersonsJoinMode.tsx",
        "summary": "This component allows users to configure how persons are joined to events in PostHog, providing a setting to choose between an inner join (the default) and a left join. It uses radio buttons to present the options and a save button to persist the selected join mode. The component also tracks usage of this feature.\n\nHere's a list of high-level product features:\n\n*   **Persons Join Mode Configuration:** Allows users to select the join mode between persons and events.\n*   **Inner Join Option:** Provides an option to use an inner join, which is the default and recommended setting.\n*   **Left Join Option:** Offers an experimental left join option for handling personless events.\n*   **Save Functionality:** Enables users to save their selected join mode.\n*   **Usage Tracking:** Tracks user interactions with the persons join mode setting.\n"
    },
    {
        "path": "frontend/src/scenes/settings/settingsSceneLogic.ts",
        "summary": "This code defines the logic for the settings scene in the PostHog frontend application. It manages the selection of settings levels (e.g., project, environment, user) and sections within those levels, as well as individual settings. The logic handles URL routing and updates the URL based on user interactions with the settings interface. It also provides breadcrumbs for navigation and copies the URL of a specific setting to the clipboard. The logic also handles redirects between project and environment settings based on feature flags.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Settings Navigation:** Allows users to navigate through different levels (project, environment, user) and sections within the settings.\n*   **URL-based Settings Access:** Enables direct access to specific settings via URLs.\n*   **Breadcrumb Navigation:** Provides breadcrumbs to help users understand their location within the settings hierarchy.\n*   **Shareable Settings URLs:** Allows users to copy the URL of a specific setting to share it with others.\n*   **Dynamic Settings Redirection:** Redirects users between project and environment settings based on feature flag status.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/GroupAnalyticsConfig.tsx",
        "summary": "This React component, `GroupAnalyticsConfig`, allows users to configure how group types are displayed within the PostHog application. It fetches existing group types and presents them in a table where users can edit the singular and plural names for each group type. The component includes input fields for editing these names, save and cancel buttons to persist or discard changes, and a banner to guide users on getting started with group analytics if no group types are available yet. The component also checks for user access to group analytics and hides the settings if access is not granted.\n\nHere's a list of high-level product features:\n\n*   **Display of Group Types:** Shows a list of existing group types in a table.\n*   **Customizable Singular Names:** Allows users to edit the singular name for each group type.\n*   **Customizable Plural Names:** Allows users to edit the plural name for each group type.\n*   **Save Changes:** Persists the changes made to the singular and plural names.\n*   **Cancel Changes:** Discards any unsaved changes, reverting to the original names.\n*   **Access Control:** Hides the settings if the user doesn't have access to group analytics.\n*   **User Guidance:** Provides a banner with a link to documentation for users getting started with group analytics.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/PathCleaningFiltersConfig.tsx",
        "summary": "This code defines the `PathCleaningFiltersConfig` component, which allows users to configure and test path cleaning rules for their PostHog team. These rules use regular expressions to replace parts of URLs or event names with aliases, making paths clearer and easier to analyze in the Paths insight. The component provides a UI for managing the path cleaning filters, including adding, editing, deleting, and reordering them. It also includes a test input where users can enter a path and see how it will be cleaned based on the configured filters. Access to this feature is gated behind a premium feature flag.\n\nHere's a list of high-level product features:\n\n*   **Path Cleaning Rule Management:** Allows users to define and manage rules for cleaning paths by aliasing URLs using regular expressions.\n*   **Rule Ordering:** Enables users to reorder path cleaning rules, as the order of application matters.\n*   **Path Cleaning Preview:** Provides a real-time preview of how a given path will be cleaned based on the configured rules.\n*   **Premium Feature Gating:** Restricts access to advanced path cleaning features based on the user's subscription or feature flags.\n*   **Documentation Links:** Provides links to the PostHog documentation for path cleaning rules.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/DataAttributes.tsx",
        "summary": "This component provides a user interface for specifying and saving a list of data attributes used in their application. These attributes are used to create more robust and readable selectors when defining actions in the toolbar, allowing users to target specific elements on their pages using data attributes instead of complex CSS selectors. The component includes a multi-select input field where users can enter data attributes (including wildcards), and a save button to persist the changes to the team settings.\n\n**Features:**\n\n*   **Data Attribute Input:** Allows users to input a list of data attributes used in their application.\n*   **Wildcard Support:** Supports the use of wildcards (`*`) in data attributes for more flexible matching.\n*   **Multi-Select Input:** Uses a multi-select input field, allowing users to enter multiple data attributes.\n*   **Custom Value Input:** Allows users to enter custom data attribute values that are not pre-defined.\n*   **Data Persistence:** Saves the list of data attributes to the team settings.\n*   **Loading State:** Displays a loading state while fetching or saving team data.\n*   **Help Text:** Provides helpful information and a link to external documentation about data attributes.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/CookielessServerHashMode.tsx",
        "summary": "This component provides a user interface for configuring the cookieless server-side hash mode for a PostHog team. It allows users to select between \"Stateful\", \"Stateless\", and \"Disabled\" modes via a radio button group. The selected mode is then saved to the team's settings using the `updateCurrentTeam` action. A save button is provided to persist the changes, and it's disabled if no changes have been made.\n\nHere's a list of high-level product features:\n\n*   **Cookieless Server-Side Hashing Configuration:** Allows users to choose between different modes for cookieless server-side hashing (\"Stateful\", \"Stateless\", \"Disabled\").\n*   **Team-Specific Settings:** The cookieless hashing mode is configured on a per-team basis.\n*   **Persistence:** The selected hashing mode is saved and persisted.\n*   **Change Detection:** The save button is disabled when no changes have been made to the setting.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/HeatmapsSettings.tsx",
        "summary": "The `HeatmapsSettings` component provides a user interface for enabling or disabling heatmap capture for a PostHog project. It leverages LemonSwitch for a toggle control, allowing users to opt-in or opt-out of heatmap data collection. The component updates the team settings via `teamLogic` and reports usage events via `eventUsageLogic`. It also displays a description of heatmaps and their purpose.\n\n**Features:**\n\n*   **Enable/Disable Heatmaps:** Allows users to toggle heatmap data collection for their web application.\n*   **Team Settings Integration:** Persists the heatmap opt-in preference to the team settings.\n*   **Usage Reporting:** Tracks user interactions with the heatmap toggle for analytics purposes.\n*   **Informative Description:** Provides context and explains the purpose of heatmaps to the user.\n*   **Loading State:** Disables the toggle during user loading to prevent unintended actions.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/AddMembersModal.tsx",
        "summary": "This code defines a React component, `AddMembersModalWithButton`, which renders a button that, when clicked, opens a modal for adding members to a project (team). The modal includes a form where users can select organization members to add and assign them a project-specific access level. The component integrates with PostHog's feature flagging system to control access to advanced permissions and uses Kea logic for state management and form handling.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Add Members to Project:** Allows users to add existing organization members to a specific project.\n*   **Project-Specific Access Levels:** Enables assigning different access levels to members within a project.\n*   **User Selection:** Provides a user-friendly interface for selecting organization members to add to the project.\n*   **Advanced Permissions Feature Flag:** Integrates with a feature flagging system to control access to advanced permission features.\n*   **Modal Interface:** Presents the add members functionality within a modal for a clean user experience.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/SessionRecordingIngestionSettings.tsx",
        "summary": "This code defines the `SessionRecordingIngestionSettings` component, which allows users to control session recording ingestion settings within PostHog. It provides options to manage the volume and targeting of session recordings. The component includes features such as sampling rate adjustment, minimum session duration configuration, and the ability to link recording to a specific feature flag and its variants. These settings help users optimize their recording usage and focus on relevant user sessions.\n\nHere's a list of high-level product features:\n\n*   **Sampling Rate Adjustment:** Controls the percentage of sessions that are recorded.\n*   **Minimum Session Duration:** Sets a minimum duration for sessions to be recorded, filtering out short, potentially uninteresting sessions.\n*   **Feature Flag Linking:** Enables recording only for users who have a specific feature flag enabled, allowing targeted recording based on feature usage.\n*   **Variant Targeting:** Allows linking recordings to specific variants of a multivariate feature flag.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/WeekStartConfig.tsx",
        "summary": "This code defines a React component, `WeekStartConfig`, that allows users to configure the first day of the week for their team. It uses a LemonSelect component to present a dropdown with \"Sunday\" and \"Monday\" options. When the user selects a different day, a confirmation dialog appears, warning about the recalculation of week-based queries. Upon confirmation, the `updateCurrentTeam` action is dispatched to persist the change. The component also handles loading states to prevent interaction during data retrieval.\n\nHere's a list of high-level product features:\n\n*   **Week Start Day Configuration:** Allows users to define the first day of the week (Sunday or Monday) for their team.\n*   **Dropdown Selection:** Uses a dropdown menu to present the available week start day options.\n*   **Confirmation Dialog:** Displays a confirmation dialog before applying the change, warning about potential data recalculations.\n*   **Data Persistence:** Saves the selected week start day to the team's settings.\n*   **Loading State Handling:** Disables interaction while the team data is loading.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/sessionReplayLinkedFlagLogic.ts",
        "summary": "This code defines a Kea logic module named `sessionReplayLinkedFlagLogic` that manages the selection and retrieval of a feature flag linked to session replay settings. It fetches a feature flag based on a provided ID, allows the user to select a different feature flag, and determines if the linked flag has variants. The logic connects to the `teamLogic` to access the current team and ensures that the displayed linked flag is up-to-date.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Link Feature Flags to Session Replay:** Allows users to associate a specific feature flag with session replay functionality.\n*   **Select Existing Feature Flag:** Enables users to choose a feature flag from a list of existing flags to link to session replay.\n*   **Load Existing Linked Flag:** Fetches and displays the currently linked feature flag from the API.\n*   **Variant Awareness:** Determines if the linked feature flag has variants, potentially influencing how session replay behaves based on flag variations.\n*   **Real-time Updates:** Ensures the displayed linked flag is current, even when the user changes the selection or the team context changes.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/webhookIntegrationLogic.ts",
        "summary": "This code defines a Kea logic module, `webhookIntegrationLogic`, responsible for handling webhook integrations, specifically for Slack and Discord. It provides functionality to test a webhook URL, remove a configured webhook, and update the current team's settings with the validated webhook. The logic includes loaders for asynchronous operations like testing and removing webhooks, selectors to determine loading states, and listeners to react to successful or failed webhook tests, displaying appropriate notifications. It also adjusts Discord webhook URLs to ensure they are compatible with the system.\n\n**Features:**\n\n*   **Webhook Testing:** Allows users to test a provided webhook URL to ensure it's valid and functional.\n*   **Discord Webhook Adjustment:** Automatically modifies Discord webhook URLs to ensure compatibility.\n*   **Webhook Removal:** Enables users to remove a previously configured webhook.\n*   **Team Settings Update:** Updates the current team's settings with the validated webhook URL.\n*   **Loading State Management:** Provides selectors to track the loading state of webhook operations.\n*   **Success/Failure Notifications:** Displays user-friendly notifications upon successful or failed webhook tests.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/TestAccountFiltersConfig.tsx",
        "summary": "This code defines the UI component `ProjectAccountFiltersSetting` which allows users to configure filters to exclude internal and test users from their PostHog data. It provides a property filter interface to define the filters, displays warnings for potentially problematic filter configurations (inclusive filters, frequent mistakes), and allows enabling these filters by default for all new insights. The component uses Lemon UI components for display and interactivity, and leverages Kea logic for state management and actions.\n\nHere's a list of high-level product features:\n\n*   **Test Account Filtering:** Allows users to define filters to exclude internal and test users from analytics data.\n*   **Property Filter Interface:** Provides a UI for defining filters based on event, person, and group properties, cohorts, and feature flags.\n*   **Filter Configuration Warnings:** Displays warnings for potentially problematic filter configurations, such as inclusive filters and frequent mistakes.\n*   **Default Filter Setting:** Allows users to enable the defined filters by default for all new insights.\n*   **Cohort Integration:** Recommends and supports using cohorts for defining user groups to exclude.\n*   **Documentation Link:** Provides a link to the PostHog documentation for more information on filtering internal users.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/PersonsOnEvents.tsx",
        "summary": "The `PersonsOnEvents.tsx` component allows users to configure how person properties are handled when filtering events. It presents three options, each with different performance characteristics and implications for data accuracy when person properties are updated. The component uses LemonRadio buttons to allow the user to select their preferred mode, and a save button to persist the changes. The selected mode determines whether queries use person properties from the time of the event or as of the time the query is run, or whether to disable the feature entirely.\n\nHere's a list of high-level product features:\n\n*   **Configuration of Person Property Handling:** Allows users to choose how person properties are used when filtering events.\n*   **Three Modes of Operation:** Offers three distinct modes: \"Use person properties from the time of the event,\" \"Use person properties as of running the query,\" and \"Use person IDs and person properties from the time of the event.\"\n*   **Performance Considerations:** Provides information about the performance implications of each mode, allowing users to make informed decisions.\n*   **Data Accuracy Considerations:** Explains how each mode affects data accuracy when person properties are updated.\n*   **Persistence of Settings:** Saves the user's selected mode for future use.\n*   **Usage Tracking:** Tracks user changes to the \"personsOnEventsMode\" setting.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/DataColorThemes.tsx",
        "summary": "The `DataColorThemes` component in PostHog's settings allows users to manage and customize data color themes for insights. It displays a table of available themes (name and whether they are official), provides a button to add new themes, and allows users to set a default theme for all insights. The component utilizes Lemon UI components for the table, buttons, and select dropdown, and integrates with the `dataColorThemesLogic` and `teamLogic` for data fetching and updates. A modal is used for creating and editing themes. The component is gated behind a feature flag.\n\nHere's a list of high-level product features:\n\n*   **View Available Data Color Themes:** Displays a list of existing data color themes with their names and whether they are official.\n*   **Add New Data Color Themes:** Allows users to create custom data color themes.\n*   **Edit Existing Data Color Themes:** Enables users to modify existing data color themes.\n*   **Set Default Data Color Theme:** Allows users to select a default theme that will be applied to all insights.\n*   **Documentation Link:** Provides a link to the PostHog documentation for more information on data color themes.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/filterTestAccountDefaultsLogic.ts",
        "summary": "This code defines a Kea logic module named `filterTestAccountsDefaultsLogic` that manages the default state of the \"filter test accounts\" setting. It handles setting and retrieving the default value at both the team and local levels, prioritizing the local setting if it exists. The logic connects to the `teamLogic` to access the current team's settings. It uses local storage to persist the user's preference.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Team-level Default Setting:** Allows setting a default \"filter test accounts\" preference for the entire team.\n*   **User-level Override:** Enables individual users to override the team-level default with their own preference.\n*   **Persistence:** Saves the user's preference in local storage so it persists across sessions.\n*   **Initial Load from Local Storage:** Loads the user's preference from local storage on component mount.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/SessionRecordingSettings.tsx",
        "summary": "This code defines the `SessionRecordingSettings` component, which allows users to configure various aspects of session recording within PostHog. It includes settings for capturing console logs, canvas elements, and network performance data (including headers and payloads). The component uses Lemon UI components for switches, selects, and banners, and provides information about supported platforms for each feature. It also includes warnings about capturing sensitive data in network payloads and links to relevant documentation.\n\nHere's a list of high-level product features configurable via this component:\n\n*   **Console Log Capture:** Enable/disable the capture of browser console logs during session recordings.\n*   **Canvas Capture:** Enable/disable the capture of canvas elements during session recordings.\n*   **Network Performance Capture:** Enable/disable the capture of network performance data during session recordings.\n*   **Network Header Capture:** Enable/disable the capture of network request and response headers.\n*   **Network Body Capture:** Enable/disable the capture of network request and response bodies.\n*   **Platform Support Information:** Display which platforms (Web, Android, iOS, React Native, Flutter) support each feature and since which version.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/TimezoneConfig.tsx",
        "summary": "This React component, `TimezoneConfig`, provides a user interface for selecting and updating the timezone setting for a team within a PostHog instance. It fetches available timezones and the current team's timezone using `kea` logic hooks. A `LemonInputSelect` component is used to display the timezones in a user-friendly format, including the UTC offset. When the user selects a new timezone, the component checks if the UTC offset differs from the current timezone. If it does, a confirmation dialog is displayed to inform the user about the potential impact on queries and data analysis due to the change in time ranges.\n\nHere's a list of high-level product features:\n\n*   **Timezone Selection:** Allows users to select a timezone for their team from a list of available timezones.\n*   **UTC Offset Display:** Shows the UTC offset for each timezone, providing clarity on the time difference.\n*   **Confirmation Dialog:** Displays a warning message when the user selects a timezone with a different UTC offset, highlighting the potential impact on data analysis.\n*   **Loading State:** Indicates when the timezone data or team data is being loaded.\n*   **Data Persistence:** Updates the team's timezone setting in the backend when a new timezone is selected.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/ReplayTriggers.tsx",
        "summary": "The `ReplayTriggers.tsx` component allows users to configure triggers for starting and pausing session recordings based on URL patterns and specific events. It provides options to define URL triggers (start recording when a URL matches a regex), URL blocklists (pause recording when a URL matches a regex), and event triggers (start recording when a specific event is emitted). The component includes UI elements for adding, editing, and removing URL patterns, as well as selecting events from a list. It also integrates with an AI Regex Helper to assist users in creating URL regex patterns.\n\nHere's a list of high-level product features:\n\n*   **URL Triggers:** Start session recordings when a user visits a URL matching a defined regex pattern.\n*   **URL Blocklists:** Pause session recordings when a user visits a URL matching a defined regex pattern.\n*   **Event Triggers:** Start session recordings when a specific event is emitted.\n*   **Regex Input with AI Assistance:** Provides a user-friendly input field for URL regex patterns, enhanced with an AI Regex Helper for generating and validating regex expressions.\n*   **Configuration UI:** Allows users to add, edit, and remove URL triggers and blocklists through a visual interface.\n*   **Event Selection:** Enables users to select specific events to trigger session recordings.\n*   **Platform Support Information:** Displays the minimum version required for the URL trigger feature.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/TeamAccessControl.tsx",
        "summary": "The `TeamAccessControl.tsx` file defines the UI for managing team access control within a PostHog project. It allows administrators to control whether a project is open to all organization members or restricted to a specific list of members. The component also handles displaying and modifying the list of team members, their access levels, and provides actions to add or remove members. It leverages Lemon UI components for a consistent user experience and integrates with Kea logic for state management and data fetching. The component also handles upgrading to a new role based access control system.\n\nHere's a list of high-level product features implemented in the code:\n\n*   **Project Privacy Control:** Allows administrators to make a project private, restricting access to only explicitly added members.\n*   **Team Member List:** Displays a list of team members with their names, emails, access levels, and join dates.\n*   **Access Level Management:** Enables administrators to modify the access level of individual team members.\n*   **Team Member Removal:** Provides functionality for administrators to remove members from a project.\n*   **Self-Service Project Leaving:** Allows users to remove themselves from a project.\n*   **Add Members Functionality:** Provides a modal to add new members to the project.\n*   **Role Based Access Control Upgrade:** Provides a banner to upgrade to a new role based access control system.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/TeamSettings.tsx",
        "summary": "The `TeamSettings.tsx` file defines the UI components for configuring team-specific settings within PostHog. It includes components for renaming a project/environment, displaying and configuring the web snippet for event tracking, providing a bookmarklet for testing PostHog on live sites, displaying team variables like API key and ID, configuring timezone and week start settings, and managing authorized URLs for web analytics and experiments. The component leverages Lemon UI components and Kea logic for state management and actions. Feature flags are used to conditionally render certain features, such as the environment-specific naming and the V2 web snippet.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Project/Environment Renaming:** Allows users to change the name of their PostHog project or environment.\n*   **Web Snippet Integration:** Provides a code snippet for integrating PostHog's JavaScript library into websites for event tracking and session recording. Includes both a standard and an experimental V2 version.\n*   **Bookmarklet for Testing:** Offers a bookmarklet that enables PostHog tracking on a live website without code changes.\n*   **API Key and Project ID Display:** Shows the project's API key and ID for use in PostHog's libraries and API.\n*   **Region Display:** Shows the region where the PostHog instance is hosted.\n*   **Debug Information:** Displays a snippet with debug information to include when reporting issues.\n*   **Timezone and Week Start Configuration:** Allows users to set the timezone and week start day for their project, affecting how time-series data is displayed and filtered.\n*   **Authorized URLs Management:** Enables users to specify the URLs where web analytics and experiment data should be collected and where the PostHog toolbar can be launched.\n"
    },
    {
        "path": "frontend/src/scenes/settings/types.ts",
        "summary": "This code defines the types and data structures used to represent settings within the PostHog application. It outlines the different levels at which settings can be configured (environment, project, organization, user), the various sections within each level, and the individual settings themselves. The code also includes mechanisms for controlling the visibility of settings based on feature flags, realm, and team access levels.\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **Configurable Settings:** Allows users to configure various aspects of the PostHog application at different levels (environment, project, organization, user).\n*   **Sectioned Settings:** Organizes settings into logical sections for easier navigation and management.\n*   **Feature Flag Gating:** Controls the visibility of settings based on feature flags, enabling A/B testing and gradual feature rollouts.\n*   **Realm-Based Visibility:** Hides settings based on the realm (e.g., cloud vs. self-hosted).\n*   **Team-Based Access Control:** Restricts access to settings based on team membership and permissions.\n*   **Environment Settings:** Configuration options specific to an environment, such as autocapture, product analytics, web analytics, replay, surveys, feature flags, error tracking, integrations, and access control.\n*   **Project Settings:** Configuration options specific to a project, such as autocapture, product analytics, replay, surveys, toolbar, integrations, and access control.\n*   **Organization Settings:** Configuration options specific to an organization, such as details, members, billing, authentication, roles, and proxy settings.\n*   **User Settings:** Configuration options specific to a user, such as profile, API keys, and customization options.\n*   **Integration Settings:** Configuration options for various integrations, such as webhooks and Slack.\n*   **Replay Settings:** Configuration options for session replay, including triggers, masking, and authorized domains.\n*   **Error Tracking Settings:** Configuration options for error tracking, including exception autocapture and alerting.\n*   **Data Capture Settings:** Configuration options for data capture, including autocapture and data attributes.\n*   **Access Control Settings:** Configuration options for managing access control, including role-based access control.\n*   **AI Consent Settings:** Configuration options for managing AI consent at the organization level.\n*   **Danger Zone Settings:** Configuration options for potentially destructive actions, such as deleting environments, projects, or organizations.\n*   **Customization Settings:** Configuration options for customizing the user interface, such as data theme and display name.\n*   **Authentication Settings:** Configuration options for authentication, such as authentication domains and two-factor authentication.\n*   **API Key Management:** Allows users to manage their personal API keys.\n*   **Notification Settings:** Allows users to configure their notification preferences.\n*   **Theme Settings:** Allows users to customize the application's theme."
    },
    {
        "path": "frontend/src/scenes/settings/environment/userGroupsLogic.tsx",
        "summary": "This code defines the logic for managing user groups within a settings environment. It handles fetching, creating, deleting, and updating user groups, as well as adding and removing members. The logic includes a search functionality to filter user groups based on their name, and a form for creating new user groups. It uses the Kea framework for state management and API calls to interact with the backend.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **User Group Management:** Allows users to view, create, edit, and delete user groups.\n*   **User Group Listing:** Displays a list of available user groups.\n*   **User Group Search:** Enables users to search for specific user groups by name.\n*   **User Group Creation:** Provides a form to create new user groups.\n*   **Membership Management:** Allows adding and removing users from user groups.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/TeamDangerZone.tsx",
        "summary": "The `TeamDangerZone` component provides a user interface for deleting a PostHog environment (team). It includes a confirmation modal that requires the user to type the environment's name to confirm the deletion. The component checks for admin privileges and a feature flag to enable the environment deletion functionality. Currently, the actual deletion functionality is disabled due to database constraints, and a message indicates that environment deletion is coming soon.\n\n**Features:**\n\n*   **Environment Deletion:** Allows users to delete a specific environment within PostHog.\n*   **Confirmation Modal:** Requires users to confirm the deletion by typing the environment's name.\n*   **Admin Restriction:** Restricts deletion functionality to users with admin privileges.\n*   **Feature Flag Control:** Enables or disables the environment deletion feature based on a feature flag.\n*   **Deletion Prevention:** Temporarily disables the actual deletion process due to database constraints, displaying a message indicating future availability.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/SurveySettings.tsx",
        "summary": "The `SurveySettings` component, located within the environment settings of the PostHog application, serves as an entry point for users to manage and understand surveys. It provides a brief description of the survey feature and directs users to the dedicated surveys page using a link. The component also embeds the `BasicSurveySettings` component, suggesting that more detailed survey configurations are handled there.\n\nHere's a list of high-level product features related to this component:\n\n*   **Survey Management:** Allows users to create, manage, and analyze surveys to gather user feedback.\n*   **Survey Access:** Provides a direct link to the surveys page for easy navigation.\n*   **Survey Configuration:** Enables users to configure survey settings (likely handled by the embedded `BasicSurveySettings` component).\n*   **User Feedback Collection:** Facilitates the collection of qualitative and quantitative data from users.\n*   **Integration with Environment Settings:** Integrates survey settings within the broader environment settings of the application.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/CorrelationConfig.tsx",
        "summary": "The `CorrelationConfig` component in the settings allows users to globally exclude events and properties from funnel correlation analysis. This helps to refine the analysis by removing irrelevant signals and improving the understanding of user conversions and drop-offs. It provides interfaces to select and exclude person properties, events, and event properties.\n\nHere's a list of high-level product features:\n\n*   **Exclude Person Properties:** Allows users to specify person properties to exclude from funnel correlation analysis.\n*   **Exclude Events:** Enables users to define events to be excluded from funnel correlation analysis.\n*   **Exclude Event Properties:** Provides a way for users to specify event properties to exclude from funnel correlation analysis.\n*   **Real-time Updates:** Changes to the exclusion lists are applied immediately, updating the team's correlation configuration.\n*   **Informative Banner:** Displays a banner explaining the purpose and benefits of correlation analysis.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/IPAllowListInfo.tsx",
        "summary": "This component displays information about IP address allowlisting for PostHog. It fetches a list of public egress IP addresses from the preflight check and presents them to the user in a code snippet. The component also provides a brief explanation of why allowlisting these IPs might be necessary, specifically for integrations like webhooks, apps, and batch exports. If the preflight check doesn't return any IP addresses, it displays a \"Not supported\" message.\n\nHere's a list of high-level product features:\n\n*   **IP Address Allowlisting Information:** Displays information about the importance of allowlisting PostHog's IP addresses.\n*   **Dynamic IP Address Display:** Fetches and displays the current list of PostHog's public egress IP addresses.\n*   **Code Snippet Formatting:** Presents the IP addresses in a code snippet for easy copying and pasting.\n*   **Integration Context:** Explains that allowlisting is relevant for integrations like webhooks, apps, and batch exports.\n*   **Support Check:** Indicates when IP allowlisting is not supported.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/groupAnalyticsConfigLogic.ts",
        "summary": "This code defines a Kea logic module named `groupAnalyticsConfigLogic` that manages the configuration of group analytics settings, specifically the singular and plural names for group types. It allows users to modify these names, track changes, and save the updated configurations. The logic connects to the `groupsModel` to access and update group type metadata.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Display Group Type Names:** Fetches and displays existing singular and plural names for each group type.\n*   **Edit Singular Group Type Names:** Allows users to modify the singular name of a group type.\n*   **Edit Plural Group Type Names:** Allows users to modify the plural name of a group type.\n*   **Track Changes:** Tracks modifications made to the singular and plural names.\n*   **Save Group Type Configuration:** Saves the updated singular and plural names for group types.\n*   **Reset Changes:** Discards any unsaved changes to the group type names.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/SessionsV2JoinModeSettings.tsx",
        "summary": "This component allows users to configure the join mode for SessionsV2, which affects how session data is joined and queried. It presents a radio button group with options for \"String\" and \"UUID\" join modes. The selected mode can be saved, updating the current team's settings. A warning message advises users to only modify this setting if they understand the implications.\n\nHere's a list of high-level product features:\n\n*   **Session Join Mode Configuration:** Allows administrators to select the join mode (String or UUID) for SessionsV2.\n*   **Team-Specific Settings:** The selected join mode is saved as part of the team's configuration.\n*   **Persistence:** The selected join mode is persisted and reloaded when the settings page is accessed.\n*   **Warning Message:** Displays a warning message to prevent accidental modification by uninformed users.\n*   **Save Functionality:** Provides a button to save the selected join mode.\n*   **Disable Save Button:** Disables the save button when no changes have been made.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/DeadClicksAutocaptureSettings.tsx",
        "summary": "This React component, `DeadClicksAutocaptureSettings`, provides a user interface for enabling or disabling the automatic capture of \"dead clicks\" within a PostHog project. It explains what dead clicks are (clicks that don't result in any action) and how tracking them can help identify user frustration points. The component uses a LemonSwitch to toggle the `capture_dead_clicks` setting for the current team, updating the team's configuration via the `teamLogic` and tracking the toggle event with `posthog-js`.\n\nHere's a list of high-level product features:\n\n*   **Dead Click Autocapture:** Automatically captures and tracks instances of dead clicks on a website.\n*   **Enable/Disable Toggle:** Provides a user-friendly switch to enable or disable the dead click autocapture feature.\n*   **Team-Level Configuration:** The setting is configured at the team level, allowing different projects within PostHog to have different settings.\n*   **Event Tracking:** Tracks when the dead click autocapture setting is toggled for analytics purposes.\n*   **User Feedback:** Provides explanatory text to inform users about what dead clicks are and the benefits of tracking them.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/maxSettingsLogic.tsx",
        "summary": "This code defines the `maxSettingsLogic` Kea logic hook, responsible for managing the \"Max's Memory\" feature within the settings. It handles loading, creating, and updating a core memory object via API calls. The logic includes state management for loading and updating states, a form for editing the core memory text, and success/failure handling with toast notifications. It fetches the core memory on mount and populates the form with the existing data.\n\nHere's a list of high-level product features:\n\n*   **Core Memory Management:** Allows users to create and update a text-based \"memory\" for Max.\n*   **Data Persistence:** Saves the core memory to the backend via API calls.\n*   **Form-based Editing:** Provides a form to edit the core memory text.\n*   **Loading State Management:** Indicates when the core memory is being loaded or updated.\n*   **Success/Error Notifications:** Displays toast notifications to inform users about the success or failure of create/update operations.\n*   **Initial Data Loading:** Automatically loads the core memory when the settings page is mounted.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/PersonDisplayNameProperties.tsx",
        "summary": "This component allows users to configure which person properties are used to generate a display name for identified persons within PostHog. It provides a UI to select, reorder, and save a list of properties. The component fetches the current team's configuration and updates it with the user's changes. It also displays a loading skeleton while the team data is being fetched.\n\nHere's a list of high-level features:\n\n*   **Property Selection:** Allows users to select person properties from a list.\n*   **Property Reordering:** Enables users to prioritize properties by dragging and dropping them.\n*   **Saving Configuration:** Provides a button to save the selected and ordered properties to the team's settings.\n*   **Display Name Generation:** Configures the system to use the selected properties to generate display names for identified persons.\n*   **Loading State:** Displays a loading indicator while fetching team data.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/proxyLogic.ts",
        "summary": "This code defines the `proxyLogic` Kea logic for managing proxy records within an organization. It handles loading, creating, and deleting proxy records via API calls, and manages the state of a form for creating new records. The logic also includes validation for the domain name entered in the form and automatically refreshes the proxy records list to reflect status changes.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Proxy Record Management:** Allows users to view a list of proxy records associated with their organization.\n*   **Proxy Record Creation:** Enables users to create new proxy records by specifying a domain.\n*   **Proxy Record Deletion:** Allows users to delete existing proxy records.\n*   **Domain Validation:** Validates the domain name entered during proxy record creation to ensure it is a valid and properly formatted domain.\n*   **Automatic Status Refresh:** Automatically refreshes the list of proxy records to reflect the current status of each record (e.g., waiting, issuing, valid, erroring, deleting).\n*   **User Feedback:** Provides user feedback via toast notifications upon successful record creation.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/dataColorThemesLogic.ts",
        "summary": "This code defines the logic for managing data color themes within the PostHog application settings. It connects to the `dataThemeLogic` to access existing themes and the `dataColorThemesModalLogic` to open a modal for creating or editing themes. The logic allows users to select a theme, open a modal to create a new theme based on the PostHog default, or open a modal to edit an existing theme. Upon successful submission of a new or edited theme, the logic updates the list of available themes.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Theme Selection:** Allows users to select a data color theme from a list of available themes.\n*   **Theme Creation:** Enables users to create new data color themes based on the default PostHog theme.\n*   **Theme Editing:** Provides the ability to modify existing data color themes.\n*   **Theme Persistence:** Saves newly created and edited themes, making them available for future use.\n*   **Modal Interface:** Uses a modal to provide a user-friendly interface for creating and editing themes.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/UserGroups.tsx",
        "summary": "This code defines the `UserGroups` component, which displays a table of user groups with their members and provides functionality to manage these groups. Users can view the groups, see the members of each group, add new members, remove existing members, delete entire groups, and create new groups. The component uses Lemon UI components for the table, buttons, and menus, and leverages kea-logic for state management and actions.\n\nHere's a list of high-level product features implemented in this code:\n\n*   **User Group Listing:** Displays a list of user groups in a table format.\n*   **Member Display:** Shows the members of each user group, with profile pictures and names.\n*   **Group Creation:** Allows users to create new user groups.\n*   **Member Addition:** Enables adding existing users to a group via a member selection component.\n*   **Member Removal:** Allows removing members from a user group.\n*   **Group Deletion:** Enables deleting existing user groups.\n*   **Expandable Rows:** Allows expanding rows to show members in a nested table.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/teamMembersLogic.tsx",
        "summary": "This code defines the `teamMembersLogic` Kea logic hook, responsible for managing team members within a specific project environment. It handles loading, adding, and removing members, as well as managing their access levels. The logic combines explicit project members with organization-level members who have implicit access based on their organization role. It also manages a modal for adding new members and provides selectors for filtering members based on their roles and permissions.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Team Member Management:** Allows administrators to view and manage team members within a specific project environment.\n*   **Role-Based Access Control:** Enables assigning different access levels (e.g., admin, member) to team members within a project.\n*   **Member Invitation/Addition:** Provides a modal interface for adding new members to a project.\n*   **Member Removal:** Allows administrators to remove members from a project.\n*   **Access Level Modification:** Enables administrators to change the access level of existing team members.\n*   **Combined Explicit and Implicit Membership:** Combines explicitly added project members with organization members who have implicit access based on their organization role.\n*   **Real-time Updates:** Updates the member list and access levels in real-time after changes are made.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/dataColorThemeModalLogic.ts",
        "summary": "This code defines a Kea logic module named `dataColorThemesModalLogic` that manages the state and actions for a modal related to data color themes. It handles opening and closing the modal, managing the theme data (name and colors), and submitting the theme data to the backend API for creation or update. The logic also includes form validation and error handling, displaying success or error messages using `lemonToast`.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Modal Management:** Opens and closes a modal for creating or editing data color themes.\n*   **Theme Editing:** Allows users to edit the name and colors of a data color theme.\n*   **Color Management:**\n    *   Adds new colors to the theme.\n    *   Duplicates existing colors.\n    *   Removes colors from the theme.\n*   **Form Validation:** Validates the theme name to ensure it's not empty.\n*   **API Integration:**\n    *   Creates new data color themes via the API.\n    *   Updates existing data color themes via the API.\n*   **User Feedback:** Provides success and error messages to the user via `lemonToast`.\n*   **Theme Reset:** Resets the theme data when the modal is opened.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/replayTriggersLogic.ts",
        "summary": "This code defines the `replayTriggersLogic` Kea logic, which manages the configuration of URL triggers and blocklists for session replays, as well as event triggers. It allows users to define URLs that, when visited, trigger session recording, and URLs that should be blocked from being recorded. The logic includes actions to add, remove, update, and edit these URL triggers and blocklists, as well as reducers to manage the state of the configuration. It also connects to the `teamLogic` to fetch and update the team's configuration. The logic also handles event triggers for session replays.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **URL-based Session Recording Triggers:** Define URLs that automatically trigger session recording when visited.\n*   **URL-based Session Recording Blocklists:** Define URLs that should be excluded from session recordings.\n*   **Event-based Session Recording Triggers:** Define events that trigger session recording.\n*   **Configuration UI:** Provides the logic for a UI to manage URL triggers and blocklists, including adding, editing, and removing entries.\n*   **Regular Expression Support:** Allows using regular expressions for URL matching in triggers and blocklists.\n*   **Real-time Configuration Updates:** Updates the team's configuration in real-time when changes are made to URL triggers and blocklists.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/HumanFriendlyComparisonPeriodsSetting.tsx",
        "summary": "This React component, `HumanFriendlyComparisonPeriodsSetting`, provides a toggle within the settings to control how PostHog compares data across different time periods (months or years). When enabled, the comparison shifts from using the exact same start and end dates to comparing the same day of the week, effectively comparing 4-week periods instead of calendar months and 52-week periods instead of calendar years. This is useful for accounting for weekend seasonality in data analysis.\n\nHere's a list of high-level product features:\n\n*   **Toggleable Setting:** Allows users to enable or disable \"human-friendly\" comparison periods.\n*   **Human-Friendly Comparison Periods:** When enabled, compares data based on the same day of the week instead of the same date, useful for accounting for seasonality.\n*   **Visual Indication:** Uses a LemonSwitch component to visually represent the setting's state (on/off).\n*   **Loading State:** Disables the toggle while the team settings are loading to prevent accidental changes.\n*   **Real-time Updates:** Updates the team settings immediately upon toggling the setting.\n*   **Informative Description:** Provides a clear explanation of the setting's purpose and effect.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/SlackIntegration.tsx",
        "summary": "This code implements the Slack integration settings within PostHog, allowing users to connect their PostHog instance to Slack workspaces. It displays existing Slack integrations, provides a button to connect to a new Slack workspace, and allows users to disconnect existing integrations. For self-hosted instances, it provides instructions and a Slack App Manifest for manual configuration if the instance is not pre-configured for Slack. The integration enables features like subscribing to Insights or Dashboards for regular reports in Slack channels.\n\nHere's a list of high-level product features:\n\n*   **Connect to Slack Workspace:** Allows users to authorize and connect their PostHog instance to a Slack workspace.\n*   **Disconnect Slack Workspace:** Enables users to remove an existing Slack integration.\n*   **Display Existing Slack Integrations:** Lists the currently connected Slack workspaces.\n*   **Slack App Manifest Generation:** Provides a pre-configured Slack App Manifest for self-hosted instances to simplify the Slack app creation process.\n*   **Manual Configuration Instructions:** Displays instructions for manually configuring the Slack integration for self-hosted instances, including setting the necessary environment variables.\n*   **Subscription to Insights/Dashboards:** Enables users to subscribe to receive regular reports of Insights or Dashboards in Slack channels (feature enabled by the integration).\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/MaxMemorySettings.tsx",
        "summary": "This React component, `MaxMemorySettings`, provides a user interface for configuring the \"memory\" of a feature named \"Max\" within a PostHog project. It allows users to input text describing what Max should know about their company or product. The component uses Lemon UI components for styling and interactivity, Kea for state management and form handling, and displays a loading state while fetching project or memory data. It includes a text area for input, a save button, and handles loading and updating states.\n\nHere's a list of high-level product features:\n\n*   **Max Memory Configuration:** Allows users to define and save information that \"Max\" should know about their project or company.\n*   **Text Input:** Provides a text area for users to input the memory content.\n*   **Character Limit:** Enforces a maximum character limit (10000) for the memory content.\n*   **Loading State:** Displays a loading indicator while fetching project or memory data.\n*   **Saving State:** Displays a loading indicator while saving the memory content.\n*   **Form Handling:** Uses Kea Forms for managing the form state and submission.\n*   **Project Context:** Dynamically adapts the placeholder text based on the current project's name.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/DataColorThemeModal.tsx",
        "summary": "This code defines a modal component, `DataColorThemeModal`, for creating and editing data color themes within a settings panel. The modal allows users to define a name for the theme and specify a set of colors. Users can add, duplicate, and remove colors from the theme, with restrictions on editing official themes. The modal utilizes Lemon UI components for styling and interactivity, and Kea logic for state management and form handling.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Create New Data Color Themes:** Allows users to define custom color palettes for data visualization.\n*   **Edit Existing Data Color Themes:** Enables modification of previously created custom themes.\n*   **Theme Naming:** Provides a field for users to assign a descriptive name to each theme.\n*   **Color Palette Management:** Supports adding, duplicating, and removing individual colors within a theme.\n*   **Color Definition:** Allows users to specify the exact color values for each color in the palette.\n*   **Official Theme Restrictions:** Prevents modification of pre-defined \"official\" color themes.\n*   **Form Validation and Submission:** Handles saving the theme data and provides visual feedback on unsaved changes.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/BounceRateDuration.tsx",
        "summary": "This React component, `BounceRateDurationSetting`, allows users to customize the bounce rate duration for their team within a PostHog environment. It provides an input field where users can specify the duration in seconds, with a defined minimum and maximum range. The component fetches the current team's bounce rate duration setting, displays it in the input, and allows users to modify it. It also includes a button to clear the input and revert to the default duration, as well as a save button to persist the changes. Input validation is performed to ensure the duration falls within the acceptable range, and the save button is disabled if there are no changes or if the input is invalid.\n\nHere's a list of high-level product features:\n\n*   **Customizable Bounce Rate Duration:** Allows users to define the duration (in seconds) a user can stay on a page before the session is considered a bounce.\n*   **Input Validation:** Enforces a minimum and maximum duration for the bounce rate.\n*   **Default Value:** Provides a default bounce rate duration if the user doesn't specify one.\n*   **Clear Input Functionality:** Allows users to easily revert to the default bounce rate duration.\n*   **Save Changes:** Persists the customized bounce rate duration for the team.\n*   **Disable Save Button:** Prevents saving when there are no changes or when the input is invalid.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/CustomChannelTypes.tsx",
        "summary": "This code defines a React component, `CustomChannelTypes`, that allows users to create and manage custom channel type rules within PostHog. These rules define how incoming events are categorized into different channel types based on properties like referring domain, UTM parameters, and URL. The component provides a user interface for defining rules with conditions based on these properties and logical operators, and allows users to save these rules to customize their event attribution. It leverages Lemon UI components for a consistent PostHog experience and utilizes drag-and-drop functionality for easy rule management.\n\nHere's a list of high-level product features:\n\n*   **Custom Channel Type Definition:** Allows users to define custom channel types beyond the default ones.\n*   **Rule-Based Channel Attribution:** Enables the creation of rules that determine channel type based on event properties.\n*   **Property-Based Conditions:** Supports conditions based on referring domain, UTM parameters (source, medium, campaign), URL, hostname, and pathname.\n*   **Logical Operators:** Allows combining multiple conditions using \"All\" (AND) or \"Any\" (OR) operators.\n*   **Drag-and-Drop Interface:** Provides a drag-and-drop interface for easy reordering and management of rules and conditions.\n*   **Session Attribution Explorer Integration:** Links to the session attribution explorer tool for debugging and testing custom channel type rules.\n*   **Persistence:** Saves custom channel type rules to the team settings.\n*   **Real-time Updates:** Updates the UI in real-time as rules are modified.\n*   **Input Validation:** Sanitizes and validates custom channel type rules before saving.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment/ManagedReverseProxy.tsx",
        "summary": "This code implements a \"Managed Reverse Proxy\" feature within PostHog, allowing users to configure custom domains to proxy events through PostHog. The component displays a table of existing proxy records, their status, and provides options to add new records or delete existing ones. The feature is gated behind a paywall, limiting the number of proxy records based on the user's subscription. The UI includes banners to display messages related to proxy records, a form for creating new records, and instructions for setting up CNAME records in the user's DNS provider.\n\nHere's a list of high-level product features:\n\n*   **Display of Proxy Records:** Shows a table of configured reverse proxy domains, including their status (live, timed out, etc.).\n*   **Reverse Proxy Creation:** Allows users to add new reverse proxy configurations by specifying a domain.\n*   **Reverse Proxy Deletion:** Enables users to delete existing reverse proxy configurations.\n*   **Status Monitoring:** Displays the status of each proxy record, indicating whether it's active, waiting for DNS configuration, or has encountered an error.\n*   **DNS Configuration Instructions:** Provides users with the necessary CNAME records to configure in their DNS provider for each proxy domain.\n*   **Paywall Integration:** Limits the number of proxy records a user can create based on their subscription level.\n*   **Admin Restriction:** Restricts access to the feature to organization administrators.\n*   **Informative Banners:** Displays warning banners with messages related to specific proxy records.\n"
    },
    {
        "path": "frontend/src/scenes/settings/environment",
        "summary": "The environment settings section provides a comprehensive suite of configuration options for tailoring PostHog to specific project needs and data governance policies. These settings span a wide range of functionalities, from controlling data capture and anonymization to customizing user interfaces and integrating with external services. The settings are designed to be team-specific, allowing for granular control over each project's behavior.\n\nHere's a list of high-level product features:\n\n*   **Data Capture Configuration:** Control what data is captured, including session recordings, console logs, network performance data, and dead clicks.\n*   **Data Anonymization and Privacy:** Configure IP address anonymization and manage data attributes for robust selector creation.\n*   **User Interface Customization:** Customize data color themes, group type names, and person display names.\n*   **Integration Management:** Configure webhooks, Slack integrations, and other external service connections.\n*   **Session Recording Control:** Define triggers and blocklists for session recordings based on URLs and events, and manage session replay ingestion settings.\n*   **Data Filtering and Exclusion:** Define filters to exclude internal and test users, and exclude specific events and properties from correlation analysis.\n*   **Timezone and Week Start Configuration:** Set the timezone and week start day for accurate time-series data analysis.\n*   **Team and User Management:** Manage team members, their access levels, and user groups.\n*   **Feature Flag Integration:** Link feature flags to session replay and other functionalities for targeted recording and control.\n*   **Bounce Rate Configuration:** Customize how pageviews are counted and the duration for bounce rate calculations.\n*   **Session Table Version Selection:** Choose between different versions of the session table.\n*   **Managed Reverse Proxy:** Configure custom domains to proxy events through PostHog.\n*   **Custom Channel Types:** Define custom channel type rules for event attribution.\n*   **Persons Join Mode Configuration:** Select the join mode between persons and events.\n*   **Cookieless Server-Side Hashing Configuration:** Choose between different modes for cookieless server-side hashing.\n*   **Test Account Filtering:** Allows users to define filters to exclude internal and test users from analytics data.\n*   **Data Color Themes:** Allows users to manage and customize data color themes for insights.\n*   **Human-Friendly Comparison Periods:** Allows users to enable or disable \"human-friendly\" comparison periods.\n*   **Environment Deletion:** Allows users to delete a specific environment within PostHog.\n*   **Max's Memory:** Allows users to create and update a text-based \"memory\" for Max.\n*   **IP Allowlisting Information:** Displays information about the importance of allowlisting PostHog's IP addresses.\n*   **SessionsV2 Join Mode Configuration:** Allows administrators to select the join mode (String or UUID) for SessionsV2.\n*   **Survey Management:** Allows users to create, manage, and analyze surveys to gather user feedback.\n"
    },
    {
        "path": "frontend/src/scenes/settings/SettingsScene.tsx",
        "summary": "The `SettingsScene.tsx` file defines a scene in the frontend application responsible for rendering the settings page. It utilizes the `kea` library for state management and routing. The scene component, `SettingsScene`, leverages the `useAnchor` hook to handle anchor links within the page and renders the `Settings` component, passing in a logic key and a flag to handle state locally.\n\nHere's a list of high-level product features based on the code:\n\n*   **Settings Page:** Provides a dedicated interface for users to modify application settings.\n*   **Anchor Link Handling:** Supports navigation to specific sections within the settings page using anchor links.\n*   **Local State Management:** Manages the settings state locally within the component.\n"
    },
    {
        "path": "frontend/src/scenes/settings",
        "summary": "The PostHog settings interface provides a comprehensive and customizable experience for users to manage their accounts, projects, organizations, and environments. It offers a hierarchical navigation system, dynamic rendering of settings components, and adaptable layouts for different screen sizes. Security is enhanced through re-authentication for sensitive settings and role-based access control. The settings cover a wide range of functionalities, including data capture configuration, user interface customization, integration management, session recording control, data anonymization, and user preferences, all designed to provide granular control over the PostHog platform.\n\nHere's a list of high-level product features:\n\n*   Hierarchical Settings Navigation\n*   Dynamic Settings Rendering\n*   Compact Navigation\n*   Re-authentication for Sensitive Settings\n*   Organization Branding\n*   Domain Management\n*   Member Management\n*   Role-Based Access Control\n*   AI Feature Management\n*   User Profile Management\n*   Password Management\n*   Theme Customization\n*   Two-Factor Authentication\n*   Personal API Key Management\n*   Email Notification Preferences\n*   Data Anonymization\n*   Project Management (Move, Rename, Delete)\n*   Data Capture Configuration\n*   Integration Management\n*   Session Recording Control\n*   Data Filtering and Exclusion\n*   Environment Configuration\n*   URL-based Settings Access\n*   Breadcrumb Navigation\n*   Shareable Settings URLs\n*   Dynamic Settings Redirection\n"
    },
    {
        "path": "frontend/src/scenes/comments/CommentsList.tsx",
        "summary": "The `CommentsList` component displays a list of comments and their replies. It fetches comments using the `commentsLogic` and displays a loading skeleton while comments are being fetched. If there are no comments, it shows a \"start the discussion\" message with a hedgehog illustration. Once loaded, it renders each comment with its replies using the `CommentWithReplies` component. The component reloads comments when the `key` prop changes, ensuring the comment list is up-to-date when the focus changes.\n\nHere's a list of high-level product features:\n\n*   **Display Comments and Replies:** Shows a list of comments and their associated replies.\n*   **Loading State:** Displays a loading skeleton while comments are being fetched.\n*   **Empty State:** Shows a helpful message and illustration when there are no comments.\n*   **Dynamic Loading:** Reloads comments when the component's key prop changes, ensuring data is up-to-date.\n"
    },
    {
        "path": "frontend/src/scenes/comments/Comment.tsx",
        "summary": "This code defines a React component for displaying and interacting with comments, including replies. It allows users to view comments with author information, timestamp, and content formatted with Markdown. Users can reply to, edit, and delete their own comments, with editing happening in an inline Markdown editor. The component also handles highlighting comments that are being replied to or edited, and provides visual cues for edited comments.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Comment Display:** Renders individual comments with author, timestamp, and formatted content.\n*   **Nested Replies:** Supports displaying comments in a threaded structure with replies.\n*   **Comment Editing:** Allows users to edit their own comments with a Markdown editor.\n*   **Comment Deletion:** Enables users to delete their own comments.\n*   **Replying to Comments:** Provides a \"Reply\" action to create nested comments.\n*   **Markdown Support:** Renders comment content using Markdown formatting.\n*   **Highlighting:** Highlights comments that are being replied to or edited.\n*   **Timestamp Display:** Shows the creation time of comments with timezone information.\n*   **Visual Indicators:** Indicates when a comment has been edited.\n*   **Keyboard Shortcuts:** Supports keyboard shortcuts for saving changes while editing.\n"
    },
    {
        "path": "frontend/src/scenes/comments/CommentComposer.tsx",
        "summary": "The `CommentComposer` component provides a user interface for composing and sending comments or replies within a discussion thread. It utilizes a markdown-enabled text area for input, displays a dynamic placeholder based on the context (replying or commenting), and includes buttons for submitting comments, canceling replies, and clearing the item context. The component leverages the `commentsLogic` Kea logic hook to manage the comment composition state, sending actions, and loading state. It also handles keyboard shortcuts for quick submission and clears the item context when the component unmounts or the discussion context changes.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Comment Composition:** Allows users to write comments using a markdown-enabled text area.\n*   **Replying to Comments:** Enables users to reply to specific comments within a discussion.\n*   **Dynamic Placeholder Text:** Displays context-aware placeholder text to guide users.\n*   **Comment Submission:** Provides a button to submit the composed comment or reply.\n*   **Cancel Reply:** Offers a button to cancel the current reply composition.\n*   **Clear Item Context:** Includes a button to clear the current item context.\n*   **Loading State:** Disables the input area and buttons while comments are loading.\n*   **Keyboard Shortcut:** Supports a keyboard shortcut (Cmd/Ctrl + Enter) for quick comment submission.\n*   **Input Validation:** Disables the submit button when the comment input is empty.\n"
    },
    {
        "path": "frontend/src/scenes/comments/commentsLogic.ts",
        "summary": "This code defines the `commentsLogic` Kea logic hook, responsible for managing comments within a PostHog application. It handles loading, creating, updating, and deleting comments, as well as managing the comment input field and its associated context. The logic supports threaded comments (replies) and maintains the state of the comment composer, including the composed comment text, the currently replying comment, and the editing comment. It also manages the focus state of the comment composer and provides a selector to transform the flat list of comments into a tree structure with replies.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Displaying Comments:** Fetches and displays a list of comments associated with a specific item (e.g., a notebook, a dashboard).\n*   **Creating Comments:** Allows users to create new comments with optional context data.\n*   **Replying to Comments:** Enables users to reply to existing comments, creating threaded conversations.\n*   **Editing Comments:** Allows users to edit their own comments.\n*   **Deleting Comments:** Enables users to delete their own comments with an undo option.\n*   **Comment Input Field:** Manages the state of the comment input field, including the composed text and focus.\n*   **Comment Context:** Supports associating context data with comments, potentially for richer interactions or metadata.\n*   **Real-time Updates:** Optimistically updates the comment list upon creation, edit, or deletion, and provides undo functionality for deletions.\n*   **Comment Sorting:** Sorts comments by creation date.\n"
    },
    {
        "path": "frontend/src/scenes/comments",
        "summary": "The provided code collectively implements a comprehensive commenting system within the PostHog application. This system allows users to engage in discussions around various items by creating, reading, updating, and deleting comments. The system supports threaded conversations through replies, provides a rich text editor with Markdown support, and offers real-time updates with undo functionality for deletions. The user interface is designed to be intuitive, with dynamic placeholders, keyboard shortcuts, and visual cues for editing and replying.\n\nHere's a list of high-level product features:\n\n*   **Comment Display:** Renders a list of comments with author, timestamp, and formatted content, including nested replies.\n*   **Comment Creation:** Allows users to create new comments and replies with a Markdown-enabled text area.\n*   **Comment Editing:** Enables users to edit their own comments with an inline Markdown editor.\n*   **Comment Deletion:** Enables users to delete their own comments with an undo option.\n*   **Real-time Updates:** Optimistically updates the comment list upon creation, edit, or deletion.\n*   **Markdown Support:** Renders comment content using Markdown formatting.\n*   **Dynamic Placeholder Text:** Displays context-aware placeholder text to guide users.\n*   **Keyboard Shortcuts:** Supports keyboard shortcuts for quick comment submission and saving changes while editing.\n*   **Loading and Empty States:** Displays appropriate loading skeletons and empty state messages.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/metrics/AppMetricsV2Sparkline.tsx",
        "summary": "This React component, `AppMetricSparkLineV2`, displays a sparkline chart visualizing the success and failure metrics of an application. It fetches the metrics using the `appMetricsV2Logic` Kea logic hook, displaying a skeleton loader while the data is loading. The component then transforms the fetched data into a format suitable for the `Sparkline` component, rendering a chart that shows the trend of successes and failures over time.\n\nHere's a list of high-level product features:\n\n*   **Metric Visualization:** Displays success and failure metrics in a sparkline chart.\n*   **Data Fetching:** Fetches application metrics using a Kea logic hook.\n*   **Loading State:** Shows a skeleton loader while metrics are being fetched.\n*   **Success/Failure Differentiation:** Visually distinguishes between success and failure metrics using different colors.\n*   **Time Series Data:** Presents metrics as a time series, showing trends over time.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/metrics/AppMetricsV2.tsx",
        "summary": "This code defines a React component, `AppMetricsV2`, that visualizes the delivery trends of events in an application. It fetches and displays metrics related to succeeded, failed, filtered, temporarily disabled, and permanently disabled events. The component includes a summary of total event counts for each category and a line graph showing the trends over time. Users can adjust the time interval (hourly, daily, weekly) and date range for the displayed data. The graph uses an external tooltip to display detailed information about each data point.\n\nHere's a list of high-level product features:\n\n*   **Metrics Summary:** Displays total counts for succeeded, failed, filtered, temporarily disabled, and permanently disabled events.\n*   **Delivery Trends Graph:** Visualizes event delivery trends over time using a line graph.\n*   **Time Interval Selection:** Allows users to select the time interval for the graph (hourly, daily, weekly).\n*   **Date Range Filtering:** Enables users to filter the data by specifying a date range.\n*   **Detailed Tooltips:** Provides detailed information about data points on the graph via interactive tooltips.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/metrics/appMetricsV2Logic.tsx",
        "summary": "This code defines a Kea logic module named `appMetricsV2Logic` responsible for fetching and managing application metrics. It fetches metrics and totals from the API based on specified filters such as date ranges and intervals. The logic provides actions to set these filters and triggers data loading when filters change. The fetched data is stored in the logic's state for use in the application.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Metrics Visualization:** Fetches and provides application metrics data for visualization.\n*   **Date Range Filtering:** Allows filtering metrics data by specifying a date range (before and after dates).\n*   **Interval Selection:** Enables grouping metrics data by a specified interval (e.g., daily, weekly).\n*   **Metrics Totals:** Fetches and provides total metrics data.\n*   **Real-time Updates:** Automatically reloads metrics data when filters are changed.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogFunctionTestingLogic.tsx",
        "summary": "This code defines the logic for testing Hog Functions within the PostHog platform. It manages the state and data fetching required to display events, retry function invocations on specific events, and paginate through event data. The logic handles date range selection, loading and retrying function invocations, managing expanded rows for detailed event views, and selecting events for retry. It also provides mechanisms for pagination and displaying total event counts.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Hog Function Testing:** Allows users to test Hog Functions against real event data.\n*   **Event Data Display:** Displays a paginated list of events that match the Hog Function's filters.\n*   **Function Invocation Retry:** Enables users to retry Hog Function invocations on specific events.\n*   **Date Range Filtering:** Allows users to filter events by a specific date range.\n*   **Event Detail Expansion:** Provides the ability to expand rows to view detailed information about individual events.\n*   **Bulk Retry Selection:** Allows users to select multiple events and retry the Hog Function on them.\n*   **Loading State Management:** Manages loading states for retries and prevents accidental page exits during active retries.\n*   **Total Event Count:** Displays the total number of events matching the function's criteria.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/PipelineNodeNew.tsx",
        "summary": "This code defines the `PipelineNodeNew` component, which serves as a central hub for creating and configuring various nodes within a data pipeline. It dynamically renders different configuration interfaces based on the selected pipeline stage (Source, Transformation, Destination, or Site App) and the provided ID, which can represent a plugin, batch export destination, or Hog Function. The component utilizes feature flags to conditionally enable certain functionalities, such as Site App functions. It also includes tables for selecting existing Site Apps and links to configuration pages for each node type.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Data Pipeline Node Creation:** Allows users to create new nodes within a data pipeline.\n*   **Stage-Specific Configuration:** Provides different configuration interfaces based on the selected pipeline stage (Source, Transformation, Destination, Site App).\n*   **Plugin Configuration:** Enables configuration of individual plugins within the pipeline.\n*   **Batch Export Destination Configuration:** Supports configuration of batch export destinations.\n*   **Hog Function Configuration:** Allows users to configure Hog Functions.\n*   **Site App Integration:** Integrates with Site Apps, allowing them to be used as pipeline nodes.\n*   **Feature Flag Control:** Uses feature flags to conditionally enable or disable certain functionalities.\n*   **Node Selection Table:** Provides a table for selecting existing Site Apps to use as pipeline nodes.\n*   **Navigation and Linking:** Provides links to configuration pages for each node type.\n"
    },
    {
        "path": "frontend/src/scenes/App.tsx",
        "summary": "The `App.tsx` file defines the main application component, responsible for rendering the user interface based on user authentication status, feature flags, and application preflight checks. It manages the loading and display of different scenes within the application, handles global modals and toast notifications, and integrates with various logic layers for user management, feature flags, API status, and more. The component also includes error handling and theming support.\n\nHere's a list of high-level product features implemented in the code:\n\n*   **User Authentication:** Checks user login status and renders different UI elements based on whether the user is authenticated.\n*   **Feature Flag Management:** Fetches and applies feature flags to control the availability of certain features.\n*   **Preflight Checks:** Performs initial checks to ensure the application is properly configured.\n*   **Scene Management:** Loads and renders different scenes (views) within the application based on the current route or application state.\n*   **Global Modals:** Manages and displays global modal dialogs.\n*   **Toast Notifications:** Displays toast notifications for user feedback.\n*   **Theming:** Applies a dark or light theme to the application.\n*   **Navigation:** Provides a navigation menu for navigating between different scenes.\n*   **Error Handling:** Wraps scenes in error boundaries to prevent application crashes.\n*   **Loading Indicators:** Displays a spinner overlay while the application is loading.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/metrics",
        "summary": "The provided code implements a comprehensive application metrics visualization tool, allowing users to monitor the delivery trends of events within their application. It fetches, manages, and displays metrics related to succeeded, failed, filtered, and disabled events, providing both a summary of total event counts and a line graph visualizing trends over time. Users can interact with the data by adjusting the time interval and date range, and detailed tooltips offer granular information about each data point. Additionally, sparkline charts provide a compact view of success and failure metrics.\n\nHere's a list of high-level product features:\n\n*   Metrics Summary: Displays total counts for succeeded, failed, filtered, temporarily disabled, and permanently disabled events.\n*   Delivery Trends Graph: Visualizes event delivery trends over time using a line graph.\n*   Time Interval Selection: Allows users to select the time interval for the graph (hourly, daily, weekly).\n*   Date Range Filtering: Enables users to filter the data by specifying a date range.\n*   Detailed Tooltips: Provides detailed information about data points on the graph via interactive tooltips.\n*   Metrics Visualization: Fetches and provides application metrics data for visualization.\n*   Metrics Totals: Fetches and provides total metrics data.\n*   Real-time Updates: Automatically reloads metrics data when filters are changed.\n*   Metric Visualization (Sparkline): Displays success and failure metrics in a sparkline chart.\n*   Loading State: Shows a skeleton loader while metrics are being fetched.\n*   Success/Failure Differentiation: Visually distinguishes between success and failure metrics using different colors.\n*   Time Series Data: Presents metrics as a time series, showing trends over time.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/PipelineNodeLogs.tsx",
        "summary": "The `PipelineNodeLogs` component displays logs for a specific pipeline node, allowing users to filter, search, and load more logs. It features a search input for filtering logs by content, checkboxes for selecting log levels to display, and buttons for loading newer or older log entries. The component uses a LemonTable to present the logs in a structured format with pagination.\n\nHere's a list of high-level product features:\n\n*   **Log Display:** Displays logs in a tabular format with columns for relevant information.\n*   **Log Level Filtering:** Allows users to filter logs based on log level (e.g., INFO, WARNING, ERROR).\n*   **Log Search:** Enables users to search for specific messages within the logs.\n*   **Load More Logs:** Provides functionality to load additional older log entries.\n*   **Load Newer Logs:** Provides functionality to load additional newer log entries.\n*   **Instance ID Filtering:** Allows filtering logs by a specific instance ID.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/NewButton.tsx",
        "summary": "This code defines a React component called `NewButton` that renders a button for creating new pipeline nodes. The button's appearance and size are customizable via props, and it navigates the user to the appropriate URL for creating a new node of the specified pipeline stage when clicked. The button includes a plus icon and text indicating the stage for which a new node will be created.\n\nHere's a list of high-level product features associated with this component:\n\n*   **New Pipeline Node Creation:** Allows users to initiate the creation of new nodes within a data pipeline.\n*   **Stage-Specific Node Creation:** Enables users to create nodes specific to a particular stage in the pipeline (e.g., ingestion, transformation, export).\n*   **UI Element for Node Creation:** Provides a button element within the user interface to trigger the node creation process.\n*   **Navigation to Node Creation Form:** Navigates the user to a dedicated form or page for defining the properties of the new pipeline node.\n*   **Customizable Button Appearance:** Offers options to customize the button's size and potentially other visual aspects.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/ImportApps.tsx",
        "summary": "The `ImportApps` component displays a table of import apps, allowing users to view and manage them. The table includes columns for the app, name, last updated time, and status of each import app. Users can also access a menu with options to toggle the enabled state and load plugin configurations for each app.\n\n**Features:**\n\n*   **Display Import Apps:** Shows a list of available import apps in a table format.\n*   **App Details:** Displays the app name, associated name, last updated time, and status for each import app.\n*   **Toggle Enabled State:** Allows users to enable or disable import apps.\n*   **Load Plugin Configurations:** Provides functionality to load plugin configurations for each import app.\n*   **Loading State:** Indicates when the data is being loaded.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/destinations/DestinationsFilters.tsx",
        "summary": "The `DestinationsFilters` component provides a filtering interface for destinations or transformations within a pipeline. It includes options to search by name, show or hide paused items, filter by kind (Realtime or Batch exports), and a link to provide feedback. Additionally, it conditionally renders a \"New Destination\" or \"New Transformation\" button based on the context. The component leverages Lemon UI components and Kea logic for state management and actions.\n\nHere's a list of high-level product features:\n\n*   **Search:** Allows users to search for destinations/transformations by name.\n*   **Show Paused Filter:** Toggles the visibility of paused destinations/transformations.\n*   **Kind Filter:** Filters destinations based on their type (Realtime or Batch exports).\n*   **Feedback Link:** Provides a direct link for users to submit feedback.\n*   **New Destination/Transformation Button:** Enables users to create new destinations or transformations.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/destinations/constants.ts",
        "summary": "The code defines three constants: `DESTINATION_TYPES`, `SITE_APP_TYPES`, and `TRANSFORMATION_TYPES`. Each constant is an array of strings that represent different types of Hog Functions. `DESTINATION_TYPES` includes 'destination' and 'site_destination', `SITE_APP_TYPES` includes 'site_app', and `TRANSFORMATION_TYPES` includes 'transformation'. These constants are likely used to categorize or filter Hog Functions within the application.\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **Destinations:** Allows users to define and manage data destinations.\n*   **Site Apps:** Supports integration with site applications.\n*   **Transformations:** Enables users to transform data.\n*   **Hog Function Typing:** Categorizes functions into destination, site app, and transformation types.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/frontendAppsLogic.tsx",
        "summary": "This code defines the `frontendAppsLogic` Kea logic module, responsible for managing and displaying frontend applications (referred to as \"Site Apps\") within a pipeline. It fetches plugins and their configurations from the backend, handles enabling/disabling of these apps, and converts them into a format suitable for display in the pipeline UI. The logic module also manages loading states and user permissions related to these operations.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Loading and Displaying Frontend Apps:** Fetches and displays a list of available frontend applications (Site Apps) and their configurations.\n*   **Enabling/Disabling Frontend Apps:** Allows users to enable or disable individual frontend applications.\n*   **Configuration Management:** Provides mechanisms for updating the configuration of frontend applications.\n*   **Permission Checks:** Enforces permission checks before enabling or disabling apps.\n*   **Loading State Management:** Tracks and indicates the loading state of plugins and configurations.\n*   **Real-time Updates:** Updates the UI when plugin configurations are changed.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/destinations/DestinationTag.tsx",
        "summary": "The `DestinationTag` component in `DestinationTag.tsx` is a React component that displays a tag based on the status of a HogFunctionTemplate. It uses the LemonTag component from `@posthog/lemon-ui` to render different tag styles based on the status prop. The component handles 'alpha', 'beta', and 'stable' statuses with specific tag types, and any other status is capitalized and displayed as a highlighted tag. The component returns null if the status is 'stable' or if the status prop is empty.\n\nHere's a list of high-level product features:\n\n*   **Status Indicators:** Displays visual tags to indicate the status of a destination (e.g., Experimental, Beta).\n*   **Dynamic Tag Rendering:** Renders different tag styles based on the destination's status.\n*   **Status-Based Visibility:** Hides the tag for stable destinations.\n*   **Customizable Status Labels:** Capitalizes and displays custom status labels.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/configUtils.ts",
        "summary": "This code provides utility functions for managing plugin configurations within a PostHog pipeline. It handles tasks such as converting config schemas between array and object formats, providing default configurations, preparing form data for API submission (including handling attachments and secrets), and dynamically determining the visibility and required status of configuration fields based on dependencies between them. The code also includes validation logic for ensuring the integrity of configuration choices and fields.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Plugin Configuration Schema Management:** Converts and manipulates plugin configuration schemas between array and object formats.\n*   **Default Configuration Generation:** Automatically generates default configuration values for plugins based on their schema.\n*   **Form Data Preparation:** Creates `FormData` objects for plugin configuration updates, including handling file attachments and sensitive data.\n*   **Conditional Field Visibility:** Dynamically shows or hides configuration fields based on the values of other fields.\n*   **Conditional Field Requirement:** Dynamically marks configuration fields as required based on the values of other fields.\n*   **Configuration Validation:** Validates the structure and content of plugin configuration options.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/BatchExportBackfillModal.tsx",
        "summary": "This code defines a modal component, `BatchExportBackfillModal`, which allows users to schedule backfills for batch exports. It provides a form to specify the start and end dates for the backfill, taking into account the project's timezone. The modal handles the submission of the backfill request, displaying loading states and error messages as needed. It also includes an option to backfill data from the beginning of time for person and session models.\n\nHere's a list of high-level product features:\n\n*   **Batch Export Backfill Scheduling:** Allows users to schedule historical data exports for batch exports.\n*   **Date Range Selection:** Provides a calendar interface to select the start and end dates for the backfill.\n*   **Timezone Handling:** Automatically adjusts date selections to the project's timezone.\n*   **\"Beginning of Time\" Backfill:** Option to backfill data from the earliest available data for person and session models.\n*   **Loading and Error Handling:** Displays loading indicators during submission and handles form validation errors.\n*   **Configurable Granularity:** Allows users to select the granularity of the backfill based on the batch export interval.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/batchExportBackfillsLogic.tsx",
        "summary": "This code defines a Kea logic module called `batchExportBackfillsLogic` responsible for managing and displaying batch export backfills associated with a specific pipeline batch export configuration. It fetches, displays, and allows cancellation of backfills, handling pagination for large datasets. The logic connects to other Kea modules for team context, batch export configuration details, and a modal for creating new backfills. It also handles error display using lemonToast.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Backfill Listing:** Displays a list of batch export backfills for a given configuration.\n*   **Backfill Pagination:** Loads and displays backfills in a paginated manner, allowing users to browse through large sets of backfills.\n*   **Backfill Cancellation:** Allows users to cancel running backfills.\n*   **Real-time Updates:** Automatically refreshes the backfill list after a backfill is cancelled.\n*   **Error Handling:** Displays user-friendly error messages for failed operations.\n*   **Date Parsing:** Safely parses and displays date information associated with backfills.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/destinations/newDestinationsLogic.tsx",
        "summary": "This code defines the logic for displaying and filtering available destination options in a data pipeline setup. It fetches Hog Function templates and determines available Batch Export services based on feature flags and user permissions. It then combines these into a list of destination items, each with an icon, name, description, backend type, and URL. The logic also includes functionality for searching and filtering these destinations based on user input, using Fuse.js for fuzzy searching.\n\n**Features:**\n\n*   **Destination Listing:** Displays a list of available destinations, including Hog Functions and Batch Exports.\n*   **Hog Function Integration:** Fetches and displays Hog Function templates as potential destinations.\n*   **Batch Export Support:** Determines and displays available Batch Export services based on feature flags and user permissions.\n*   **Filtering:** Allows users to filter destinations by type (Hog Function or Batch Export) and search term.\n*   **Fuzzy Search:** Implements fuzzy searching using Fuse.js for destination names and descriptions.\n*   **Dynamic Batch Export Services:** Enables or disables Batch Export services based on feature flags and user roles (e.g., HTTP Batch Export for internal use).\n*   **Site Destination Support:** Conditionally includes or excludes \"site_destination\" types based on feature flags.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/BatchExportBackfills.tsx",
        "summary": "This code defines the `BatchExportBackfills` component, which manages and displays backfills for a batch export configuration. It allows users to start new backfills, view the status and progress of existing backfills, refresh the backfill list, load older backfills, and cancel running backfills. The component uses Lemon UI components for displaying data in a table format, progress indicators, buttons, and dialogs. It also handles cases where the batch export configuration is not found.\n\nHere's a list of high-level product features:\n\n*   **Start Backfill:** Allows users to initiate a new backfill process for a batch export.\n*   **View Backfill Status:** Displays the current status of each backfill (e.g., Running, Completed, Failed).\n*   **Monitor Backfill Progress:** Shows a progress bar and details (finished runs/total runs) for running backfills.\n*   **View Backfill History:** Presents a table of past backfills with details like start/end times, IDs, and status.\n*   **Cancel Backfill:** Enables users to cancel backfills that are currently running or starting.\n*   **Refresh Backfill List:** Provides a button to manually refresh the list of backfills.\n*   **Load More Backfills:** Allows users to load older backfill records for historical analysis.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/FrontendApps.tsx",
        "summary": "This code defines the `FrontendApps` component, which displays a list of site apps (also referred to as frontend apps) within the PostHog platform. It fetches site app data using the `frontendAppsLogic` Kea logic hook and renders them in a LemonTable. The component includes a page header with a \"New\" button for creating new site apps, a product introduction section explaining site apps, and the table itself. The table displays information about each site app, including its app identifier, name, last updated time, status (enabled/disabled), and a \"More\" menu for actions like enabling/disabling and loading plugin configurations. The component also handles displaying a message when there are no site apps and differentiates between legacy and newer site apps.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Site App Listing:** Displays a list of existing site apps.\n*   **Site App Creation:** Provides a button to create new site apps.\n*   **Site App Details:** Shows key information about each site app (name, status, last updated).\n*   **Site App Enable/Disable:** Allows users to toggle the enabled status of a site app.\n*   **Legacy Site App Support:** Handles the display of legacy site apps with a specific message.\n*   **Product Introduction:** Provides a description of site apps and their purpose.\n*   **Plugin Configuration Loading:** Allows loading plugin configurations related to the site app.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/destinations/destinationsFiltersLogic.tsx",
        "summary": "This code defines a Kea logic module called `destinationsFiltersLogic` that manages the filters applied to a list of destinations or transformations (referred to as \"items\"). It handles setting, resetting, and persisting these filters in the URL. The logic also includes functionality for capturing user feedback on desired destinations or transformations through a dialog, sending the feedback to PostHog. The filters include search terms, destination kind, sub-template, and a flag to show paused items.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Filtering Destinations/Transformations:** Allows users to filter a list of destinations or transformations based on various criteria.\n*   **Search Functionality:** Enables users to search for specific destinations or transformations by name.\n*   **Persistence of Filters:** Saves and restores filter settings in the URL, maintaining the user's filtering preferences across sessions.\n*   **Feedback Collection:** Provides a mechanism for users to submit feedback on desired destinations or transformations that are not currently available.\n*   **Telemetry Tracking:** Tracks user search activity and feedback submissions using PostHog for product analytics.\n*   **Show Paused Items:** Allows users to view destinations that are paused.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/destinations/NewDestinations.tsx",
        "summary": "This code defines a React component, `NewDestinations`, which displays a table of available data pipeline destinations. It fetches and filters these destinations based on user-defined criteria and displays them in a `LemonTable`. Each destination entry includes its icon, name (as a link), and a \"Create\" button that navigates the user to the destination's configuration page. The component also handles access control, displaying a paywall for destinations requiring a paid feature and allowing staff users to bypass these restrictions. It also provides filtering capabilities and a way to show hidden destinations.\n\nHere's a list of high-level product features:\n\n*   **Destination Listing:** Displays a list of available data pipeline destinations.\n*   **Filtering:** Allows users to filter destinations based on various criteria.\n*   **Access Control:** Restricts access to certain destinations based on the user's subscription.\n*   **Paywall Integration:** Integrates with a paywall system to prompt users to upgrade for premium destinations.\n*   **Staff Override:** Allows staff users to bypass access restrictions for testing and support purposes.\n*   **Destination Creation:** Provides a button to navigate to the destination creation page.\n*   **Destination Information:** Displays key information about each destination, including its icon, name, and description.\n*   **Hidden Destination Display:** Notifies the user about hidden destinations and provides a way to reveal them."
    },
    {
        "path": "frontend/src/scenes/pipeline/destinations/Destinations.tsx",
        "summary": "This code defines the `Destinations` component, which is a page in the PostHog application for managing data pipeline nodes such as destinations, site apps, and transformations. It displays a table of existing nodes with features like filtering, sorting, and status indicators. Users can create new nodes, view node details, and reorder transformations. The component also integrates with PostHog's paygate to restrict access to certain features based on the user's plan.\n\nHere's a list of high-level product features:\n\n*   **Data Pipeline Node Management:** Create, view, edit, and delete destinations, site apps, and transformations.\n*   **Node Listing and Filtering:** Display a list of pipeline nodes with filtering options.\n*   **Node Status Indication:** Show the active/disabled status of each node.\n*   **Node Metrics Visualization:** Display sparklines for node metrics over the last 7 days.\n*   **Transformation Reordering:** Allow users to change the order in which transformations are executed.\n*   **Paygate Integration:** Restrict access to pipeline features based on the user's PostHog plan.\n*   **Integration with Hog Functions:** Support for Hog Functions as a type of pipeline node.\n*   **Real-time and Batch Data Export:** Support for sending data to external destinations in real-time or in batches.\n*   **Custom Website Scripting:** Support for running custom scripts on websites via site apps.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/PipelineNode.tsx",
        "summary": "The `PipelineNode.tsx` file defines the `PipelineNode` component, which is a central view for managing and monitoring different types of pipeline nodes within a data pipeline. It dynamically renders different tabs and content based on the node's `stage` (e.g., Source, Transformation, Destination), `backend` (e.g., ManagedSource, HogFunction, BatchExport), and feature flags. The component utilizes `kea` for state management and displays various sub-components for configuration, metrics, logs, schemas, syncs, runs, backfills, and activity history, tailored to the specific type of pipeline node. It uses LemonTabs for navigation between these different aspects of a pipeline node.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Pipeline Node Configuration:** Allows users to configure settings specific to a pipeline node.\n*   **Metrics Monitoring:** Displays performance metrics for pipeline nodes, including specialized metrics for HogFunction nodes.\n*   **Log Viewing:** Provides access to logs generated by pipeline nodes for debugging and monitoring.\n*   **Schema Management:** Enables users to view and manage schemas associated with data sources.\n*   **Data Synchronization Management:** Allows users to manage data synchronization settings for data sources.\n*   **Batch Export Management:** Provides tools for managing batch export runs and backfills.\n*   **Activity History Tracking:** Logs user actions and system events related to pipeline nodes.\n*   **Testing Menu:** Provides a testing interface for destination pipeline nodes.\n*   **Self-Managed Source Configuration:** Allows configuration of self-managed data sources.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/destinations/destinationsLogic.tsx",
        "summary": "This code defines the logic for managing pipeline destinations within PostHog. It handles loading, creating, updating, deleting, and filtering various types of destinations, including webhooks, batch exports, and Hog Functions (data transformations). The logic also manages the state of the UI, such as whether a reordering modal is open, and provides selectors for filtering and searching destinations. It connects to other kea logics such as projectLogic, userLogic, featureFlagLogic, and destinationsFiltersLogic to access project-specific data, user permissions, feature flags, and filter settings.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Destination Management:** Allows users to view, create, update, and delete data pipeline destinations (webhooks, batch exports, Hog Functions).\n*   **Destination Enabling/Disabling:** Enables users to toggle the active state of destinations.\n*   **Destination Filtering and Searching:** Provides filtering options based on type and status (enabled/disabled), as well as a search functionality.\n*   **Data Transformation Ordering:** Allows users to reorder data transformations (Hog Functions) within a pipeline.\n*   **Batch Export Configuration:** Supports the configuration of batch data exports, including pausing and unpausing exports.\n*   **Webhook Configuration:** Manages the configuration of webhook destinations.\n*   **Hog Function Management:** Supports the management of Hog Functions, including enabling, disabling, and deleting.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/destinations",
        "summary": "The provided code collectively implements a comprehensive data pipeline management system within PostHog, enabling users to define and manage data flow from ingestion to external destinations. This system includes features for creating, configuring, filtering, and monitoring various types of destinations, such as webhooks, batch exports, and data transformations (Hog Functions). Access control mechanisms are integrated to restrict certain features based on user subscription levels, while staff users have override capabilities. The system also facilitates user feedback collection and provides visual indicators for destination status and performance.\n\nHere's a consolidated list of high-level product features:\n\n*   **Destination Management:** Allows users to view, create, update, and delete data pipeline destinations (webhooks, batch exports, Hog Functions, Site Apps).\n*   **Destination Listing and Filtering:** Provides a searchable and filterable list of available destinations, including options to filter by type, status (enabled/disabled, paused), and search by name.\n*   **Data Transformation (Hog Function) Management:** Supports the creation, configuration, enabling/disabling, deletion, and reordering of data transformations within the pipeline.\n*   **Batch Export Configuration:** Enables users to configure batch data exports, including pausing and unpausing exports.\n*   **Webhook Configuration:** Manages the configuration of webhook destinations.\n*   **Access Control and Paywall Integration:** Restricts access to certain destinations or features based on the user's subscription plan, with staff override capabilities.\n*   **Status Indicators:** Displays visual tags to indicate the status of a destination (e.g., Experimental, Beta, Enabled, Paused).\n*   **Node Metrics Visualization:** Displays sparklines for node metrics over the last 7 days.\n*   **Feedback Collection:** Provides a mechanism for users to submit feedback on desired destinations or transformations.\n*   **Persistence of Filters:** Saves and restores filter settings in the URL, maintaining the user's filtering preferences across sessions.\n*   **Site App Integration:** Supports integration with site applications, enabling custom website scripting.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/batch-exports/utils.ts",
        "summary": "This code provides a utility function `humanizeBatchExportName` that takes a `BatchExportService` type as input and returns a human-readable string representation of the service name. Currently, it handles the 'HTTP' service type, converting it to 'PostHog HTTP'. For any other service type, it simply returns the original service type string.\n\nHere's a list of high-level product features related to this code:\n\n*   **Batch Data Export:** Enables users to export data in batches to external services.\n*   **HTTP Export:** Supports exporting data to HTTP endpoints.\n*   **Service Name Humanization:** Presents user-friendly names for different batch export services in the UI.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/PipelineNodeConfiguration.tsx",
        "summary": "The `PipelineNodeConfiguration` component dynamically renders configuration interfaces for different types of pipeline nodes based on their backend. It uses the `pipelineNodeLogic` to access the current node and stage. If the stage is not found, a \"Not Found\" message is displayed. Depending on the node's `backend` property, it renders either `HogFunctionConfiguration`, `PipelinePluginConfiguration`, or `PipelineBatchExportConfiguration`.\n\n**Features:**\n\n*   **Dynamic Configuration Rendering:** Renders different configuration components based on the pipeline node's backend type.\n*   **Hog Function Configuration:** Provides a configuration interface for nodes using the `HogFunction` backend.\n*   **Plugin Configuration:** Provides a configuration interface for nodes using the `Plugin` backend.\n*   **Batch Export Configuration:** Provides a configuration interface for nodes using a batch export backend.\n*   **\"Not Found\" Handling:** Displays a \"Not Found\" message if the pipeline stage is missing.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/overviewLogic.tsx",
        "summary": "This code defines the `pipelineOverviewLogic` using Kea, a state management library. It connects to other Kea logics, specifically `teamLogic`, `pipelineTransformationsLogic`, and `pipelineDestinationsLogic`, to access and manage data related to the current team, pipeline transformations, and pipeline destinations. It fetches data such as the current team ID, loading states, transformations, and destinations. It also connects to actions for loading plugins and plugin configurations for both transformations and destinations, as well as loading batch export configurations for destinations.\n\nHere's a list of high-level product features that can be inferred from the code:\n\n*   **Team Management:** Accessing and utilizing the current team's ID.\n*   **Data Pipeline Transformations:** Managing and displaying data transformations within a pipeline. This includes loading transformations and their configurations.\n*   **Data Pipeline Destinations:** Managing and displaying data destinations within a pipeline. This includes loading destinations, their configurations, and batch export configurations.\n*   **Plugin Management:** Loading and managing plugins for both data transformations and destinations.\n*   **Loading State Management:** Tracking and displaying loading states for transformations and destinations.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/pipelineNodeNewLogic.tsx",
        "summary": "This code defines the logic for creating new pipeline nodes within a data pipeline management system. It uses Kea for state management and data loading. The logic handles loading plugins based on the pipeline stage (Transformation, Destination, SiteApp, Source) and generates breadcrumbs for navigation. It also manages the loading state and provides selectors for accessing the loaded data and breadcrumbs.\n\n**High-Level Features:**\n\n*   **Plugin Loading:** Dynamically loads available plugins based on the selected pipeline stage.\n*   **Pipeline Stage Handling:** Manages different pipeline stages (Transformation, Destination, SiteApp, Source) for node creation.\n*   **Breadcrumb Generation:** Creates breadcrumbs for easy navigation within the pipeline node creation flow.\n*   **Loading State Management:** Tracks and exposes the loading state of plugins.\n*   **User Context Integration:** Connects to user logic to access user-related data.\n*   **Destination Type Handling:** Differentiates destination types for new destination creation.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/batchExportRunsLogic.tsx",
        "summary": "This code defines the logic for managing and displaying batch export runs within a pipeline. It handles fetching runs, filtering them by date range or displaying the latest runs, grouping runs by their data interval, and providing actions to retry or cancel individual runs. The logic also integrates with a backfill modal to trigger new runs for specific date ranges.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Display Batch Export Runs:** Shows a list of batch export runs associated with a specific pipeline.\n*   **Date Range Filtering:** Allows users to filter batch export runs by a specific date range.\n*   **Latest Runs View:** Provides an option to view only the latest batch export runs.\n*   **Run Grouping:** Groups batch export runs by their data interval (start and end dates).\n*   **Run Retrying:** Enables users to retry failed or incomplete batch export runs.\n*   **Run Cancellation:** Allows users to cancel running batch export runs.\n*   **Backfill Runs:** Integrates with a backfill modal to initiate new batch export runs for historical data.\n*   **Real-time Updates:** Automatically refreshes the list of runs after actions like retrying, canceling, or submitting a backfill form."
    },
    {
        "path": "frontend/src/scenes/pipeline/pipelineNodeLogic.tsx",
        "summary": "This code defines a Kea logic module named `pipelineNodeLogic` that manages the state and behavior of a single node within a data pipeline. It handles the current tab being viewed (Configuration, History, etc.), the breadcrumb title, and determines the type of pipeline node (Plugin, BatchExport, HogFunction, ManagedSource, or DataWarehouse) based on its ID. The logic also manages URL routing for tab changes and provides context for side panels based on the node type.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Node Type Detection:** Automatically identifies the type of pipeline node based on its ID.\n*   **Tab Management:** Allows users to switch between different tabs (e.g., Configuration, History) for a pipeline node.\n*   **URL Routing:** Updates the URL when the active tab changes and restores the active tab from the URL.\n*   **Breadcrumb Navigation:** Generates breadcrumbs for navigating through the data pipeline, including the current node.\n*   **Side Panel Context:** Provides context for side panels based on the type of pipeline node, enabling dynamic content and actions.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/batch-exports/types.ts",
        "summary": "This code defines the `BatchExportConfigurationForm` type, which is used for creating or updating batch export configurations in the PostHog frontend. It combines the base `BatchExportConfiguration` type (excluding `id`, `destination`, `start_at`, and `end_at`) with optional configuration properties specific to different destination services like Postgres, Redshift, BigQuery, S3, Snowflake, and HTTP. It also includes properties for destination selection (`destination`), start and end times using Dayjs objects (`start_at`, `end_at`), and the ability to upload a JSON configuration file (`json_config_file`).\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **Batch Data Export:** Allows users to export data in batches.\n*   **Multiple Destination Support:** Supports exporting data to various destinations, including S3, Snowflake, Postgres, BigQuery, Redshift, and HTTP endpoints.\n*   **Configurable Export Schedules:** Enables users to define a start and end time for the batch export process.\n*   **Service-Specific Configuration:** Provides configuration options tailored to each destination service (e.g., Postgres, Redshift).\n*   **JSON Configuration Upload:** Supports uploading a JSON file to configure the batch export.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/PipelineBatchExportConfiguration.tsx",
        "summary": "This code defines a React component, `PipelineBatchExportConfiguration`, which allows users to configure and manage batch exports of data from PostHog to external services. It provides a user interface for creating new batch export configurations or editing existing ones. The component handles various aspects of configuration, including destination service, export frequency, data model selection, event filtering, and testing the configuration. It leverages Kea logic for state management and form handling, and utilizes Lemon UI components for a consistent user experience.\n\nHere's a list of high-level product features:\n\n*   **Batch Export Configuration:** Allows users to configure and schedule the export of data to external services.\n*   **Destination Service Selection:** Supports multiple destination services for exporting data (e.g., Snowflake, BigQuery).\n*   **Export Frequency Configuration:** Enables users to define the frequency of batch export runs (e.g., hourly, daily, every 5 minutes).\n*   **Data Model Selection:** Allows users to select the data model to be exported (e.g., events, sessions).\n*   **Event Filtering:** Provides options to include or exclude specific events from the export based on event names.\n*   **Configuration Testing:** Enables users to test the batch export configuration to ensure it works as expected.\n*   **Schema Viewing:** Allows users to view the schema of the selected data model.\n*   **Pause/Resume Export:** Allows users to enable or disable the export.\n*   **Naming:** Allows users to name the export."
    },
    {
        "path": "frontend/src/scenes/pipeline/pipelineNodeLogsLogic.tsx",
        "summary": "This code defines the logic for displaying logs related to pipeline nodes in a PostHog application. It fetches logs from different backends (Batch Export, Hog Function, Managed Source, or Plugin Configs) based on the node type, allows filtering by log level and search term, and supports pagination and background polling for new logs. The component displays the logs in a table with columns for timestamp, instance ID (invocation or run ID), log level, and message.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Log Display:** Shows logs associated with pipeline nodes.\n*   **Backend Support:** Fetches logs from various pipeline node backends (Batch Export, Hog Function, Managed Source, Plugin Configs).\n*   **Log Level Filtering:** Allows users to filter logs by severity level (DEBUG, LOG, INFO, WARNING, ERROR).\n*   **Search:** Enables users to search for specific terms within the logs.\n*   **Pagination:** Supports loading logs in portions and loading more logs as the user scrolls.\n*   **Background Polling:** Automatically fetches new logs in the background and allows users to reveal them.\n*   **Instance ID Filtering:** Allows filtering logs by a specific instance ID (invocation or run ID).\n*   **Timestamp Display:** Shows the timestamp of each log entry with timezone information.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/PipelinePluginImage.tsx",
        "summary": "This React component, `PluginImage`, is responsible for displaying an image representing a PostHog plugin within the pipeline UI. It dynamically determines the image source based on the plugin's type, URL, and icon properties. It prioritizes specific image overrides for known plugins, then uses the plugin's icon if available. If the URL points to a GitHub repository, it attempts to fetch the logo from the repository's `logo.png` file. Finally, it defaults to a generic plugin icon if no other image source is found. The component also handles errors by falling back to the default image and adjusts the image size based on the provided `size` prop. Source plugins are represented by a terminal icon.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Dynamic Plugin Image Display:** Displays an image associated with a PostHog plugin.\n*   **Image Source Prioritization:** Determines the image source based on a defined priority order (overrides, icon, GitHub repo logo, default).\n*   **GitHub Repository Logo Fetching:** Automatically fetches the logo from a GitHub repository if the plugin URL points to one.\n*   **Default Image Fallback:** Uses a default image if no other image source is available or if an error occurs.\n*   **Plugin Type Specific Icon:** Uses a terminal icon for source plugins.\n*   **Image Size Customization:** Allows specifying the image size (small, medium, large).\n*   **Specific Plugin Icon Overrides:** Uses custom icons for specific plugins based on their URL.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/batch-exports/BatchExportEditForm.tsx",
        "summary": "This code defines React components for editing batch export configurations in PostHog. It provides forms for configuring general settings like name and end date, as well as destination-specific settings for S3, Snowflake, and Postgres. The forms include input fields, dropdowns, checkboxes, and tooltips, allowing users to specify details such as bucket names, regions, file formats, authentication credentials, and database connection parameters. The UI adapts based on whether the export is new, part of a pipeline, and the selected destination.\n\nHere's a list of high-level product features that can be derived from the code:\n\n*   **Batch Export Configuration:** Allows users to configure automated exports of data to external destinations.\n*   **Destination Support:** Supports exporting data to S3, Snowflake, and Postgres.\n*   **S3 Configuration:** Provides options for configuring S3 exports, including bucket name, region, key prefix, file format, compression, encryption, and AWS credentials.\n*   **Snowflake Configuration:** Provides options for configuring Snowflake exports, including account, user, authentication type (password or key pair), database, warehouse, schema, table name, and role.\n*   **Postgres Configuration:** Provides options for configuring Postgres exports, including user, password, host, port, database, schema, and table name.\n*   **End Date:** Allows users to specify an end date for the export.\n*   **Pause on Creation:** Allows users to create a batch export in a paused state.\n*   **UI Adaptability:** The UI adapts based on the selected destination and whether the export is new or part of a pipeline.\n*   **Input Validation:** Includes input fields with placeholders and optional fields.\n*   **Secure Credential Handling:** Uses password input types for sensitive information.\n*   **Informative Tooltips:** Provides tooltips to guide users through the configuration process.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/pipelinePluginActivityDescriptions.tsx",
        "summary": "This code defines a function `pluginActivityDescriber` that generates human-readable descriptions of activity log items related to plugins and their configurations within a pipeline. It handles various plugin-related activities such as installation, uninstallation, enabling, disabling, configuration updates, job triggers, and attachment changes. The function constructs descriptions that include the user who performed the action, the name of the plugin, and details about the specific activity, such as the fields changed in a configuration or the type of job triggered. It also handles sensitive information by masking secret values.\n\nHere's a list of high-level product features that can be inferred from the code:\n\n*   **Plugin Installation/Uninstallation Tracking:** Logs when a plugin is installed or uninstalled, including the plugin's name and the user who performed the action.\n*   **Plugin Configuration Change Tracking:** Records changes to plugin configurations, including which fields were modified, added, or removed, and their previous and new values.\n*   **Plugin Enable/Disable Tracking:** Logs when a plugin is enabled or disabled, including the user who performed the action and the plugin's name.\n*   **Job Trigger Tracking:** Records when a plugin triggers a job, including the job type and any associated payload.\n*   **Historical Event Export Tracking:** Specifically tracks the triggering, success, and failure of historical event export jobs, including the date range being exported.\n*   **Attachment Management Tracking:** Logs the creation, update, and deletion of attachments associated with plugins.\n*   **User Attribution:** All activities are associated with the user who performed them.\n*   **Secret Value Masking:** Sensitive configuration values are masked in the activity logs to protect them from exposure.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/batch-exports",
        "summary": "This collection of code files details the implementation of a batch data export feature within PostHog, enabling users to automate the export of data to various external destinations. The system provides a user-friendly interface for configuring these exports, including support for multiple destinations like S3, Snowflake, Postgres, Redshift, BigQuery, and HTTP endpoints, with service-specific configuration options and secure credential handling. Users can define schedules, upload JSON configurations, and manage the export process through an adaptable UI with informative tooltips.\n\nHere's a list of high-level product features:\n\n*   Batch Data Export\n*   Multiple Destination Support (S3, Snowflake, Postgres, Redshift, BigQuery, HTTP)\n*   Service-Specific Configuration\n*   Configurable Export Schedules\n*   JSON Configuration Upload\n*   UI Adaptability\n*   Secure Credential Handling\n*   Service Name Humanization\n*   Pause on Creation\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/AppMetricSparkLine.tsx",
        "summary": "This React component, `AppMetricSparkLine`, displays a sparkline graph visualizing the success and failure metrics of a pipeline node over the last 7 days. It fetches the metrics data using the `pipelineNodeMetricsLogic` and renders a `Sparkline` component, showing successes and failures as separate lines. The component handles loading states and only displays the failure line if there are any failures in the data.\n\nHere's a list of high-level product features:\n\n*   **Visualized Pipeline Node Metrics:** Displays a sparkline graph representing the success and failure rates of a specific pipeline node.\n*   **Time-Series Data:** Shows metrics data over a 7-day period.\n*   **Success/Failure Differentiation:** Clearly distinguishes between successful and failed executions using different colors.\n*   **Loading State Handling:** Provides a loading indicator while fetching metrics data.\n*   **Dynamic Failure Display:** Only shows the failure line if there are actual failures to display.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/pipelineAccessLogic.tsx",
        "summary": "This code defines a Kea logic module called `pipelineAccessLogic` that determines user permissions and access control for data pipelines features. It connects to `userLogic` to access user information and available features. The logic defines selectors that determine whether a user can globally manage plugins, configure plugins, and enable new destinations based on their organization's permissions and available features. It also provides a selector to determine if a user can enable a specific destination, considering whether the destination is free or requires specific permissions.\n\nHere's a list of high-level product features enabled/controlled by this logic:\n\n*   **Global Plugin Management:** Determines if a user can manage plugins across the entire organization.\n*   **Plugin Configuration:** Determines if a user can configure plugins.\n*   **Destination Management:** Determines if a user can enable new data pipeline destinations.\n*   **Destination Access Control:** Determines if a user can enable a specific data pipeline destination, considering free vs. paid features.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/filters/HogFunctionFiltersInternal.tsx",
        "summary": "This component provides a user interface for selecting event-based filters to trigger a Hog Function destination. It uses a LemonSelect component to display a list of predefined filter options, which can vary depending on the `logicKey` prop passed to the component (e.g., 'errorTracking'). The component manages the selected filter value and updates the Hog Function configuration accordingly.\n\n**Features:**\n\n*   **Event-Based Triggers:** Allows users to define specific events that trigger a Hog Function.\n*   **Predefined Filter Options:** Offers a selection of predefined event filters (e.g., \"Team activity\", \"Error tracking issue created\").\n*   **Contextual Filter Options:** Dynamically adjusts the available filter options based on the Hog Function's context (e.g., error tracking).\n*   **User-Friendly Selection:** Uses a LemonSelect component for easy selection of filter options.\n*   **Configuration Management:** Manages the selected filter value and updates the Hog Function configuration.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/pipelineNodeMetricsLogic.tsx",
        "summary": "This code defines a Kea logic module named `pipelineNodeMetricsLogic` responsible for fetching and managing metrics related to a specific pipeline node (identified by its ID). It fetches data from the PostHog API, including success and failure rates, error summaries, and detailed error information. The logic allows users to specify a date range for the metrics, view error details in a modal, and displays the fetched data. It connects to the `projectLogic` to get the current project ID.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Metrics Dashboard:** Displays success and failure rates for a specific pipeline node over time.\n*   **Date Range Filtering:** Allows users to filter metrics by specifying a start and end date.\n*   **Error Summary:** Provides a summary of different error types encountered by the pipeline node.\n*   **Error Details Modal:** Enables users to view detailed information about specific errors, including timestamps, error messages, and related event data.\n*   **Real-time Updates:** Automatically fetches and updates metrics data when the date range is changed.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/TestingMenu.tsx",
        "summary": "The `TestingMenu.tsx` file provides a user interface for testing Hog Functions with historical events. It allows users to filter events, select specific invocations for retry, view event details and logs, and save configuration changes. The component utilizes Lemon UI components for a consistent user experience and Kea logic for state management.\n\n**High-Level Product Features:**\n\n*   **Event Filtering:** Allows users to filter historical events based on various criteria to narrow down the scope of testing.\n*   **Invocation Selection & Retry:** Enables users to select specific event invocations and retry them, facilitating targeted testing and debugging.\n*   **Event Details & Logs Viewing:** Provides detailed information about each event and its associated logs, aiding in understanding function behavior.\n*   **Hog Function Configuration:** Allows users to modify and save the configuration of the Hog Function being tested.\n*   **Paygate Integration:** Integrates with a paygate to restrict access to the feature based on subscription status.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/Pipeline.tsx",
        "summary": "The `Pipeline` component in `Pipeline.tsx` renders a tabbed interface for managing data pipelines. It includes tabs for Overview, Sources, Transformations, Destinations, Site Apps (or Frontend Apps based on feature flags), Import Apps (conditionally shown if any are enabled), Apps Management (conditionally shown based on user permissions), and History (activity log). The active tab is controlled by the router, and the tab labels are human-friendly.\n\nHere's a list of high-level product features:\n\n*   **Pipeline Overview:** Provides a summary view of the data pipeline.\n*   **Data Source Management:** Allows users to configure and manage data sources.\n*   **Data Transformation:** Enables users to define and manage transformations applied to data.\n*   **Data Destination Management:** Allows users to configure and manage data destinations.\n*   **Site Apps/Frontend Apps:** Enables integration with site apps or frontend apps.\n*   **Import Apps (Deprecated):** Supports importing existing apps (conditionally displayed).\n*   **Apps Management:** Provides tools for managing installed apps (conditionally displayed based on permissions).\n*   **Activity History:** Logs activity related to the pipeline, plugins, and configurations.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/Overview.tsx",
        "summary": "The `Overview` component in the Pipeline feature provides a central dashboard for managing data pipelines. It displays managed and self-managed sources, transformations, and destinations. Users can navigate to detailed views for each of these pipeline stages, create new pipeline nodes (sources, transformations, or destinations) via a dropdown menu, and view active transformations and destinations. The component utilizes tables to display sources and a `DestinationsTable` component to display transformations and destinations, with options to hide feedback, the add destination button, and the change order button.\n\nHere's a list of high-level product features:\n\n*   **Data Pipeline Overview Dashboard:** Provides a centralized view of data pipeline components.\n*   **Managed and Self-Managed Source Management:** Displays and links to managed and self-managed data sources.\n*   **Transformation Management:** Displays and links to data transformations.\n*   **Destination Management:** Displays and links to data destinations.\n*   **Pipeline Node Creation:** Allows users to create new sources, transformations, and destinations.\n*   **Navigation to Detailed Views:** Enables users to navigate to detailed views for each pipeline stage (sources, transformations, destinations).\n*   **Active Pipeline Component Filtering:** Shows only active transformations and destinations in the overview.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/AppCode.tsx",
        "summary": "This component, `AppCode`, provides a user interface for viewing and editing the source code of PostHog Apps. It fetches the plugin source code, displays it in a tabbed interface with syntax highlighting, and allows authorized users to edit the code using a Monaco-based code editor. The component also handles submission of the edited code, displays validation errors, and provides links to the PostHog documentation for app building.\n\nHere's a list of high-level product features:\n\n*   **Code Viewing:** Displays plugin source code in a tabbed interface, with each tab representing a file.\n*   **Syntax Highlighting:** Provides syntax highlighting for JavaScript and JSON files.\n*   **Code Editing:** Allows authorized users to edit the plugin source code using a Monaco-based code editor within a modal.\n*   **Error Display:** Displays validation errors for the plugin source code.\n*   **Code Submission:** Enables users to submit the edited plugin source code.\n*   **Loading Indicators:** Shows loading spinners during data fetching and submission.\n*   **Access Control:** Restricts editing functionality to users with global plugin management permissions and source-based plugins.\n*   **Documentation Links:** Provides links to the PostHog documentation for app building.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/types.ts",
        "summary": "This code defines the types and interfaces for building data pipelines in PostHog. It uses a discriminated union approach to define different types of pipeline nodes based on their backend (Batch Export, Plugin, Hog Function, Managed Source, Self Managed Source) and stage (Transformation, Destination, Site App, Import App, Source). The code also includes utility functions for converting various configuration objects into pipeline nodes.\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **Data Transformation:** Allows users to transform data using plugins before it reaches its destination.\n*   **Data Destinations:** Supports various destination types, including webhooks, batch exports, and Hog Functions, for sending processed data.\n*   **Plugin Integration:** Enables users to integrate custom plugins into the data pipeline for specialized processing.\n*   **Batch Export:** Supports exporting data in batches to external services.\n*   **Real-time Data Processing:** Enables real-time data processing for certain destinations.\n*   **Site Apps:** Supports the integration of site apps into the data pipeline.\n*   **Data Sources:** Allows users to ingest data from various sources.\n*   **Pipeline Management:** Provides a way to manage and configure data pipelines, including enabling/disabling nodes and setting intervals.\n*   **Hog Function Integration:** Enables the use of Hog Functions within data pipelines.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/filters/HogFunctionFilters.tsx",
        "summary": "This code defines the `HogFunctionFilters` component in the PostHog frontend, which allows users to configure filters for Hog functions (server-side functions that process events). The filters vary depending on the Hog function's type (`broadcast`, `internal_destination`, `destination`, or `transformation`) and whether mappings are used. The component includes property filters, test account filters, and action filters, with specific options and warnings displayed based on the function type and selected filter properties. It also supports masking options for destination functions, allowing users to control how often the function is triggered.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Property Filtering:** Allows filtering events based on event properties, person properties, feature flags, elements, and HogQL expressions.\n*   **Test Account Filtering:** Enables filtering out test accounts from the events processed by the Hog function.\n*   **Action/Event Matching:** Allows the Hog function to run only when events match specified events or actions.\n*   **Event Dropping (Conditional):** Provides an option to drop events that do not match the defined filters.\n*   **Masking/Trigger Options:** Controls the frequency with which a destination Hog function is triggered (e.g., run every time, once per interval, once per person per interval).\n*   **Transformation-Specific Filters:** Restricts filters for transformations to event properties and HogQL expressions.\n*   **Global Filters (with Mapping):** Applies filters to all events before they reach a mapping.\n*   **Warnings and Information Banners:** Displays contextual warnings and information to guide the user, such as warnings about using person properties and explanations of filter behavior.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/hogFunctionConfigurationLogic.tsx",
        "summary": "This code defines the logic for configuring Hog Functions within the PostHog platform. It handles loading, creating, updating, and deleting Hog Functions, as well as managing templates and configurations. The logic includes features for validating configurations, sanitizing input data, and generating sample data for testing. It also handles sparkline queries for visualizing data trends and provides warnings for high event volumes. The code uses Kea for state management and interacts with the PostHog API for data persistence.\n\nHere's a list of high-level product features:\n\n*   **Hog Function Creation and Editing:** Allows users to create new Hog Functions or edit existing ones.\n*   **Template Management:** Provides a library of Hog Function templates that users can use as a starting point.\n*   **Configuration Validation:** Validates Hog Function configurations to ensure they are valid and complete.\n*   **Data Sanitization:** Sanitizes input data to prevent security vulnerabilities.\n*   **Sample Data Generation:** Generates sample data for testing Hog Functions.\n*   **Sparkline Visualization:** Visualizes data trends using sparkline charts.\n*   **Event Volume Monitoring:** Monitors event volumes and provides warnings when volumes are high.\n*   **Code Editor:** Provides a code editor for writing and editing Hog Function code.\n*   **Input Schema Definition:** Allows users to define the input schema for Hog Functions.\n*   **Mapping Configuration:** Allows users to configure mappings between input data and Hog Function inputs.\n*   **Filter Configuration:** Allows users to configure filters to select specific events for processing.\n*   **Duplication:** Allows users to duplicate existing Hog Functions.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/filters",
        "summary": "The HogFunctionFilters component provides a comprehensive interface for configuring event filters that trigger Hog functions, allowing users to define precise conditions for function execution. The available filter options dynamically adapt based on the Hog function's type and context, offering a tailored experience for different use cases such as event processing, data transformation, and destination integrations. The component also includes features for managing test accounts, controlling trigger frequency, and providing contextual guidance through warnings and information banners.\n\n**Features:**\n\n*   Event-Based Triggers: Allows users to define specific events that trigger a Hog Function.\n*   Predefined Filter Options: Offers a selection of predefined event filters.\n*   Contextual Filter Options: Dynamically adjusts the available filter options based on the Hog Function's context.\n*   Property Filtering: Allows filtering events based on event properties, person properties, feature flags, elements, and HogQL expressions.\n*   Test Account Filtering: Enables filtering out test accounts from the events processed by the Hog function.\n*   Action/Event Matching: Allows the Hog function to run only when events match specified events or actions.\n*   Event Dropping (Conditional): Provides an option to drop events that do not match the defined filters.\n*   Masking/Trigger Options: Controls the frequency with which a destination Hog function is triggered.\n*   Transformation-Specific Filters: Restricts filters for transformations to event properties and HogQL expressions.\n*   Global Filters (with Mapping): Applies filters to all events before they reach a mapping.\n*   Warnings and Information Banners: Displays contextual warnings and information to guide the user.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/mapping/HogFunctionMappings.tsx",
        "summary": "This code defines React components for configuring Hog Function Mappings within a PostHog pipeline. It allows users to define how events and actions trigger a function, including filtering events based on properties and transforming input values. The UI provides options to add, duplicate, remove, enable/disable mappings, and define input variables for the function. The `HogFunctionMappings` component renders a list of `HogFunctionMapping` components, each representing a mapping between events/actions and the function. Each mapping can be configured with event/action filters and input transformations.\n\nHere's a list of high-level product features:\n\n*   **Event/Action Matching:** Define which events and actions trigger a Hog Function.\n*   **Event Filtering:** Filter events based on properties, feature flags, and other criteria.\n*   **Input Transformation:** Transform event data into inputs for the Hog Function.\n*   **Mapping Management:** Add, duplicate, remove, and enable/disable mappings.\n*   **Input Variable Definition:** Define custom input variables for the function.\n*   **Mapping Templates:** Use pre-defined mapping templates for common use cases.\n*   **Mapping Summary:** Provides a concise summary of each mapping's configuration.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/mapping",
        "summary": "The code provides a React-based user interface for configuring mappings between events/actions and Hog Functions within a PostHog pipeline. Users can define triggers based on specific events or actions, apply filters to narrow down the events that activate the function, and transform event data into suitable input variables for the function. The UI supports managing these mappings through adding, duplicating, removing, and enabling/disabling functionalities, allowing for flexible and customizable pipeline configurations.\n\nHere's a list of high-level product features:\n\n*   **Event/Action Matching:** Define which events and actions trigger a Hog Function.\n*   **Event Filtering:** Filter events based on properties, feature flags, and other criteria.\n*   **Input Transformation:** Transform event data into inputs for the Hog Function.\n*   **Mapping Management:** Add, duplicate, remove, and enable/disable mappings.\n*   **Input Variable Definition:** Define custom input variables for the function.\n*   **Mapping Templates:** Use pre-defined mapping templates for common use cases.\n*   **Mapping Summary:** Provides a concise summary of each mapping's configuration.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/metrics/HogFunctionEventEstimates.tsx",
        "summary": "The `HogFunctionEventEstimates` component provides insights into the potential impact of a HogFunction by estimating the number of events it would have triggered over the past 7 days. It displays this estimate as a sparkline chart and provides warnings if the trigger count exceeds a defined threshold. Users can toggle a view to display a sample of the matching events in a table and open the event data in either a new Insight or a new Canvas for further analysis.\n\nHere's a list of high-level product features:\n\n*   **Event Trigger Estimation:** Estimates the number of times a HogFunction would have triggered in the last 7 days.\n*   **Sparkline Visualization:** Displays the event trigger estimates as a sparkline chart.\n*   **Threshold-Based Warnings:** Shows a warning banner if the estimated trigger count exceeds a defined threshold.\n*   **Event Sample Display:** Allows users to view a sample of the events that would have triggered the HogFunction.\n*   **Integration with Insights:** Provides a button to open the event data in a new Insight for further analysis.\n*   **Integration with Canvases:** Provides a button to open the event data in a new Canvas for further analysis.\n*   **Toggleable Event List:** Allows users to show or hide the list of matching events."
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/metrics",
        "summary": "The HogFunctionEventEstimates component enhances the user's understanding of a HogFunction's behavior by estimating its impact over the past week. It visualizes the estimated trigger count using a sparkline chart and alerts the user if a predefined threshold is exceeded. The component also allows users to inspect a sample of the events that would have triggered the function and provides seamless integration with Insights and Canvases for in-depth analysis. Users can toggle the visibility of the event sample list for focused analysis.\n\nHere's a list of high-level product features:\n\n*   Event Trigger Estimation\n*   Sparkline Visualization\n*   Threshold-Based Warnings\n*   Event Sample Display\n*   Integration with Insights\n*   Integration with Canvases\n*   Toggleable Event List\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/HogFunctionIcon.tsx",
        "summary": "This code defines two React components, `HogFunctionIcon` and `HogFunctionIconEditable`, for displaying and editing icons associated with Hog Functions. The `HogFunctionIcon` component displays an icon, either from a provided URL or a default hedgehog icon, with optional sizing. The `HogFunctionIconEditable` component wraps the `HogFunctionIcon` in a popover, allowing users to change the icon. It provides options to upload a custom image, search for company logos, and select from a list of possible icons. The component uses `kea` for state management and actions, and `lemon-ui` components for UI elements.\n\nHere's a list of high-level product features:\n\n*   **Icon Display:** Displays an icon for a Hog Function, supporting different sizes.\n*   **Custom Icon Upload:** Allows users to upload a custom image as an icon.\n*   **Icon Search:** Enables users to search for company logos to use as icons.\n*   **Icon Selection:** Provides a list of possible icons for users to choose from.\n*   **Editable Icon:** Wraps the icon in a popover to allow users to change the icon.\n*   **Base64 Conversion:** Converts uploaded images to base64 data URIs for storage and display.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/email-templater/emailTemplaterLogic.tsx",
        "summary": "This code defines a Kea logic module called `emailTemplaterLogic` that manages the state and actions for an email template editor component. It handles loading, saving, and managing the email template design, HTML, and other related data. The logic connects to a parent form logic to retrieve and update email template data, and it uses a modal to display the email editor. It also includes functionality to escape curly braces in the HTML to prevent issues with templating engines.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Email Template Editor Integration:** Provides the logic to integrate an email template editor (likely react-email-editor) into a larger form or application.\n*   **Email Template Saving:** Allows users to save the design and HTML content of an email template.\n*   **Email Template Loading:** Enables loading existing email template designs into the editor.\n*   **Modal Management:** Manages the display of the email editor within a modal.\n*   **Form Integration:** Connects to a parent form logic to retrieve and update email template data seamlessly.\n*   **HTML Escaping:** Escapes curly braces in the HTML content to prevent conflicts with templating engines.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/activityDescriptions.tsx",
        "summary": "This code defines components and functions for displaying activity logs related to Hog Functions within a PostHog pipeline. It provides human-readable descriptions of events like creation, deletion, and updates to Hog Functions, including displaying diffs of changes to code, input schemas, and other fields. The code leverages Monaco Editor for displaying code diffs and Lemon UI components for dropdowns and links. It also handles displaying user names and links to Hog Function details.\n\nHere's a list of high-level product features that can be derived from this code:\n\n*   **Activity Logging for Hog Functions:** Tracks and displays a history of actions performed on Hog Functions.\n*   **Human-Readable Activity Descriptions:** Converts raw activity log data into user-friendly descriptions of events.\n*   **Code Diffing:** Allows users to view the differences between versions of Hog function code, input schemas, and other text-based fields.\n*   **User Attribution:** Identifies the users responsible for specific actions on Hog Functions.\n*   **Navigation to Hog Function Details:** Provides links to view the details of specific Hog Functions from the activity log.\n*   **Input Change Highlighting:** Highlights specific input values that have been changed.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/urls.ts",
        "summary": "This code defines URL generation functions for different types of Hog Functions within a data pipeline. It handles creating new Hog Function URLs, retrieving existing Hog Function URLs, and mapping Hog Function types to Pipeline Stages. The code supports email, broadcast, and internal destination (specifically error tracking) Hog Function types, as well as generic pipeline nodes for destinations, transformations, and site apps. It leverages a central `urls` object (imported from `scenes/urls`) to construct the actual URLs based on the provided type, ID, and template.\n\nHere's a list of high-level product features supported by this code:\n\n*   **Email Integration:** Creating and managing email-based Hog Functions.\n*   **Broadcast Messaging:** Creating and managing broadcast messaging Hog Functions.\n*   **Error Tracking Alerts:** Configuring and managing alerts for error tracking.\n*   **Data Pipeline Destination Management:** Creating and managing destinations within a data pipeline.\n*   **Data Pipeline Transformation Management:** Creating and managing transformations within a data pipeline.\n*   **Site App Integration:** Creating and managing Site App integrations within a data pipeline.\n*   **URL Generation:** Dynamically generating URLs for different Hog Function types and pipeline stages.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/email-templater/EmailTemplater.tsx",
        "summary": "The `EmailTemplater.tsx` file defines a React component for creating and editing email templates within a PostHog application. It provides a form with fields for \"From\", \"To\", and \"Subject\", each powered by an inline code editor for dynamic content. The component supports two modes: \"full\" for a complete email editor experience using `react-email-editor`, and \"preview\" which displays an `iframe` preview of the email and allows editing the HTML content in a modal. The modal provides a full email editor interface for detailed template customization.\n\nHere's a list of high-level product features:\n\n*   **Email Template Creation:** Allows users to create email templates with fields for \"From\", \"To\", and \"Subject\".\n*   **Inline Code Editors:** Provides inline code editors for dynamic content within the email fields.\n*   **Full Email Editor Mode:** Integrates a full-featured email editor (`react-email-editor`) for comprehensive template design.\n*   **HTML Preview Mode:** Displays an `iframe` preview of the email template.\n*   **Modal-Based HTML Editing:** Enables users to edit the HTML content of the email template in a modal window.\n*   **Dynamic Content Support:** Supports dynamic content injection into email templates using code.\n*   **Template Saving:** Allows users to save the created email templates.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/hogFunctionTestLogic.tsx",
        "summary": "This code defines the logic for testing Hog Functions within the PostHog platform. It manages the state and actions related to configuring test invocations, running tests, and displaying results. The logic handles parsing and validating JSON inputs for test globals, saving and managing previously used globals, and displaying test results in both raw and diff modes. It also includes functionality for handling transformation-specific event structures and scrolling to the first difference in the Monaco editor when displaying test results.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Hog Function Testing:** Allows users to test their Hog Functions with custom input.\n*   **Test Configuration:** Enables users to configure test invocations with globals and mock async functions.\n*   **JSON Validation:** Validates the JSON input for test globals with error highlighting.\n*   **Saved Globals:** Allows users to save and reuse frequently used test globals.\n*   **Test Result Display:** Displays test results in raw and diff modes.\n*   **Transformation Event Handling:** Handles transformation-specific event structures for testing.\n*   **Monaco Editor Integration:** Integrates with the Monaco editor for displaying and navigating test results.\n*   **Error Handling:** Provides error messages and feedback for invalid configurations and test failures.\n*   **Automatic Scrolling:** Automatically scrolls to the first difference in the Monaco editor when displaying test results.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/email-templater",
        "summary": "The email templater feature provides a comprehensive solution for creating and managing email templates within the PostHog application. It offers a user-friendly interface with inline code editors for dynamic content in the \"From\", \"To\", and \"Subject\" fields, along with a full email editor mode powered by `react-email-editor` for detailed design customization. Users can preview their templates in an `iframe` and further refine the HTML content within a modal, ensuring precise control over the final email appearance. The system also handles loading, saving, and integrating with parent forms, including escaping curly braces to prevent conflicts with templating engines.\n\n*   Email Template Creation\n*   Inline Code Editors for Dynamic Content\n*   Full Email Editor Integration\n*   HTML Preview\n*   Modal-Based HTML Editing\n*   Email Template Saving\n*   Email Template Loading\n*   Form Integration\n*   HTML Escaping\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/integrations/HogFunctionInputIntegration.tsx",
        "summary": "This code defines a React component, `HogFunctionInputIntegration`, responsible for rendering an integration choice within a Hog Function configuration interface. It leverages the `IntegrationChoice` component to present integration options based on a provided schema, which includes the integration type and a key. The component also uses `kea` for state management, specifically to persist data before redirecting to an integration configuration page. The `persistForUnload` action ensures that any unsaved changes are stored before the user is redirected to configure the selected integration.\n\n**Features:**\n\n*   **Integration Selection:** Allows users to select an integration for a specific Hog Function input.\n*   **Dynamic Integration Configuration:** Dynamically renders integration configuration options based on the selected integration type.\n*   **Data Persistence:** Persists unsaved changes before redirecting to the integration configuration page, preventing data loss.\n*   **Redirection to Configuration:** Redirects the user to a dedicated page for configuring the selected integration.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/integrations/HogFunctionInputIntegrationField.tsx",
        "summary": "This component, `HogFunctionInputIntegrationField`, dynamically renders input fields for Hog Function configurations based on defined schemas and external integrations. It fetches integration data and configuration details to display appropriate pickers for services like Slack, Google Ads, and LinkedIn Ads. The component handles dependencies between fields, displaying messages to guide users to configure required fields or integrations before proceeding. It also manages loading states and error conditions arising from misconfigurations or unsupported integration types.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Dynamic Input Field Rendering:** Renders different input fields based on the schema definition for Hog Function inputs.\n*   **Integration Support:** Provides specific input components for integrations with Slack, Google Ads, and LinkedIn Ads.\n*   **Dependency Management:** Handles dependencies between input fields, prompting users to configure required fields before others.\n*   **Integration Configuration Guidance:** Guides users to configure necessary integrations before using related input fields.\n*   **Loading State Handling:** Displays a loading skeleton while integration data is being fetched.\n*   **Error Handling:** Displays error messages for misconfigurations, missing required fields, or unsupported integration types.\n*   **Value Handling:** Manages the input value and provides a callback function for onChange events.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/integrations/IntegrationChoice.tsx",
        "summary": "The `IntegrationChoice` component provides a user interface for selecting and configuring integrations within PostHog, specifically for Hog functions. It dynamically renders options based on the integration type (`kind`) and existing integrations of that type. Users can connect to new integrations, upload Google Cloud key files, manage existing integrations, and clear their selection. The component uses Lemon UI components for a consistent look and feel and leverages the `integrationsLogic` Kea logic for managing integration data.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Integration Selection:** Allows users to choose from a list of available integrations of a specific type (e.g., Google Pub/Sub, Google Cloud Storage, Google Ads, LinkedIn Ads).\n*   **Integration Connection:** Enables users to connect to new integrations via OAuth or by uploading a Google Cloud .json key file.\n*   **Integration Management:** Provides a link to the project integrations settings page for managing all integrations.\n*   **Integration Clearing:** Allows users to clear their current integration selection.\n*   **Integration Display:** Shows the currently selected integration using the `IntegrationView` component.\n*   **Dynamic UI:** Adapts the UI based on the integration type and the availability of existing integrations.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/HogFunctionInputs.tsx",
        "summary": "This code defines React components for managing and rendering inputs for Hog Function configurations within PostHog. It provides a user interface for defining input schemas, including their type, label, description, and default values. The components support various input types such as string, boolean, dictionary, choice, JSON, integration, and email templates, each with specific rendering and editing capabilities. Drag and drop functionality is used to sort the inputs.\n\nHere's a list of high-level product features:\n\n*   **Input Schema Definition:** Allows users to define the schema for Hog Function inputs, including type, label, description, and whether the input is required or a secret.\n*   **Input Type Support:** Supports a variety of input types, including string, boolean, dictionary, choice, JSON, integration (Slack, Salesforce, Hubspot), and email templates.\n*   **Dynamic Input Rendering:** Renders input fields dynamically based on the defined schema.\n*   **Templating Support:** Enables templating within string and JSON input fields using HogQL.\n*   **Dictionary Input:** Provides a key-value pair input for dictionary types.\n*   **Choice Input:** Allows users to select from a predefined list of choices.\n*   **JSON Input:** Provides a code editor for editing JSON inputs.\n*   **Integration Input:** Facilitates integration with external services like Slack, Salesforce, and Hubspot.\n*   **Email Template Input:** Provides a dedicated editor for creating and managing email templates.\n*   **Drag and Drop Sorting:** Enables users to reorder input fields using drag and drop.\n*   **Input Validation:** Validates input values based on the schema.\n*   **Default Value Support:** Allows users to specify default values for input fields.\n*   **Code Editor Integration:** Integrates with a code editor (Monaco) for JSON and template editing.\n*   **Secret Input Masking:** Provides an option to mark inputs as \"secret,\" likely masking their values in the UI."
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/HogFunctionConfiguration.tsx",
        "summary": "This code defines the `HogFunctionConfiguration` component, a React component in a PostHog application that allows users to configure and manage Hog Functions. Hog Functions are server-side functions that can be used to process events in a data pipeline. The component provides a UI for editing the function's name, description, icon, source code, inputs, filters, and mappings. It also displays the function's status, allows enabling/disabling the function, and provides testing capabilities. The component handles different types of Hog Functions, including destinations, transformations, and broadcasts, and adapts its UI based on the function type and available feature flags. It also integrates with PostHog's paygate to restrict access to certain features based on the user's plan.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Hog Function Configuration:** Allows users to create, edit, and manage Hog Functions.\n*   **Function Definition:** Enables users to define the function's name, description, and icon.\n*   **Source Code Editor:** Provides a code editor for writing the function's source code (Hog code).\n*   **Input Management:** Allows users to define and configure input parameters for the function.\n*   **Data Mapping:** Enables users to map event properties to function inputs.\n*   **Filtering:** Allows users to define filters to control which events are processed by the function.\n*   **Status Monitoring:** Displays the function's current status (e.g., enabled, disabled, error).\n*   **Testing:** Provides a testing interface to validate the function's behavior.\n*   **Duplication:** Allows users to duplicate existing Hog Functions.\n*   **Template Management:** Supports creating functions from templates and updating functions to the latest template version.\n*   **Paygate Integration:** Restricts access to certain features based on the user's PostHog plan.\n*   **Event Volume Estimation:** Estimates the volume of events that will be processed by the function.\n*   **Integration with Destinations:** Allows configuring destinations to send data to external services.\n*   **Transformation Functionality:** Supports transformation functions to modify event data.\n*   **Broadcast Functionality:** Supports broadcast functions to send data to multiple destinations.\n*   **Filter Error Handling:** Displays errors related to filter bytecode.\n*   **Rate Limit Warnings:** Displays warnings about rate limits imposed by receiving destinations.\n*   **Person Count Display:** Shows the number of persons affected by a broadcast function.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/integrations",
        "summary": "The Hog Function integration components provide a comprehensive user interface for connecting and configuring external integrations within PostHog. Users can select from a list of available integrations, connect to new integrations via OAuth or file upload, manage existing integrations, and clear their selection. The system dynamically renders input fields based on the schema definition for Hog Function inputs, handles dependencies between fields, and guides users to configure required integrations before proceeding. Data persistence ensures no data loss during redirection to integration configuration pages, and loading states and error messages provide a smooth and informative user experience.\n\n**Features:**\n\n*   Integration Selection: Choose from available integrations for Hog Functions.\n*   Integration Connection: Connect to new integrations via OAuth or file upload.\n*   Integration Management: Manage existing integrations through a dedicated settings page.\n*   Dynamic Input Field Rendering: Render input fields based on the schema definition.\n*   Dependency Management: Handle dependencies between input fields, guiding users through configuration.\n*   Data Persistence: Persist unsaved changes before redirecting to configuration pages.\n*   Loading and Error Handling: Provide informative loading states and error messages.\n*   Integration Configuration Guidance: Guide users to configure necessary integrations.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/logs/LogsViewer.tsx",
        "summary": "The `LogsViewer` component provides a user interface for viewing and filtering logs. It fetches logs, allows filtering by search term, log level, and date range, and displays them in a table. Users can expand log entries to see individual messages within a grouped log. The component also supports loading more logs and revealing hidden logs.\n\nHere's a list of high-level features:\n\n*   **Log Display:** Displays logs in a tabular format with columns for timestamp, invocation ID, log level, and last message.\n*   **Filtering:**\n    *   **Search:** Allows users to search logs by message content.\n    *   **Log Level:** Filters logs by selecting specific log levels (e.g., debug, info, warning, error).\n    *   **Date Range:** Filters logs by a specified date range.\n*   **Log Expansion:** Allows users to expand grouped log entries to view individual log messages with timestamps and levels.\n*   **Loading More Logs:** Provides a button to load older log entries in batches.\n*   **Revealing Hidden Logs:** Provides a button to reveal newer log entries that were initially hidden.\n*   **Timestamp Display:** Displays timestamps with timezone information.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/HogFunctionTest.tsx",
        "summary": "This code provides a React component, `HogFunctionTest`, for testing Hog functions within the PostHog platform. It allows users to input test data (globals), execute the function, and view the results. The component features a JSON editor with validation, options to mock async functions, load sample globals from existing events, save and load test data sets, and display test results in different modes. It integrates with kea-logic for state management and form handling.\n\nHere's a list of high-level product features:\n\n*   **Hog Function Testing:** Enables users to test Hog functions with custom input data.\n*   **JSON Editor with Validation:** Provides a code editor for inputting test data in JSON format with real-time validation and error highlighting.\n*   **Mocking Async Functions:** Allows users to mock or enable real HTTP requests during testing.\n*   **Sample Globals Loading:** Fetches and populates test data from existing events.\n*   **Test Data Management:** Enables users to save and load test data sets for reuse.\n*   **Test Result Display:** Shows the results of the function execution.\n*   **Toggleable Expanded View:** Collapsible UI to show or hide the testing interface.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/logs/HogFunctionLogs.tsx",
        "summary": "This React component, `HogFunctionLogs`, displays logs for a specific Hog Function and provides functionality to retry failed invocations. It fetches logs using the `LogsViewer` component and adds a custom \"Status\" column to the log table. The component allows users to select individual or all invocations for retry, displaying a confirmation dialog before initiating the retry process. The status of each log entry (success, failure, or running) is displayed with a corresponding tag, and users can navigate to the associated event or retry the event directly from the log entry.\n\n**Features:**\n\n*   **Log Display:** Displays logs for a specific Hog Function.\n*   **Status Indication:** Shows the status of each log entry (success, failure, running) with a color-coded tag.\n*   **Invocation Retry:** Allows users to retry failed Hog Function invocations.\n*   **Bulk Selection:** Enables users to select multiple invocations for retry.\n*   **Retry Confirmation:** Presents a confirmation dialog before retrying invocations.\n*   **Event Navigation:** Provides a link to view the event associated with a log entry.\n*   **Individual Retry:** Allows users to retry a single event directly from the log entry.\n*   **Selecting Many:** Allows users to select individual events for retry.\n*   **Select All:** Allows users to select all events for retry.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/logs/logsViewerLogic.tsx",
        "summary": "This code defines a Kea logic module called `logsViewerLogic` that manages the display and filtering of logs for a specific source (e.g., a Hog Function). It fetches logs from an API, groups them by instance ID, and allows users to filter them by log level, search term, and date range. The logic also handles loading more logs, both older and newer, and manages a \"hidden logs\" list for logs that are newer than the currently displayed logs. The component polls for new logs every 5 seconds.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Log Display:** Displays grouped log entries with details like instance ID, timestamps, log level, and messages.\n*   **Log Filtering:** Allows filtering logs by log level (DEBUG, LOG, INFO, WARNING, ERROR), search term, and date range.\n*   **Log Loading:** Fetches initial logs and provides functionality to load older logs (pagination) and newer logs (real-time updates).\n*   **Real-time Updates:** Automatically polls for and displays new log entries.\n*   **Log Grouping:** Groups log entries by instance ID for better organization.\n*   **Expandable Rows:** Allows users to expand rows to view detailed log entries for a specific instance.\n*   **Hidden Logs:** Manages logs newer than the current view, allowing users to reveal them.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/logs/hogFunctionLogsLogic.ts",
        "summary": "This code defines a Kea logic module, `hogFunctionLogsLogic`, responsible for managing and displaying logs related to HogQL function invocations. It provides functionality for selecting, retrying, and displaying logs, including fetching related event data from ClickHouse to facilitate retries. The logic connects to a `logsViewerLogic` module to display the logs. It also handles user interactions such as selecting logs for retry, retrying invocations, and displaying status updates via lemonToast notifications.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Log Display:** Displays logs associated with HogQL function invocations, grouped by invocation ID.\n*   **Log Filtering:** Leverages `logsViewerLogic` to filter logs based on various criteria (not explicitly defined in this module but inherited).\n*   **Event Association:** Associates log entries with specific events in ClickHouse, enabling retrieval of event data for retries.\n*   **Invocation Retry:** Allows users to retry failed HogQL function invocations, using the associated event data.\n*   **Bulk Retry:** Supports retrying multiple selected invocations at once.\n*   **Retry Status Tracking:** Tracks the status of retry attempts (pending, success, failure) and provides visual feedback to the user.\n*   **User Notifications:** Provides user feedback through lemonToast notifications for retry operations (success, failure, pending).\n*   **Before Unload Protection:** Warns users if they attempt to leave the page while retries are in progress, preventing data loss.\n*   **Log Selection:** Allows users to select individual logs for retry.\n*   **Select All Logs:** Allows users to select all logs for retry."
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/logs",
        "summary": "The provided code collectively implements a comprehensive log management and retry system for HogQL function invocations. It features real-time log display with grouping, filtering, and detailed views, coupled with the ability to retry failed invocations, either individually or in bulk, with status tracking and user notifications. The system also ensures data integrity by preventing accidental page exits during retry operations.\n\n**Features:**\n\n*   **Real-time Log Display:** Displays logs in a tabular format, grouped by invocation ID, with timestamps, log levels, and message content.\n*   **Log Filtering:** Allows users to filter logs by search term, log level (DEBUG, LOG, INFO, WARNING, ERROR), and date range.\n*   **Log Expansion:** Enables users to expand grouped log entries to view individual log messages with timestamps and levels.\n*   **Log Loading & Pagination:** Supports loading older logs in batches and revealing newer, initially hidden logs.\n*   **Invocation Retry:** Allows users to retry failed HogQL function invocations, both individually and in bulk.\n*   **Event Association & Data Retrieval:** Associates log entries with specific events in ClickHouse, enabling retrieval of event data for retries.\n*   **Retry Status Tracking:** Tracks the status of retry attempts (pending, success, failure) and provides visual feedback.\n*   **User Notifications:** Provides user feedback through lemonToast notifications for retry operations.\n*   **Before Unload Protection:** Warns users if they attempt to leave the page while retries are in progress.\n*   **Status Indication:** Shows the status of each log entry (success, failure, running) with a color-coded tag.\n*   **Event Navigation:** Provides a link to view the event associated with a log entry.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/list/LinkedHogFunctions.tsx",
        "summary": "The `LinkedHogFunctions` component conditionally renders either a list of existing Hog Functions (`HogFunctionList`) or a list of Hog Function templates (`HogFunctionTemplateList`) for creating new Hog Functions. The component takes props to filter the Hog Functions displayed, specify the type of Hog Function, and control the display of the \"New notification\" button, which toggles between the two lists. The component uses the `LemonButton` component from `@posthog/lemon-ui` for the \"New notification\" and \"Cancel\" buttons.\n\nHere's a list of high-level product features:\n\n*   **Display Existing Hog Functions:** Shows a list of existing Hog Functions based on specified filters and type.\n*   **Create New Hog Functions from Templates:** Allows users to create new Hog Functions by selecting from a list of pre-defined templates.\n*   **Filtering Hog Functions:** Supports filtering of Hog Functions based on various criteria.\n*   **Toggle Between Existing and New Hog Functions:** Provides a button to switch between viewing existing Hog Functions and creating new ones from templates.\n*   **Disable New Function Creation:** Allows disabling the creation of new Hog Functions with a specified reason.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/list/hogFunctionTemplateListLogic.tsx",
        "summary": "This code defines a Kea logic module named `hogFunctionTemplateListLogic` responsible for managing and displaying a list of Hog Function templates in the PostHog pipeline. It handles fetching templates of a specific type (e.g., destination), filtering them based on search terms and user permissions, and generating URLs for creating new Hog Functions from these templates. The logic also synchronizes the filter state with the URL when enabled.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Template Listing:** Displays a list of available Hog Function templates based on type and sub-template.\n*   **Filtering:** Allows users to filter templates by search terms.\n*   **Access Control:** Filters templates based on user permissions (e.g., staff status for alpha templates).\n*   **URL Generation:** Generates URLs for creating new Hog Functions from templates, pre-populating configuration with relevant filters.\n*   **URL Synchronization:** Keeps the filter state synchronized with the URL for shareability and bookmarking.\n*   **Free vs Paid Template Differentiation:** Differentiates between free and paid templates.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/list/HogFunctionTemplateList.tsx",
        "summary": "This component, `HogFunctionTemplateList`, displays a list of Hog Function templates within a PostHog pipeline. It allows users to search and filter templates, view their names and descriptions, and create new Hog Functions from the templates. The list also indicates if a user needs to upgrade their plan to enable a specific Hog Function. The component uses Lemon UI components for the table, search input, and buttons, and integrates with the PostHog icons and paygate functionality.\n\nHere's a list of high-level product features:\n\n*   **Display Hog Function Templates:** Shows a list of available Hog Function templates with their names, descriptions, and icons.\n*   **Search and Filter Templates:** Allows users to search for templates by name.\n*   **Create Hog Functions from Templates:** Enables users to create new Hog Functions based on selected templates.\n*   **Plan Upgrade Indication:** Informs users if a specific Hog Function requires a plan upgrade, linking to the paygate.\n*   **Template Status Indication:** Displays the status of a template using tags.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/hogFunctionIconLogic.ts",
        "summary": "This code defines a Kea logic module named `hogFunctionIconLogic` responsible for managing the state and behavior related to selecting and displaying icons for Hog Functions within a pipeline. It handles loading a list of possible icons based on a search term, managing the visibility of a popover for icon selection, and updating the search term used to filter the icons. The logic includes actions for triggering icon loading and setting the popover's visibility and search term, reducers for managing the `showPopover` and `searchTerm` state variables, and a loader for fetching the `possibleIcons` from an API endpoint.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Icon Selection:** Allows users to select an icon for a Hog Function from a list of available icons.\n*   **Searchable Icon Library:** Provides a search interface to filter and find specific icons within the library.\n*   **Popover Interface:** Uses a popover to display the icon selection options, improving the user experience.\n*   **Asynchronous Icon Loading:** Loads icons asynchronously from an API, preventing UI blocking and improving performance.\n*   **Temporary Icon URLs:** Uses temporary URLs for icons, potentially for previewing or caching purposes.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/list/hogFunctionListLogic.tsx",
        "summary": "This code defines the logic for managing a list of Hog Functions (data processing functions) in a PostHog pipeline. It handles fetching, filtering, searching, enabling/disabling, and deleting Hog Functions. The logic also synchronizes filter settings with the URL for persistence and sharing. It uses kea for state management, fuse.js for fuzzy searching, and the PostHog API for interacting with Hog Functions.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Hog Function Listing:** Display a list of available Hog Functions, categorized by type.\n*   **Filtering:** Filter the list of Hog Functions based on various criteria (e.g., search term, enabled/paused status).\n*   **Fuzzy Search:** Search for Hog Functions by name or description using fuzzy matching.\n*   **Enable/Disable:** Toggle the enabled status of a Hog Function.\n*   **Deletion:** Delete a Hog Function with undo functionality.\n*   **URL Synchronization:** Persist and share filter settings via the URL.\n*   **Access Control:** Restrict enabling new destinations based on the Data Pipelines add-on.\n*   **Hidden Functions:** Hide functions based on user status.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/list/HogFunctionsList.tsx",
        "summary": "This React component, `HogFunctionsList`, displays a list of Hog Functions (destinations) in a table format. It allows users to search, filter (by paused status), and view Hog Functions. Each Hog Function entry displays its icon, name (as a link to its configuration page), a sparkline graph of its recent activity, its last updated time, and its current status (Active/Paused). Users can also pause/unpause and delete Hog Functions via a \"More\" dropdown menu. The component fetches and manages the Hog Function data using the `hogFunctionListLogic` Kea logic hook.\n\nHere's a list of high-level product features:\n\n*   **Display Hog Function List:** Shows a list of available Hog Functions (destinations) in a tabular format.\n*   **Search and Filter:** Allows users to search for specific Hog Functions and filter them based on their paused status.\n*   **Hog Function Details:** Displays key information for each Hog Function, including its icon, name, description, status, and last updated time.\n*   **Link to Configuration:** Provides a link to the configuration page for each Hog Function.\n*   **Activity Sparkline:** Shows a sparkline graph representing the recent activity of each Hog Function.\n*   **Pause/Unpause Functionality:** Enables users to pause or unpause Hog Functions.\n*   **Delete Functionality:** Allows users to delete Hog Functions.\n*   **Status Indication:** Clearly indicates the status (Active/Paused) of each Hog Function.\n*   **Empty State Handling:** Displays appropriate messages when no Hog Functions are found or when no Hog Functions match the applied filters.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/list",
        "summary": "The provided code collectively enables a comprehensive Hog Function management system within PostHog, allowing users to discover, create, manage, and monitor data processing functions. This system provides features for listing both existing Hog Functions and templates for creating new ones, with robust filtering and search capabilities. Users can easily enable/disable, delete, and configure Hog Functions, while also being informed about plan requirements for specific functions. The system also ensures a consistent user experience by synchronizing filter settings with the URL and providing clear indications of function status and activity.\n\nHere's a list of high-level product features:\n\n*   Hog Function Listing: Display a list of available Hog Functions, categorized by type.\n*   Template Listing: Displays a list of available Hog Function templates based on type and sub-template.\n*   Filtering: Filter the list of Hog Functions and templates based on various criteria (e.g., search term, enabled/paused status).\n*   Fuzzy Search: Search for Hog Functions and templates by name or description using fuzzy matching.\n*   Enable/Disable: Toggle the enabled status of a Hog Function.\n*   Deletion: Delete a Hog Function with undo functionality.\n*   Create Hog Functions from Templates: Allows users to create new Hog Functions by selecting from a list of pre-defined templates.\n*   URL Synchronization: Persist and share filter settings via the URL.\n*   Access Control: Restrict enabling new destinations based on the Data Pipelines add-on and user permissions.\n*   Hog Function Details: Displays key information for each Hog Function, including its icon, name, description, status, and last updated time.\n*   Activity Sparkline: Shows a sparkline graph representing the recent activity of each Hog Function.\n*   Plan Upgrade Indication: Informs users if a specific Hog Function requires a plan upgrade, linking to the paygate.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions/HogFunctionStatusIndicator.tsx",
        "summary": "The `HogFunctionStatusIndicator` component provides a visual representation of the status of a Hog Function (either a site app or a site destination) within PostHog. It uses a Lemon Tag to display the status (e.g., Active, Degraded, Disabled) and a Lemon Dropdown to provide a more detailed description of the status. The status is determined based on the `HogWatcherState` of the function or whether the function is manually enabled/disabled.\n\nHere's a list of high-level product features:\n\n*   **Hog Function Status Display:** Visually indicates the operational status of a Hog Function using a color-coded tag.\n*   **Detailed Status Description:** Provides a more detailed explanation of the function's status via a dropdown.\n*   **Status States:** Supports various status states including \"Active\", \"Degraded\", \"Disabled Temporarily\", \"Disabled\", \"Paused\" and \"Unknown\".\n*   **Manual Enable/Disable Handling:** Reflects the status of Hog Functions that are manually enabled or disabled.\n*   **Differentiation between Site Apps/Destinations and other Hog Functions:** Handles status display differently based on the type of Hog Function.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/hogfunctions",
        "summary": "The Hog Function feature within PostHog empowers users to create, manage, and monitor server-side functions for processing events in a data pipeline. This includes a comprehensive suite of tools for configuring function logic, defining input schemas, mapping event data, and applying filters to control function execution. Users can leverage pre-built templates, test functions with custom data, visualize performance metrics, and track activity logs for auditing and debugging. The system also supports integrations with external services, email templating, and robust error handling with retry mechanisms, all while providing a user-friendly interface with real-time feedback and contextual guidance.\n\nHere's a list of high-level product features:\n\n*   Hog Function Creation and Editing\n*   Template Management\n*   Configuration Validation and Data Sanitization\n*   Event Filtering and Mapping\n*   Input Schema Definition and Management\n*   Testing and Debugging Tools\n*   Real-time Log Management and Retry System\n*   Integration with External Services\n*   Email Templating\n*   Activity Logging and Auditing\n*   Performance Monitoring and Visualization\n*   Role-Based Access Control and Paygate Integration\n*   Icon Management\n*   URL Generation for Different Function Types\n*   Status Monitoring and Alerts\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/access.ts",
        "summary": "This code defines a set of functions that determine a user's access level to plugins based on their organization's `plugins_access_level`. The functions check if a user can globally manage plugins, install plugins (potentially for a specific organization), view plugins, and configure plugins. Each function takes an organization object as input and returns a boolean indicating whether the user has the required permissions.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Plugin Management:** Allows administrators to manage plugins across the entire platform.\n*   **Plugin Installation:** Enables users to install plugins, potentially with restrictions to specific organizations.\n*   **Plugin Visibility:** Controls which users can view the available plugins.\n*   **Plugin Configuration:** Grants users the ability to configure installed plugins.\n*   **Role-Based Access Control:** Implements role-based access control for plugins, allowing different levels of access based on user roles or organizational settings.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/importAppsLogic.tsx",
        "summary": "This code defines the `importAppsLogic` Kea logic which manages the state and side effects related to importing applications within a pipeline. It fetches and stores plugin definitions and configurations, allows toggling the enabled state of plugin configurations, and provides selectors to derive computed data such as a list of `ImportApp` objects and a boolean indicating whether any import apps are enabled. The logic interacts with the PostHog API to load plugins and plugin configurations, update plugin configurations, and capture plugin events.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Import App Management:** Allows users to view and manage a list of available import applications.\n*   **Plugin Configuration:** Enables users to configure individual import applications, including enabling or disabling them.\n*   **Dynamic Plugin Loading:** Fetches plugin definitions dynamically from the PostHog API.\n*   **Real-time Updates:** Updates the UI in real-time when plugin configurations are changed.\n*   **Permission Checks:** Enforces permission checks before enabling or disabling import apps.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/sources/SelfManaged.tsx",
        "summary": "This code defines a React component, `SelfManaged`, which is responsible for displaying and editing a data warehouse table's configuration. It fetches the table data using `dataWarehouseTableLogic` and provides a form (`DatawarehouseTableForm`) for updating the table's properties such as name, URL pattern, format, and credentials (access key and secret). The component also includes a \"Cancel\" button that navigates the user back to the pipeline page.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Data Warehouse Table Configuration:** Allows users to view and modify the configuration of a self-managed data warehouse table.\n*   **Table Property Editing:** Enables users to edit table properties like name, URL pattern, and format.\n*   **Credential Management:** Provides a mechanism for managing access key and secret credentials for the data warehouse table.\n*   **Form-based UI:** Uses a form to present and handle table configuration updates.\n*   **Navigation:** Includes a \"Cancel\" button to navigate back to the pipeline page.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/transformationsLogic.tsx",
        "summary": "This code defines the `pipelineTransformationsLogic` using Kea, a state management library. It manages the state and logic for pipeline transformations, which are plugins that process events in a data pipeline. The logic handles loading plugins and their configurations, enabling/disabling plugins, reordering plugins, and updating plugin configurations. It fetches data from the backend API, manages temporary ordering of plugins during reordering, and provides selectors for derived data like sorted transformations and the next available order for new plugins.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Plugin Management:** Loading, enabling, disabling, and updating pipeline transformation plugins.\n*   **Plugin Configuration:** Loading and managing configurations for each plugin.\n*   **Plugin Reordering:** Allows users to reorder the execution order of enabled plugins.\n*   **Data Transformation Pipeline:** Defines the order and execution of data transformation steps.\n*   **Real-time Updates:** Updates the UI in real-time when plugin configurations are changed.\n*   **Permissions Management:** Checks user permissions before allowing changes to plugin configurations.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/sources/Sources.tsx",
        "summary": "The `Sources` component renders a page for managing data warehouse sources within PostHog. It displays a page header with a \"New\" button for creating new sources. If no sources exist, it shows a product introduction explaining the purpose of data warehouse sources and linking to relevant documentation. The page then presents two tables: one for managed sources (where PostHog handles the connection) and another for self-managed sources (where the user configures the connection). The component uses the `dataWarehouseSettingsLogic` to fetch and display existing data warehouse sources.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Data Warehouse Source Management:** Allows users to manage data sources for importing external data into PostHog.\n*   **Managed Sources:** Provides a table to view and manage sources where PostHog handles the connection.\n*   **Self-Managed Sources:** Provides a table to view and manage sources where the user configures the connection.\n*   **\"New Source\" Creation:** Enables users to create new data warehouse sources.\n*   **Empty State Guidance:** Displays a product introduction when no data sources are configured, guiding users on how to get started.\n*   **Documentation Link:** Provides a link to the PostHog documentation for data warehouses.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/sourceAppInitialCode.tsx",
        "summary": "This code defines the initial code templates for different types of source plugins within a PostHog environment. It provides a function `getInitialCode` that returns a set of files (`plugin.json` and either `index.ts`, `site.ts`, or `frontend.tsx`) based on the specified `SourcePluginKind`. These templates include boilerplate code and configuration options to help users quickly create plugins for filtering events, modifying events, composing webhooks, or adding site/frontend functionalities. The `plugin.json` file defines the plugin's name and configuration schema, while the other files contain the actual code logic for the plugin.\n\nHere's a list of high-level product features based on the code:\n\n*   **Source Plugin Creation:** Allows users to create custom source plugins to extend PostHog's functionality.\n*   **Event Filtering:** Provides a template for plugins that can filter incoming events based on specified criteria.\n*   **Event Modification:** Offers a template for plugins that can modify event properties before they are processed.\n*   **Webhook Composition:** Enables the creation of plugins that can compose and send webhooks based on incoming events.\n*   **Site Integration:** Supports plugins that can inject code into a website.\n*   **Frontend Customization:** Allows users to create custom frontend components within the PostHog interface.\n*   **Configuration Management:** Provides a standardized way to define and manage plugin configurations through the `plugin.json` file.\n*   **Code Templates:** Offers pre-built code templates to accelerate plugin development.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/pipelineBatchExportConfigurationLogic.tsx",
        "summary": "This code defines the logic for configuring batch exports in a data pipeline, allowing users to define how data is exported to various destinations like Snowflake, S3, BigQuery, Postgres, and Redshift. It handles loading existing configurations, creating new ones, and managing the settings for each destination, including authentication, data models (events, persons, sessions), and filtering. The logic also includes definitions for the schema of the data being exported, such as the fields available in the events, persons, and sessions tables.\n\nHere's a list of high-level product features based on the code:\n\n*   **Batch Export Configuration:** Allows users to configure and manage batch data exports to various destinations.\n*   **Destination Support:** Supports multiple destination types, including Snowflake, S3, BigQuery, Postgres, and Redshift.\n*   **Data Model Selection:** Enables users to select the data model to export (events, persons, sessions).\n*   **Schema Definition:** Provides predefined schemas for events, persons, and sessions tables, defining the fields available for export.\n*   **Configuration Management:** Supports loading, creating, updating, and saving batch export configurations.\n*   **Authentication Handling:** Manages authentication settings for different destinations (e.g., password authentication for Snowflake).\n*   **Pausing/Resuming Exports:** Allows users to pause and resume batch exports.\n*   **Interval Configuration:** Enables users to set the interval for batch exports.\n*   **Data Filtering:** Supports filtering data before export.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/batchExportBackfillModalLogic.tsx",
        "summary": "This code defines a Kea logic module for managing a modal that allows users to backfill data for batch exports. It handles the state and actions related to opening and closing the modal, setting the earliest backfill option, and managing a form for specifying the start and end dates for the backfill. The form includes validation to ensure that the dates are valid and that the end date is not too far in the future. Upon submission, the form sends a request to the API to create the backfill job.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Open/Close Backfill Modal:** Allows users to open and close a modal for configuring batch export backfills.\n*   **Specify Backfill Date Range:** Enables users to define a specific start and end date for the backfill process.\n*   **Earliest Backfill Option:** Provides an option to backfill data from the earliest available date.\n*   **Date Validation:** Validates the start and end dates entered by the user to ensure they are valid and within acceptable limits.\n*   **API Integration:** Communicates with the backend API to initiate the batch export backfill process.\n*   **Error Handling:** Displays error messages to the user if there are issues with the backfill configuration or API request.\n*   **Timezone Awareness:** Considers the project's timezone when validating the end date.\n*   **Minute Interval Validation:** Validates that the start and end times are valid for minute-based batch exports."
    },
    {
        "path": "frontend/src/scenes/pipeline/sources",
        "summary": "The provided code implements features for managing and configuring data warehouse sources within PostHog, allowing users to import external data. It distinguishes between managed sources, where PostHog handles the connection, and self-managed sources, where users configure the connection themselves. Users can create new sources, view and edit existing source configurations (including table properties and credentials for self-managed sources), and are guided by an empty state introduction when no sources are configured.\n\n*   Data Warehouse Source Management:\n    *   Managed Sources: View and manage PostHog-managed connections.\n    *   Self-Managed Sources: View and manage user-configured connections.\n    *   New Source Creation: Create new data warehouse sources.\n*   Data Warehouse Table Configuration:\n    *   Table Property Editing: Edit table name, URL pattern, and format.\n    *   Credential Management: Manage access keys and secrets.\n*   User Guidance:\n    *   Empty State Guidance: Product introduction when no sources exist.\n    *   Documentation Link: Link to PostHog documentation.\n*   Navigation:\n    *   Cancel Button: Navigate back to the pipeline page.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/pipelineLogic.tsx",
        "summary": "This code defines the logic for the data pipeline feature in the application. It manages the current tab the user is viewing within the pipeline (Destinations, Sources, etc.), generates breadcrumbs for navigation, and integrates with the URL to maintain state and enable direct linking to specific tabs. It also provides context for the side panel, indicating that the activity scope is related to plugins.\n\nHere's a list of high-level product features:\n\n*   **Tabbed Navigation:** Allows users to switch between different sections of the data pipeline (e.g., Destinations, Sources).\n*   **URL-Based State Management:** The current tab is reflected in the URL, enabling direct linking and bookmarking.\n*   **Breadcrumb Navigation:** Provides a clear navigation path for users to understand their location within the data pipeline.\n*   **Side Panel Context:** Provides context to the side panel to show plugin related activity.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/PipelineNodeMetrics.tsx",
        "summary": "The `PipelineNodeMetrics.tsx` file provides a React component for visualizing metrics related to a specific pipeline node. It displays an overview of events processed successfully and failed, a time series graph of delivery trends, and a table of errors encountered during processing. Users can filter the data by date range and view detailed information about specific errors, including the error message, event payload, and stack trace.\n\nHere's a list of high-level product features:\n\n*   **Metrics Overview:** Displays total successes and failures for a pipeline node.\n*   **Delivery Trends Graph:** Visualizes success and failure rates over time.\n*   **Date Range Filtering:** Allows users to select a specific time period for the metrics.\n*   **Error Table:** Lists error types, counts, and last seen timestamps.\n*   **Error Details Modal:** Provides detailed information about specific errors, including the error message, event payload, and stack trace.\n*   **Collapsible Sections:** Allows users to expand and collapse sections of the error details modal to focus on specific information."
    },
    {
        "path": "frontend/src/scenes/pipeline/appCodeLogic.tsx",
        "summary": "This code defines a Kea logic module named `appsCodeLogic` responsible for managing and editing the source code of a plugin within a pipeline. It handles fetching plugin source code, displaying it in a user-friendly format, allowing users to edit the code, and submitting the changes back to the server. The logic also includes functionality for formatting the code using Prettier to ensure consistency and readability.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Plugin Source Code Viewing:** Allows users to view the source code files associated with a specific plugin.\n*   **Code Editing:** Enables users to modify the source code of plugin files directly within the application.\n*   **Syntax Highlighting and Formatting:** Provides syntax highlighting and automatic code formatting (using Prettier) for improved readability and code quality.\n*   **File Management:** Displays a list of available source code files for the plugin and allows users to switch between them.\n*   **Change Management:** Tracks changes made to the source code and allows users to submit these changes to update the plugin.\n*   **Error Handling:** Provides error handling and feedback during code formatting and submission.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/Transformations.tsx",
        "summary": "The `Transformations.tsx` file defines the UI for managing pipeline transformations within PostHog. It provides a page for creating, viewing, and managing transformations that modify incoming events before they are stored or sent to destinations. The UI includes a table displaying transformations with key information like name, status, and performance metrics, as well as actions to enable, disable, and reorder them. The page also includes an introduction to pipeline transformations and a section for managing destinations.\n\nHere's a list of high-level product features:\n\n*   **Transformation Management:** Create, view, edit, enable, disable, and reorder pipeline transformations.\n*   **Transformation Table:** Display transformations with details like name, status, last updated time, and performance metrics.\n*   **Performance Metrics:** Display a sparkline chart showing the performance of each transformation over the last 7 days.\n*   **Destination Management:** Manage destinations where transformed events are sent.\n*   **Access Control:** Restrict reordering transformations based on user permissions.\n*   **Product Introduction:** Provide an overview and documentation link for pipeline transformations.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/pipelineDefaultEnabledLogic.tsx",
        "summary": "This code defines a Kea logic module called `pipelineDefaultEnabledLogic` that manages the default enabled data pipeline transformations (plugins) in PostHog. It fetches plugins and their configurations, filters for plugins that have corresponding content mappings (like GeoIP), and transforms them into a list of `DefaultEnabledType` objects. These objects contain information about the plugin's title, description, ID, and enabled status, as well as a list of product onboarding pages where the plugin should be hidden. The logic connects to `pipelineTransformationsLogic` to access plugin data and the `toggleEnabled` action.\n\nHere's a list of high-level product features related to this code:\n\n*   **Data Pipeline Management:** Enables users to manage and configure data transformations applied to incoming events.\n*   **Default Enabled Plugins:** Provides a set of pre-configured plugins that are enabled by default for new PostHog instances.\n*   **Plugin Configuration:** Allows users to view and modify the settings of individual plugins.\n*   **IP Geolocation Enrichment:** Automatically enriches event data with location information based on IP addresses.\n*   **Product Onboarding Customization:** Hides specific plugins during the onboarding process for certain PostHog products (e.g., Session Replay).\n*   **Plugin Enable/Disable:** Allows users to toggle the enabled state of individual plugins.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/pipelinePluginConfigurationLogic.tsx",
        "summary": "This code defines the logic for configuring plugins within a data pipeline. It handles loading plugin details and configurations, updating plugin configurations, and managing form state for editing plugin settings. The logic supports different pipeline stages (Transformation, Destination, SiteApp, ImportApp) and ensures data consistency across the application by updating relevant lists upon successful configuration updates. It also includes checks for feature flags and add-on requirements before enabling new destinations.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Plugin Configuration:** Allows users to configure individual plugins within a data pipeline.\n*   **Plugin Management:** Enables users to manage plugins, including enabling/disabling, setting order, and editing descriptions.\n*   **Form Management:** Provides a form for editing plugin configurations with validation and submission handling.\n*   **Pipeline Stage Support:** Supports different stages in the data pipeline (Transformation, Destination, SiteApp, ImportApp).\n*   **Data Consistency:** Ensures that plugin configuration changes are reflected across the application.\n*   **Feature Flag Integration:** Integrates with feature flags to control access to certain features.\n*   **Add-on Requirement Checks:** Checks for add-on requirements before enabling new destinations.\n*   **Migration to Hog Function:** Allows migrating existing plugin configurations to Hog Function.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/AppsManagement.tsx",
        "summary": "This code defines the Apps Management scene in PostHog, a staff-only page for managing plugins (referred to as \"apps\"). It allows staff to install apps from URLs, local files (in development mode), or source code. The page displays installed apps in tables, categorized as global, local, or inline plugins, and provides actions to update, make global/local, and uninstall them. It also highlights apps that are out of sync with the global plugin state and allows checking for updates.\n\nHere's a list of high-level product features:\n\n*   **App Installation:** Install apps from URL, local files (dev mode), or source code.\n*   **App Listing:** Display installed apps categorized as global, local, and inline.\n*   **App Updates:** Check for and install updates for apps.\n*   **App Management:** Make apps global or local, uninstall apps.\n*   **App Code Viewing:** View the code of installed apps.\n*   **Global Plugin Synchronization:** Identify and resolve discrepancies between global and local plugin states.\n*   **App Capability Display:** Show the capabilities of each app, including methods, jobs, and scheduled tasks.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/appsManagementLogic.tsx",
        "summary": "This code defines the `appsManagementLogic` Kea logic which manages the installation, uninstallation, updating, and overall management of plugins within the PostHog application. It handles fetching plugins, managing plugin URLs and paths, and interacting with the PostHog API to perform plugin-related operations. The logic also includes checks for user permissions, displays error messages using lemonToast, and captures plugin-related events using PostHog's analytics. It also manages the state of plugin updates, including checking for available updates and displaying notifications.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Plugin Installation:** Allows users to install plugins from various sources, including repositories, custom URLs, local files, and source code.\n*   **Plugin Uninstallation:** Enables users to remove installed plugins.\n*   **Plugin Updates:** Provides functionality to check for and install updates for existing plugins.\n*   **Plugin Management:** Offers a centralized interface for managing installed plugins, including enabling/disabling and configuring them.\n*   **Global Plugin Management:** Supports the concept of global plugins that apply across the entire PostHog instance.\n*   **Permission Control:** Enforces permission checks to ensure only authorized users can install, uninstall, or update plugins.\n*   **Error Handling:** Displays user-friendly error messages for common plugin-related issues.\n*   **Analytics Tracking:** Captures plugin-related events for analytics purposes.\n*   **Source Code Plugin Creation:** Allows users to create plugins from source code.\n*   **Plugin Discovery:** Helps users discover missing global plugins.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/BatchExportRuns.tsx",
        "summary": "The `BatchExportRuns.tsx` component provides a user interface for viewing and managing batch export runs within a PostHog pipeline. It allows users to filter runs by date range or view the latest runs, refresh the run list, load older runs, retry failed runs, and initiate a backfill process for historical data. The component displays run status, IDs, data interval start and end times, and run start times in a table format, with options to group runs and expand them for detailed information.\n\nHere's a list of high-level product features implemented in this component:\n\n*   **View Batch Export Runs:** Displays a list of batch export runs, including their status, ID, and time intervals.\n*   **Filter Runs by Date Range:** Allows users to filter the displayed runs based on a specified date range.\n*   **View Latest Runs:** Provides an option to view only the most recent batch export runs.\n*   **Refresh Run List:** Enables users to manually refresh the list of batch export runs to see the latest updates.\n*   **Load Older Runs:** Supports pagination, allowing users to load and view older batch export runs.\n*   **Retry Failed Runs:** Allows users to retry individual batch export runs that have failed.\n*   **Initiate Data Backfill:** Provides a mechanism to start a backfill process for exporting historical data.\n*   **Run Cancellation:** Allows users to cancel running batch exports.\n*   **Grouped Run View:** Groups runs by data interval, providing a summarized view with the option to expand for details.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/utils.tsx",
        "summary": "This code provides utility functions and components for managing data pipelines within PostHog. It includes functions for capturing plugin and batch export events, loading paginated results from the API, rendering plugin and batch export icons, displaying log levels, and generating table columns with links to pipeline node configurations, metrics, and logs. It also defines constants for whitelisted plugins and provides menu items for interacting with pipeline nodes, including editing configurations, viewing metrics and logs, enabling/disabling apps, and deleting apps. The code also handles permission checks and determines if a batch export run is in progress.\n\nHere's a list of high-level product features supported by this code:\n\n*   **Data Pipeline Management:** Provides core functionality for managing data pipelines, including creating, configuring, and monitoring pipeline nodes.\n*   **Plugin Integration:** Supports the integration of plugins into data pipelines, including rendering plugin information and providing links to plugin source code.\n*   **Batch Export:** Enables exporting data to external services through batch exports, with support for various destinations like BigQuery, Postgres, Redshift, S3, Snowflake, and HTTP.\n*   **Logging and Monitoring:** Offers features for viewing logs and metrics related to pipeline nodes, aiding in debugging and performance analysis.\n*   **Access Control:** Implements permission checks to restrict access to certain actions based on user roles.\n*   **UI Components:** Provides reusable UI components for displaying plugin information, batch export icons, and log levels.\n*   **Event Tracking:** Captures events related to plugin and batch export usage for analytics and insights.\n*   **Plugin Whitelisting:** Defines a mechanism for whitelisting plugins that can be used without requiring data pipelines.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline/PipelinePluginConfiguration.tsx",
        "summary": "This code defines a React component, `PipelinePluginConfiguration`, which allows users to configure plugins within a PostHog pipeline stage. It fetches plugin details, renders a form based on the plugin's configuration schema, and handles submission and reset actions. The component supports various field types, including text inputs, JSON editors, file uploads, and dropdown selections. It also includes features like displaying plugin information, enabling/disabling the plugin, and upgrading legacy plugins to a new version.\n\nHere's a list of high-level product features:\n\n*   **Plugin Configuration:** Allows users to configure plugins with a dynamic form based on the plugin's schema.\n*   **Field Type Support:** Supports various field types including text, JSON, file attachments, and dropdown selections.\n*   **Secret Management:** Handles secret fields with write-only access and reset functionality.\n*   **Plugin Information Display:** Displays plugin name, description, and logo.\n*   **Enable/Disable Plugin:** Allows users to enable or disable the plugin.\n*   **Custom Name and Description:** Allows users to set a custom name and description for the plugin instance.\n*   **Configuration Reset:** Provides a button to reset the configuration to the last saved state.\n*   **Form Validation:** Indicates invalid configuration fields.\n*   **Upgrade Legacy Plugins:** Provides a banner and dialog to upgrade legacy plugins to a new version.\n*   **Real-time Updates:** Disables form elements during loading or submission.\n*   **Contextual Help:** Displays field hints and markdown descriptions.\n"
    },
    {
        "path": "frontend/src/scenes/pipeline",
        "summary": "This collection of code files outlines a comprehensive data pipeline management system within PostHog, empowering users to ingest, transform, and export data with ease. The system provides a user-friendly interface for creating and configuring various pipeline nodes, including sources, transformations (Hog Functions and plugins), and destinations (webhooks, batch exports, and data warehouses). Users can monitor pipeline performance through detailed metrics and logs, manage access control, and customize the system with site apps and plugins. The system also supports batch export backfills, enabling users to export historical data.\n\nHere's a list of high-level product features:\n\n*   **Data Pipeline Management:** Create, configure, and manage data pipelines with a visual interface.\n*   **Data Source Integration:** Connect to various data sources, including managed and self-managed options.\n*   **Data Transformation:** Transform data using Hog Functions and plugins, with support for filtering, mapping, and enriching events.\n*   **Data Destination Export:** Export data to various destinations, including webhooks, batch exports (S3, Snowflake, BigQuery, etc.), and data warehouses.\n*   **Plugin Management:** Install, configure, and manage plugins to extend pipeline functionality.\n*   **Hog Function Support:** Create, test, and deploy server-side functions for real-time data processing.\n*   **Batch Export Backfills:** Schedule and manage historical data exports for batch exports.\n*   **Metrics and Monitoring:** Visualize pipeline performance with detailed metrics and logs.\n*   **Access Control:** Manage user permissions and access to pipeline features.\n*   **Site App Integration:** Integrate site apps to customize the PostHog interface and functionality.\n*   **Real-time Updates:** Automatically update the UI with the latest data and changes.\n*   **Error Handling:** Provide user-friendly error messages and logging for debugging.\n*   **Configuration Management:** Manage plugin and batch export configurations with dynamic forms and validation.\n*   **Activity History Tracking:** Log user actions and system events related to pipeline nodes.\n*   **Code Editing:** View and edit plugin source code with syntax highlighting and formatting.\n*   **Template Management:** Utilize pre-built code templates to accelerate plugin development.\n*   **Testing and Debugging Tools:** Test Hog Functions and plugins with historical events and view detailed logs.\n*   **User Guidance:** Provide helpful documentation and onboarding experiences.\n*   **Data Schema Management:** Define and manage data schemas for events, persons, and sessions.\n*   **Automated Data Export:** Schedule and automate data exports to various destinations.\n*   **Data Filtering:** Filter data based on various criteria before transformation or export.\n*   **Alerting and Notifications:** Configure alerts and notifications for pipeline events and errors.\n*   **Version Control:** Track changes to pipeline configurations and code.\n*   **Collaboration Tools:** Enable collaboration among team members on pipeline development and management.\n*   **Scalability and Performance Optimization:** Optimize pipeline performance for large-scale data processing.\n*   **Security and Compliance:** Ensure data security and compliance with relevant regulations.\n*   **Customizable Dashboards:** Create custom dashboards to monitor pipeline performance and key metrics.\n*   **Integration with Other PostHog Features:** Seamlessly integrate with other PostHog features, such as feature flags and experiments.\n*   **Data Governance:** Implement data governance policies to ensure data quality and consistency.\n*   **Data Lineage Tracking:** Track the lineage of data as it flows through the pipeline.\n*   **Data Catalog Integration:** Integrate with data catalogs to provide metadata and documentation for pipeline data.\n*   **AI-Powered Data Transformation:** Utilize AI to automate data transformation tasks.\n*   **Data Quality Monitoring:** Monitor data quality and identify potential issues.\n*   **Data Anonymization:** Anonymize sensitive data to protect user privacy.\n*   **Data Encryption:** Encrypt data at rest and in transit to ensure security.\n*   **Compliance Reporting:** Generate reports to demonstrate compliance with relevant regulations.\n*   **Automated Testing:** Automate testing of pipeline configurations and code.\n*   **Continuous Integration/Continuous Deployment (CI/CD):** Implement CI/CD pipelines for automated deployment of pipeline changes.\n*   **Disaster Recovery:** Implement disaster recovery plans to ensure business continuity in the event of a failure.\n*   **Cost Optimization:** Optimize pipeline costs by identifying and eliminating inefficiencies.\n*   **Resource Management:** Manage pipeline resources effectively to ensure optimal performance.\n*   **Performance Tuning:** Tune pipeline performance to meet specific requirements.\n*   **Data Compression:** Compress data to reduce storage costs and improve performance.\n*   **Data Partitioning:** Partition data to improve query performance.\n*   **Data Indexing:** Index data to speed up data retrieval.\n*   **Data Caching:** Cache data to reduce latency and improve performance.\n*   **Data Replication:** Replicate data to ensure high availability and disaster recovery.\n*   **Data Backup and Restore:** Back up and restore data to protect against data loss.\n*   **Data Archiving:** Archive data to reduce storage costs and comply with retention policies.\n*   **Data Purging:** Purge data to comply with privacy regulations.\n*   **Data Masking:** Mask sensitive data to protect user privacy.\n*   **Data Tokenization:** Tokenize sensitive data to protect user privacy.\n*   **Data Auditing:** Audit data access and modifications to ensure compliance.\n*   **Data Security Monitoring:** Monitor data security and detect potential threats.\n*   **Data Loss Prevention (DLP):** Implement DLP policies to prevent data leakage.\n*   **Intrusion Detection and Prevention:** Implement intrusion detection and prevention systems to protect against cyberattacks.\n*   **Vulnerability Management:** Manage vulnerabilities in pipeline components to reduce security risks.\n*   **Security Incident Response:** Develop and implement security incident response plans.\n*   **Security Awareness Training:** Provide security awareness training to pipeline users.\n*   **Compliance Audits:** Conduct regular compliance audits to ensure adherence to regulations.\n*   **Data Privacy Assessments:** Conduct data privacy assessments to identify and mitigate privacy risks.\n*   **Data Governance Framework:** Implement a data governance framework to ensure data quality and consistency.\n*   **Data Stewardship:** Assign data stewards to oversee data quality and governance.\n*   **Data Quality Metrics:** Define and track data quality metrics.\n*   **Data Quality Rules:** Implement data quality rules to ensure data accuracy and completeness.\n*   **Data Validation:** Validate data to ensure it meets quality standards.\n*   **Data Cleansing:** Cleanse data to remove errors and inconsistencies.\n*   **Data Standardization:** Standardize data to ensure consistency across systems.\n*   **Data Enrichment:** Enrich data with additional information to improve its value.\n*   **Data Transformation Libraries:** Utilize data transformation libraries to simplify data processing.\n*   **Data Integration Tools:** Integrate with data integration tools to connect to various data sources.\n*   **Data Visualization Tools:** Integrate with data visualization tools to create insightful dashboards.\n*   **Machine Learning Integration:** Integrate with machine learning platforms to build and deploy AI models.\n*   **Real-time Analytics:** Perform real-time analytics on pipeline data.\n*   **Predictive Analytics:** Utilize predictive analytics to forecast future trends.\n*   **Anomaly Detection:** Detect anomalies in pipeline data.\n*   **Root Cause Analysis:** Perform root cause analysis to identify the underlying causes of issues.\n*   **A/B Testing:** Conduct A/B testing to optimize pipeline performance.\n*   **Personalization:** Personalize data experiences based on user preferences.\n*   **Recommendation Engines:** Build recommendation engines to provide personalized recommendations.\n*   **Fraud Detection:** Detect fraudulent activities in pipeline data.\n*   **Risk Management:** Manage risks associated with pipeline data.\n*   **Compliance Automation:** Automate compliance tasks to reduce manual effort.\n*   **Data Discovery:** Discover and catalog pipeline data assets.\n*   **Data Collaboration:** Enable collaboration among data teams.\n*   **Data Sharing:** Share pipeline data with authorized users.\n*   **Data Monetization:** Monetize pipeline data to generate revenue.\n*   **Data Marketplace:** Create a data marketplace to share and sell pipeline data.\n*   **Data Governance Policies:** Implement data governance policies to ensure data quality and compliance.\n*   **Data Lineage Tracking:** Track the lineage of data as it flows through the pipeline.\n*   **Data Catalog Integration:** Integrate with data catalogs to provide metadata and documentation for pipeline data.\n*   **AI-Powered Data Transformation:** Utilize AI to automate data transformation tasks.\n*   **Data Quality Monitoring:** Monitor data quality and identify potential issues.\n*   **Data Anonymization:** Anonymize sensitive data to protect user privacy.\n*   **Data Encryption:** Encrypt data at rest and in transit to ensure security.\n*   **Compliance Reporting:** Generate reports to demonstrate compliance with relevant regulations.\n*   **Automated Testing:** Automate testing of pipeline configurations and code.\n*   **Continuous Integration/Continuous Deployment (CI/CD):** Implement CI/CD pipelines for automated deployment of pipeline changes.\n*   **Disaster Recovery:** Implement disaster recovery plans to ensure business continuity in the event of a failure.\n*   **Cost Optimization:** Optimize pipeline costs by identifying and eliminating inefficiencies.\n*   **Resource Management:** Manage pipeline resources effectively to ensure optimal performance.\n*   **Performance Tuning:** Tune pipeline performance to meet specific requirements.\n*   **Data Compression:** Compress data to reduce storage costs and improve performance.\n*   **Data Partitioning:** Partition data to improve query performance.\n*   **Data Indexing:** Index data to speed up data retrieval.\n*   **Data Caching:** Cache data to reduce latency and improve performance.\n*   **Data Replication:** Replicate data to ensure high availability and disaster recovery.\n*   **Data Backup and Restore:** Back up and restore data to protect against data loss.\n*   **Data Archiving:** Archive data to reduce storage costs and comply with retention policies.\n*   **Data Purging:** Purge data to comply with privacy regulations.\n*   **Data Masking:** Mask sensitive data to protect user privacy.\n*   **Data Tokenization:** Tokenize sensitive data to protect user privacy.\n*   **Data Auditing:** Audit data access and modifications to ensure compliance.\n*   **Data Security Monitoring:** Monitor data security and detect potential threats.\n*   **Data Loss Prevention (DLP):** Implement DLP policies to prevent data leakage.\n*   **Intrusion Detection and Prevention:** Implement intrusion detection and prevention systems to protect against cyberattacks.\n*   **Vulnerability Management:** Manage vulnerabilities in pipeline components to reduce security risks.\n*   **Security Incident Response:** Develop and implement security incident response plans.\n*   **Security Awareness Training:** Provide security awareness training to pipeline users.\n*   **Compliance Audits:** Conduct regular compliance audits to ensure adherence to regulations.\n*   **Data Privacy Assessments:** Conduct data privacy assessments to identify and mitigate privacy risks.\n"
    },
    {
        "path": "frontend/src/scenes/products/productsLogic.ts",
        "summary": "This code defines the `productsLogic` using Kea, a state management library. It manages the selection of products, particularly in the context of onboarding. It allows users to toggle the selection of products, tracks which product is selected for the first onboarding experience, and handles the initiation of the onboarding flow based on the selected products. The logic also dispatches product intent events to track user behavior during onboarding.\n\nHere's a list of high-level product features:\n\n*   **Product Selection:** Allows users to select multiple products from a list.\n*   **Onboarding Flow Management:** Initiates and manages the onboarding flow based on the user's product selection.\n*   **Primary Product Designation:** Designates one of the selected products as the primary product for onboarding.\n*   **Product Intent Tracking:** Tracks user interactions with products during the onboarding process.\n*   **Navigation:** Navigates the user to specific onboarding steps based on the selected product.\n"
    },
    {
        "path": "frontend/src/scenes/products/Products.tsx",
        "summary": "The `Products` component in `Products.tsx` presents users with a selection of available products for onboarding. Users can select multiple products they intend to use. If multiple products are selected, the component prompts the user to choose the primary product to start with. Once a product (or products) is selected, the user can initiate the onboarding process. The component also provides a link to invite team members.\n\nHere's a list of high-level product features:\n\n*   **Product Selection:** Allows users to select one or more products they want to use.\n*   **Primary Product Selection:** If multiple products are selected, allows users to choose the primary product for onboarding.\n*   **Onboarding Initiation:** Starts the onboarding process for the selected product(s).\n*   **Team Invitation:** Provides a link to invite team members to the platform.\n*   **Visual Product Cards:** Displays available products as selectable cards with icons and names.\n*   **Onboarding Status Indication:** Shows a visual indicator if a product's onboarding has already been completed.\n"
    },
    {
        "path": "frontend/src/scenes/dataThemeLogic.tsx",
        "summary": "This code defines a Kea logic module named `dataThemeLogic` responsible for managing data color themes within a PostHog application. It fetches, stores, and provides access to data color themes, including a global PostHog theme and team-specific themes. The logic provides selectors to retrieve the appropriate theme based on team settings and allows accessing specific colors within a theme using tokens. It also includes a component `ThemeName` to display the name of a theme given its ID.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Data Color Theme Management:** Allows users to define and manage custom color palettes for data visualizations.\n*   **Global PostHog Theme:** Provides a default, globally applicable color theme.\n*   **Team-Specific Themes:** Enables teams to customize their data visualization colors independently.\n*   **Theme Selection:** Automatically selects the appropriate theme based on team settings, falling back to the global theme if no team-specific theme is defined.\n*   **Color Token Access:** Provides a mechanism to access specific colors within a theme using tokens, simplifying the application of themes to charts and other visualizations.\n*   **Theme Name Display:** Displays the name of a theme based on its ID.\n"
    },
    {
        "path": "frontend/src/scenes/teamLogic.tsx",
        "summary": "This code defines the `teamLogic` Kea logic module, responsible for managing the current team/environment within the PostHog application. It handles loading, updating, creating, and deleting teams, as well as managing team-specific settings and configurations. The logic interacts with the PostHog API to persist changes and provides selectors for accessing team data and derived properties. It also manages product intent tracking and onboarding completion.\n\nHere's a list of high-level product features managed by this logic:\n\n*   **Team/Environment Management:** Creating, updating, deleting teams/environments.\n*   **Team Settings:** Managing team-specific settings like name, timezone, week start day, authorized URLs, and Slack webhook integration.\n*   **API Token Management:** Resetting the API token for a team.\n*   **Session Replay Configuration:** Managing session replay settings for the team.\n*   **Product Intent Tracking:** Recording user intent for various PostHog products.\n*   **Onboarding:** Tracking and managing onboarding progress for different PostHog features.\n*   **Test Account Filters:** Managing test account filters for the team.\n*   **Funnel Correlation Configuration:** Managing funnel correlation settings.\n*   **Access Control:** Determining user access levels and permissions for the team.\n"
    },
    {
        "path": "frontend/src/scenes/appScenes.ts",
        "summary": "This code defines a mapping of application scenes to their corresponding React components, enabling dynamic loading of different parts of the PostHog application based on the current scene. It includes scenes for dashboards, insights, web analytics, cohorts, data management, session recordings, persons management, feature flags, experiments, error tracking, surveys, data warehouse, organization and project management, billing, authentication, debugging, notebooks, products, onboarding, settings, heatmaps, messaging, and wizards. The `appScenes` object acts as a central registry for all available scenes in the application.\n\nHere's a list of high-level product features based on the scenes defined in the code:\n\n*   **Dashboards:** Customizable dashboards for visualizing key metrics.\n*   **Insights:** Tools for creating and analyzing insights from data.\n*   **Web Analytics:** Features for tracking and analyzing website user behavior.\n*   **Cohorts:** Segmentation of users based on shared characteristics.\n*   **Data Management:** Tools for managing and defining data properties and events.\n*   **Session Recordings:** Recording and playback of user sessions.\n*   **Persons Management:** Management of user profiles and identities.\n*   **Feature Flags:** Control the release of new features to specific user segments.\n*   **Experiments:** A/B testing and experimentation platform.\n*   **Error Tracking:** Monitoring and analysis of application errors.\n*   **Surveys:** Creation and deployment of user surveys.\n*   **Data Warehouse:** Integration with external data warehouses.\n*   **Organization and Project Management:** Tools for managing organizations and projects within PostHog.\n*   **Billing:** Management of billing and subscription information.\n*   **Authentication:** User authentication and authorization.\n*   **Debugging:** Tools for debugging and troubleshooting issues.\n*   **Notebooks:** Collaborative notebooks for data analysis and exploration.\n*   **Products:** Management of PostHog products and features.\n*   **Onboarding:** Guided onboarding experience for new users.\n*   **Settings:** Application settings and configurations.\n*   **Heatmaps:** Visualization of user interaction on web pages.\n*   **Messaging:** Tools for sending messages to users via broadcasts and automations.\n*   **Wizards:** Guided workflows for common tasks."
    },
    {
        "path": "frontend/src/scenes/products",
        "summary": "The code implements a product selection and onboarding flow. Users are presented with a list of products, can select one or more, and designate a primary product if multiple are chosen. The system then initiates the onboarding process based on the selection, tracking user interactions and navigating them through relevant steps. Additionally, the interface provides a means to invite team members and indicates the onboarding status of each product.\n\n*   Product Selection: Allows users to select multiple products from a list.\n*   Primary Product Designation: Designates one of the selected products as the primary product for onboarding.\n*   Onboarding Flow Management: Initiates and manages the onboarding flow based on the user's product selection.\n*   Product Intent Tracking: Tracks user interactions with products during the onboarding process.\n*   Team Invitation: Provides a link to invite team members to the platform.\n*   Onboarding Status Indication: Shows a visual indicator if a product's onboarding has already been completed.\n"
    },
    {
        "path": "frontend/src/scenes/retention/RetentionBreakdownFilter.tsx",
        "summary": "This React component, `RetentionBreakdownFilter`, provides a dropdown menu for filtering retention data based on breakdown values. It utilizes `kea` for state management and interacts with `insightLogic` and `retentionLogic` to fetch and update the available breakdown values and the selected value. The component renders a `LemonSelect` dropdown, populated with options representing each breakdown value, including an \"All breakdown values\" option. If no breakdown values are available, the component renders nothing.\n\nHere's a list of high-level product features:\n\n*   **Breakdown Value Filtering:** Allows users to filter retention data based on specific breakdown values.\n*   **\"All\" Option:** Provides an option to view retention data across all breakdown values.\n*   **Dynamic Options:** The dropdown options are dynamically populated based on available breakdown values.\n*   **Empty Value Handling:** Displays \"(empty)\" for null or empty breakdown values.\n"
    },
    {
        "path": "frontend/src/scenes/retention/constants.ts",
        "summary": "This code defines constants and mappings used in the retention analysis feature of the application. It specifies the supported time periods for retention analysis (Hour, Day, Week, Month) and provides mappings to their corresponding dayjs time interval codes. It also defines labels and descriptions for different retention calculation methods: \"for the first time\" and \"recurringly,\" clarifying how users are assigned to cohorts based on their event performance.\n\nHere's a list of high-level product features that leverage these constants:\n\n*   **Retention Analysis:** Allows users to analyze user retention over time.\n*   **Time Period Selection:** Enables users to select the time period (Hour, Day, Week, Month) for retention analysis.\n*   **Retention Calculation Methods:** Supports different methods for calculating retention, including \"first time\" and \"recurring\" retention.\n*   **Cohort Definition:** Defines how users are grouped into cohorts based on their event performance within the specified time periods.\n"
    },
    {
        "path": "frontend/src/scenes/retention/RetentionContainer.tsx",
        "summary": "The `RetentionContainer` component is the main container for the retention analysis feature. It conditionally renders a retention graph and/or a retention table based on `vizSpecificOptions`, `inCardView`, and `retentionFilter` properties. It also includes a `RetentionModal` for further configuration, unless the component is in shared mode. The component utilizes `retentionLogic` and `insightLogic` to manage the state and props for the retention analysis.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Retention Graph Visualization:** Displays a line graph visualizing user retention over time.\n*   **Retention Table Visualization:** Displays a table showing detailed retention data.\n*   **Conditional Display of Graph and Table:** Allows users to choose whether to display the graph, the table, or both.\n*   **Configuration Modal:** Provides a modal for configuring retention analysis parameters.\n*   **Shared Mode:** Disables the configuration modal when in shared mode.\n*   **Dashboard Integration:** Supports integration into dashboards with options to display only the graph or only the table.\n"
    },
    {
        "path": "frontend/src/scenes/organizationLogic.tsx",
        "summary": "This code defines the `organizationLogic` using Kea, a state management library. It handles fetching, creating, updating, and deleting organization data. It also manages the current organization's state, including loading status, and provides selectors for checking user permissions and available features related to the organization. The logic interacts with the PostHog API to perform these operations and updates the user's state accordingly.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Organization Management:** Create, update, and delete organizations.\n*   **Current Organization Context:** Load and maintain the current organization's data for the user.\n*   **User Permissions:** Determine user roles and permissions within the organization (admin, owner, etc.).\n*   **Feature Availability:** Check if specific features (e.g., tagging) are available for the organization.\n*   **Onboarding:** Complete the organization onboarding process.\n*   **Access Control Migration:** Migrate the organization's access control version.\n*   **Two-Factor Authentication Enforcement:** Enforce 2FA for organization members.\n*   **Email Notifications:** Enable/disable email notifications for new member joins.\n*   **Data Processing Approval:** Manage AI data processing approval status.\n"
    },
    {
        "path": "frontend/src/scenes/retention/types.ts",
        "summary": "This code defines the data structures and interfaces used for representing retention analysis results in the PostHog frontend. It includes interfaces for processed retention values (counts, percentages, dates), retention payloads (data for each row), retention table rows (label, cohort size, values), retention trends (data for trend charts), and data structures for fetching and displaying people who match specific retention criteria. It also defines a constant for representing no breakdown value.\n\nHere's a list of high-level product features that utilize these data structures:\n\n*   **Retention Analysis Visualization:** Displaying retention rates over time in a table format.\n*   **Cohort Analysis:** Grouping users into cohorts based on their initial activity.\n*   **Breakdown Support:** Allowing retention analysis to be broken down by user properties or event properties.\n*   **Trend Analysis:** Visualizing retention trends over time in a chart format.\n*   **User Identification:** Providing the ability to identify and view the users who match specific retention criteria.\n*   **Data Pagination:** Handling large datasets of users through pagination.\n"
    },
    {
        "path": "frontend/src/scenes/retention/retentionTableLogic.ts",
        "summary": "This code defines the `retentionTableLogic` Kea logic for managing the display and interaction of retention data in a table format. It handles filtering retention results based on selected breakdown values, formatting dates for display, and structuring the data into rows suitable for a table. The logic also manages the expansion state of breakdown values within the table, automatically expanding a single breakdown if only one exists. It connects to other logics such as `insightVizDataLogic` and `retentionLogic` to access and react to changes in data and settings.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Retention Table Display:** Renders retention data in a tabular format.\n*   **Breakdown Filtering:** Filters retention data based on selected breakdown values.\n*   **Date Formatting:** Formats dates in the table based on the selected period (Hour, Day, Week, Month).\n*   **Breakdown Expansion/Collapse:** Allows users to expand or collapse rows based on breakdown values.\n*   **Automatic Breakdown Expansion:** Automatically expands a single breakdown if only one exists.\n*   **Hides cohort size column:** Allows the user to hide the cohort size column.\n"
    },
    {
        "path": "frontend/src/scenes/retention/retentionModalLogic.ts",
        "summary": "This code defines a Kea logic module named `retentionModalLogic` that manages the state and behavior of a modal for displaying user details within a retention analysis view. It connects to other logic modules like `insightVizDataLogic`, `groupsModel`, `featureFlagLogic`, and `retentionPeopleLogic` to access data and functionality related to insights, groups, feature flags, and user data. The logic handles opening and closing the modal, selecting a specific interval (cohort) within the retention analysis, and constructing queries to fetch the relevant user data for the selected interval. It also generates URLs for exploring the data in more detail within the insights and events views.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Modal Display of User Details:** Opens a modal to display users belonging to a specific retention cohort.\n*   **Cohort Selection:** Allows users to select a specific interval (cohort) in the retention analysis to view.\n*   **Data Fetching for Selected Cohort:** Fetches user data relevant to the selected retention cohort.\n*   **URL Generation for Data Exploration:** Generates URLs to explore the data in more detail within the insights and events views.\n*   **Integration with Insights and Events Views:** Seamlessly integrates with the insights and events views for deeper data exploration.\n*   **Support for Group Analytics:** Handles aggregation based on group types.\n"
    },
    {
        "path": "frontend/src/scenes/retention/retentionGraphLogic.ts",
        "summary": "This code defines the `retentionGraphLogic` using Kea, a state management library. This logic is responsible for preparing and processing data for the retention graph in the PostHog application. It connects to other logics like `insightVizDataLogic` and `retentionLogic` to fetch necessary data and filters. It transforms the raw retention data into a format suitable for charting, calculates the incompleteness offset for the graph based on the date range, and handles filtering of the trend series based on breakdown values.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Data Transformation for Retention Graph:** Transforms raw retention data into a chart-friendly format, including calculating labels, data points, and series information.\n*   **Date Range Handling:** Calculates the incompleteness offset for the graph based on the selected date range, ensuring accurate representation of data.\n*   **Breakdown Filtering:** Filters the trend series based on selected breakdown values, allowing users to focus on specific segments of their data.\n*   **Aggregation Group Type Handling:** Determines the aggregation group type index for the query, influencing how data is grouped and displayed.\n*   **Conditional Series Display:** Hides the line graph when breakdowns are present but not selected, reducing visual noise and improving clarity.\n"
    },
    {
        "path": "frontend/src/scenes/retention/retentionPeopleLogic.ts",
        "summary": "This code defines the `retentionPeopleLogic` Kea logic, which manages the state and data fetching for displaying people who match specific retention criteria in a retention table. It connects to `insightVizDataLogic` to access the retention query and uses it to fetch the relevant actors (people) for a selected interval. The logic handles loading, clearing, and appending people data, including pagination for large datasets. It also converts the query source into API filters for data retrieval.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Display of People in Retention Table:** Fetches and displays a list of users who match the criteria for a specific interval in a retention analysis.\n*   **Pagination of People Data:** Loads people data in chunks, allowing users to browse through large lists of users.\n*   **Dynamic Data Loading:** Clears and reloads people data when the underlying retention query or filters change.\n*   **Loading State Management:** Tracks and indicates when people data is being loaded.\n*   **Integration with Retention Query:** Uses the retention query defined in `insightVizDataLogic` to determine which users to display.\n*   **\"Load More\" Functionality:** Allows users to load additional people data for a selected interval.\n"
    },
    {
        "path": "frontend/src/scenes/retention/RetentionGraph.tsx",
        "summary": "The `RetentionGraph` component visualizes retention data using a line or bar graph. It fetches data and settings via kea-logic hooks, displaying a message if no breakdown is selected. The graph renders retention trends for cohorts, allowing users to click on data points to open a modal with more details. The graph type (line or bar) is determined by the retention filter's display setting. It also handles shared mode display and data incompleteness.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Retention Visualization:** Displays retention data as a line or bar graph.\n*   **Cohort Analysis:** Visualizes retention trends for different cohorts.\n*   **Breakdown Selection Prompt:** Guides users to select a breakdown for the retention analysis.\n*   **Interactive Data Points:** Allows users to click on data points to view more details in a modal.\n*   **Graph Type Configuration:** Supports line and bar graph types based on user settings.\n*   **Shared Mode Display:** Adapts the graph for shared mode viewing.\n*   **Data Incompleteness Handling:** Indicates data incompleteness in the graph.\n*   **Percentage Formatting:** Displays retention values as percentages.\n"
    },
    {
        "path": "frontend/src/scenes/retention/retentionLogic.ts",
        "summary": "This code defines the `retentionLogic` Kea logic for managing retention analysis in the PostHog frontend. It handles fetching, processing, and displaying retention data, including calculating percentages, determining current and future periods, and providing date mapping options. The logic connects to `insightVizDataLogic` to access insight query data and update insight filters and date ranges. It also manages the selected breakdown value for the retention analysis.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Retention Analysis:** Calculates and displays user retention rates over time.\n*   **Data Processing:** Transforms raw retention data into a format suitable for visualization, including calculating percentages and identifying current/future periods.\n*   **Date Range Selection:** Provides predefined date range options (e.g., Last 7 days, Last 30 days, Year to date) for retention analysis.\n*   **Breakdown Analysis:** Allows users to break down retention data by a specific property or characteristic.\n*   **Dynamic Date Mapping:** Generates date mapping options based on the selected retention period (day, week, month).\n*   **Visualization Integration:** Connects with insight visualization logic to display retention data in charts and tables.\n"
    },
    {
        "path": "frontend/src/scenes/retention/queries.ts",
        "summary": "This code defines functions for querying actors (people or groups) who have performed certain actions within a retention analysis. It translates a retention query into an actors query, specifying which actors and their activity intervals to select. The `retentionToActorsQuery` function transforms a retention query into an actors query, optimizing it for fetching data about actors' appearances across specified time intervals. The `queryForActors` function then executes this actors query, processes the results to format them for a retention table, and returns the data along with pagination information and a count of missing actors.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Retention Analysis:** Allows users to analyze how many users/groups return to perform specific actions over time.\n*   **Actor-Level Drilldown:** Enables users to drill down into the specific actors (people or groups) who are retained at each interval.\n*   **Customizable Time Intervals:** Supports different time periods (e.g., day, week, month) for retention analysis.\n*   **Pagination:** Handles large datasets by providing pagination for the actor-level drilldown results.\n*   **Missing Actors Tracking:** Tracks and reports the number of actors that are missing from the dataset.\n*   **Group Analytics:** Supports retention analysis for groups of users, not just individual users.\n"
    },
    {
        "path": "frontend/src/scenes/retention/RetentionTable.tsx",
        "summary": "This React component, `RetentionTable`, visualizes retention data in a tabular format. It fetches data and configurations using kea logic hooks, including insight properties, table rows split by breakdown values, and theme settings. The table displays cohort sizes and retention percentages across specified intervals, with options for breakdown analysis and customization of appearance. Users can expand breakdowns to view individual rows and interact with the data, such as opening a modal for detailed information. The component also supports different mean retention calculation methods and adjusts the color scheme based on the selected theme and data values.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Retention Data Visualization:** Displays retention rates in a table format.\n*   **Cohort Analysis:** Shows retention for different cohorts based on breakdown values.\n*   **Breakdown Expansion:** Allows users to expand rows to view individual data points within a breakdown.\n*   **Customizable Appearance:** Supports theming and layout adjustments for visual customization.\n*   **Interactive Data Exploration:** Enables users to click on table cells to view detailed information (via modal).\n*   **Mean Retention Calculation:** Supports different methods for calculating mean retention (weighted and simple).\n*   **Data Highlighting:** Highlights current periods and uses color gradients to represent retention percentages.\n*   **Shared Mode Support:** Adapts behavior when in shared mode, potentially disabling interactive features.\n"
    },
    {
        "path": "frontend/src/scenes/retention/RetentionModal.tsx",
        "summary": "This code defines a `RetentionModal` component in a React application, likely part of a product analytics platform. The modal displays detailed retention data for a selected cohort, showing which users/groups from the initial cohort returned in subsequent periods. It fetches and displays a table of users/groups, highlighting their presence in each retention interval. The modal provides options to download the data as a CSV, explore the data further in insights, or view the underlying events. It also handles loading states, empty states, and missing data scenarios, offering a comprehensive view of user/group retention.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Retention Data Visualization:** Displays a table showing user/group retention across different time intervals.\n*   **Cohort Selection:** Allows users to select a specific cohort to view retention data for.\n*   **User/Group Identification:** Lists the users/groups belonging to the selected cohort.\n*   **Retention Interval Highlighting:** Indicates which users/groups returned in each retention interval.\n*   **Data Export:** Enables users to download the retention data as a CSV file.\n*   **Data Exploration:** Provides links to explore the data further in insights or view the underlying events.\n*   **Loading State Management:** Displays a spinner while data is being fetched.\n*   **Empty State Handling:** Shows a message when there is no data to display.\n*   **Missing Data Alert:** Alerts the user if there is missing data for users/groups.\n*   **Pagination:** Allows loading more users/groups if the initial set is limited.\n"
    },
    {
        "path": "frontend/src/scenes/urls.ts",
        "summary": "This code defines a comprehensive set of URL routes for a web application, likely a product analytics platform. It includes routes for various features such as data management (events, properties, annotations), pipelines, cohorts, feature management, error tracking, surveys, data warehouse, settings, onboarding, billing, and messaging. The code utilizes `kea-router` for combining URLs and includes specific routes for creating, editing, and viewing individual items within these features. It also handles authentication-related routes (login, signup, password reset) and routes specific to cloud and self-hosted deployments.\n\nHere's a list of high-level product features based on the URLs:\n\n*   **Data Management:** Event and property definitions, data history, database management, ingestion warnings, revenue tracking, annotations.\n*   **Pipelines:** Data pipeline creation, configuration, and management.\n*   **Cohorts:** User cohort definition and management.\n*   **Feature Management:** Feature flag management.\n*   **Error Tracking:** Error monitoring and alerting.\n*   **Surveys:** Survey creation, distribution, and analysis.\n*   **Data Warehouse:** Data warehousing and SQL editor.\n*   **Settings:** Project and organization settings.\n*   **Onboarding:** User onboarding flows.\n*   **Billing:** Organization billing management.\n*   **Instance Management (Self-hosted):** Instance status, user management, Kafka inspection, settings, metrics, async migrations, dead letter queue.\n*   **Integrations:** Integration management and redirects.\n*   **Debugging:** Debugging tools and information.\n*   **Feedback:** User feedback collection.\n*   **Heatmaps:** Website heatmap visualization.\n*   **Session Attribution Explorer:** Session attribution analysis.\n*   **Messaging:** Broadcast and automated messaging, message library.\n"
    },
    {
        "path": "frontend/src/scenes/retention",
        "summary": "The provided code collectively implements a comprehensive retention analysis feature within the PostHog platform. This feature allows users to analyze how effectively they retain users or groups over time, providing tools for visualizing retention rates, drilling down into specific cohorts, and exploring the underlying data. The system supports various time periods, breakdown analyses, and retention calculation methods, offering flexibility in how retention is measured and understood. The user interface includes interactive graphs and tables, along with modals for detailed data exploration and configuration options to tailor the analysis to specific needs.\n\nHere's a list of high-level product features:\n\n*   Retention Analysis: Calculates and displays user/group retention rates over time.\n*   Data Visualization: Presents retention data in interactive graphs and tables.\n*   Cohort Analysis: Groups users/groups into cohorts based on initial activity and analyzes their retention.\n*   Breakdown Analysis: Allows users to break down retention data by properties or characteristics.\n*   Actor-Level Drilldown: Enables users to drill down into the specific users/groups who are retained at each interval.\n*   Customizable Time Intervals: Supports different time periods (e.g., day, week, month) for retention analysis.\n*   Data Export: Enables users to download retention data in CSV format.\n*   Interactive Data Exploration: Provides modals and links to explore data in more detail within insights and events views.\n*   Configuration Options: Allows users to configure retention analysis parameters, such as time period, calculation method, and graph type.\n*   Shared Mode Support: Adapts the display and functionality for shared dashboards and views.\n"
    },
    {
        "path": "frontend/src/scenes/activity/ActivityScene.tsx",
        "summary": "The `ActivityScene.tsx` file defines the Activity Scene, which allows users to explore and monitor events within the application. It uses Kea for state management and routing, providing two tabs: \"Explore\" and \"Live\". The \"Explore\" tab displays an `EventsScene` component, while the \"Live\" tab shows a `LiveEventsTable` component. The scene uses `LemonTabs` for tab navigation and updates the active tab based on the URL.\n\nHere's a list of high-level product features:\n\n*   **Event Exploration:** Allows users to explore events through the \"Explore\" tab.\n*   **Live Event Monitoring:** Enables users to monitor live events in real-time through the \"Live\" tab.\n*   **Tabbed Navigation:** Provides a tabbed interface for switching between event exploration and live monitoring.\n*   **URL-Based Tab Selection:** Updates the active tab based on the URL, enabling direct linking to specific tabs.\n*   **Breadcrumb Navigation:** Displays breadcrumbs to show the user's location within the Activity scene.\n"
    },
    {
        "path": "frontend/src/scenes/activity/explore/EventsScene.tsx",
        "summary": "The `EventsScene` component in `EventsScene.tsx` leverages the `kea` library for state management and actions, specifically using `eventsSceneLogic` to manage a query. It renders a `Query` component, passing the current query state and a function to update it. The component configures the `Query` component with a context that enables the \"Open Editor\" button and adds `QueryFeature.highlightExceptionEventRows` as an extra data table query feature. This feature likely highlights rows in the data table that represent exception events.\n\n**Features:**\n\n*   **Query Management:** Enables users to define and manage queries related to events.\n*   **Query Editor Integration:** Provides an \"Open Editor\" button to facilitate query creation and modification.\n*   **Exception Event Highlighting:** Highlights rows in the data table that represent exception events, improving visibility and debugging.\n"
    },
    {
        "path": "frontend/src/scenes/sceneTypes.ts",
        "summary": "This code defines an enumeration `Scene` that lists all the different scenes (or pages) within the PostHog application. It also defines interfaces for managing scene properties, parameters, exports, and configuration. The `Scene` enum covers a wide range of functionalities, from error pages and dashboards to feature management, data warehousing, authentication, and messaging automations. The configuration options allow for customization of the scene's layout, authentication requirements, and the display of notices.\n\nHere's a list of high-level product features based on the scenes defined in the code:\n\n*   **Error Handling:** Displaying various error pages (404, network errors, project unavailable, tracking errors).\n*   **Dashboards and Insights:** Creating and viewing dashboards and individual insights.\n*   **Web Analytics:** Analyzing website data, including web vitals and page reports.\n*   **Cohort Management:** Defining and managing cohorts of users.\n*   **Activity Tracking:** Viewing user activity within the application.\n*   **Data Management:** Managing events and properties, including definitions and edits.\n*   **Session Replay:** Recording and replaying user sessions.\n*   **Customization:** Applying custom CSS to the application.\n*   **User Management:** Managing users and groups.\n*   **Data Pipelines:** Creating and managing data pipelines.\n*   **Experimentation:** Running and analyzing experiments.\n*   **Feature Management:** Managing feature flags.\n*   **Surveys:** Creating and managing surveys.\n*   **Data Warehousing:** Managing data warehouses and SQL queries.\n*   **Authentication:** Handling login, signup, password reset, and 2FA.\n*   **Onboarding:** Guiding new users through the application.\n*   **Billing:** Managing billing information.\n*   **Integrations:** Integrating with other services.\n*   **Debugging:** Tools for debugging queries and the application.\n*   **Notebooks:** Creating and managing notebooks.\n*   **Canvases:** Visual workspace for collaboration and data exploration.\n*   **Heatmaps:** Visualizing user interaction on websites.\n*   **Session Attribution Explorer:** Analyzing the sources of user sessions.\n*   **Messaging Automations:** Creating and managing automated messaging campaigns.\n"
    },
    {
        "path": "frontend/src/scenes/activity/explore/eventsSceneLogic.tsx",
        "summary": "This code defines the logic for the \"Explore Events\" scene in the activity section of the application. It manages the query used to fetch and display events, persisting it in the URL for shareability and restoring it from the URL when the scene is loaded. It uses `kea` for state management, `kea-router` for URL synchronization, and interacts with `teamLogic` and `featureFlagLogic` for team-specific defaults and feature flag considerations. The logic also handles invalid queries in the URL, displaying an error toast.\n\n**Features:**\n\n*   **Event Query Management:** Manages the query used to fetch and display events in the \"Explore Events\" scene.\n*   **URL Synchronization:** Persists the event query in the URL, allowing for shareable links and restoring state on page load.\n*   **Default Query Handling:** Provides default event queries based on the current team and scene.\n*   **Invalid Query Handling:** Detects and handles invalid queries in the URL, displaying an error message.\n*   **Team-Specific Configuration:** Uses teamLogic to provide team-specific default queries.\n"
    },
    {
        "path": "frontend/src/scenes/activity/explore/defaults.ts",
        "summary": "This code defines a function `getDefaultEventsSceneQuery` that returns a default query configuration for displaying events in a data table. The query is pre-configured to fetch events from the last 24 hours, order them by timestamp in descending order, and include a set of default columns. It also allows for filtering events based on properties passed as an argument. The data table is configured to display saved queries, persist column configurations, and accept properties via the URL.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Default Event Query:** Provides a pre-configured query for displaying events, simplifying initial setup.\n*   **Data Table Visualization:** Displays event data in a structured table format.\n*   **Real-time Event Display:** Fetches events from the last 24 hours, providing a near real-time view.\n*   **Sorting:** Orders events by timestamp, allowing users to easily view the most recent events.\n*   **Filtering:** Allows users to filter events based on properties.\n*   **Saved Queries:** Enables users to save and reuse common queries.\n*   **Persistent Column Configuration:** Allows users to customize and persist the columns displayed in the table.\n*   **URL-based Configuration:** Enables configuration of the data table via URL parameters.\n"
    },
    {
        "path": "frontend/src/scenes/activity/explore/createActionFromEvent.tsx",
        "summary": "This code defines a function `createActionFromEvent` that automatically creates a PostHog action based on a given event. It analyzes the event properties and elements to generate a sensible action name and define the action's steps, including targeting specific elements on the page using selectors. The function handles different event types like `$autocapture` and `$pageview` differently, and it also includes logic to handle data attributes and IDs for more precise element selection. If the action creation fails due to a unique constraint, the function recursively attempts to create the action with an incremented suffix. Upon successful creation, the user is redirected to the newly created action's page.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Automatic Action Creation:** Automatically creates actions based on events, simplifying the process of defining user interactions to track.\n*   **Intelligent Action Naming:** Generates descriptive action names based on the event type and properties.\n*   **Element Targeting:** Uses element selectors to precisely target specific elements on the page for action steps.\n*   **Data Attribute and ID Handling:** Leverages data attributes and element IDs for more robust and accurate element selection.\n*   **Recursive Action Creation with Increment:** Handles unique constraint errors by recursively attempting action creation with an incremented suffix.\n*   **Automatic Redirection:** Redirects the user to the newly created action's page for immediate review and modification.\n*   **Submit Event Handling:** Adds a property filter for submit events.\n"
    },
    {
        "path": "frontend/src/scenes/activity/explore/EventDetails.tsx",
        "summary": "The `EventDetails` component in `EventDetails.tsx` provides a detailed view of a specific event, presenting its properties, metadata, and raw data in a tabbed interface. It dynamically adjusts the displayed information and available tabs based on the event type and properties, offering specialized views for exceptions, AI-generated conversations, and autocaptured elements. The component also allows users to view and manage system properties, feature flag properties, and person properties associated with the event.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Tabbed Event Details:** Organizes event information into logical tabs for properties, metadata, raw data, and more.\n*   **Dynamic Tab Display:** Shows or hides tabs based on event type and properties (e.g., elements, image, exception, conversation).\n*   **Properties Table:** Displays event properties in a structured table with filtering and searching capabilities.\n*   **Metadata Display:** Shows key event metadata like event name, distinct ID, and timestamp.\n*   **Raw Event Data Viewer:** Provides a JSON viewer for inspecting the raw event data.\n*   **HTML Elements Display:** Renders HTML elements associated with the event.\n*   **Autocapture Image Tab:** Displays an image representation of autocaptured elements.\n*   **Exception Display:** Shows error details for exception events.\n*   **AI Conversation Display:** Presents AI-generated conversation details, including a link to the session recording.\n*   **Feature Flag Properties Display:** Shows feature flags associated with the event.\n*   **Person Properties Display:** Shows person properties set with the event, differentiating between \"set\" and \"set once\" properties.\n*   **System Properties Toggle:** Allows users to show or hide system properties.\n"
    },
    {
        "path": "frontend/src/scenes/activity/explore",
        "summary": "The provided code snippets detail the \"Explore Events\" scene within a larger application, focusing on event data visualization, querying, and action creation. The system provides a rich interface for exploring event data, including detailed views, dynamic tab display based on event type, and the ability to filter and sort events. It also automates the creation of actions based on events, simplifying the process of tracking user interactions. The system leverages URL synchronization for shareable queries and handles invalid queries gracefully.\n\n**Features:**\n\n*   **Event Querying and Management:** Allows users to define, save, and manage queries for event data, with URL synchronization for shareability.\n*   **Data Table Visualization:** Displays event data in a structured table with sorting, filtering, and persistent column configuration.\n*   **Detailed Event View:** Provides a comprehensive view of individual events, including properties, metadata, raw data, and specialized views for exceptions, AI conversations, and autocaptured elements.\n*   **Automatic Action Creation:** Automatically generates PostHog actions based on events, simplifying the process of tracking user interactions.\n*   **Exception Event Highlighting:** Highlights exception events in the data table for improved visibility.\n"
    },
    {
        "path": "frontend/src/scenes/activity/live/liveEventsTableLogic.tsx",
        "summary": "This code defines the logic for a live events table component in a PostHog application. It manages the state and behavior of the table, including fetching live event data from a stream, filtering events, pausing/resuming the stream, and displaying event statistics. The logic uses Kea for state management and interacts with the PostHog API to retrieve and process live event data. It also handles error scenarios and displays appropriate notifications.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Live Event Streaming:** Fetches and displays events in real-time as they occur.\n*   **Event Filtering:** Allows users to filter events based on event type and client-side properties.\n*   **Pause/Resume Stream:** Provides controls to pause and resume the live event stream.\n*   **Event Statistics:** Displays real-time statistics related to the events, such as the number of users on the product.\n*   **Error Handling:** Gracefully handles errors during event retrieval and displays user-friendly notifications.\n*   **Event Host Tracking:** Tracks and displays the hosts from which events are originating.\n"
    },
    {
        "path": "frontend/src/scenes/activity/live/LiveEventsTable.tsx",
        "summary": "The `LiveEventsTable` component displays a table of live events streamed from the PostHog backend. It provides real-time insights into user activity, showing event details, associated person distinct IDs, URLs or screen names, and timestamps. The table includes features to pause/resume the event stream, filter events by name, and view event details with a link to explore the event. It also displays an estimate of active users in the last 30 seconds.\n\nHere's a list of the high-level product features:\n\n*   **Real-time Event Streaming:** Displays events as they occur.\n*   **Event Details:** Shows event name, associated person, URL/Screen, and timestamp.\n*   **Pause/Resume Stream:** Allows users to control the flow of live events.\n*   **Event Filtering:** Enables filtering events by name.\n*   **Active User Count:** Provides an estimate of users active in the last 30 seconds.\n*   **Event Exploration Link:** Provides a link to explore the event in more detail.\n"
    },
    {
        "path": "frontend/src/scenes/activity/live",
        "summary": "The provided code implements a live events table within a PostHog application, offering real-time insights into user activity. This feature allows users to monitor events as they occur, filter them based on various criteria, pause or resume the event stream, and view event details such as name, associated person, URL/screen, and timestamp. The table also displays an estimate of active users and provides links to explore individual events further, while handling errors gracefully and displaying relevant notifications.\n\nHere's a list of high-level product features:\n\n*   Real-time Event Streaming\n*   Event Filtering\n*   Pause/Resume Stream\n*   Event Details Display\n*   Active User Count\n*   Event Exploration Link\n*   Error Handling and Notifications\n*   Event Host Tracking\n"
    },
    {
        "path": "frontend/src/scenes/activity",
        "summary": "The Activity Scene provides a comprehensive platform for users to explore and monitor events within the application. It offers two primary modes: \"Explore\" for in-depth event analysis and \"Live\" for real-time event monitoring. The \"Explore\" mode allows users to query, filter, and visualize event data, create actions based on events, and view detailed event information. The \"Live\" mode provides a real-time stream of events with filtering capabilities, active user count, and links to explore individual events. The scene utilizes tabbed navigation, URL-based tab selection, and breadcrumb navigation for a seamless user experience.\n\n**Features:**\n\n*   **Event Exploration:** Allows users to explore historical event data through querying, filtering, and visualization.\n*   **Live Event Monitoring:** Enables users to monitor events in real-time with filtering and pause/resume functionality.\n*   **Detailed Event View:** Provides comprehensive information about individual events, including properties, metadata, and raw data.\n*   **Automatic Action Creation:** Automatically generates PostHog actions based on events.\n*   **Real-time Event Streaming:** Displays a live stream of events as they occur.\n*   **Event Filtering:** Allows users to filter events based on various criteria.\n*   **Active User Count:** Displays an estimate of active users based on live events.\n*   **Tabbed Navigation:** Provides a tabbed interface for switching between event exploration and live monitoring.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/database/DatabaseTableList.tsx",
        "summary": "The `DatabaseTableList` component provides a user interface for browsing and searching database tables that can be queried using HogQL. It includes a search input for filtering tables and a link to the HogQL documentation. The component leverages the `databaseTableListLogic` kea logic for managing the search term and the `DatabaseTablesContainer` component to display the list of tables.\n\nHere's a list of high-level product features:\n\n*   **Table Search:** Allows users to search for specific database tables by name.\n*   **Table Listing:** Displays a list of available database tables.\n*   **HogQL Documentation Link:** Provides a direct link to the HogQL documentation for users to learn more about querying the tables.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/database/databaseTableListLogic.ts",
        "summary": "This code defines a Kea logic module named `databaseTableListLogic` responsible for managing and filtering a list of database tables. It fetches database schema information, including tables and views, and provides functionalities to filter these tables based on a search term. The logic categorizes tables into different types like \"posthog\", \"data_warehouse\", and \"view\", providing selectors to access these filtered lists and maps. It also includes an action to set the search term and a loader to fetch the database schema upon mounting.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Database Schema Loading:** Fetches and stores the database schema, including tables and views.\n*   **Table Filtering:** Allows filtering of tables based on a search term.\n*   **Table Categorization:** Categorizes tables into different types (e.g., PostHog tables, Data Warehouse tables, Views).\n*   **Table Listing:** Provides selectors to retrieve lists of tables, both filtered and unfiltered.\n*   **Table Mapping:** Provides selectors to retrieve maps of tables, keyed by name or ID.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/database/DatabaseTable.tsx",
        "summary": "The `DatabaseTable` component displays a table representing the schema of a database table within PostHog. It fetches and displays column names, types, and additional information about each column. Users can edit the schema (column types) if in edit mode, with certain types being non-editable. The component also handles displaying links to manage event or person properties when applicable and provides actions for managing joins related to views and lazy tables, including editing and deleting them.\n\nHere's a list of high-level product features:\n\n*   **Schema Visualization:** Displays the schema of a database table, including column names and types.\n*   **Schema Editing:** Allows users to modify the data type of columns within a database table (with restrictions on certain types).\n*   **Data Type Display:** Shows the data type of each column, with special handling for virtual tables, lazy tables, and expressions.\n*   **Property Management Links:** Provides links to manage event and person properties when viewing the properties columns of the events and persons tables.\n*   **Join Management:** Enables users to manage joins related to views and lazy tables, including editing and deleting existing joins.\n*   **Schema Validation Indication:** Indicates whether a column's schema is valid or not.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/database/DatabaseTables.tsx",
        "summary": "This code defines a React component, `DatabaseTablesContainer`, that displays a list of database tables and their schemas. It fetches the table data using the `databaseTableListLogic` and renders them in a `LemonTable`. Each table row displays the table name as a link to a new insight with a default query for that table, and the table type (PostHog or data warehouse). Data warehouse tables also show the last synced time. Each row can be expanded to show the table's columns using the `DatabaseTable` component, along with a button to add a link to a view using `viewLinkLogic`. The `DatabaseTables` component is a generic table component that takes the table data, loading state, and a render function for the expanded row as props.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Display Database Tables:** Shows a list of available database tables.\n*   **Table Type Identification:** Indicates the type of each table (e.g., PostHog, data warehouse).\n*   **Last Synced Time Display:** For data warehouse tables, shows the last time the table was synced.\n*   **Schema Exploration:** Allows users to view the columns (schema) of each table.\n*   **Insight Creation Link:** Provides a direct link to create a new insight with a default query for a selected table.\n*   **View Linking:** Enables users to add a link to a view for a selected table.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/database",
        "summary": "The provided code collectively implements a database management interface within PostHog, allowing users to explore and manage database tables and their schemas. The interface provides functionalities for searching, filtering, and categorizing tables, displaying table schemas with column details, and enabling schema editing with certain restrictions. Furthermore, it facilitates the creation of insights from tables, management of joins for views and lazy tables, and provides links to manage event and person properties.\n\nHere's a list of high-level product features:\n\n*   Database Schema Loading & Visualization\n*   Table Search & Filtering\n*   Table Categorization (PostHog, Data Warehouse, Views)\n*   Table Schema Exploration (Column Names, Types)\n*   Schema Editing (Column Type Modification)\n*   Data Type Display & Validation\n*   Insight Creation from Tables\n*   Join Management for Views and Lazy Tables\n*   Property Management Links (Event/Person Properties)\n*   Last Synced Time Display (Data Warehouse Tables)\n*   HogQL Documentation Link\n"
    },
    {
        "path": "frontend/src/scenes/data-management/dataManagementDescribers.tsx",
        "summary": "This code defines a `dataManagementActivityDescriber` function that generates human-readable descriptions of changes made to event and property definitions within a data management system. It parses activity log items, identifies the type of change (e.g., description update, tag modification, verification status change), and constructs sentences describing these changes, including links to the affected event or property definition. It also handles cases where events or properties are deleted. The describer utilizes a mapping of actions to specific handlers that generate the appropriate descriptions.\n\nHere's a list of high-level product features that can be inferred from the code:\n\n*   **Activity Logging:** Tracks changes to event and property definitions.\n*   **Change Descriptions:** Generates human-readable descriptions of changes.\n*   **Event/Property Linking:** Provides links to the affected event or property definitions within the activity log.\n*   **Tag Management:** Tracks the addition and removal of tags associated with events and properties.\n*   **Verification Status Tracking:** Records changes to the verification status of events and properties.\n*   **User Attribution:** Identifies the user who made the changes.\n*   **Event and Property Deletion Tracking:** Logs when events and properties are deleted.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/properties/propertyDefinitionsTableLogic.ts",
        "summary": "This code defines the logic for a property definitions table in a data management interface. It handles loading, filtering, and displaying property definitions, including event, person, and group properties. The logic manages pagination, caching, and URL synchronization for filters, and it also tracks performance and reports usage events.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Property Definition Listing:** Displays a paginated list of property definitions (event, person, and group properties).\n*   **Filtering:** Allows users to filter property definitions by property name, type (event, person, group), and group type index.\n*   **Property Type Selection:** Provides a dropdown to select the type of property definitions to display (event, person, or group properties).\n*   **Hover Highlighting:** Highlights a property definition on hover.\n*   **Detail View:** Opens a detail view for a selected property definition.\n*   **Local Updates:** Allows for local updates to property definitions, reflected in the table.\n*   **URL Synchronization:** Keeps the filter state synchronized with the URL for shareability and bookmarking.\n*   **Performance Tracking:** Tracks the loading time of property definitions and reports success/failure events.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/properties/PropertyDefinitionsTable.tsx",
        "summary": "The `PropertyDefinitionsTable` component in PostHog's frontend provides a user interface for managing and viewing property definitions. It displays a table of property definitions with columns for icon, name, type, and tags (if tagging is enabled). Users can search for specific properties, filter by property type, and navigate through paginated results. The component also includes a banner with a link to a SQL query for analyzing property usage statistics.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Display Property Definitions:** Shows a table of defined properties with key information.\n*   **Search Properties:** Allows users to search for properties by name.\n*   **Filter by Property Type:** Enables filtering properties based on their type (e.g., event, person).\n*   **Pagination:** Supports pagination for browsing through a large number of property definitions.\n*   **Property Type Display:** Shows the type of each property in a user-friendly format.\n*   **Tag Display:** Displays tags associated with each property (if tagging is enabled).\n*   **Link to Property Details:** Provides links to individual property definition pages for more detailed information.\n*   **SQL Query Link:** Offers a link to a pre-built SQL query for analyzing property usage."
    },
    {
        "path": "frontend/src/scenes/data-management/DataManagementScene.tsx",
        "summary": "The `DataManagementScene` component provides a centralized location for managing and organizing event data within PostHog. It offers a tabbed interface to navigate between different data management features, including event definitions, actions, property definitions, annotations, activity history, revenue tracking settings, and ingestion warnings. Each tab provides a dedicated view and tools for managing the respective data type, enhancing data clarity, and facilitating collaboration. Feature flags control the visibility of certain tabs, such as Revenue and Ingestion Warnings, allowing for staged rollouts and feature experimentation.\n\nHere's a list of high-level product features provided by the `DataManagementScene`:\n\n*   **Event Definitions Management:** Define and manage event types tracked in PostHog.\n*   **Actions Management:** Group events into meaningful actions for use in insights and dashboards.\n*   **Property Definitions Management:** Define and manage properties associated with events and users.\n*   **Annotations:** Add annotations to the timeline for important events or milestones.\n*   **Activity History:** Track changes and actions performed within the data management interface.\n*   **Revenue Tracking Settings:** Configure settings related to revenue event tracking (Beta).\n*   **Ingestion Warnings:** View and address warnings related to data ingestion (Feature Flag controlled).\n"
    },
    {
        "path": "frontend/src/scenes/data-management/properties",
        "summary": "The code collectively enables a comprehensive property definition management interface within PostHog. This interface allows users to view, search, filter, and manage event, person, and group properties, providing insights into data structures and usage. The system tracks performance, synchronizes filter states with the URL, and offers links to detailed property views and SQL queries for advanced analysis.\n\nHere's a list of high-level product features:\n\n*   Property Definition Listing: Displays a paginated list of property definitions (event, person, and group properties).\n*   Filtering: Allows users to filter property definitions by property name and type (event, person, group).\n*   Property Type Selection: Provides a dropdown to select the type of property definitions to display.\n*   Search Properties: Allows users to search for properties by name.\n*   Pagination: Supports pagination for browsing through a large number of property definitions.\n*   Property Type Display: Shows the type of each property in a user-friendly format.\n*   Tag Display: Displays tags associated with each property (if tagging is enabled).\n*   Detail View: Opens a detail view for a selected property definition.\n*   SQL Query Link: Offers a link to a pre-built SQL query for analyzing property usage.\n*   URL Synchronization: Keeps the filter state synchronized with the URL for shareability and bookmarking.\n*   Performance Tracking: Tracks the loading time of property definitions and reports success/failure events.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/definition/DefinitionEdit.tsx",
        "summary": "This code defines the `DefinitionEdit` component, a form for editing event or property definitions within a data management interface. It allows users to modify attributes such as tags, descriptions, verification status (verified/hidden), and property type (for properties). The component fetches and displays the current definition, handles saving changes, and provides a way to cancel edits. It leverages Lemon UI components for form elements and displays loading states and error messages.\n\nHere's a list of high-level product features implemented in the code:\n\n*   **Edit Event/Property Definitions:** Allows users to modify existing event and property definitions.\n*   **Tag Management:** Enables users to add, remove, and manage tags associated with definitions.\n*   **Description Editing:** Provides a text area for editing the description of a definition.\n*   **Status Control (Verification/Hidden):** Allows users to set the verification status (verified/unverified) and visibility (hidden/visible) of a definition.\n*   **Property Type Selection:** For property definitions, allows users to select the data type of the property (DateTime, String, Numeric, Boolean).\n*   **Loading State:** Displays a loading indicator while fetching definition data.\n*   **Error Handling:** Shows a \"Not Found\" message if the definition does not exist.\n*   **Cancel/Save Actions:** Provides buttons to cancel edits and save changes.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/definition/definitionEditLogic.ts",
        "summary": "This code defines the logic for editing event or property definitions within a data management interface. It uses Kea for state management, forms for handling user input, loaders for managing API requests, and router for navigation. The logic handles saving definitions to the backend, updating local data tables, displaying success messages, and preventing accidental data loss when navigating away from the edit page.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Edit Event Definitions:** Allows users to modify existing event definitions, including properties like name, owner, and verification status.\n*   **Edit Property Definitions:** Enables users to modify existing property definitions.\n*   **Form Validation:** Provides real-time validation of user input in the edit forms, ensuring required fields are filled.\n*   **Data Persistence:** Saves changes made to event and property definitions to the backend API.\n*   **Real-time Updates:** Updates the displayed data tables with the modified definitions after saving.\n*   **Success Notifications:** Displays user-friendly success messages upon saving definitions.\n*   **Navigation:** Redirects the user to the detail view of the edited definition after saving.\n*   **Unsaved Changes Protection:** Warns users about unsaved changes when attempting to navigate away from the edit page, preventing data loss.\n*   **Tag Reloading:** Reloads tags after saving a definition, ensuring the tag list is up-to-date.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/definition/definitionLogic.ts",
        "summary": "This code defines a Kea logic module named `definitionLogic` responsible for managing the state and behavior of a single event or property definition within a data management interface. It handles loading, creating, updating, and deleting definitions via API calls to either event or property definition endpoints. The logic also manages breadcrumbs for navigation, determines if taxonomy features are available, and distinguishes between event and property definitions.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Definition Management:** Create, read, update, and delete event and property definitions.\n*   **API Integration:** Fetches and persists definition data via API calls.\n*   **Navigation:** Provides breadcrumbs for navigating between data management sections.\n*   **Feature Flagging:** Determines availability of taxonomy features based on user permissions.\n*   **Event/Property Differentiation:** Handles event and property definitions differently based on the current context.\n*   **Real-time Updates:** Updates the property definitions model after fetching a property definition.\n*   **Table Updates:** Refreshes the event or property definitions table after deleting a definition.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/definition/DefinitionView.tsx",
        "summary": "The `DefinitionView.tsx` file defines the user interface for viewing and managing event or property definitions within PostHog. It allows users to view details such as the definition's name, description, verification status, and associated tags. For event definitions, it also displays when the event was first and last seen, provides a link to view recordings related to the event, and shows a list of connected destinations (HogFunctions) and matching events. Users can edit the definition (if taxonomy features are enabled or if it's a property), delete the definition, and view/edit its description and tags.\n\nHere's a list of high-level product features implemented in this file:\n\n*   **View Event/Property Definition Details:** Displays key information about an event or property definition, including name, description, verification status, first/last seen timestamps (for events), and property type (for properties).\n*   **Edit Definition:** Allows users to modify the definition's properties, such as its description and tags.\n*   **Delete Definition:** Enables users to remove an event or property definition.\n*   **View Recordings (for Events):** Provides a direct link to view session recordings related to a specific event.\n*   **Manage Connected Destinations (for Events):** Displays and allows management of HogFunctions (destinations) connected to an event, enabling notifications and actions based on event capture.\n*   **View Matching Events (for Events):** Shows a list of recent events that match the current definition, providing a sample of the data being captured.\n*   **Tag Management:** Allows users to add, remove, and view tags associated with the definition for better organization and categorization.\n*   **Verification Status:** Displays the verification status of the event or property (verified, hidden, visible) and provides a tooltip explaining the status.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/definition",
        "summary": "The provided code collectively implements a comprehensive data management interface focused on event and property definitions. This interface empowers users to view, create, edit, and delete definitions, manage associated metadata like tags and descriptions, and control their verification status and visibility. The system integrates with a backend API for data persistence, provides real-time updates to the UI, and offers features like navigation breadcrumbs and unsaved changes protection to enhance the user experience. For event definitions, the interface also provides links to recordings and allows management of connected destinations.\n\nHere's a list of high-level product features:\n\n*   Create, Read, Update, and Delete (CRUD) operations for Event and Property Definitions.\n*   Tag Management: Add, remove, and view tags associated with definitions.\n*   Description Editing: Modify the description of a definition.\n*   Verification Status Control: Set the verification status (verified/unverified) and visibility (hidden/visible) of a definition.\n*   Property Type Selection: Choose the data type of a property (DateTime, String, Numeric, Boolean).\n*   View Recordings (for Events): Access session recordings related to a specific event.\n*   Manage Connected Destinations (for Events): Configure HogFunctions (destinations) connected to an event.\n*   View Matching Events (for Events): See a list of recent events that match the current definition.\n*   Form Validation: Real-time validation of user input.\n*   Navigation: Breadcrumbs for easy navigation.\n*   Unsaved Changes Protection: Warn users about unsaved changes before navigating away.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/actions/ActionsTable.tsx",
        "summary": "This code defines the `ActionsTable` component, which is a table displaying a list of actions within the PostHog application. It allows users to view, search, filter, and manage actions. The table includes features such as pinning actions, displaying action names and types, showing associated tags (if the tagging feature is available), displaying creation information, and providing options to edit, duplicate, view recordings related to the action, try the action in insights, and delete the action. The component also includes a product introduction and search/filter functionality.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Action Listing and Display:** Displays a list of actions with key information like name, type, and associated tags.\n*   **Action Pinning:** Allows users to pin actions for easy access.\n*   **Action Searching and Filtering:** Enables users to search for actions by name and filter them by \"All actions\" or \"My actions\".\n*   **Action Editing and Duplication:** Provides options to edit existing actions or duplicate them to create new ones.\n*   **Action Usage Exploration:** Integrates with session replay and insights, allowing users to view recordings related to an action and try it out in insights.\n*   **Action Deletion:** Allows users to delete actions with an undo option.\n*   **Tagging Support:** Displays tags associated with actions (if the tagging feature is enabled).\n*   **Webhook Integration:** Indicates whether an action posts to Slack (if Slack integration is enabled).\n*   **Product Introduction:** Provides a brief introduction to actions and their purpose."
    },
    {
        "path": "frontend/src/scenes/data-management/actions",
        "summary": "The `ActionsTable` component provides a comprehensive interface for managing actions within PostHog. It displays a searchable and filterable list of actions, each with key details like name, type, associated tags, and creation information. Users can pin important actions, edit or duplicate existing ones, explore action usage through session replays and insights, and delete actions when necessary. The component also integrates with PostHog features like tagging and Slack integration, and includes a product introduction for new users.\n\nHere's a list of high-level product features implemented by this component:\n\n*   Action Listing and Display\n*   Action Pinning\n*   Action Searching and Filtering\n*   Action Editing and Duplication\n*   Action Usage Exploration (Session Replay & Insights)\n*   Action Deletion\n*   Tagging Support\n*   Webhook Integration (Slack)\n*   Product Introduction\n"
    },
    {
        "path": "frontend/src/scenes/data-management/ingestion-warnings/ingestionWarningsLogic.ts",
        "summary": "This code defines the logic for displaying and managing ingestion warnings in a data management interface. It fetches ingestion warning summaries from the API, allows users to search for specific warnings, and presents the data in a user-friendly format, including sparklines for historical trends. The logic also manages breadcrumbs for navigation and provides a selector to determine when to show a product introduction message.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Display Ingestion Warning Summaries:** Shows a list of different types of ingestion warnings with key information like last seen time and total count.\n*   **Historical Trend Visualization:** Presents a sparkline for each warning type, showing the count of warnings over the past 30 days.\n*   **Search Functionality:** Allows users to search for specific ingestion warnings based on keywords.\n*   **Data Loading and Refreshing:** Fetches and updates ingestion warning data from the backend API.\n*   **Navigation Breadcrumbs:** Provides breadcrumbs for easy navigation within the data management section.\n*   **Product Introduction Message:** Displays a helpful message when no data is available, guiding new users.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/ingestion-warnings/IngestionWarningsView.tsx",
        "summary": "This code implements the Ingestion Warnings View, a feature within PostHog that helps users monitor and troubleshoot issues related to data ingestion. It displays a table summarizing different types of ingestion warnings, along with a sparkline graph showing the trend of each warning over time. Users can search for specific warnings or distinct IDs, and expand each warning type to view individual instances with detailed descriptions and timestamps. The view also provides links to relevant documentation and, for replay-related warnings, includes buttons to view the corresponding session recordings.\n\nHere's a list of the high-level product features:\n\n*   **Ingestion Warning Summary Table:** Displays a summary of different types of data ingestion warnings.\n*   **Warning Trend Visualization:** Shows a sparkline graph for each warning type, visualizing its occurrence over time.\n*   **Detailed Warning Instances:** Allows users to expand each warning type to view individual instances with detailed descriptions and timestamps.\n*   **Search Functionality:** Enables users to search for specific warnings or distinct IDs.\n*   **Documentation Links:** Provides links to relevant documentation for each warning type.\n*   **Session Recording Integration:** For replay-related warnings, includes buttons to view the corresponding session recordings.\n*   **Product Introduction:** Displays a message when no warnings are present, guiding users and linking to relevant documentation."
    },
    {
        "path": "frontend/src/scenes/data-management/ingestion-warnings",
        "summary": "The Ingestion Warnings feature provides users with a comprehensive view of data ingestion issues within PostHog, enabling them to quickly identify, understand, and resolve problems. It aggregates warning data, presents it in a user-friendly format with visualizations, and offers tools for detailed investigation and resolution, including search, documentation links, and session recording integration. The feature also guides new users with helpful messages when no warnings are present.\n\nHere's a list of high-level product features:\n\n*   Ingestion Warning Summary Table: Displays a summary of different types of data ingestion warnings.\n*   Warning Trend Visualization: Shows a sparkline graph for each warning type, visualizing its occurrence over time.\n*   Detailed Warning Instances: Allows users to expand each warning type to view individual instances with detailed descriptions and timestamps.\n*   Search Functionality: Enables users to search for specific warnings or distinct IDs.\n*   Documentation Links: Provides links to relevant documentation for each warning type.\n*   Session Recording Integration: For replay-related warnings, includes buttons to view the corresponding session recordings.\n*   Product Introduction Message: Displays a helpful message when no data is available, guiding new users.\n*   Data Loading and Refreshing: Fetches and updates ingestion warning data from the backend API.\n*   Navigation Breadcrumbs: Provides breadcrumbs for easy navigation within the data management section.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/events/EventDefinitionProperties.tsx",
        "summary": "The `EventDefinitionProperties` component displays a table of properties associated with a specific event definition. It fetches and displays property details such as name, type, tags (if tagging is enabled), and an example value. The table supports pagination to handle a large number of properties and indicates loading state while fetching data. It excludes PostHog properties and shares descriptions and tags across events.\n\nHere's a list of high-level features:\n\n*   **Property Table Display:** Shows a table of properties associated with an event definition.\n*   **Property Details:** Displays property name, type, example value, and tags.\n*   **Tagging Support:** Shows tags if the organization has tagging enabled.\n*   **Pagination:** Supports pagination for a large number of properties.\n*   **Loading State:** Indicates loading state while fetching data.\n*   **Exclusion of PostHog Properties:** Excludes PostHog properties from the list.\n*   **Shared Descriptions and Tags:** Indicates that descriptions and tags are shared across events.\n*   **Navigation to Property Definition:** Allows navigation to the property definition page.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/events/EventDefinitionsTable.tsx",
        "summary": "This code defines a React component, `EventDefinitionsTable`, which displays a table of event definitions fetched from the PostHog backend. The table provides functionalities for searching, filtering, and sorting event definitions, along with pagination for handling large datasets. Each event definition row includes details like name, last seen time, and associated tags (if tagging is enabled). Users can also view recordings related to specific events and expand rows to see event definition properties.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Display Event Definitions:** Presents a tabular view of event definitions, including name, last seen time, and tags.\n*   **Search:** Allows users to search for specific event definitions by name.\n*   **Filtering:** Enables filtering of event definitions by type (e.g., all events, custom events, PostHog events).\n*   **Sorting:** Supports sorting of event definitions by name and last seen time.\n*   **Pagination:** Implements pagination for handling large sets of event definitions.\n*   **View Recordings:** Provides a link to view recordings related to a specific event.\n*   **View Event Definition Properties:** Allows users to expand rows to view detailed properties of each event definition.\n*   **SQL Query Generation:** Offers a link to generate and run a SQL query for event usage statistics.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/events/DefinitionHeader.tsx",
        "summary": "This code defines React components and utility functions for displaying event and property definitions within a data management interface. It focuses on visually representing these definitions using icons and badges to indicate their type (e.g., custom event, autocapture event, property), origin (e.g., PostHog event), and status (verified, hidden). The `DefinitionHeader` component renders a link with a title and description, incorporating the appropriate icon based on the definition type. The code leverages PostHog's Lemon UI library for consistent styling and tooltips.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Visual Representation of Event and Property Definitions:** Displays events and properties with distinct icons based on their type and origin.\n*   **Status Indicators:** Uses badges to indicate whether an event or property is verified or hidden.\n*   **Tooltips for Definitions:** Provides tooltips to display additional information about each event or property.\n*   **Links to Definition Details:** Creates clickable links to navigate to detailed information about each event or property.\n*   **Consistent UI:** Leverages Lemon UI components for a consistent and visually appealing user interface.\n*   **Metadata Display:** Shows descriptions for events and properties, including those defined by PostHog.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/events/eventDefinitionsTableLogic.ts",
        "summary": "This code defines a Kea logic module named `eventDefinitionsTableLogic` responsible for managing and displaying event definitions and their associated property definitions within a data management interface. It handles fetching paginated event definitions and property definitions from an API, filtering them based on event name, property filters, and event type, and caching the results for performance. The logic also supports updating event and property definitions locally, tracking loading states, and reporting usage events for performance monitoring. It integrates with the router to synchronize filters with the URL, allowing for shareable and bookmarkable states.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Event Definition Listing:** Displays a paginated list of event definitions.\n*   **Property Definition Listing:** Displays a paginated list of property definitions associated with a specific event.\n*   **Filtering:** Allows filtering event definitions by event name, event type, and property filters.\n*   **Local Editing:** Enables local updates to event and property definitions, reflected in the UI.\n*   **Loading State Management:** Tracks and displays loading states for event and property definitions.\n*   **Caching:** Caches API responses for improved performance and reduced network requests.\n*   **URL Synchronization:** Synchronizes filter settings with the URL for shareable states.\n*   **Performance Monitoring:** Tracks and reports performance metrics for data loading operations.\n*   **Example Property Values:** Displays example values for properties based on recent events."
    },
    {
        "path": "frontend/src/scenes/data-management/events",
        "summary": "The provided code collectively enables a comprehensive data management interface focused on event and property definitions within PostHog. It provides tools for users to easily view, search, filter, and understand their data schema. The interface displays event and property definitions with visual cues for type and status, allows for detailed inspection of properties associated with events, and offers functionalities for searching, filtering, and sorting event definitions. The system also incorporates performance optimizations like caching and URL synchronization for shareable states.\n\nHere's a list of high-level product features:\n\n*   **Event and Property Definition Listing:** Displays paginated lists of event and property definitions with key details.\n*   **Filtering and Searching:** Allows users to filter and search event definitions by name, type, and associated properties.\n*   **Visual Representation and Status Indicators:** Uses icons and badges to visually represent event/property types, origins, and statuses (verified, hidden).\n*   **Detailed Property View:** Provides a table view of properties associated with each event, including name, type, example value, and tags.\n*   **Navigation and Linking:** Enables navigation to detailed information about events and properties, including links to recordings and SQL query generation.\n*   **Local Editing and Updates:** Supports local updates to event and property definitions, reflected in the UI.\n*   **Performance Optimization:** Implements caching and URL synchronization for improved performance and shareable states.\n*   **Tagging Support:** Displays and utilizes tags for event and property definitions when tagging is enabled.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/revenue/RevenueExampleDataWarehouseTablesData.tsx",
        "summary": "This React component, `RevenueExampleDataWarehouseTablesData`, displays a query result of revenue data imported from data warehouse tables. It uses the `revenueEventsSettingsLogic` to fetch the query and renders it using the `Query` component. The component also provides a brief description of the data and a button to open the query editor.\n\nHere's a list of high-level product features:\n\n*   **Data Warehouse Revenue Data Display:** Shows revenue data imported from data warehouse tables.\n*   **Query-Based Data Fetching:** Uses a query to fetch and display the data.\n*   **Query Editor Integration:** Provides a button to open the query editor for debugging and modification.\n*   **Contextual Information:** Displays a description of the data being shown.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/revenue/CurrencyDropdown.tsx",
        "summary": "This code defines a `CurrencyDropdown` component, built using LemonSelect, that allows users to select a currency from a list. The dropdown displays currencies with their symbol, name, and code, and categorizes them into \"Most Popular\" and \"Other currencies\" sections for improved usability. Some currencies can be disabled based on configuration. The component takes a currency value and an onChange handler as props, enabling it to be used in forms or other interactive contexts.\n\nHere's a list of high-level product features:\n\n*   **Currency Selection:** Allows users to select a currency from a dropdown list.\n*   **Categorized Currency List:** Organizes currencies into \"Most Popular\" and \"Other currencies\" sections.\n*   **Currency Display:** Shows currency symbol, name, and code for each currency option.\n*   **Disabled Currencies:** Supports disabling certain currencies from being selected.\n*   **Customizable Size:** Allows adjusting the size of the dropdown component.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/revenue/BaseCurrency.tsx",
        "summary": "This React component, `BaseCurrency`, allows users to configure the base currency used for revenue calculations within PostHog. It displays the currently selected base currency and provides a dropdown menu (`CurrencyDropdown`) to change it. Upon selecting a new currency, the component updates the `baseCurrency` state via the `revenueEventsSettingsLogic` and triggers a save action to persist the changes. The component also provides a description of the base currency's purpose in revenue calculations and currency conversion.\n\nHere's a list of high-level product features:\n\n*   **Base Currency Configuration:** Allows users to set a base currency for revenue calculations.\n*   **Currency Selection:** Provides a dropdown menu to select the desired base currency from a list of available currencies.\n*   **Automatic Currency Conversion:** Converts all revenue values to the base currency for consistent reporting.\n*   **Default Currency Assumption:** Assumes revenue events without specified currency are in the base currency.\n*   **Persistence:** Saves the selected base currency to persist the setting across sessions.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/revenue/RevenueExampleEventsTable.tsx",
        "summary": "This React component, `RevenueExampleEventsTable`, displays a table of example revenue events fetched using a Kea logic hook (`revenueEventsSettingsLogic`). It utilizes the `Query` component to render the query results, providing a way to debug and understand the structure of revenue events within the user's data. The component conditionally renders based on the availability of the `exampleEventsQuery` data.\n\nHere's a list of high-level product features:\n\n*   **Revenue Event Display:** Shows a table of example revenue events.\n*   **Data Debugging:** Helps users understand and debug their revenue event data.\n*   **Dynamic Querying:** Uses a `Query` component to fetch and display data based on a query.\n*   **Conditional Rendering:** Only renders when revenue event data is available.\n*   **Open Editor Button:** Provides a button to open the query editor for further customization.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/revenue/DataWarehouseTablesConfiguration.tsx",
        "summary": "This component provides a user interface for configuring how revenue data is tracked from data warehouse tables. It allows users to map columns from their data warehouse tables to PostHog's revenue tracking system. Users can specify which column contains the timestamp, revenue amount, and currency information. The currency can be specified either as a dynamic column within the table or as a static currency for all entries in the table. The component also allows users to add new data warehouse tables to track and delete existing configurations.\n\nHere's a list of high-level product features:\n\n*   **Data Warehouse Table Mapping:** Map data warehouse tables to PostHog for revenue tracking.\n*   **Timestamp Column Configuration:** Specify the column containing the timestamp of revenue entries.\n*   **Revenue Column Configuration:** Specify the column containing the revenue amount.\n*   **Currency Configuration:** Configure the currency for revenue entries, either dynamically from a column or statically.\n*   **Table Management:** Add and delete data warehouse table configurations.\n*   **Save Configuration:** Save the configured data warehouse table mappings.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/revenue/RevenueEventsSettings.tsx",
        "summary": "The `RevenueEventsSettings` component provides a user interface for configuring how revenue is tracked within PostHog. It allows users to define which events are considered revenue events and which event properties represent the revenue value. The component also supports importing revenue data from data warehouse tables, if the corresponding feature flag is enabled. The UI includes a product introduction, base currency setting, event configuration, and data warehouse table configuration sections. Example tables are displayed to illustrate the structure of revenue events and data warehouse tables.\n\nHere's a list of high-level product features:\n\n*   **Revenue Event Configuration:** Define custom events as revenue events and map event properties to revenue values.\n*   **Data Warehouse Revenue Import:** Import revenue data from data warehouse tables (feature flag controlled).\n*   **Base Currency Setting:** Configure the base currency for revenue tracking.\n*   **Example Data Display:** Show example revenue events and data warehouse tables for guidance.\n*   **Tabbed Interface:** Organize revenue events and data warehouse tables into separate tabs (feature flag controlled).\n"
    },
    {
        "path": "frontend/src/scenes/data-management/revenue/EventConfiguration.tsx",
        "summary": "This component, `EventConfiguration`, provides a user interface for configuring revenue tracking events within a data management system. It allows users to define which events are considered revenue events, specify the property that holds the revenue value for each event, and configure the property or static value that represents the currency of the revenue. The component includes features for adding new revenue events, deleting existing ones, and saving the configuration. It also provides helpful tooltips and validation to guide the user through the configuration process.\n\nHere's a list of the high-level product features:\n\n*   **Event Selection:** Allows users to select specific events to be tracked as revenue events.\n*   **Revenue Property Mapping:** Enables users to map a specific event property to represent the revenue value for each event.\n*   **Currency Configuration:** Supports configuring the currency for revenue events, either through a dynamic event property or a static currency selection.\n*   **Event Management:** Provides functionality to add new revenue events and delete existing ones.\n*   **Save Configuration:** Allows users to save the configured revenue event settings.\n*   **User Guidance:** Offers tooltips and validation to assist users in configuring revenue events correctly.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/revenue/revenueEventsSettingsLogic.ts",
        "summary": "This code defines the logic for managing revenue tracking settings within a product analytics platform. It allows users to configure how revenue is tracked from events and data warehouse tables. The logic manages the revenue tracking configuration, including event names, revenue properties, currency settings, and data warehouse table mappings. It also handles saving and resetting the configuration, as well as providing example queries for events and data warehouse tables based on the current configuration.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Revenue Tracking Configuration:** Allows users to define which events and data warehouse tables contribute to revenue tracking.\n*   **Event-Based Revenue Tracking:** Enables users to specify the event name, revenue property, and currency property for tracking revenue from events.\n*   **Data Warehouse Revenue Tracking:** Enables users to map data warehouse tables to revenue, specifying the timestamp column, revenue column, and currency column.\n*   **Currency Management:** Allows users to set the base currency for revenue tracking and configure currency properties for events and data warehouse tables.\n*   **Configuration Persistence:** Saves and retrieves the revenue tracking configuration for each team.\n*   **Configuration Reset:** Allows users to reset the configuration to the last saved state.\n*   **Example Queries:** Generates example queries for events and data warehouse tables based on the current configuration to help users validate their settings.\n*   **Change Management:** Tracks changes to the configuration and prompts users to save before leaving the page.\n"
    },
    {
        "path": "frontend/src/scenes/data-management/revenue",
        "summary": "The provided code collectively implements a comprehensive revenue tracking configuration system within a product analytics platform. This system allows users to define and manage how revenue data is collected and interpreted from both event streams and data warehouse tables. Key features include flexible currency handling, data mapping, and example data display to aid in configuration and debugging.\n\nHere's a list of high-level product features:\n\n*   **Revenue Event Configuration:** Define custom events as revenue events and map event properties to revenue values.\n*   **Data Warehouse Revenue Import:** Import revenue data from data warehouse tables.\n*   **Data Warehouse Table Mapping:** Map data warehouse tables to PostHog for revenue tracking.\n*   **Base Currency Configuration:** Allows users to set a base currency for revenue calculations and automatic currency conversion.\n*   **Currency Selection:** Provides a dropdown menu to select the desired currency from a list of available currencies.\n*   **Example Data Display:** Show example revenue events and data warehouse tables for guidance.\n*   **Data Debugging:** Helps users understand and debug their revenue event data.\n*   **Configuration Persistence:** Saves and retrieves the revenue tracking configuration for each team.\n*   **Table Management:** Add and delete data warehouse table configurations.\n"
    },
    {
        "path": "frontend/src/scenes/data-management",
        "summary": "The provided code implements a comprehensive suite of data management tools within PostHog, designed to empower users to understand, organize, and control their event data. This includes features for defining and managing event and property definitions, exploring database schemas, tracking data ingestion, and configuring revenue tracking. The system emphasizes usability through features like search, filtering, visual representations, and detailed views, while also providing tools for advanced analysis and debugging, such as SQL query generation and session replay integration.\n\nHere's a consolidated list of high-level product features:\n\n*   Event Definitions Management: Define and manage event types tracked in PostHog.\n*   Property Definitions Management: Define and manage properties associated with events and users.\n*   Actions Management: Group events into meaningful actions for use in insights and dashboards.\n*   Database Schema Loading & Visualization: Explore and manage database tables and their schemas.\n*   Ingestion Warnings: View and address warnings related to data ingestion.\n*   Revenue Tracking Settings: Configure settings related to revenue event tracking.\n*   Activity Logging: Tracks changes to event and property definitions.\n*   Tag Management: Add, remove, and view tags associated with definitions.\n*   Search & Filtering: Enables users to quickly find specific data elements.\n*   Visual Representation & Status Indicators: Uses visual cues to represent data types and statuses.\n*   Detailed Views: Provides in-depth information about events, properties, and database schemas.\n*   SQL Query Generation: Offers links to pre-built SQL queries for analyzing data.\n*   Session Replay Integration: Links to session recordings for relevant events and warnings.\n*   Data Warehouse Integration: Import and manage data from external data warehouses.\n*   Currency Configuration: Configure currency settings for revenue tracking.\n*   Change Descriptions: Generates human-readable descriptions of changes.\n*   Annotations: Add annotations to the timeline for important events or milestones.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/Metrics/MetricSourceModal.tsx",
        "summary": "This code defines a modal component, `MetricSourceModal`, which allows users to choose the source of a metric for an experiment. The modal presents two options: creating a single-use metric specific to the experiment or using a pre-configured shared metric. Upon selection, the modal closes and either opens a metric creation modal with a default metric or opens a modal to select a shared metric. The modal supports both primary and secondary metrics for an experiment.\n\nHere's a list of high-level product features:\n\n*   **Metric Source Selection:** Allows users to choose between creating a single-use metric or using a shared metric for an experiment.\n*   **Single-Use Metric Creation:** Creates a new metric specific to the current experiment.\n*   **Shared Metric Selection:** Allows users to select a pre-configured metric from a list of shared metrics.\n*   **Primary/Secondary Metric Support:** Supports the selection of metric sources for both primary and secondary metrics of an experiment.\n*   **Modal Interface:** Provides a user-friendly modal interface for selecting the metric source.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/Metrics/PrimaryGoalTrendsExposure.tsx",
        "summary": "This component, `PrimaryGoalTrendsExposure`, allows users to define and configure the exposure metric for an experiment's primary goal. It provides an interface for selecting actions and events to track as part of the exposure metric, along with options to filter test accounts. A preview insight is displayed based on a default duration of data, and a query component visualizes the exposure metric data.\n\nHere's a list of high-level product features:\n\n*   **Define Exposure Metric:** Allows users to define the exposure metric for an experiment's primary goal.\n*   **Action and Event Selection:** Enables users to select specific actions and events to track as part of the exposure metric.\n*   **Test Account Filtering:** Provides an option to filter out test accounts from the exposure metric data.\n*   **Data Preview:** Displays a preview insight based on a default duration of data to give users an idea of the metric's behavior.\n*   **Metric Visualization:** Visualizes the exposure metric data using a query component.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/Metrics/ExperimentMetricModal.tsx",
        "summary": "This code defines a modal component, `ExperimentMetricModal`, for editing experiment metrics within a PostHog experiment. The modal allows users to modify the properties of a selected metric (either primary or secondary), including its name and other parameters defined in the `ExperimentMetricForm` component. Users can save the changes or delete the metric entirely. The modal also handles loading states and confirmation dialogs for deletion.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Edit Experiment Metrics:** Allows users to modify existing metrics associated with an experiment.\n*   **Primary/Secondary Metric Distinction:** Supports editing both primary and secondary metrics separately.\n*   **Metric Deletion:** Enables users to remove metrics from an experiment with a confirmation dialog.\n*   **Real-time Updates:** Updates the experiment metrics and reflects changes in the UI.\n*   **Form Validation and Submission:** Integrates with `ExperimentMetricForm` for metric property editing and form submission.\n*   **Loading State:** Displays a loading indicator during metric updates.\n*   **Optional Metric Name:** Allows users to provide a name for the metric.\n*   **Cancel Changes:** Allows users to discard changes made to the metric.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/Metrics/Selectors.tsx",
        "summary": "This code defines React components used as selectors for configuring funnel experiments within PostHog. It provides components for selecting the aggregation method (e.g., unique users, unique sessions, or custom SQL), setting a conversion window (time limit for conversion), and choosing an attribution type for breakdowns (first touch, last touch, all steps, or specific step). These components enhance the flexibility and customization of funnel analysis.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Funnel Aggregation Selection:** Allows users to define what constitutes a \"unique\" conversion in a funnel (e.g., unique users, sessions, or groups).\n*   **Custom SQL Aggregation:** Enables advanced users to define custom aggregation logic using SQL expressions.\n*   **Conversion Window Configuration:** Lets users set a time limit for conversions within a funnel, improving accuracy and relevance.\n*   **Attribution Type Selection:** Provides options for attributing breakdowns to specific steps or touchpoints within the funnel, offering deeper insights into user behavior.\n*   **Group Analytics Integration:** Supports analyzing funnels based on group properties, enabling B2B or account-based analytics.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/Metrics/FunnelsMetricForm.tsx",
        "summary": "This code defines the `FunnelsMetricForm` component, which is used to configure funnel-based metrics for experiments within the PostHog platform. It allows users to define the funnel steps using an `ActionFilter` component, customize the aggregation method, conversion window, and attribution settings. The form also includes a toggle to filter test accounts and displays a preview of the funnel insight using the `Query` component. The form supports both primary and secondary metrics for experiments.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Funnel Definition:** Allows users to define funnel steps using events and actions.\n*   **Metric Naming:** Enables users to assign a custom name to the funnel metric.\n*   **Aggregation Customization:** Provides options to customize how funnel data is aggregated.\n*   **Conversion Window Configuration:** Allows users to set the time window for conversion within the funnel.\n*   **Attribution Settings:** Enables users to configure attribution models for funnel conversions.\n*   **Test Account Filtering:** Provides a toggle to include or exclude test accounts from the metric calculation.\n*   **Funnel Preview:** Displays a preview of the funnel insight based on the current configuration.\n*   **Support for Primary and Secondary Metrics:** Allows configuration of both primary and secondary funnel metrics for experiments."
    },
    {
        "path": "frontend/src/scenes/experiments/Metrics/TrendsMetricForm.tsx",
        "summary": "This code defines a React component, `TrendsMetricForm`, used within the PostHog experiments feature to configure metrics for A/B tests. It allows users to define both the main metric and the exposure metric for an experiment. The main metric is configured using an `ActionFilter` component, allowing users to select events, actions, and properties to track. Users can also optionally name the metric and filter test accounts. The exposure metric can be set to either the default `$feature_flag_called` event or a custom event. The component also displays a preview of the metric's data using the `Query` component.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Define Main Experiment Metric:** Allows users to select events, actions, and properties to track as the primary metric for an experiment.\n*   **Custom Metric Naming:** Users can optionally name the metric for better organization and clarity.\n*   **Test Account Filtering:** Option to filter out test accounts from the metric calculation.\n*   **Metric Data Preview:** Displays a preview of the metric's data to help users understand the configuration.\n*   **Default Exposure Metric:** Uses the `$feature_flag_called` event as the default exposure metric.\n*   **Custom Exposure Metric:** Allows users to define a custom exposure metric for specific use cases.\n*   **Data Warehouse Metric Support:** Supports metrics based on data warehouse queries.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/Metrics/LegacyMetricModal.tsx",
        "summary": "This component, `LegacyMetricModal`, provides a modal interface for editing experiment metrics, either primary or secondary, within an experiment. It allows users to modify the type of metric (Trends or Funnels) and configure the specifics of each metric type using dedicated forms (`TrendsMetricForm` and `FunnelsMetricForm`). The modal includes options to save, cancel, or delete the metric, with appropriate confirmations for deletion. It leverages Lemon UI components for a consistent user experience and integrates with the experiment logic to manage the experiment's state and update metrics.\n\nHere's a list of high-level product features:\n\n*   **Metric Type Selection:** Allows users to switch between Trends and Funnels metrics.\n*   **Metric Configuration:** Provides dedicated forms for configuring Trends and Funnels metrics.\n*   **Metric Editing:** Enables modification of existing experiment metrics.\n*   **Metric Deletion:** Allows users to delete metrics with a confirmation dialog.\n*   **Save/Cancel Actions:** Provides buttons to save changes or cancel editing.\n*   **Real-time Updates:** Updates the experiment metrics upon saving.\n*   **Modal Interface:** Presents the metric editing interface in a modal dialog.\n*   **Primary/Secondary Metric Distinction:** Supports editing of both primary and secondary metrics.\n*   **Funnel Step Validation:** Disables saving if a Funnels metric has fewer than two steps."
    },
    {
        "path": "frontend/src/scenes/experiments/experimentsLogic.ts",
        "summary": "This code defines the logic for managing experiments within the PostHog application. It handles fetching, filtering, searching, and displaying experiments, as well as actions like deleting and archiving them. The logic also manages the UI state for experiment views, including search terms, status filters, and tab selection. It connects to other logic files like `projectLogic`, `userLogic`, and `featureFlagLogic` to access project, user, and feature flag data.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Experiment Listing and Filtering:** Display a list of experiments with filtering options based on status (draft, running, complete), search term, user, and archive status.\n*   **Experiment Creation and Management:** Allows users to create, delete, archive, and update experiments.\n*   **Experiment Search:** Enables users to search for experiments by name, feature flag key, or description.\n*   **Experiment Status Tracking:** Tracks the status of experiments (draft, running, complete) and displays them accordingly.\n*   **User-Specific Experiment Views:** Provides a view of experiments created by the current user.\n*   **Integration with Feature Flags:** Connects experiments to feature flags and manages the availability of feature flags associated with experiments.\n*   **Tabbed Navigation:** Uses tabs to organize experiments by status (all, archived, yours).\n*   **Redirection to Shared Metrics:** Handles redirection to the shared metrics page from the experiments tab.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/Metrics/SharedMetricModal.tsx",
        "summary": "This code defines a modal component, `SharedMetricModal`, used within the PostHog experiments feature to manage shared metrics. It allows users to add existing shared metrics to an experiment, either as primary or secondary metrics, or remove them. The modal displays a list of compatible shared metrics, allows filtering by tags (if the tagging feature is enabled), and provides information about each metric, including its name, description, type, and tags. It also handles cases where no compatible shared metrics exist, prompting the user to create a new one. When editing a shared metric, the modal displays the metric's details and a link to edit the shared metric.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Shared Metric Selection:** Allows users to select one or more shared metrics from a list of compatible metrics to add to an experiment.\n*   **Primary/Secondary Metric Assignment:** Enables users to specify whether the selected shared metrics should be added as primary or secondary metrics for the experiment.\n*   **Metric Filtering by Tags:** Provides a tag-based filtering mechanism to quickly find and select relevant shared metrics (if the tagging feature is enabled).\n*   **Metric Information Display:** Shows detailed information about each shared metric, including its name, description, type (Trend or Funnel), and associated tags.\n*   **Metric Removal:** Allows users to remove a shared metric from an experiment.\n*   **Metric Limit Enforcement:** Enforces limits on the number of primary and secondary metrics that can be added to an experiment.\n*   **Shared Metric Creation Prompt:** Guides users to create new shared metrics if no compatible metrics are available.\n*   **Shared Metric Editing Link:** Provides a direct link to edit a shared metric's definition.\n*   **Display Trends/Funnels:** Displays a preview of the trend or funnel associated with the shared metric.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/Metrics",
        "summary": "The provided code collectively implements a comprehensive suite of features for defining, configuring, and managing experiment metrics within PostHog. Users can create single-use metrics specific to an experiment or leverage pre-configured shared metrics. The system supports both primary and secondary metrics, allowing for nuanced analysis. A variety of metric types are supported, including Trends and Funnels, each with dedicated configuration forms. Users can customize aggregation methods, conversion windows, and attribution settings for funnels, and filter out test accounts to ensure data accuracy. Real-time data previews and visualizations provide immediate feedback on metric configurations.\n\nHere's a list of high-level product features:\n\n*   **Experiment Metric Creation & Editing:** Allows users to create new metrics or modify existing ones for A/B tests.\n*   **Shared Metric Management:** Enables the use of pre-defined, reusable metrics across multiple experiments.\n*   **Trends Metric Configuration:** Provides tools to define and customize event-based metrics.\n*   **Funnel Metric Configuration:** Supports the creation and configuration of funnel-based metrics with customizable steps, aggregation, and attribution.\n*   **Metric Source Selection:** Allows users to choose between creating a single-use metric or using a shared metric.\n*   **Data Visualization & Preview:** Displays real-time previews and visualizations of metric data.\n*   **Test Account Filtering:** Provides options to exclude test accounts from metric calculations.\n*   **Metric Type Selection:** Supports different metric types, including Trends and Funnels.\n*   **Exposure Metric Definition:** Allows users to define the exposure metric for an experiment.\n*   **Tag-Based Metric Filtering:** Enables users to filter shared metrics by tags.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/SharedMetrics/LegacySharedFunnelsMetricForm.tsx",
        "summary": "This code defines the `LegacySharedFunnelsMetricForm` component, which is used to configure and preview shared funnel metrics for experiments. It allows users to define the steps in the funnel, set aggregation, conversion window, and attribution settings, and filter out test accounts. The component also displays a preview of the funnel insight based on a default data duration, along with a warning about potential mismatches with actual results.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Funnel Step Definition:** Allows users to define the steps of a funnel using events and actions.\n*   **Funnel Aggregation:** Allows users to define how the funnel data is aggregated.\n*   **Conversion Window Configuration:** Enables users to set the time window within which a user must complete the funnel steps to be counted as converted.\n*   **Attribution Settings:** Allows users to configure how conversions are attributed to specific steps in the funnel.\n*   **Test Account Filtering:** Provides a toggle to include or exclude test accounts from the funnel analysis.\n*   **Funnel Preview:** Displays a preview of the funnel insight based on the current configuration.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/SharedMetrics/sharedMetricsLogic.tsx",
        "summary": "This code defines the logic for managing shared metrics within the experiments feature of the application. It uses Kea to manage state, actions, and side effects related to displaying and filtering shared metrics. The logic fetches shared metrics from the backend, stores them in the state, and allows users to switch between different views (All, Yours, Archived) using tabs. It also handles routing to the shared metrics page and loading the metrics upon mounting the component.\n\nHere's a list of high-level product features:\n\n*   **Shared Metrics Listing:** Displays a list of shared metrics fetched from the backend.\n*   **Tabbed Navigation:** Allows users to switch between different views of shared metrics (All, Yours, Archived).\n*   **Data Fetching:** Fetches shared metrics data from the backend API.\n*   **Routing:** Navigates the user to the shared metrics page.\n*   **State Management:** Manages the current tab selection and the list of shared metrics.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/SharedMetrics/SharedMetric.tsx",
        "summary": "This code defines a component for creating and editing shared experiment metrics within PostHog. It allows users to define a metric based on either a trend or a funnel, providing forms to configure the specific details of each type. Users can also provide a name, description, and tags for the metric. The component supports creating new metrics, updating existing ones, and deleting metrics.\n\nHere's a list of high-level product features:\n\n*   **Shared Metric Creation:** Allows users to create reusable metrics for experiments.\n*   **Metric Type Selection:** Supports defining metrics based on trends or funnels.\n*   **Metric Configuration Forms:** Provides specific forms for configuring trend and funnel metrics.\n*   **Metric Metadata:** Enables users to define a name, description, and tags for each metric.\n*   **Metric Editing:** Allows users to modify existing shared metrics.\n*   **Metric Deletion:** Enables users to delete shared metrics.\n*   **Tagging:** Allows users to categorize and organize metrics using tags.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/SharedMetrics/SharedMetrics.tsx",
        "summary": "The `SharedMetrics` component in PostHog provides a user interface for managing reusable metrics that can be used across multiple experiments. It displays a table of existing shared metrics with details like name, description, tags, type, creator, and creation date. Users can navigate back to the experiments list, create new shared metrics, and edit existing ones. The component also includes an informative banner explaining the purpose of shared metrics.\n\nHere's a list of high-level product features:\n\n*   **Display Shared Metrics:** Shows a list of existing shared metrics in a table format.\n*   **Metric Details:** Displays key information for each metric, including name, description, tags, type, creator, and creation date.\n*   **Create New Metric:** Allows users to create new shared metrics.\n*   **Edit Existing Metric:** Enables users to modify existing shared metrics.\n*   **Navigation:** Provides a way to navigate back to the main experiments page.\n*   **Tagging Support:** Allows users to tag shared metrics for better organization and filtering.\n*   **Informative Banner:** Explains the purpose and benefits of using shared metrics.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/SharedMetrics/sharedMetricLogic.tsx",
        "summary": "This code defines the logic for managing shared metrics within the experiment feature of the application. It handles creating, updating, deleting, and loading shared metrics, which are reusable metric definitions that can be used across multiple experiments. The logic interacts with the backend API to persist and retrieve shared metric data, and it uses Kea for state management and data flow. It also integrates with feature flags to determine the default query type for new shared metrics.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Create Shared Metric:** Allows users to define and save a reusable metric definition.\n*   **Update Shared Metric:** Enables users to modify existing shared metric definitions.\n*   **Delete Shared Metric:** Provides the ability to remove shared metrics.\n*   **Load Shared Metric:** Fetches and displays the details of a specific shared metric.\n*   **List Shared Metrics:** (Implicit, handled by `sharedMetricsLogic`) Provides a list of available shared metrics.\n*   **Integration with Experiment Feature:** Allows shared metrics to be used within the experiment creation and analysis workflows.\n*   **Default Metric Query Configuration:** Uses feature flags to determine the default query type (Funnel or Trends) for new shared metrics.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentCodeSnippets.tsx",
        "summary": "This code provides code snippets for integrating PostHog feature flags into various programming languages and frameworks. The snippets demonstrate how to check the value of a feature flag and execute different code paths based on the variant assigned to the user. The code also includes warnings for server-side implementations, emphasizing the need to manually send feature flag information. Additionally, some snippets provide guidance on testing the feature flag implementation by overriding the flag value.\n\nHere's a list of high-level product features:\n\n*   **Code Snippets for Multiple Languages:** Provides code examples for integrating feature flags in Android (Kotlin), iOS (Swift), NodeJS, Javascript, React, React Native, PHP, Go, Flutter, Ruby, and Python.\n*   **Feature Flag Evaluation:** Demonstrates how to retrieve and evaluate feature flag values within the code.\n*   **Variant-Based Logic:** Shows how to execute different code paths based on the feature flag variant assigned to a user.\n*   **Server-Side Implementation Warning:** Alerts users about the specific requirements for server-side feature flag implementations, including the need to manually send feature flag data.\n*   **Testing Guidance:** Offers code snippets for overriding feature flag values to facilitate testing and validation.\n*   **React Hook Example:** Provides an example of using the `useFeatureFlagVariantKey` hook in React for feature flag evaluation.\n*   **React Component Example:** Provides an example of using the `PostHogFeature` component in React for feature flag evaluation."
    },
    {
        "path": "frontend/src/scenes/experiments/SharedMetrics/LegacySharedTrendsMetricForm.tsx",
        "summary": "This code defines a React component, `LegacySharedTrendsMetricForm`, for configuring shared metrics within an experiment. It allows users to define both the main metric and the exposure metric used in the experiment. The component uses LemonTabs to separate the configuration of the main metric and the exposure metric. The main metric is configured using an ActionFilter component, allowing users to define actions and events to track. Users can also filter out test accounts from the main metric. The exposure metric can be set to a default value (unique users triggering the `$feature_flag_called` event) or customized using another ActionFilter. Test account filtering is also available for the custom exposure metric. A preview insight is displayed for the main metric.\n\nHere's a list of high-level product features:\n\n*   **Main Metric Configuration:** Define the primary metric for an experiment using actions, events, and data warehouse properties.\n*   **Exposure Metric Configuration:** Define how exposure to the experiment is measured, with options for a default setting (unique users triggering `$feature_flag_called`) or a custom definition.\n*   **Test Account Filtering:** Exclude test accounts from both the main and exposure metrics.\n*   **Action Filter Integration:** Utilize the ActionFilter component for defining actions and events in both main and exposure metrics.\n*   **Metric Preview:** Display a preview insight for the main metric to visualize the data being tracked.\n*   **Tabbed Interface:** Organize metric configuration into separate tabs for main metric and exposure metric.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/SharedMetrics",
        "summary": "The provided code collectively implements a comprehensive shared metrics management system within the PostHog experiments feature. This system allows users to define, store, and reuse metric definitions across multiple experiments, promoting consistency and efficiency. Users can create metrics based on trends or funnels, configure detailed settings for each type, and apply filters such as test account exclusion. The system also provides features for organizing metrics with tags, previewing metric insights, and managing metric visibility through archiving.\n\nHere's a list of high-level product features:\n\n*   **Shared Metric Creation:** Define and save reusable metric definitions based on trends or funnels.\n*   **Shared Metric Editing:** Modify existing shared metric definitions.\n*   **Shared Metric Deletion:** Remove shared metrics.\n*   **Shared Metric Listing:** Display a list of available shared metrics with details like name, description, tags, type, creator, and creation date.\n*   **Metric Type Selection:** Supports defining metrics based on trends or funnels.\n*   **Metric Configuration Forms:** Provides specific forms for configuring trend and funnel metrics, including aggregation, conversion windows, and attribution settings.\n*   **Metric Metadata:** Define a name, description, and tags for each metric.\n*   **Tagging:** Categorize and organize metrics using tags.\n*   **Metric Preview:** Display a preview insight for the metric to visualize the data being tracked.\n*   **Test Account Filtering:** Exclude test accounts from metric calculations.\n*   **Exposure Metric Configuration:** Define how exposure to the experiment is measured.\n*   **Tabbed Navigation:** Allows users to switch between different views of shared metrics (All, Yours, Archived).\n*   **Integration with Experiment Feature:** Allows shared metrics to be used within the experiment creation and analysis workflows.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentView/ExperimentHeader.tsx",
        "summary": "The `ExperimentHeader` component displays key information and tools related to an experiment. It conditionally renders a `PreLaunchChecklist` when the experiment is not running, guiding users through necessary steps before launch. Regardless of the experiment's status, it always shows the `RunningTime` and `Exposures` components, providing insights into the experiment's duration and user exposure metrics.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Pre-Launch Checklist:** Guides users through the necessary steps before launching an experiment.\n*   **Experiment Running Time Display:** Shows how long the experiment has been running.\n*   **Experiment Exposure Metrics:** Displays data related to user exposure to the experiment.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentView/LegacyExperimentHeader.tsx",
        "summary": "The `LegacyExperimentHeader` component is a React component that renders a `DataCollection` component within a div. The div has styling to control its width and margin. This component likely serves as a header section for a legacy experiment view, specifically focusing on displaying data collection related information or controls.\n\nHere's a list of high-level product features:\n\n*   **Data Collection Display:** Shows information related to data collection for the experiment.\n*   **Layout and Styling:** Provides a specific layout and styling for the data collection section within the experiment view.\n*   **Legacy Experiment Support:** Integrates with a legacy experiment view, suggesting compatibility with older experiment setups.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentView/Overview.tsx",
        "summary": "This code defines the `Overview` component for displaying experiment results. It shows the winning variant of an experiment, along with its probability of being the best, and indicates whether the results are statistically significant. The component utilizes data fetched and processed by the `experimentLogic` kea logic. It also includes helper components `WinningVariantText` and `SignificanceText` to display the winning variant and significance information, respectively.\n\n**Features:**\n\n*   **Winning Variant Display:** Shows the variant with the highest probability of being the best.\n*   **Probability Display:** Displays the probability of the winning variant being the best.\n*   **Statistical Significance Indication:** Indicates whether the experiment results are statistically significant.\n*   **Metric Selection:** Supports displaying results for different metrics of the experiment.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentView/RunningTime.tsx",
        "summary": "This React component, `RunningTime`, displays information about the running time of an experiment within PostHog. It shows the recommended sample size, estimated running time, and minimum detectable effect, all derived from the experiment's parameters. A progress bar visually represents the actual running time compared to the recommended running time. If the running time hasn't been calculated yet, it prompts the user to calculate it via a modal. Users can also edit the running time calculation through a button that opens the same modal.\n\nHere's a list of high-level product features:\n\n*   **Display of Experiment Running Time:** Shows the progress of the experiment's running time against the recommended duration.\n*   **Display of Recommended Sample Size:** Shows the recommended sample size for the experiment.\n*   **Display of Minimum Detectable Effect:** Shows the minimum detectable effect for the experiment.\n*   **Visual Progress Bar:** Provides a visual representation of the experiment's progress.\n*   **Running Time Calculation Modal:** Allows users to calculate or edit the recommended running time for the experiment.\n*   **Human-Friendly Number Formatting:** Displays large numbers in a readable format.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentView/ExperimentDates.tsx",
        "summary": "The `ExperimentDates` component displays the creation, start, and end dates of an experiment. If a start date exists, it shows the date and provides an option to modify it using a calendar input. If no start date exists but a creation date does, it displays the creation date. The component also displays the end date if it is available. The component leverages PostHog's Lemon UI components for the calendar input and button.\n\nHere's a list of high-level product features:\n\n*   **Experiment Creation Date Display:** Shows the date when the experiment was created.\n*   **Experiment Start Date Display:** Shows the date when the experiment started.\n*   **Experiment Start Date Modification:** Allows users to change the start date of an experiment using a calendar input.\n*   **Experiment End Date Display:** Shows the date when the experiment ended.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentView/PreLaunchChecklist.tsx",
        "summary": "The `PreLaunchChecklist` component provides a checklist to guide users through the necessary steps before launching an experiment. It visually indicates the completion status of each step (hypothesis, metric, running time) using checkmarks or highlighted circles. Users can add a hypothesis, define a primary success metric, and calculate the experiment duration through dedicated buttons that open modals. The component leverages the `experimentLogic` kea logic to manage experiment data and modal interactions.\n\nHere's a list of high-level product features:\n\n*   **Pre-launch Checklist:** A checklist to guide users through the steps required before launching an experiment.\n*   **Hypothesis Input:** Allows users to add and document their experiment hypothesis.\n*   **Primary Metric Definition:** Enables users to define the primary success metric for the experiment.\n*   **Experiment Duration Calculation:** Helps users determine the appropriate running time for the experiment.\n*   **Visual Progress Indication:** Displays the completion status of each checklist item with checkmarks or highlighted circles.\n*   **Modal Interactions:** Uses modals to facilitate hypothesis input, metric definition, and duration calculation."
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentView/Info.tsx",
        "summary": "This React component, `Info`, displays key information about an experiment within a PostHog application. It shows the experiment's status, the associated feature flag (with a link to it), the stats engine used, and the stats version (with the ability to switch between versions). It also displays the last refreshed time of the experiment results, allows manual refreshing of results, and shows who created the experiment. Finally, it displays the experiment's hypothesis and allows editing it via a modal.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Experiment Status Display:** Shows the current status of the experiment (e.g., Running, Completed).\n*   **Feature Flag Integration:** Displays the associated feature flag and provides a link to the feature flag settings.\n*   **Stats Engine Information:** Shows which stats engine is being used for the experiment.\n*   **Stats Version Control:** Allows users to select and switch between different stats versions for the experiment.\n*   **Results Refresh:** Displays the last refreshed time and allows manual refreshing of experiment results.\n*   **Experiment Creator Information:** Shows who created the experiment.\n*   **Hypothesis Management:** Displays the experiment's hypothesis and allows users to edit it.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentView/VariantScreenshot.tsx",
        "summary": "This code defines a React component called `VariantScreenshot` that allows users to upload and manage screenshots for different variants of an experiment. It provides functionality to upload images, display them as thumbnails, preview them in a modal, and delete them. The component limits the number of images to 5 per variant and uses PostHog's Lemon UI components for styling and interactions. It also leverages kea-logic for state management and hooks for file uploading.\n\nHere's a list of high-level product features implemented by the code:\n\n*   **Image Upload:** Allows users to upload images for a specific experiment variant.\n*   **Thumbnail Display:** Displays uploaded images as thumbnails.\n*   **Image Preview:** Enables users to view a larger version of the image in a modal.\n*   **Image Deletion:** Provides functionality to delete uploaded images.\n*   **Image Limit:** Restricts the number of images that can be uploaded per variant to a maximum of 5.\n*   **Variant Tag:** Displays a tag indicating the variant the screenshots belong to, along with the rollout percentage.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentView/Exposures.tsx",
        "summary": "The `Exposures` component visualizes experiment exposure data, showing the daily cumulative count of unique users exposed to each variant over the experiment's duration. It displays this data in a line chart, providing a clear view of exposure trends. If no exposures have occurred yet, it displays a message prompting the user to edit the exposure criteria. It also shows a table with the total exposures for each variant, including the percentage of total exposures. Users can edit the exposure criteria via a modal.\n\nHere's a list of high-level product features:\n\n*   **Exposure Visualization Chart:** Displays a line chart showing the cumulative exposures for each variant over time.\n*   **\"No Exposures Yet\" State:** Provides guidance and a call to action (edit exposure criteria) when no exposures have been recorded.\n*   **Exposure Criteria Display:** Shows the current exposure criteria and allows users to edit them.\n*   **Total Exposures Table:** Presents a table summarizing the total number of exposures for each variant, including percentages.\n*   **Variant Tag:** Displays a tag for each variant, likely linking to more variant-specific information.\n*   **Loading State:** Shows a spinner while exposure data is loading.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentView/DataCollectionCalculator.tsx",
        "summary": "The `DataCollectionCalculator` component in `ExperimentView` provides insights into the data collection requirements for an A/B test experiment. It calculates and displays metrics such as baseline conversion rate, minimum acceptable conversion rate, recommended sample size, and recommended running time, based on the selected primary metric (funnel or trend). The component allows users to adjust the minimum detectable effect using a slider and input field, which dynamically updates the displayed metrics. It also includes an information banner explaining the basis of the calculations and a hidden query component to ensure the goal insight is loaded for calculations.\n\nHere's a list of high-level product features:\n\n*   **Minimum Detectable Effect Adjustment:** Allows users to modify the minimum detectable effect for the experiment, influencing sample size and running time calculations.\n*   **Sample Size Recommendation:** Calculates and displays the recommended sample size needed per variant to achieve statistically significant results.\n*   **Running Time Recommendation:** Estimates and displays the recommended running time for the experiment based on the current event volume.\n*   **Baseline and Minimum Acceptable Metric Display:** Shows the current baseline conversion rate/count and the minimum acceptable conversion rate/count based on the minimum detectable effect.\n*   **Dynamic Metric Calculation:** Updates the displayed metrics in real-time as the minimum detectable effect is adjusted.\n*   **Insight Loading:** Loads the underlying funnel or trends insight to ensure accurate calculations based on the experiment's primary metric.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentView/SummaryTable.tsx",
        "summary": "This code defines a React component called `SummaryTable` that displays experiment results in a table format. The table visualizes the performance of different variants of an experiment based on the chosen metric (Trends or Funnels). It shows metrics like counts, exposure, mean, delta (percentage change), credible interval, conversion rate, p-value, and win probability for each variant. The table also provides tooltips to explain the meaning of each metric and allows users to watch recordings of users exposed to specific variants.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Experiment Result Visualization:** Displays experiment results in a tabular format.\n*   **Variant Performance Metrics:** Shows key metrics for each variant, including counts, exposure, mean, delta, credible interval, conversion rate, p-value, and win probability.\n*   **Metric Definitions:** Provides tooltips to explain the meaning of each metric.\n*   **Trends Insight Support:** Handles the display of metrics specific to Trends insights.\n*   **Funnels Insight Support:** Handles the display of metrics specific to Funnels insights.\n*   **Win Probability Calculation:** Calculates and displays the win probability for each variant.\n*   **Recording Playback Integration:** Allows users to watch recordings of users exposed to specific variants.\n*   **A/B Test Analysis:** Facilitates A/B test analysis by comparing the performance of different variants.\n*   **Statistical Significance:** Displays P-value to show statistical significance."
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentView/ReleaseConditionsTable.tsx",
        "summary": "This code defines two React components, `ReleaseConditionsModal` and `ReleaseConditionsTable`, used for managing and displaying the release conditions of an experiment's feature flag. The `ReleaseConditionsTable` displays the current release conditions in a table format, showing the rollout percentage and variant overrides for each condition. It also provides a button to open the `ReleaseConditionsModal`. The `ReleaseConditionsModal` allows users to modify the release conditions of the feature flag associated with the experiment, providing a warning about the potential impact on experiment validity. It uses the `FeatureFlagReleaseConditions` component to handle the actual modification of the release conditions and persists the changes upon saving.\n\nHere's a list of high-level product features:\n\n*   **Display Release Conditions:** Shows a table of current release conditions for an experiment's feature flag, including rollout percentage and variant overrides.\n*   **Manage Release Conditions Modal:** Opens a modal to view and modify the release conditions of the feature flag associated with the experiment.\n*   **Edit Rollout Percentage:** Allows users to adjust the rollout percentage for each release condition.\n*   **Override Variants:** Enables users to set specific variant overrides for each release condition.\n*   **Save Release Conditions:** Persists the modified release conditions to the feature flag.\n*   **Warning Banner:** Displays a warning message about the potential impact of modifying release conditions on experiment validity.\n*   **Experiment Release Conditions View Reporting:** Reports when a user views the release conditions for an experiment.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentView/DataCollection.tsx",
        "summary": "The `DataCollection` component displays the progress of data collection for an experiment, including the percentage complete, the actual running time versus the recommended running time (for Trends insights), and the number of participants seen versus the recommended sample size (for Funnels insights). It also shows the minimum detectable effect and provides a button to edit the data collection goal, which opens a modal containing the `DataCollectionCalculator` component. The `DataCollectionGoalModal` component allows users to recalculate the estimated sample size for the experiment, displaying a loading state while fetching past events and providing options to save or cancel changes.\n\nHere's a list of high-level product features:\n\n*   **Experiment Data Collection Progress Visualization:** Displays the progress of data collection for an experiment, including a progress bar and completion percentages.\n*   **Insight-Specific Data Collection Metrics:** Shows relevant metrics based on the insight type (Trends or Funnels), such as running time or participant count.\n*   **Minimum Detectable Effect Display:** Shows the minimum detectable effect for the experiment.\n*   **Data Collection Goal Editing:** Allows users to edit the data collection goal for the experiment.\n*   **Sample Size Recalculation Modal:** Provides a modal for recalculating the estimated sample size, including a loading state and save/cancel options.\n*   **Contextual Tooltips:** Provides contextual information and documentation links via tooltips.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentView/ExperimentView.tsx",
        "summary": "The `ExperimentView` component provides a comprehensive interface for viewing and managing experiments. It features tabs for \"Results\" and \"Variants\", displaying experiment results, variant distributions, and release conditions. The component also includes modals for creating and managing metrics, exposure criteria, and release conditions, as well as tools for calculating running time and exploring query results. It adapts its header and metric modals based on whether the new experiment metrics system is enabled.\n\nHere's a list of high-level product features:\n\n*   **Experiment Results Visualization:** Displays experiment results, including summary tables, trends, and funnels.\n*   **Variant Management:** Allows users to view and manage experiment variants, including release conditions and distribution.\n*   **Metric Management:** Enables users to create, edit, and manage experiment metrics, including primary and secondary metrics, and shared metrics.\n*   **Exposure Criteria Configuration:** Provides a modal for defining and managing experiment exposure criteria.\n*   **Running Time Calculation:** Offers a tool for calculating the estimated running time of an experiment.\n*   **Query Exploration:** Allows users to explore the underlying data and queries used to generate experiment results.\n*   **Release Condition Management:** Provides a table and modal for managing release conditions for experiment variants.\n*   **Experiment Overview:** Displays a high-level overview of the experiment, including key metrics and results.\n*   **Experiment Implementation Details:** Shows implementation details for web and non-web experiments.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentView/DistributionTable.tsx",
        "summary": "This code defines two React components, `DistributionModal` and `DistributionTable`, for managing and displaying the distribution of variants in an experiment. The `DistributionModal` component allows users to adjust the rollout percentage for each variant of a feature flag associated with the experiment, ensuring the total rollout sums to 100%. It also includes a holdout selector. The `DistributionTable` component displays the current distribution of variants, including a holdout group if one exists, and provides a button to open the `DistributionModal` for editing. For web experiments, it also offers a preview feature that allows users to select a domain and preview a specific variant on that domain.\n\nHere's a list of high-level product features:\n\n*   **Variant Rollout Management:** Allows users to view and adjust the rollout percentage for each variant in an experiment.\n*   **Equal Distribution:** Provides a button to automatically distribute the rollout percentage equally among all variants.\n*   **Rollout Validation:** Validates that the sum of all variant rollout percentages equals 100%.\n*   **Holdout Group Support:** Displays and manages a holdout group within the experiment, adjusting variant rollout percentages accordingly.\n*   **Web Experiment Preview:** Enables users to preview web experiment variants on a selected domain.\n*   **Experiment Distribution Overview:** Provides a table view of the current variant distribution, including rollout percentages and screenshots (if available).\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentView/HoldoutSelector.tsx",
        "summary": "This React component, `HoldoutSelector`, allows users to select a holdout group for an experiment. It fetches experiment details, holdout options, and experiment status from the `experimentLogic` using kea hooks. The component renders a LemonSelect dropdown populated with available holdout groups, including an option for \"No holdout\". The selection is disabled if the experiment is currently running and hasn't ended. When a holdout group is selected, the component updates the experiment's `holdout_id` and reports the assignment. A tooltip provides information about the holdout group feature.\n\nHere's a list of high-level product features:\n\n*   **Holdout Group Selection:** Allows users to select a holdout group for an experiment from a dropdown list.\n*   **\"No Holdout\" Option:** Provides an option to exclude any holdout group from the experiment.\n*   **Dynamic Option Population:** Populates the dropdown with available holdout groups fetched from the backend.\n*   **Experiment Status Check:** Disables the selection if the experiment is running and hasn't ended.\n*   **Real-time Update:** Updates the experiment's `holdout_id` upon selection.\n*   **Reporting:** Reports the holdout group assignment to the backend.\n*   **Informative Tooltip:** Provides a tooltip explaining the purpose and limitations of holdout groups.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentView/ExposureCriteria.tsx",
        "summary": "This code defines a modal component, `ExposureCriteriaModal`, that allows users to configure the exposure criteria for an experiment in PostHog. The modal provides options to use the default exposure criteria (counting unique users who trigger the `$feature_flag_called` event) or define a custom exposure metric. When a custom metric is selected, an `ActionFilter` component is displayed, enabling users to specify the event and properties to use for counting exposures. The modal also includes a toggle to filter out test accounts from the exposure count. The modal provides save and cancel buttons, and utilizes kea logic for state management and actions.\n\nHere's a list of the high-level product features implemented in this code:\n\n*   **Experiment Exposure Criteria Configuration:** Allows users to define how experiment exposure is measured.\n*   **Default Exposure Metric:** Provides a default option to count unique users who trigger the feature flag event.\n*   **Custom Exposure Metric:** Enables users to define custom events and properties for counting exposures.\n*   **Action Filter Integration:** Uses the `ActionFilter` component to provide a user-friendly interface for defining custom exposure metrics.\n*   **Test Account Filtering:** Allows users to exclude test accounts from the exposure count.\n*   **Modal Interface:** Presents the exposure criteria configuration options in a modal dialog.\n*   **State Management:** Uses kea logic for managing the state of the modal and experiment exposure criteria.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentView/components.tsx",
        "summary": "This code defines React components for displaying and interacting with experiment data within the PostHog platform. It includes components for visualizing experiment results, displaying variant information, and controlling the experiment lifecycle (launching, stopping, archiving). The components leverage Lemon UI for styling and Kea for state management. The code also handles displaying experiment status, significance, and providing options to explore the data as an insight or create an exposure cohort.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Experiment Variant Display:** Shows the different variants of an experiment with associated colors and tooltips for additional information.\n*   **Experiment Result Visualization:** Displays experiment results in a table or chart format, powered by the Query component.\n*   **Experiment Status Indication:** Shows the current status of the experiment (running, stopped, etc.) with corresponding color-coded tags.\n*   **Statistical Significance Reporting:** Indicates whether the primary metric of the experiment is statistically significant.\n*   **Experiment Control:** Allows users to launch, stop, and archive experiments.\n*   **Exposure Cohort Management:** Enables the creation or viewing of an exposure cohort for the experiment.\n*   **Insight Exploration:** Provides a button to explore experiment data as a new insight.\n*   **Experiment Dashboard Creation:** Allows users to create a dashboard for the experiment.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentView",
        "summary": "The Experiment View in PostHog provides a comprehensive suite of tools for managing and analyzing A/B tests. It allows users to define experiment parameters, track data collection progress, manage variant distributions and release conditions, visualize results, and control the experiment lifecycle. The interface guides users through the pre-launch checklist, provides insights into running time and exposure metrics, and facilitates collaboration through hypothesis management and experiment dashboards.\n\nHere's a list of high-level product features:\n\n*   Experiment Creation and Management: Define experiment parameters, including hypothesis, metrics, and variants.\n*   Variant Distribution and Release Condition Management: Control the rollout and targeting of different experiment variants.\n*   Data Collection and Progress Tracking: Monitor data collection progress, including sample size, running time, and exposure metrics.\n*   Results Visualization and Analysis: Visualize experiment results, including variant performance, statistical significance, and win probability.\n*   Experiment Lifecycle Management: Launch, stop, archive, and manage the experiment lifecycle.\n*   Collaboration and Reporting: Share experiment results, create dashboards, and generate reports.\n*   Pre-Launch Checklist: Guides users through the necessary steps before launching an experiment.\n*   Holdout Group Management: Allows users to select a holdout group for an experiment.\n*   Exposure Criteria Configuration: Allows users to define how experiment exposure is measured.\n*   Variant Screenshot Management: Allows users to upload and manage screenshots for different variants of an experiment.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/MetricsView/const.tsx",
        "summary": "This code defines constants that limit the number of primary and secondary metrics that can be displayed in the experiments metrics view. Specifically, it sets a maximum of 10 primary metrics and 10 secondary metrics.\n\nHere's a list of high-level product features implied by this code:\n\n*   **Metrics View:** A user interface for viewing experiment metrics.\n*   **Primary Metrics:** A designated set of metrics considered most important for evaluating experiments.\n*   **Secondary Metrics:** An additional set of metrics that provide supplementary information about experiments.\n*   **Metric Limits:** A restriction on the number of primary and secondary metrics that can be displayed simultaneously.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentImplementationDetails.tsx",
        "summary": "The `ExperimentImplementationDetails` component in PostHog provides developers with the necessary code snippets and documentation links to implement experiments in their applications. It allows users to select a specific variant group for the experiment and choose their preferred programming language or platform from a dropdown menu. Based on the selection, the component displays a code snippet tailored to the chosen variant and language, along with a link to the relevant documentation for further implementation details.\n\nHere's a list of high-level product features:\n\n*   **Language Selection:** Allows users to select their preferred programming language or platform from a dropdown menu.\n*   **Code Snippet Generation:** Generates code snippets tailored to the selected language and experiment variant.\n*   **Variant Group Selection:** Enables users to choose a specific variant group for the experiment.\n*   **Documentation Links:** Provides links to relevant documentation for further implementation details.\n*   **Client and Server Library Support:** Offers code snippets and documentation for both client-side and server-side libraries.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/MetricsView/utils.ts",
        "summary": "This code provides utility functions for handling experiment metrics in the PostHog frontend. It includes functions to determine the display tag for a metric based on its type (ExperimentMetric, ExperimentTrendsQuery, or ExperimentFunnelsQuery), returning \"Funnel\", \"Trend\", or the metric type (e.g., \"Binary\"). It also provides a function to generate a default title for an ExperimentMetric based on its configuration, using the event name for event-based metrics or the action name (or a generic \"Action X\" if the name is missing) for action-based metrics.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Metric Tagging:** Displaying a user-friendly tag indicating the type of metric (e.g., \"Funnel\", \"Trend\", \"Binary\").\n*   **Default Metric Titling:** Automatically generating a descriptive title for metrics based on their underlying event or action.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/MetricsView/MetricHeader.tsx",
        "summary": "The `MetricHeader` component displays information about a metric within an experiment, including its index, title, and type. It also provides an edit button to modify the metric and displays tags indicating the metric type and whether it's a shared metric. The component uses the `experimentLogic` to open the appropriate modal for editing the metric, distinguishing between primary and secondary metrics, as well as shared and non-shared metrics.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Metric Display:** Shows the metric's index number and title.\n*   **Metric Type Tag:** Displays a tag indicating the type of metric.\n*   **Shared Metric Tag:** Indicates if the metric is shared.\n*   **Metric Editing:** Provides a button to open a modal for editing the metric's properties.\n*   **Modal Selection:** Opens the correct modal for editing based on whether the metric is primary or secondary, and whether it is shared or not.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/MetricsView/MetricTitle.tsx",
        "summary": "The `MetricTitle` component in `MetricTitle.tsx` dynamically renders the title of a metric based on its properties and type. It prioritizes the metric's name if available. If the metric is an experiment metric, it uses a default title. For Trends insights, it displays the name of the first series in the count query. For Funnels insights, it shows a visual representation of the funnel, displaying the first and last steps with arrow icons. If none of the above conditions are met, it displays \"Untitled metric\".\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Dynamic Metric Title Generation:** Automatically generates metric titles based on metric properties and insight type.\n*   **Experiment Metric Title Handling:** Uses a default title for experiment metrics when a name is not provided.\n*   **Trends Insight Title Handling:** Displays the series name for Trends insights.\n*   **Funnels Insight Title Handling:** Visually represents Funnels insights by displaying the first and last steps.\n*   **Fallback Title:** Displays \"Untitled metric\" when a specific title cannot be determined.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/MetricsView/NoResultEmptyState.tsx",
        "summary": "The `NoResultEmptyState` component in the experiment metrics view displays helpful messages and diagnostic tools when experiment results are unavailable. It checks for specific error conditions, such as missing control or test variant events, or missing exposure events. When these errors occur, it presents a checklist indicating which events are missing and provides links to the Activity tab to investigate the missing data. It also handles timeout errors and displays a generic error message for unexpected issues.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Error Diagnosis:** Identifies specific reasons why experiment results are missing (e.g., missing control variant events).\n*   **Status Checklist:** Presents a checklist of required events and their status (received or missing).\n*   **Activity Tab Integration:** Provides links to the Activity tab pre-populated with queries to find missing events.\n*   **Timeout Handling:** Displays a specific message when experiment result retrieval times out.\n*   **Generic Error Display:** Shows a generic error message for unexpected errors.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/MetricsView/VariantDeltaTimeseries.tsx",
        "summary": "This component, `VariantDeltaTimeseries`, renders a modal containing a line chart that visualizes the performance of a variant over time in an experiment. The chart displays the delta, upper bound, and lower bound of a metric across 14 days. The modal is controlled by the `experimentLogic` store, which determines its open state. The chart is rendered using Chart.js and includes tooltips, a legend, and customized styling. The data for the chart is hardcoded in this component.\n\nHere's a list of high-level product features:\n\n*   **Modal Display:** Presents a modal window to display detailed variant performance.\n*   **Timeseries Chart:** Visualizes variant performance metrics (delta, upper bound, lower bound) over time using a line chart.\n*   **Chart.js Integration:** Leverages Chart.js library for rendering the chart.\n*   **Customizable Chart Appearance:** Offers customization options for chart styling, including colors, labels, and tooltips.\n*   **Experiment Logic Integration:** Connects to the `experimentLogic` store to manage the modal's open state.\n*   **Data Visualization:** Presents data in a clear and understandable format to aid in experiment analysis.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/MetricsView/MetricsView.tsx",
        "summary": "This code defines the `MetricsView` component, which is responsible for displaying the primary and secondary metrics of an experiment. It fetches experiment data, calculates credible intervals for each variant, and renders delta charts to visualize the performance of each variant against the control. The component also includes functionality to add new primary or secondary metrics via modals, with limits on the number of metrics that can be added. It uses tooltips to explain the metrics and charts, and provides guidance on interpreting the results.\n\nHere's a list of high-level product features implemented in the code:\n\n*   **Display of Primary and Secondary Metrics:** Shows a list of metrics associated with an experiment, categorized as primary or secondary.\n*   **Delta Chart Visualization:** Renders charts that visualize the difference in performance between experiment variants and the control group for each metric.\n*   **Credible Interval Calculation:** Calculates and displays credible intervals to represent the uncertainty in the performance of each variant.\n*   **Metric Addition:** Allows users to add new primary and secondary metrics to an experiment.\n*   **Metric Limits:** Enforces limits on the number of primary and secondary metrics that can be added.\n*   **Tooltips and Explanations:** Provides tooltips and explanations to help users understand the metrics and charts.\n*   **Shared Metrics:** Supports the use of shared metrics, which are metrics that can be used across multiple experiments.\n*   **Error Handling:** Displays error messages if there are issues fetching or processing metric data.\n*   **Empty State:** Shows a helpful message and action when no metrics have been added yet."
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentForm.tsx",
        "summary": "This code defines the `ExperimentFormFields` component, which is the form used to create and configure experiments within the PostHog platform. It allows users to define the experiment's name, description, and the feature flag that backs it. Users can either link the experiment to an existing feature flag or create a new one. The form also handles experiment types (product vs. web), participant types (persons vs. groups), and the configuration of experiment variants, including the control and up to 9 test variants.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Experiment Creation:** Allows users to create new experiments with a defined name, description, and associated feature flag.\n*   **Feature Flag Linking:** Enables linking experiments to existing feature flags.\n*   **Experiment Type Selection:** Supports different experiment types (product and web) with corresponding setup options.\n*   **Participant Type Selection:** Allows users to define the type of participant for the experiment (persons or groups).\n*   **Variant Configuration:** Provides a user interface for configuring experiment variants, including the control and multiple test variants.\n*   **Web Experiment Support:** Allows users to define variants on their website using the PostHog toolbar, without coding.\n*   **Integration with Insights:** Allows users to create experiments based on insights.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/MetricsView/DeltaChart.tsx",
        "summary": "This code defines the `DeltaChart` component, a visualization used in PostHog's experiment feature to display the performance of different experiment variants against a chosen metric. The chart uses a violin plot-like representation to show the credible interval for each variant's performance, along with vertical grid lines representing tick values. It includes interactive elements like tooltips and a modal for detailed information, and adapts its appearance based on the theme and the number of variants. The component also handles loading states and empty states gracefully.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Experiment Variant Performance Visualization:** Displays the performance of different experiment variants for a given metric.\n*   **Credible Interval Representation:** Visualizes the uncertainty in variant performance using a violin plot-like representation of the credible interval.\n*   **Interactive Tooltips:** Provides detailed information about variant performance on hover.\n*   **Detailed View Modal:** Offers a modal with more in-depth information about the metric and variant performance.\n*   **Dynamic Chart Scaling:** Adapts the chart's appearance based on the number of variants.\n*   **Loading State Handling:** Displays a loading indicator while data is being fetched.\n*   **Empty State Handling:** Shows a helpful message when no results are available.\n*   **Significance Highlighting:** Highlights statistically significant results.\n*   **Theme Adaptability:** Adjusts the chart's colors based on the current theme (light/dark mode).\n*   **Metric Selection and Display:** Allows users to select and display different metrics for comparison.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/experimentLogic.tsx",
        "summary": "This code defines the `experimentLogic` Kea logic for managing experiments in the PostHog product. It handles creating, editing, launching, ending, archiving, and resetting experiments. It manages experiment properties such as name, type, feature flag key, filters, metrics, and variants. The logic also handles loading and displaying experiment results, including trends and funnels, and managing modals for various experiment settings. It connects to other Kea logics for feature flags, cohorts, groups, insights, and project management, and reports experiment-related events for usage tracking.\n\nHere's a list of high-level product features managed by this logic:\n\n*   **Experiment Creation and Editing:** Allows users to create new experiments and modify existing ones, including setting experiment name, type, feature flag, filters, and metrics.\n*   **Variant Management:** Enables users to define and manage experiment variants, including their rollout percentages.\n*   **Experiment Launch and Termination:** Provides functionality to start and stop experiments, controlling when they are active and collecting data.\n*   **Results Visualization:** Loads and displays experiment results, including trends and funnels, to help users analyze the impact of different variants.\n*   **Metric Definition and Selection:** Allows users to define and select metrics to track during the experiment, including primary and secondary metrics.\n*   **Experiment Archiving and Resetting:** Enables users to archive completed experiments and reset running experiments to start fresh.\n*   **Exposure Criteria:** Allows users to define the criteria for exposing users to the experiment.\n*   **Feature Flag Integration:** Integrates with feature flags to control which users are exposed to the experiment variants.\n*   **Experiment Statistics:** Calculates and displays experiment statistics, such as significance and confidence intervals.\n*   **Shared Metrics:** Allows users to add shared metrics to experiments.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/MetricsView",
        "summary": "The experiment metrics view provides a comprehensive interface for analyzing experiment results, displaying both primary and secondary metrics with limits on the number displayed. The view includes delta charts visualizing variant performance against a control, credible interval calculations, and interactive elements like tooltips and detailed modals. When results are unavailable, the system provides error diagnosis, status checklists, and links to activity logs for investigation. The system also supports metric tagging, default metric titling, and dynamic title generation based on metric properties and insight type.\n\nHere's a list of high-level product features:\n\n*   Metrics View: A user interface for viewing experiment metrics.\n*   Primary and Secondary Metrics: Designated sets of metrics for evaluating experiments.\n*   Metric Limits: Restrictions on the number of metrics displayed.\n*   Metric Display: Shows metric index, title, and type.\n*   Shared Metric Tag: Indicates if a metric is shared.\n*   Metric Editing: Allows modification of metric properties.\n*   Delta Chart Visualization: Visualizes performance differences between variants and control.\n*   Credible Interval Calculation: Represents uncertainty in variant performance.\n*   Metric Addition: Allows adding new metrics to an experiment.\n*   Tooltips and Explanations: Provides guidance on interpreting metrics and charts.\n*   Error Diagnosis: Identifies reasons for missing experiment results.\n*   Status Checklist: Presents a checklist of required events.\n*   Activity Tab Integration: Links to activity logs for investigating missing events.\n*   Timeout Handling: Displays specific messages for timeout errors.\n*   Metric Tagging: Displays user-friendly tags indicating metric type.\n*   Default Metric Titling: Automatically generates descriptive metric titles.\n*   Experiment Variant Performance Visualization: Displays variant performance for a given metric.\n*   Interactive Tooltips: Provides detailed information on hover.\n*   Detailed View Modal: Offers in-depth information about metrics and variants.\n*   Dynamic Metric Title Generation: Automatically generates titles based on metric properties.\n*   Trends Insight Title Handling: Displays series names for Trends insights.\n*   Funnels Insight Title Handling: Visually represents Funnels insights.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/RunningTimeCalculator/components.tsx",
        "summary": "This code defines React components for displaying statistical information related to experiment running time calculations. It includes panels for displaying the number of unique users, average events per user, average property value per user, and the estimated standard deviation of a metric. Each panel displays the data in a user-friendly format, and the standard deviation panel includes a tooltip explaining its significance.\n\nHere's a list of high-level product features:\n\n*   **Unique Users Display:** Shows the approximate number of unique users within a specified timeframe (last 14 days).\n*   **Average Events Per User Display:** Shows the approximate average number of events per user.\n*   **Average Property Value Per User Display:** Shows the approximate average property value per user.\n*   **Standard Deviation Display:** Shows the estimated standard deviation of a metric, with a tooltip explaining its meaning and relevance to sample size calculation.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/RunningTimeCalculator/RunningTimeCalculatorModal.tsx",
        "summary": "The `RunningTimeCalculatorModal` component provides a user interface for estimating the required running time and sample size for an experiment based on historical data and user-defined parameters. The modal guides the user through a three-step process: selecting a metric, choosing a minimum detectable effect (MDE), and viewing the estimated experiment size and duration. It fetches and displays relevant metric data, allows users to input MDE, and presents the calculated recommended sample size and running time. The component also allows users to save the recommended running time, sample size, and MDE to the experiment.\n\nHere's a list of high-level product features:\n\n*   **Metric Selection:** Allows users to select a metric from the experiment's defined metrics to base the running time calculation on.\n*   **Historical Data Display:** Displays historical data related to the selected metric, including unique users, average events per user, average property value per user, standard deviation, and conversion rates (automatic and manual).\n*   **Conversion Rate Input:** Provides options for specifying the conversion rate, either automatically calculated or manually entered.\n*   **Minimum Detectable Effect (MDE) Input:** Enables users to define the minimum detectable effect as a percentage.\n*   **Estimated Running Time and Sample Size Calculation:** Calculates and displays the recommended sample size and estimated running time based on the selected metric, historical data, and user-defined MDE.\n*   **Save Recommendations:** Allows users to save the calculated recommended running time, sample size, and MDE to the experiment.\n*   **Loading State:** Displays a loading indicator while fetching metric data.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/RunningTimeCalculator/runningTimeCalculatorLogic.tsx",
        "summary": "This code defines the logic for a running time calculator for experiments. It fetches historical data for a given experiment metric, calculates the required sample size based on the minimum detectable effect, variance, and other parameters. The logic supports different metric types (mean, funnel) and methods for calculating the conversion rate (manual, automatic). It uses queries to retrieve data from the backend and provides selectors to derive values from the loaded data.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Experiment Running Time Estimation:** Calculates the estimated running time or sample size needed for an experiment to reach statistical significance.\n*   **Metric Selection:** Allows users to select a metric from the experiment to base the running time calculation on.\n*   **Minimum Detectable Effect (MDE) Input:** Enables users to specify the minimum effect size they want to be able to detect.\n*   **Conversion Rate Input (Manual/Automatic):** Provides options for users to either manually input the conversion rate or have it automatically calculated based on historical data.\n*   **Historical Data Fetching:** Fetches historical data for the selected metric to estimate variance and other parameters.\n*   **Sample Size Calculation:** Calculates the recommended sample size based on the provided inputs and historical data.\n*   **Support for Different Metric Types:** Supports different metric types, including mean (total count, sum) and funnel metrics.\n*   **Variance Calculation:** Calculates the variance of the metric based on historical data.\n*   **Display of Intermediate Values:** Exposes intermediate values like variance, standard deviation, and average events/property values per user for better transparency."
    },
    {
        "path": "frontend/src/scenes/experiments/RunningTimeCalculator",
        "summary": "The code collectively implements a Running Time Calculator for experiments, providing a user-friendly interface to estimate the necessary duration and sample size for achieving statistically significant results. This involves fetching and displaying historical data related to experiment metrics, allowing users to select a metric, define a minimum detectable effect (MDE), and choose between automatic or manual conversion rate input. The calculator then computes and presents the recommended sample size and running time, enabling users to save these recommendations to the experiment for future reference.\n\nHere's a list of high-level product features:\n\n*   Experiment Running Time Estimation: Calculates the estimated running time or sample size needed for an experiment to reach statistical significance.\n*   Metric Selection: Allows users to select a metric from the experiment to base the running time calculation on.\n*   Minimum Detectable Effect (MDE) Input: Enables users to specify the minimum effect size they want to be able to detect.\n*   Conversion Rate Input (Manual/Automatic): Provides options for users to either manually input the conversion rate or have it automatically calculated based on historical data.\n*   Historical Data Fetching and Display: Fetches and displays historical data for the selected metric, including unique users, average events/property values per user, standard deviation, and conversion rates.\n*   Sample Size Calculation: Calculates the recommended sample size based on the provided inputs and historical data.\n*   Support for Different Metric Types: Supports different metric types, including mean (total count, sum) and funnel metrics.\n*   Variance Calculation: Calculates the variance of the metric based on historical data.\n*   Save Recommendations: Allows users to save the calculated recommended running time, sample size, and MDE to the experiment.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/Experiment.tsx",
        "summary": "This code defines the `Experiment` scene in the frontend application. It uses the `experimentLogic` to manage the state of the experiment, including whether it's a new experiment, an existing experiment being edited, or if the experiment is missing. Based on the state, it renders either the `ExperimentForm` for creating or editing experiments or the `ExperimentView` for viewing an existing experiment. If the experiment is not found, it renders a `NotFound` component.\n\nHere's a list of high-level product features:\n\n*   **Experiment Creation:** Allows users to create new experiments.\n*   **Experiment Editing:** Enables users to modify existing experiments.\n*   **Experiment Viewing:** Provides a detailed view of an experiment's configuration and results.\n*   **Experiment Not Found Handling:** Displays a user-friendly message when an experiment cannot be found.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/WebExperimentImplementationDetails.tsx",
        "summary": "The `WebExperimentImplementationDetails` component provides the user interface for configuring and launching a web experiment toolbar. It displays information about defining variant changes directly on a website using the toolbar and allows the user to select a domain to launch the toolbar on. The component uses a dialog to present a list of authorized URLs for the experiment, enabling the user to choose the appropriate domain.\n\nHere's a list of high-level product features:\n\n*   **Experiment Variant Configuration:** Allows users to define and configure experiment variants directly on their website.\n*   **Visual Toolbar Integration:** Provides a toolbar that can be launched on a website to visually select elements and apply transformations for each variant.\n*   **Authorized URL Management:** Enables users to manage and select authorized URLs for launching the experiment toolbar.\n*   **Domain Selection:** Presents a dialog to choose the specific domain on which to launch the experiment toolbar.\n*   **Toolbar Launch:** Provides a button to launch the toolbar on the selected website domain.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/utils.ts",
        "summary": "This code provides utility functions and default configurations for managing experiments within the PostHog platform. It includes functions for calculating minimum detectable effect, transforming filters for winning variants, generating filters for viewing recordings based on experiment metrics, validating feature flags for experiment eligibility, and creating default experiment metrics (Trends, Funnels, Count, Continuous). Additionally, it offers functionality to convert existing insights into experiment metrics and to transform experiment exposure configurations into filter objects.\n\nHere's a list of high-level product features supported by this code:\n\n*   **Experiment Setup and Configuration:** Defines default experiment metrics and configurations (Trends, Funnels, Count, Continuous).\n*   **Feature Flag Validation:** Validates feature flags to ensure they are eligible for use in experiments.\n*   **Variant Management:** Transforms filters to isolate winning variants in experiments.\n*   **Metric Calculation:** Calculates the Minimum Detectable Effect (MDE) for experiment metrics.\n*   **Insight Conversion:** Converts existing insights into experiment metrics.\n*   **Experiment Recording Filters:** Generates filters for viewing recordings related to specific experiment variants.\n*   **Exposure Event Configuration:** Transforms experiment exposure configurations into filter objects.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/constants.ts",
        "summary": "This code defines constants related to experiments in the PostHog frontend. It specifies IDs for different types of metric insights used in experiments, such as Trends and Funnels. It also defines a list of allowed math types for legacy experiments, including basic counts, unique users/sessions, active users, first-time events, group analytics, sums, and HogQL queries. Additionally, it defines a constant for representing multiple experiment variants and a minimum exposure count required to display experiment results.\n\nHere's a list of high-level product features based on the code:\n\n*   **Experiment Metric Insights:** Support for various metric insights within experiments, including Trends, Funnels, and secondary metrics.\n*   **Legacy Experiment Math Types:** Defines the types of calculations allowed for legacy experiments, including counts, unique users, group analytics, sums, and custom HogQL queries.\n*   **Multiple Experiment Variants:** Support for experiments with multiple variants.\n*   **Minimum Exposure Threshold:** Enforces a minimum number of exposures before experiment results are displayed.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/holdoutsLogic.tsx",
        "summary": "This code defines the logic for managing experiment holdouts in a product analytics platform. It uses Kea, a state management library, to handle the state, actions, and side effects related to holdouts. The logic includes functionalities for creating, updating, deleting, and loading holdouts, as well as reporting when a holdout is created. It interacts with a backend API to persist and retrieve holdout data.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Holdout Creation:** Allows users to define new holdouts with a name, description, and filter criteria.\n*   **Holdout Editing:** Enables users to modify existing holdouts, including their name, description, and filter criteria.\n*   **Holdout Deletion:** Provides the ability to remove holdouts that are no longer needed.\n*   **Holdout Listing:** Displays a list of all defined holdouts.\n*   **Holdout Details:** Shows the details of a specific holdout, including its configuration.\n*   **Experiment Holdout Reporting:** Tracks when a new experiment holdout is created.\n*   **User Interface Notifications:** Provides user feedback through toast notifications upon successful creation, update, or deletion of holdouts.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/Holdouts.tsx",
        "summary": "This code defines a React component called `Holdouts` that allows users to manage holdout groups for experiments. Holdout groups are stable sets of users excluded from experiment variations, serving as a baseline for comparison. The component provides functionality to create, edit, and delete holdout groups, each with a name, description, and rollout percentage. The component displays a table of existing holdouts and provides a modal for creating and editing them.\n\nHere's a list of high-level product features:\n\n*   **Holdout Group Management:** Create, read, update, and delete holdout groups.\n*   **Holdout Group Configuration:** Define the name, description, and rollout percentage for each holdout group.\n*   **Rollout Percentage Control:** Use a slider and input field to specify the percentage of users included in a holdout group.\n*   **Holdout Group Listing:** Display a table of existing holdout groups with their name, description, and rollout percentage.\n*   **Experiment Integration:** Apply holdout groups to experiments during creation (though this part is not visible in the code).\n*   **User Interface:** Provides a modal for creating and editing holdouts, and uses Lemon UI components for a consistent look and feel.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/ExperimentMetricForm.tsx",
        "summary": "The `ExperimentMetricForm` component allows users to define and configure metrics for experiments. It provides options to select the metric type (Funnel or Mean), define the metric using an ActionFilter component, and set a time window for considering metric values relevant to an experiment exposure. The component also displays a read-only query visualization based on the metric configuration.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Metric Type Selection:** Allows users to choose between Funnel and Mean metrics.\n*   **Metric Definition via Action Filter:** Enables users to define metrics using an ActionFilter component, supporting both event and action-based definitions.\n*   **Data Warehouse Metric Support:** Supports metrics based on data warehouse events.\n*   **Time Window Configuration:** Allows users to define a time window (experiment duration or conversion window) for considering metric values.\n*   **Read-Only Query Visualization:** Displays a read-only query visualization of the defined metric.\n*   **Funnel Step Definition:** Supports defining steps for Funnel metrics.\n*   **Numerical Properties Only Filtering:** Allows filtering for numerical properties when defining metrics.\n"
    },
    {
        "path": "frontend/src/scenes/experiments/Experiments.tsx",
        "summary": "This code defines the Experiments scene in PostHog, providing a user interface for managing and analyzing experiments. It includes features for creating new experiments, viewing experiment details, archiving/deleting experiments, and filtering/searching experiments based on status, creator, and name. The scene also incorporates tabs for viewing all experiments, user-specific experiments, archived experiments, holdout groups, and shared metrics. The UI leverages Lemon UI components for a consistent look and feel.\n\nHere's a list of high-level product features:\n\n*   **Experiment Creation:** Allows users to create new experiments.\n*   **Experiment Listing:** Displays a list of experiments with details like name, creator, start date, duration, and status.\n*   **Experiment Filtering:** Enables filtering experiments by status (Draft, Running, Complete), creator, and search term.\n*   **Experiment Archiving:** Provides the ability to archive experiments.\n*   **Experiment Deletion:** Allows users to permanently delete experiments.\n*   **Experiment Details View:** Links to a detailed view of each experiment.\n*   **Tabbed Navigation:** Organizes experiments into tabs for \"All\", \"Yours\", \"Archived\", \"Holdouts\", and \"Shared Metrics\".\n*   **Holdout Group Management:** Provides a dedicated section for managing holdout groups.\n*   **Shared Metrics Management:** Provides a dedicated section for managing shared metrics.\n*   **User-Specific Experiments:** Allows users to view experiments created by them.\n"
    },
    {
        "path": "frontend/src/scenes/experiments",
        "summary": "The provided code collectively implements a comprehensive A/B testing and experimentation platform within PostHog, enabling users to design, implement, analyze, and manage experiments to optimize their products and features. The platform supports a wide range of functionalities, from defining experiment parameters and variants to tracking metrics, visualizing results, and managing the experiment lifecycle. It also includes features for creating and managing shared metrics and holdout groups, providing code snippets for integrating feature flags into various programming languages, and offering a visual toolbar for configuring web experiments.\n\nHere's a list of high-level product features:\n\n*   **Experiment Creation and Management:** Define experiment parameters, including hypothesis, metrics, and variants, and manage the experiment lifecycle (launch, stop, archive, reset).\n*   **Variant Management:** Define and manage experiment variants, including their rollout percentages and release conditions.\n*   **Feature Flag Integration:** Connect experiments to feature flags and manage the availability of feature flags associated with experiments.\n*   **Metric Definition and Selection:** Define and select metrics to track during the experiment, including primary and secondary metrics, and create shared, reusable metrics.\n*   **Results Visualization and Analysis:** Load and display experiment results, including trends and funnels, to help users analyze the impact of different variants.\n*   **Code Snippet Generation:** Generate code snippets tailored to the selected language and experiment variant for easy integration.\n*   **Visual Experiment Configuration:** Define and configure experiment variants directly on a website using a visual toolbar.\n*   **Holdout Group Management:** Create, read, update, and delete holdout groups to serve as a baseline for comparison.\n*   **Experiment Running Time Estimation:** Calculate the estimated running time or sample size needed for an experiment to reach statistical significance.\n*   **Experiment Listing and Filtering:** Display a list of experiments with filtering options based on status, search term, user, and archive status.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/FeatureFlagSettings.tsx",
        "summary": "This React component, `FeatureFlagSettings`, renders a settings panel for feature flags, specifically controlling the default persistence behavior of new flags. It utilizes a LemonSwitch component to toggle the `flags_persistence_default` setting for the current team. When enabled, new feature flags will automatically have persistence enabled, ensuring consistent user experiences across authentication steps. The component also includes a link to the PostHog documentation for more information. The `openFeatureFlagSettingsDialog` function opens a modal dialog containing the settings panel.\n\nHere's a list of high-level product features:\n\n*   **Default Flag Persistence Control:** Allows users to enable or disable flag persistence by default for new feature flags.\n*   **Team-Level Setting:** The persistence setting is configured at the team level, affecting all new flags created within that team.\n*   **UI Toggle:** Provides a user-friendly switch to control the default persistence setting.\n*   **Documentation Link:** Offers direct access to relevant documentation for more information on flag persistence.\n*   **Modal Dialog:** Presents the settings in a modal dialog for a clean and focused user experience.\n"
    },
    {
        "path": "frontend/src/scenes/sceneLogic.ts",
        "summary": "This code defines the core logic for managing scenes (or \"pages\") within the PostHog application. It handles routing, authentication, and the loading/unloading of scene-specific logic. The code ensures proper redirects based on user authentication status, organization/project availability, and onboarding completion. It also manages the state of loaded scenes, including their parameters and associated logic.\n\nHere's a breakdown of the high-level product features this code supports:\n\n*   **Scene Management:** Loading, unloading, and switching between different scenes (pages) in the application.\n*   **Routing:** Handling URL changes and mapping them to specific scenes.\n*   **Authentication & Authorization:** Redirecting users based on their authentication status and permissions (e.g., redirecting unauthenticated users to the login page).\n*   **Organization & Project Management:** Ensuring users are redirected to organization/project creation flows if they don't have an organization or project.\n*   **Onboarding:** Guiding users through product onboarding flows and redirecting them to the appropriate onboarding steps based on their progress.\n*   **Feature Flag Management:** Controlling access to features based on feature flags.\n*   **Error Handling:** Displaying error pages (e.g., 404) when a scene cannot be found.\n*   **Product Analytics:** Tracking page views and user behavior.\n*   **Deep Linking:** Handling deep links with parameters and search queries.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/FeatureFlagProjects.tsx",
        "summary": "This code defines a React component, `FeatureFlagProjects`, that displays information about feature flag usage across different projects within an organization and allows users to copy a feature flag to another project. It fetches and displays a table of projects using the current feature flag, including the project name, creator, creation date, release conditions, and status (enabled/disabled). The component also includes a feature to copy the current feature flag to another project, with a warning if the flag uses a static cohort. An info banner provides context and instructions based on the user's permissions and the number of projects in the organization.\n\nHere's a list of high-level product features:\n\n*   **Display Feature Flag Usage Across Projects:** Shows a table listing all projects where a specific feature flag is being used.\n*   **Project Details:** Displays key information for each project using the feature flag, including name, creator, creation date, release conditions, and status.\n*   **Copy Feature Flag to Another Project:** Allows users to duplicate a feature flag and its configuration to a different project within the organization.\n*   **Static Cohort Warning:** Provides a warning message when copying a feature flag that references a static cohort, explaining potential data inconsistencies in the target project.\n*   **Contextual Information Banner:** Displays an information banner with instructions and context based on user permissions and the number of projects in the organization.\n*   **Destination Project Selection:** Provides a dropdown to select the destination project for copying the feature flag.\n*   **Update Existing Flag:** Allows updating the flag in the destination project if it already exists.\n"
    },
    {
        "path": "frontend/src/scenes/scenes.ts",
        "summary": "This code defines the different scenes (or routes) within the PostHog application, along with their configurations. It specifies whether a scene is project-based, organization-based, or instance-level, and assigns names, layouts, and default documentation paths to each. It also handles redirects from old URLs to new ones. The code configures various parts of the application, including dashboards, insights, data management, session replay, feature flags, surveys, data warehouse, and more.\n\nHere's a list of high-level product features based on the code:\n\n*   **Dashboards:** Create and manage dashboards for data visualization.\n*   **Insights:** Analyze data and create insights.\n*   **Error Tracking:** Monitor and manage application errors.\n*   **Web Analytics:** Analyze website traffic and user behavior.\n*   **Cohorts:** Group users based on shared characteristics.\n*   **Activity Feed:** Track user activity and events.\n*   **Data Management:** Manage events, properties, and data definitions.\n*   **Session Replay:** Record and replay user sessions.\n*   **People & Groups:** Manage user profiles and group properties.\n*   **Feature Flags:** Control feature releases and A/B test new features.\n*   **Experiments:** Run A/B tests and analyze experiment results.\n*   **Surveys:** Create and distribute surveys to collect user feedback.\n*   **Data Warehouse:** Integrate with data warehouses for advanced analytics.\n*   **SQL Editor:** Write and execute SQL queries.\n*   **Notebooks:** Create and share interactive notebooks for data analysis.\n*   **Heatmaps:** Visualize user interactions on web pages.\n*   **Messaging:** Send broadcasts and automated messages to users.\n*   **Settings:** Configure project and organization settings.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/FeatureFlagCodeExample.tsx",
        "summary": "The `FeatureFlagCodeExample` component displays instructions on how to implement a given feature flag. It receives a `featureFlag` object as a prop and renders a heading \"How to implement\" followed by the `FeatureFlagInstructions` component, passing the `featureFlag` prop to it. This component is likely part of a larger feature flag management system, providing developers with guidance on integrating feature flags into their codebase.\n\nHere's a list of high-level product features:\n\n*   **Feature Flag Display:** Renders a specific feature flag's implementation details.\n*   **Implementation Instructions:** Provides instructions on how to implement a given feature flag.\n*   **Integration with Feature Flag Management:** Integrates with a broader system for managing feature flags.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/featureManagementDetailLogic.ts",
        "summary": "This code defines a Kea logic module named `featureManagementDetailLogic` that is part of the feature flags management functionality. It connects to `teamLogic` to access the current team ID and to `featureManagementLogic` to access the currently active feature flag's ID and details. This logic module likely provides the data and actions necessary to display and interact with the details of a specific feature flag.\n\n**Features:**\n\n*   Connects to team context to scope feature flags to the current team.\n*   Connects to the main feature management logic to access the currently selected feature flag.\n*   Provides a dedicated logic module for handling the details view of a feature flag.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/JSONEditorInput.tsx",
        "summary": "The `JSONEditorInput` component provides a JSON editor with syntax highlighting and dynamic height adjustment based on content. It leverages the `CodeEditor` component and allows for read-only mode, custom line height, and a placeholder when the editor is empty and not focused. The component also includes styling to customize the appearance of the editor.\n\nHere's a list of high-level product features:\n\n*   **JSON Syntax Highlighting:** Provides syntax highlighting for JSON content within the editor.\n*   **Dynamic Height Adjustment:** Automatically adjusts the height of the editor based on the number of lines of content.\n*   **Read-Only Mode:** Allows the editor to be set to read-only, preventing users from modifying the content.\n*   **Placeholder Text:** Displays placeholder text when the editor is empty and not focused.\n*   **Customizable Line Height:** Allows customization of the line height within the editor.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/FeatureManagement.tsx",
        "summary": "This code implements a feature management interface. It displays a list of feature flags on the left and the details of the selected feature flag on the right. Users can select a feature flag from the list to view and presumably edit its details using the `FeatureManagementDetail` component. The component uses `kea` for state management, allowing it to fetch and display feature flags and manage the active selection.\n\nHere's a list of high-level product features:\n\n*   **Feature Flag Listing:** Displays a list of available feature flags.\n*   **Feature Flag Selection:** Allows users to select a feature flag from the list.\n*   **Feature Flag Details:** Displays detailed information about the selected feature flag.\n*   **State Management:** Uses `kea` to manage the state of the feature flags and the active selection.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/FeatureFlagCodeOptions.tsx",
        "summary": "This code defines the configuration and snippets for displaying feature flag code examples in various programming languages and platforms within the PostHog application. It provides a structured way to present code snippets for different SDKs, along with links to relevant documentation. The code also categorizes libraries based on their support for local evaluation, payloads, remote configuration, and bootstrapping.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Feature Flag Code Snippets:** Display code snippets for integrating feature flags into various client and server-side applications.\n*   **Multi-Language Support:** Provide code examples for JavaScript, Android, API, Go, Flutter, iOS, Node.js, React, React Native, PHP, Python, Ruby, and C#/.NET.\n*   **Documentation Links:** Link code snippets to relevant documentation for each language/platform.\n*   **Client/Server Differentiation:** Categorize SDKs as either client-side or server-side.\n*   **Local Evaluation Support:** Indicate which libraries support local feature flag evaluation.\n*   **Payload Support:** Indicate which libraries support feature flag payloads.\n*   **Remote Configuration Support:** Indicate which libraries support remote configuration.\n*   **Bootstrapping Support:** Provide code snippets for bootstrapping feature flags in JavaScript and React Native.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/FeatureFlagAnalysisTab.tsx",
        "summary": "The `FeatureFlagAnalysisTab` component provides a user interface for analyzing feature flags using dashboards. It displays existing dashboards associated with a feature flag in a table or allows the user to create a new dashboard from a template or from scratch. The component conditionally renders either a table of existing dashboards or a dashboard template chooser and a modal for creating new dashboards, depending on whether the feature flag already has associated dashboards.\n\nHere's a list of high-level product features:\n\n*   **Display Existing Dashboards:** Shows a table of dashboards associated with a specific feature flag.\n*   **Create New Dashboard:** Allows users to create new dashboards for feature flag analysis.\n*   **Dashboard Templates:** Provides pre-built dashboard templates tailored for feature flag analysis.\n*   **Dashboard Filtering:** Supports filtering and searching of dashboards.\n*   **New Dashboard Modal:** Presents a modal interface for creating dashboards from scratch.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/FeatureFlagStatusIndicator.tsx",
        "summary": "This React component, `FeatureFlagStatusIndicator`, displays the status of a feature flag using a `LemonTag` component from the Lemon UI library. It shows a warning tag with the feature flag's status (e.g., \"STALE\" or \"INACTIVE\") if the status is not one of the default states (ACTIVE, INACTIVE, DELETED, or UNKNOWN). A tooltip provides additional information about the status, including the reason for the status and guidance on how to handle the flag (e.g., removing references before deleting).\n\nHere's a list of high-level product features:\n\n*   **Feature Flag Status Display:** Shows the current status of a feature flag.\n*   **Status-Specific Warnings:** Displays warnings based on the feature flag's status (e.g., \"STALE\", \"INACTIVE\").\n*   **Tooltip Information:** Provides detailed information about the feature flag's status and recommended actions.\n*   **Lemon UI Integration:** Uses Lemon UI components for consistent styling and user experience.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/RecentFeatureFlagInsightsCard.tsx",
        "summary": "The `RecentFeatureFlagInsightsCard.tsx` component displays a list of insights related to a specific feature flag. It fetches related insights and their loading state from the `featureFlagLogic`. If no related insights exist, it displays a message with a button to create a new insight pre-configured to analyze the feature flag's usage. The component uses a `CompactList` to efficiently render the insights, limiting the display to the first 5 items. Clicking the \"Create insight\" button triggers a product intent event for cross-selling to product analytics.\n\n**Features:**\n\n*   **Displays related insights:** Shows a list of existing insights that utilize a specific feature flag.\n*   **Loading state:** Indicates when related insights are being fetched.\n*   **Empty state:** Provides a helpful message and a call to action when no related insights exist.\n*   **Insight creation shortcut:** Offers a button to create a new insight pre-configured to analyze the feature flag.\n*   **Product intent tracking:** Records user intent to create insights from feature flags for cross-selling purposes.\n*   **Limited display:** Restricts the number of displayed insights to a maximum of 5.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/featureManagementLogic.ts",
        "summary": "This code defines the logic for managing feature flags in a product. It uses Kea, a state management library, to handle the state and side effects related to feature flags. The logic fetches feature flags from an API, stores them in the state, and allows the user to select a specific feature flag to view its details. It also manages the breadcrumbs for navigation within the feature management section. The logic also handles routing, updating the URL when a feature flag is selected and vice versa.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Feature Flag Listing:** Displays a list of available feature flags.\n*   **Feature Flag Selection:** Allows users to select a specific feature flag from the list.\n*   **Feature Flag Details:** Displays detailed information about a selected feature flag.\n*   **URL-based Navigation:** Enables navigation to specific feature flags via URLs.\n*   **Breadcrumb Navigation:** Provides breadcrumbs for easy navigation within the feature management section.\n*   **Automatic Feature Flag Selection:** Automatically selects the first feature flag when the list is loaded, if no feature flag is currently selected.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/FeatureManagementDetail.tsx",
        "summary": "The `FeatureManagementDetail.tsx` file defines the UI for displaying detailed information about a specific feature flag. It uses LemonSkeletons to show loading states for different sections: Metadata, Rollout, Usage, Activity, History, and Permissions. The component fetches the active feature flag's name using `featureManagementDetailLogic` and displays it at the top.\n\nHere's a list of high-level product features that can be inferred from the code:\n\n*   **Feature Flag Metadata:** Displaying and potentially editing metadata associated with a feature flag.\n*   **Feature Flag Rollout Configuration:** Configuring the rollout strategy for a feature flag (e.g., percentage rollout, targeting specific user segments).\n*   **Feature Flag Usage Tracking:** Tracking how a feature flag is being used in the application.\n*   **Feature Flag Activity Logging:** Logging events related to a feature flag's lifecycle (e.g., creation, updates, enabling/disabling).\n*   **Feature Flag History Tracking:** Displaying a history of changes made to a feature flag.\n*   **Feature Flag Permissions Management:** Managing access control and permissions for feature flags.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/FeatureFlagSchedule.tsx",
        "summary": "This code defines the `FeatureFlagSchedule` component, which allows users to schedule changes to a feature flag. Users can schedule changes to either enable/disable the flag or add a new release condition. The component displays a table of scheduled changes, including the type of change, the scheduled time, creation information, and status. Users with edit permissions can create new scheduled changes and delete existing ones that haven't been executed yet.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Schedule Feature Flag Status Changes:** Allows users to schedule enabling or disabling a feature flag at a specific date and time.\n*   **Schedule Release Condition Additions:** Enables users to schedule the addition of new release conditions to a feature flag at a future time.\n*   **View Scheduled Changes:** Displays a list of all scheduled changes for a feature flag, including their status (scheduled, complete, error).\n*   **Delete Scheduled Changes:** Provides the ability to delete scheduled changes that have not yet been executed.\n*   **User Permissions Check:** Restricts scheduling and editing capabilities based on user permissions.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/featureFlagPermissionsLogic.tsx",
        "summary": "This code defines the `featureFlagPermissionsLogic` Kea logic, responsible for managing permissions related to feature flags. It handles loading, adding, and deleting roles associated with a specific feature flag, as well as managing the visibility of a modal for adding these roles. The logic fetches available roles and existing associated roles from the API, and provides selectors to derive lists of roles that can be added to a feature flag. It also tracks roles that are pending addition.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Role-Based Access Control for Feature Flags:** Allows associating specific roles with feature flags, controlling who can access or modify them.\n*   **Permission Management UI:** Provides a modal interface for managing feature flag permissions, including adding and removing roles.\n*   **Role Assignment:** Enables assigning existing roles to feature flags, granting the roles' members the defined access.\n*   **Dynamic Role Filtering:** Filters available roles to only show those that are not already associated with the feature flag.\n*   **API Integration:** Interacts with the backend API to fetch roles, associated roles, and manage permission assignments.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/FeatureFlagSnippets.tsx",
        "summary": "This code provides code snippets for using PostHog feature flags in various programming languages (Node.js, PHP, Go, Ruby, Python, and C#). The snippets demonstrate how to check if a feature is enabled, retrieve a feature flag's variant, or retrieve a feature flag's payload, considering user and group properties. The snippets also include options for local evaluation and remote configuration, along with reminders about setting API keys for these features.\n\nHere's a list of high-level product features that can be inferred from the code:\n\n*   **Feature Flag Evaluation:** Determine if a feature flag is enabled for a specific user or group.\n*   **Multivariate Feature Flags:** Retrieve the variant of a feature flag assigned to a user or group.\n*   **Feature Flag Payloads:** Retrieve a payload associated with a feature flag.\n*   **User and Group Targeting:** Target feature flags based on user and group properties.\n*   **Local Evaluation:** Evaluate feature flags locally within the application, without requiring a network request.\n*   **Remote Configuration:** Fetch feature flag configurations remotely from the PostHog server.\n*   **Encrypted Payloads:** Support for encrypted feature flag payloads.\n*   **Code Snippet Generation:** Generate code snippets for various programming languages to simplify feature flag implementation.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/featureFlagsLogic.ts",
        "summary": "This code defines the logic for managing feature flags in a PostHog application. It handles fetching, updating, and deleting feature flags, as well as managing filters, pagination, and the active tab on the feature flags page. The logic also integrates with the activation flow to mark the \"Create Feature Flag\" task as completed upon successful creation of a feature flag. It uses kea-router to synchronize the UI state with the URL, allowing for shareable links with specific filters and tabs.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Feature Flag Management:** Create, read, update, and delete feature flags.\n*   **Filtering and Searching:** Filter feature flags based on various criteria (active status, creator, type, search term, order).\n*   **Pagination:** Browse feature flags in a paginated manner.\n*   **Tabbed Interface:** Navigate between different views of feature flags (Overview, History, Exposure, Analysis, Usage, Permissions, Projects, Schedule).\n*   **URL Synchronization:** Shareable URLs that persist filters and active tab.\n*   **Activation Flow Integration:** Track user progress in setting up feature flags.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/FeatureFlagAutoRollout.tsx",
        "summary": "This component, `FeatureFlagAutoRollback`, allows users to define conditions under which a feature flag will automatically roll back. It supports two types of rollback conditions: error-based (using Sentry integration) and metric-based (using insights). Users can add multiple conditions, each with its own threshold and operator. The component displays the current conditions and allows users to remove them. When read-only, the component displays the configured rollback conditions.\n\nHere's a list of high-level product features:\n\n*   **Define Auto Rollback Conditions:** Allows users to specify conditions for automatic feature flag rollback.\n*   **Error-Based Rollback:** Triggers rollback based on Sentry error counts, with options for percentage increase/decrease thresholds.\n*   **Metric-Based Rollback:** Triggers rollback based on insight metrics, allowing users to select a metric and define a threshold with greater than/less than operators.\n*   **Multiple Rollback Conditions:** Supports adding multiple rollback conditions, evaluated as \"OR\".\n*   **Read-Only Mode:** Displays configured rollback conditions in a read-only format.\n*   **Sentry Integration Check:** Verifies and prompts for Sentry integration if error-based rollback is selected.\n*   **Dynamic Metric Display:** Displays the current trailing average of the selected metric.\n*   **Condition Removal:** Allows users to remove existing rollback conditions."
    },
    {
        "path": "frontend/src/scenes/feature-flags/FeatureFlags.tsx",
        "summary": "This code defines the FeatureFlags scene in PostHog, providing a user interface for managing feature flags. It includes functionalities for creating, viewing, editing, enabling/disabling, duplicating, and deleting feature flags. The UI displays a table of feature flags with key information such as key, tags, creator, creation date, release conditions, and status. Users can also copy the feature flag key, try it out in Insights, and view activity logs related to the flags. Access control is implemented to restrict certain actions based on user permissions.\n\nHere's a list of high-level product features:\n\n*   **Feature Flag Management:** Create, read, update, and delete feature flags.\n*   **Feature Flag Listing:** Display a list of feature flags with key information (key, tags, creator, creation date, release conditions, status).\n*   **Feature Flag Status Control:** Enable/disable feature flags.\n*   **Feature Flag Duplication:** Duplicate existing feature flags.\n*   **Feature Flag Key Copying:** Copy the feature flag key to the clipboard.\n*   **Insights Integration:** Try out feature flags in Insights.\n*   **Access Control:** Restrict feature flag actions based on user permissions.\n*   **Tagging:** Add and view tags associated with feature flags.\n*   **Activity Logging:** Track activity related to feature flags.\n*   **Stale Flag Detection:** Identify and flag stale feature flags.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/FeatureFlagReleaseConditionsLogic.ts",
        "summary": "This code defines the logic for managing feature flag release conditions in a PostHog application. It handles the UI state and API interactions for defining who sees a feature flag based on properties, rollout percentages, and multivariate variants. The logic allows users to add, remove, duplicate, and reorder condition sets, each defining a specific group of users or entities that should be targeted by the feature flag. It also calculates the estimated number of users affected by each condition set, providing insights into the potential impact of the feature flag.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Define Feature Flag Release Conditions:** Allows users to specify conditions for releasing a feature flag to a subset of users or entities.\n*   **Property-Based Targeting:** Enables targeting based on user or entity properties, allowing for granular control over feature flag exposure.\n*   **Rollout Percentage Control:** Provides the ability to gradually roll out a feature flag by specifying a percentage of users or entities to target.\n*   **Multivariate Flag Variants:** Supports assigning different variants of a feature flag to different groups of users or entities.\n*   **Condition Set Management:** Allows users to add, remove, duplicate, and reorder condition sets to create complex targeting rules.\n*   **Estimated User Impact Calculation:** Calculates the estimated number of users affected by each condition set, providing insights into the potential impact of the feature flag.\n*   **Group-Based Targeting:** Enables targeting based on groups, allowing for feature flag releases to specific segments of users.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/FeatureFlagInstructions.tsx",
        "summary": "This component, `FeatureFlagInstructions.tsx`, provides code snippets and instructions for implementing feature flags in various client and server-side libraries. It allows users to select their preferred language/library and view corresponding code examples. The component also offers advanced options to display code snippets for payloads, bootstrapping, and local evaluation, depending on the selected library and feature flag configuration. It dynamically adjusts the available options and code snippets based on the feature flag's properties, such as whether it uses remote configuration, encrypted payloads, or requires experience continuity.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Code Snippet Generation:** Generates code snippets for feature flag implementation in various programming languages and libraries.\n*   **Language/Library Selection:** Allows users to select their preferred language or library from a dropdown list.\n*   **Payload Code Snippets:** Displays code snippets for handling feature flag payloads, if applicable.\n*   **Bootstrapping Code Snippets:** Shows code snippets for bootstrapping feature flags, primarily for client-side libraries.\n*   **Local Evaluation Code Snippets:** Provides code snippets for local evaluation of feature flags, suitable for server-side implementations.\n*   **Dynamic Option Display:** Adjusts the available options (payload, bootstrapping, local evaluation) based on the selected library and feature flag configuration.\n*   **Documentation Links:** Provides links to relevant documentation for each language/library.\n*   **Remote Configuration Support:** Handles feature flags configured for remote configuration.\n*   **Encrypted Payload Support:** Handles feature flags with encrypted payloads.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/FeatureFlagReleaseConditions.tsx",
        "summary": "This code defines the `FeatureFlagReleaseConditions` component, which allows users to define conditions for releasing a feature flag to a subset of users or groups. It provides a UI for adding and configuring multiple condition sets, each consisting of a set of property filters. Users can define criteria based on user properties, event properties, or cohorts. The component also includes features for duplicating, removing, and reordering condition sets. It provides visual feedback on the potential impact of the feature flag on the user base and warnings about using properties that are not immediately available.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Conditional Feature Flag Releases:** Define rules to release a feature flag to specific user segments based on properties and cohorts.\n*   **Multiple Condition Sets:** Support for defining multiple \"OR\" conditions, allowing for flexible targeting.\n*   **Property-Based Targeting:** Target users based on user properties, event properties, and cohorts.\n*   **Condition Set Management:** Features for adding, duplicating, removing, and reordering condition sets.\n*   **Impact Estimation:** Display the estimated percentage of users affected by the feature flag.\n*   **Early Access Feature Awareness:** Warn users about using properties that are not immediately available, and guide them to learn more about bootstrapping.\n*   **Read-Only Mode:** Display conditions in a read-only format.\n*   **Group-Based Targeting:** Target users based on group properties.\n*   **Visual Condition Display:** Display conditions in a clear and readable format.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/featureFlagLogic.ts",
        "summary": "This code defines the `featureFlagLogic` using Kea, a state management library. It handles the state and logic for managing feature flags within the application. This includes loading, creating, updating, and deleting feature flags, as well as managing their associated filters, variants, and rollback conditions. The logic also integrates with other parts of the application, such as dashboards, experiments, and user settings, to provide a comprehensive feature flag management experience.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Feature Flag Creation and Management:** Allows users to create new feature flags with various configurations.\n*   **Feature Flag Targeting:** Enables targeting feature flags to specific user groups based on properties and rollout percentages.\n*   **Multivariate Feature Flags:** Supports creating feature flags with multiple variants and assigning rollout percentages to each variant.\n*   **Remote Configuration:** Allows configuring feature flags to be remotely configured, requiring a payload.\n*   **Rollback Conditions:** Enables setting up rollback conditions based on performance metrics to automatically disable a feature flag if it negatively impacts performance.\n*   **Scheduled Changes:** Supports scheduling changes to feature flag configurations, such as enabling or disabling them at a specific time.\n*   **Feature Flag Usage Analysis:** Provides insights into feature flag usage and impact through integration with dashboards and experiments.\n*   **Permissions Management:** Manages user access levels and permissions for feature flags.\n*   **Copy Feature Flags:** Allows copying feature flags between projects.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/activityDescriptions.tsx",
        "summary": "This code defines how activity log items related to feature flags are described in a human-readable format. It maps different actions performed on a feature flag (like creation, updates to name, status, filters, rollout percentage, tags, etc.) to specific descriptions that can be displayed in an activity log. The code uses components like `SentenceList`, `ObjectTags`, and `PropertyFilterButton` to construct these descriptions, and it also handles linking to the feature flag itself. It also handles multivariate flags and boolean flags differently.\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **Feature Flag Creation Logging:** Logs when a new feature flag is created, including the user who created it and the flag's name.\n*   **Feature Flag Status Tracking:** Logs when a feature flag is enabled or disabled.\n*   **Filter Condition Change Logging:** Logs changes to the filter conditions that determine which users a feature flag applies to, including changes to rollout percentages and property filters.\n*   **Multivariate Flag Support:** Logs changes to multivariate flag variants, including rollout percentages and payloads.\n*   **Tagging and Tag Change Logging:** Logs when tags are added or removed from a feature flag.\n*   **Rollout Percentage Tracking:** Logs changes to the rollout percentage of a feature flag.\n*   **Key Change Logging:** Logs when the key of a feature flag is changed.\n*   **Soft Delete Logging:** Logs when a feature flag is deleted or un-deleted.\n*   **Experience Continuity Tracking:** Logs when experience continuity is enabled or disabled for a feature flag.\n*   **Activity Log Display:** Displays human-readable descriptions of feature flag activities in a log format.\n*   **User Attribution:** Identifies the user who performed each action on a feature flag.\n*   **Linking to Feature Flags:** Provides links from activity log entries directly to the corresponding feature flag.\n"
    },
    {
        "path": "frontend/src/scenes/feature-flags/FeatureFlag.tsx",
        "summary": "This code defines the `FeatureFlag` component in a PostHog application, responsible for displaying and managing feature flags. It allows users to view, create, edit, and manage feature flags, including their rollout conditions, usage, associated projects, and schedules. The component provides a tabbed interface for organizing different aspects of a feature flag, such as an overview, usage analysis, project associations, scheduling, history, and permissions. It also integrates with other PostHog features like experiments, dashboards, and activity logs.\n\nHere's a list of high-level product features implemented in the code:\n\n*   **Feature Flag Management:** Create, read, update, and delete feature flags.\n*   **Rollout Configuration:** Define conditions for feature flag rollout, including release conditions and auto-rollback settings.\n*   **Usage Analysis:** Analyze how feature flags are being used within the application.\n*   **Project Association:** Associate feature flags with specific projects.\n*   **Scheduling:** Schedule feature flag activation and deactivation.\n*   **History Tracking:** Track changes made to feature flags over time.\n*   **Permissions Management:** Control access to feature flags based on user roles and permissions.\n*   **Code Example Generation:** Generate code snippets for using feature flags in different programming languages.\n*   **Experiment Integration:** Link feature flags to experiments for A/B testing.\n*   **Dashboard Integration:** Integrate feature flags with dashboards for monitoring and analysis.\n*   **Activity Logging:** Log all actions performed on feature flags for auditing purposes.\n*   **Tagging:** Add tags to feature flags for organization and filtering.\n*   **Variant Management:** Configure different variants for a feature flag.\n*   **Auto Rollback:** Automatically rollback a feature flag if performance degrades.\n*   **JSON Editor:** Edit the JSON configuration of a feature flag.\n*   **Permissions Tab:** Manage permissions for a feature flag.\n*   **Analysis Tab:** Analyze the usage of a feature flag.\n*   **Schedule Tab:** Schedule the activation and deactivation of a feature flag.\n*   **Projects Tab:** View and manage the projects associated with a feature flag.\n*   **Usage Tab:** View the usage of a feature flag.\n*   **Overview Tab:** View the overview of a feature flag.\n*   **History Tab:** View the history of a feature flag."
    },
    {
        "path": "frontend/src/scenes/feature-flags",
        "summary": "This collection of code files outlines a comprehensive feature flag management system within PostHog, enabling users to control feature releases, target specific user segments, and analyze the impact of their flags. The system provides tools for creating, updating, and deleting feature flags, defining rollout conditions, scheduling changes, and managing permissions. It also offers code snippets for various programming languages, integrates with other PostHog features like Insights and Dashboards, and tracks activity for auditing purposes.\n\nHere's a list of high-level product features:\n\n*   **Feature Flag Management:** Create, read, update, and delete feature flags with a user-friendly interface.\n*   **Targeted Rollouts:** Define release conditions based on user properties, cohorts, and rollout percentages for granular control.\n*   **Multivariate Flags:** Support for creating feature flags with multiple variants and assigning rollout percentages to each.\n*   **Automatic Rollback:** Configure automatic rollback based on error rates or metric performance.\n*   **Scheduling:** Schedule feature flag activation and deactivation for future dates and times.\n*   **Code Snippet Generation:** Generate code snippets for various programming languages and libraries to simplify implementation.\n*   **Usage Analysis:** Integrate with Insights and Dashboards to analyze the impact of feature flags on user behavior.\n*   **Activity Logging:** Track all actions performed on feature flags for auditing and debugging.\n*   **Permissions Management:** Control access to feature flags based on user roles and permissions.\n*   **Project Association:** Associate feature flags with specific projects for better organization and management.\n*   **Copy Feature Flags:** Duplicate feature flags between projects.\n*   **Default Persistence Control:** Enable or disable flag persistence by default for new feature flags.\n*   **JSON Editor:** Edit the JSON configuration of a feature flag.\n"
    },
    {
        "path": "frontend/src/scenes/wizard/Wizard.tsx",
        "summary": "The `Wizard.tsx` file defines a setup wizard component that guides users through an authentication process. It leverages the `wizardLogic` to manage the wizard's state and displays different views based on the current state. The component uses a `BridgePage` for layout and presents messages and animations to the user depending on whether the authentication is pending, successful, or invalid.\n\nHere's a list of high-level product features:\n\n*   **Authentication Setup Wizard:** Guides users through the authentication process for setting up PostHog.\n*   **Loading/Pending State:** Displays a loading spinner and message while the authentication is in progress.\n*   **Success State:** Shows a success message and animation upon successful authentication.\n*   **Error/Invalid State:** Displays an error message and animation if the authentication fails.\n*   **Bridge Page Integration:** Uses a `BridgePage` component to provide a consistent layout and styling.\n"
    },
    {
        "path": "frontend/src/scenes/wizard/wizardLogic.tsx",
        "summary": "The `wizardLogic.tsx` file defines the logic for a wizard flow in the PostHog frontend, likely related to user onboarding or a similar guided setup process. It manages the state of the wizard, including a wizard hash, the current view (pending, creating, success, or invalid), and handles the authentication of the wizard using an API call. The logic also integrates with the router to trigger actions based on the URL, specifically when the `/wizard` route is accessed with a hash parameter.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Wizard Authentication:** Authenticates a user's access to the wizard flow using a hash.\n*   **State Management:** Manages the different states of the wizard flow (pending, creating, success, invalid).\n*   **URL-Based Navigation:** Triggers wizard actions based on the URL, allowing users to enter the wizard flow via a specific link.\n*   **API Integration:** Communicates with the backend API to authenticate the wizard.\n*   **Error Handling:** Handles authentication failures and sets the view to \"invalid\".\n"
    },
    {
        "path": "frontend/src/scenes/teamActivityDescriber.tsx",
        "summary": "This code defines a set of functions that describe changes made to a team's configuration within the PostHog application. These functions, organized in the `teamActionsMapping` object, map specific team properties to human-readable descriptions of their changes. The descriptions cover various aspects of team settings, including session recording configurations (duration, URL triggers, masking, sampling rate), autocapture settings (exceptions, web vitals), heatmaps, team name, test account filters, survey configurations, and more. The code leverages React components (`SentenceList`, `PropertyFiltersDisplay`) and utility functions to construct informative and user-friendly activity logs.\n\nHere's a list of high-level product features that are reflected in this code:\n\n*   **Session Recording Configuration:** Allows users to configure various aspects of session recording, such as minimum duration, URL triggers, masking sensitive data, and sampling rate.\n*   **Autocapture Settings:** Enables users to control automatic data capture, including exceptions, web vitals, and opting in/out of autocapture.\n*   **Heatmaps:** Provides the ability to enable or disable heatmap functionality.\n*   **Team Name Management:** Allows users to set or change the team name.\n*   **Test Account Filters:** Enables users to define and manage filters for internal and test accounts, excluding their data from insights.\n*   **Survey Configuration:** Allows customization of survey appearance and behavior, including white labeling, thank you messages, and various styling options.\n*   **Person on Events (v2):** Enables or disables the Person on Events (v2) feature.\n"
    },
    {
        "path": "frontend/src/scenes/wizard",
        "summary": "The provided code implements a setup wizard within the PostHog frontend, guiding users through an authentication process. The wizard manages its state, including pending, success, and error states, and uses a `BridgePage` for consistent layout. It authenticates users via a hash parameter in the URL, communicating with the backend API to validate access and manage the wizard's flow.\n\nHere's a list of high-level product features:\n\n*   Authentication Setup Wizard\n*   Loading/Pending State with visual indicators\n*   Success State with visual indicators\n*   Error/Invalid State with visual indicators\n*   URL-Based Navigation for wizard access\n*   API Integration for authentication\n*   State Management for wizard flow\n"
    },
    {
        "path": "frontend/src/scenes/paths/constants.ts",
        "summary": "The code defines constants related to the visual layout of path nodes in the frontend application. These constants specify the width of a path node card and the top and left offsets used for positioning these cards within the path visualization.\n\nHere's a list of high-level product features that could utilize these constants:\n\n*   **Path Visualization:** Displaying a visual representation of a path, likely a sequence of steps or nodes.\n*   **Node Card UI:** Rendering individual nodes within the path as cards with a specific width.\n*   **Node Positioning:** Precisely positioning node cards within the path visualization using top and left offsets.\n"
    },
    {
        "path": "frontend/src/scenes/paths/PathsLabel.tsx",
        "summary": "The `PathCanvasLabel` component displays a message to the user explaining how path items are visualized on the canvas. It informs users that larger path items are shown by default and that smaller items can be viewed by hovering over a node. This provides guidance on how to interact with and interpret the path visualizations.\n\nHere's a list of high-level product features related to this component:\n\n*   **Path Visualization:** Displaying paths between nodes on a canvas.\n*   **Path Item Size Differentiation:** Representing path items with varying sizes.\n*   **Default Path Item Visibility:** Showing larger path items by default.\n*   **Interactive Path Item Display:** Revealing smaller path items on hover.\n*   **User Guidance:** Providing instructions on how to view different path items.\n"
    },
    {
        "path": "frontend/src/scenes/paths/types.ts",
        "summary": "This code defines the data structures used to represent paths in the frontend. It introduces three types: `PathsNode`, `PathsLink`, and `Paths`. `PathsNode` represents a node in the path, containing only a name. `PathsLink` is imported from `~/queries/schema/schema-general` and likely defines the connection between nodes. `Paths` represents the entire path, containing an array of `PathsNode` and an array of `PathsLink`.\n\nHere's a list of high-level product features that could utilize this code:\n\n*   **Path Visualization:** Displaying a visual representation of user paths through the application.\n*   **Path Analysis:** Analyzing common user journeys and identifying drop-off points.\n*   **Funnel Creation:** Defining funnels based on user paths.\n*   **User Segmentation:** Segmenting users based on their path behavior.\n*   **Personalized Recommendations:** Providing personalized recommendations based on user paths.\n"
    },
    {
        "path": "frontend/src/scenes/paths/Paths.tsx",
        "summary": "The `Paths` component visualizes user journey paths as a directed graph. It fetches path data based on insight properties and renders it using SVG canvases. The component dynamically adjusts the canvas size based on the container, removes and re-renders the paths when data changes, and displays node cards for each path node. It also handles loading and error states, displaying appropriate messages when no data is available or an error occurs.\n\nHere's a list of high-level product features:\n\n*   **Path Visualization:** Renders user journey paths as a directed graph.\n*   **Dynamic Canvas Resizing:** Adjusts the canvas size based on the container dimensions.\n*   **Data-Driven Rendering:** Fetches and renders path data based on insight properties.\n*   **Node Card Display:** Shows detailed information for each node in the path.\n*   **Loading and Error Handling:** Displays appropriate messages during data loading and error states.\n*   **Customizable Theme:** Allows customization of the path visualization's colors.\n"
    },
    {
        "path": "frontend/src/scenes/paths/PathNodeCardMenu.tsx",
        "summary": "The `PathNodeCardMenu` component displays detailed information about a specific node within a user path in a funnel or journey analysis. It shows the number of users continuing along the path, the number dropping off, and the average conversion time from the previous step. Users can click on the \"Continuing\" or \"Dropping off\" counts to open a modal displaying the list of users who took that action. The component adapts its display based on whether the node is the start or end of the path, omitting irrelevant information.\n\nHere's a list of high-level features provided by this component:\n\n*   **Display Continuing Users:** Shows the number and percentage of users continuing from the current node to the next step in the path.\n*   **Display Drop-off Users:** Shows the number and percentage of users dropping off at the current node.\n*   **Display Average Conversion Time:** Shows the average time users take to move from the previous step to the current node.\n*   **User List Modal:** Allows users to open a modal displaying the list of users who continued or dropped off at the current node.\n*   **Contextual Display:** Adapts the displayed information based on whether the node is the start or end of the path.\n"
    },
    {
        "path": "frontend/src/scenes/paths/PathNodeCard.tsx",
        "summary": "The `PathNodeCard.tsx` file defines a React component called `PathNodeCard` that represents a node in a path visualization. This component displays information about a specific node, such as its name and value (count), and provides interactive elements like a dropdown menu with further details and actions. The card's position is dynamically calculated based on the node's coordinates, and its appearance changes based on whether it's a start or end node and whether it's selected. The component leverages Lemon UI components for dropdowns and tooltips, and interacts with the `pathsDataLogic` to access and update path-related data and actions.\n\nHere's a list of high-level product features associated with this component:\n\n*   **Path Visualization:** Displays a node within a path visualization, showing its name and count.\n*   **Interactive Node Details:** Provides a dropdown menu on hover with detailed information about the node, including continuing count, drop-off count, and average conversion time.\n*   **Path Exploration Actions:** Offers actions within the dropdown menu, such as opening a persons modal or viewing the path to a funnel.\n*   **Dynamic Positioning:** Positions the node card dynamically based on its coordinates in the path visualization.\n*   **Visual Highlighting:** Highlights selected path start or end nodes with a distinct border color.\n*   **Tooltip Information:** Displays the page URL associated with the node in a tooltip.\n"
    },
    {
        "path": "frontend/src/scenes/paths/PathNodeCardButton.tsx",
        "summary": "This component, `PathNodeCardButton`, renders a button within a path visualization, displaying the name and count of a specific node in the path. It provides several actions related to the node, accessible through a dropdown menu. These actions include setting the node as the path start or end point, excluding the node from the path, viewing a funnel based on the path, copying the node's name, and opening a modal to view persons who followed the path to that node. Some actions are only available if the user has the \"Advanced Paths\" feature enabled.\n\nHere's a list of the high-level features provided by the `PathNodeCardButton` component:\n\n*   **Display Path Node Information:** Shows the name and count of a specific node in a path.\n*   **Set as Path Start/End:** Allows users to set the selected node as the starting or ending point of the path.\n*   **Exclude Path Item:** Enables users to exclude the selected node from the path analysis.\n*   **View Funnel:** Provides a way to view a funnel based on the path leading to the selected node.\n*   **Copy Path Item Name:** Allows users to copy the name of the path node to the clipboard.\n*   **Open Persons Modal:** Opens a modal displaying the users who have traversed the path to the selected node.\n*   **Advanced Paths Feature Check:** Conditionally displays certain actions based on whether the user has the \"Advanced Paths\" feature enabled.\n*   **Truncated Path Handling:** Disables certain actions if the path is truncated for efficiency.\n"
    },
    {
        "path": "frontend/src/scenes/paths/pathsDataLogic.ts",
        "summary": "This code defines the logic for the Paths feature in PostHog, using the kea framework. It manages the data and interactions for visualizing user paths through a website or app. It fetches path data, transforms it into a graph representation, and handles user interactions such as opening a modal to view persons who followed a specific path or viewing a path as a funnel. The logic connects to other parts of the application, such as the insight visualization data logic and feature flag logic, to provide a comprehensive paths analysis experience.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Path Visualization:** Displays user paths as a graph, showing how users navigate through the application.\n*   **Data Fetching and Transformation:** Fetches path data from the backend and transforms it into a format suitable for visualization.\n*   **Persons Modal:** Opens a modal to view the users who followed a specific path, providing insights into user behavior.\n*   **Path to Funnel Conversion:** Allows users to convert a selected path into a funnel, enabling further analysis of user conversion rates.\n*   **Taxonomic Filtering:** Enables filtering paths based on event types (page views, screens, custom events).\n*   **Integration with Insights:** Integrates with the insights system to allow users to create new insights based on paths data.\n*   **Dynamic Query Generation:** Generates queries based on user interactions and selections, allowing for flexible data exploration.\n"
    },
    {
        "path": "frontend/src/scenes/paths/pathUtils.ts",
        "summary": "This code defines interfaces for representing path nodes and links in a Sankey diagram, specifically for visualizing user flows or funnels. It includes utility functions for generating rounded rectangles in SVG, formatting URLs for display, and determining if a path node represents a selected start or end point based on filter criteria. The code is designed to support interactive path analysis and funnel visualization within a product analytics platform.\n\nHere's a list of high-level product features that this code supports:\n\n*   **Path Visualization:** Display user flows as Sankey diagrams, showing how users navigate through a website or application.\n*   **Funnel Analysis:** Visualize user conversion funnels, highlighting drop-off points and common paths between steps.\n*   **URL Formatting:** Clean and format URLs for readability in the path visualization.\n*   **Path Selection:** Allow users to select specific paths or nodes to highlight or filter the visualization.\n*   **Filtering:** Filter paths based on start and end points, or based on steps within a funnel.\n*   **Interactive Exploration:** Enable users to explore the path diagram, such as hovering over nodes to see more details or clicking on paths to drill down into specific user journeys.\n"
    },
    {
        "path": "frontend/src/scenes/paths/renderPaths.ts",
        "summary": "This code renders a Sankey diagram representing user paths on a website, visualizing how users navigate between different events or pages. It uses the d3.js and d3-sankey libraries to create the diagram within a specified HTML div element. The diagram displays nodes representing events/pages and links representing transitions between them, with the width of the links indicating the volume of users transitioning between nodes. The code also handles node highlighting on hover, displays node details, and visually distinguishes start and end nodes based on applied filters.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Sankey Diagram Visualization:** Renders a Sankey diagram to visualize user paths.\n*   **Node Representation:** Displays events/pages as nodes in the diagram.\n*   **Transition Links:** Shows transitions between events/pages as links, with link width proportional to user volume.\n*   **Node Highlighting:** Highlights nodes and related paths on hover.\n*   **Node Details:** Displays node name and value (e.g., number of users) on hover.\n*   **Start/End Node Identification:** Visually distinguishes start and end nodes based on applied filters.\n*   **Dynamic Canvas Resizing:** Adjusts the canvas size based on the number of layers and available width.\n*   **Dropoff Visualization:** Visualizes dropoffs using a gradient effect.\n*   **Axis Lines:** Adds axis lines to the chart for better readability when there are many layers."
    },
    {
        "path": "frontend/src/scenes/paths",
        "summary": "The provided code snippets collectively implement a comprehensive path analysis feature within a product analytics platform. This feature allows users to visualize user journeys as directed graphs or Sankey diagrams, providing insights into how users navigate through a website or application. The system fetches and transforms path data, dynamically renders visualizations, and offers interactive elements for exploring node details, user counts, conversion times, and drop-off rates. Users can also perform actions such as setting start/end points, excluding nodes, converting paths to funnels, and viewing lists of users who followed specific paths.\n\nHere's a list of high-level product features:\n\n*   **Path Visualization:** Renders user journey paths as interactive directed graphs or Sankey diagrams.\n*   **Data-Driven Rendering:** Fetches and transforms path data to dynamically generate path visualizations.\n*   **Interactive Node Details:** Provides detailed information about each node in the path, including user counts, conversion times, and drop-off rates.\n*   **Path Exploration Actions:** Enables users to set start/end points, exclude nodes, convert paths to funnels, and view user lists.\n*   **Filtering and Highlighting:** Allows users to filter paths based on various criteria and highlight specific paths or nodes.\n*   **Dynamic Canvas Resizing:** Adapts the visualization to different screen sizes and data volumes.\n*   **User Guidance:** Provides instructions and tooltips to help users understand and interact with the path visualizations.\n*   **Funnel Conversion:** Converts selected paths into funnels for further analysis of user conversion rates.\n"
    },
    {
        "path": "frontend/src/scenes/groups/activityDescriptions.tsx",
        "summary": "This code defines a function `groupActivityDescriber` that generates human-readable descriptions for activity log items related to groups. It specifically handles the `update_property` activity, indicating when a user has changed a property of a group. For other group-related activities, it falls back to a default description handler.\n\nHere's a list of high-level product features related to this code:\n\n*   **Activity Logging:** Tracks changes and actions performed on groups.\n*   **Human-Readable Activity Descriptions:** Converts raw activity log data into user-friendly descriptions.\n*   **Group Property Change Tracking:** Specifically tracks and describes changes to group properties.\n*   **User Attribution:** Identifies the user responsible for each activity.\n"
    },
    {
        "path": "frontend/src/scenes/groups/relatedGroupsLogic.ts",
        "summary": "This code defines a Kea logic module called `relatedGroupsLogic` that fetches and manages related actors (groups or persons) based on a given group type index and ID. It uses the `kea-loaders` plugin to handle the asynchronous loading of related actors from an API endpoint. The logic connects to `teamLogic` to access the current team ID and triggers the data loading after the component mounts.\n\n**Features:**\n\n*   **Fetches Related Actors:** Loads a list of related actors (groups or persons) from the backend API based on group type index and ID.\n*   **Asynchronous Data Loading:** Uses `kea-loaders` for managing the asynchronous loading state of related actors.\n*   **Team Context:** Connects to `teamLogic` to fetch the current team ID for API requests.\n*   **Automatic Loading on Mount:** Triggers the loading of related actors automatically when the component mounts.\n"
    },
    {
        "path": "frontend/src/scenes/groups/Groups.tsx",
        "summary": "The `Groups` component renders a view for managing groups, determined by the `groupTypeIndex`. It uses `groupsListLogic` to manage the query for fetching groups and `groupsAccessLogic` to determine access status. Depending on the `groupsAccessStatus`, it either renders a `GroupsIntroduction` component or a `Query` component for displaying and managing groups based on the provided query. If `groupTypeIndex` is undefined, it throws an error.\n\nHere's a list of high-level product features:\n\n*   **Group Management:** Allows users to view and manage groups.\n*   **Querying Groups:** Enables users to query and filter groups based on specific criteria.\n*   **Access Control:** Restricts access to group management features based on user permissions.\n*   **Introduction/Onboarding:** Provides an introduction or onboarding experience for new users or when access is limited.\n*   **Dynamic Group Types:** Supports different types of groups, indicated by `groupTypeIndex`.\n"
    },
    {
        "path": "frontend/src/scenes/groups/GroupOverview.tsx",
        "summary": "The `GroupOverview` component in `frontend/src/scenes/groups/GroupOverview.tsx` displays information and actions related to a specific group type. If a detail dashboard exists for the group type, it renders the dashboard. Otherwise, it displays a message prompting the user to create a detail dashboard, along with a button to generate one. The component uses `kea` for state management and actions, and displays a loading state while the dashboard is being created.\n\nHere's a list of high-level product features:\n\n*   **Group Type Dashboard Display:** Renders a dashboard associated with a specific group type.\n*   **Dashboard Creation Prompt:** Displays a message prompting the user to create a dashboard if one doesn't exist for the group type.\n*   **Dashboard Generation:** Allows users to generate a default dashboard for a group type.\n*   **Loading State:** Provides visual feedback during dashboard creation.\n"
    },
    {
        "path": "frontend/src/scenes/groups/GroupDashboard.tsx",
        "summary": "The `GroupDashboard` component displays a dashboard associated with a specific group. If a dashboard already exists for the group, it renders the `GroupDashboardExisting` component, which displays the dashboard and allows the user to change it. If no dashboard exists, it prompts the user to choose a dashboard using the `SceneDashboardChoiceRequired` component. The component also ensures that the dashboard filters include the group's ID, so the dashboard only displays data relevant to that group.\n\nHere's a list of high-level product features:\n\n*   **Display Group-Specific Dashboard:** Shows a dashboard tailored to a specific group.\n*   **Dashboard Selection:** Allows users to select a dashboard to associate with a group.\n*   **Dashboard Filtering:** Automatically filters the dashboard data to only show information relevant to the selected group, using the group's ID.\n*   **Dashboard Switching:** Enables users to change the dashboard associated with a group.\n"
    },
    {
        "path": "frontend/src/scenes/groups/GroupsIntroduction.tsx",
        "summary": "The `GroupsIntroduction.tsx` file defines two React components, `GroupsIntroduction` and `GroupIntroductionFooter`, related to the Group Analytics feature in PostHog. The `GroupsIntroduction` component is a paygate mini component that prompts users to learn how to track groups in their code and directs them to the documentation. The `GroupIntroductionFooter` component displays a message based on whether the user needs to upgrade to access Group Analytics. If an upgrade is needed, it provides links to the billing page and documentation. Otherwise, it provides a link to get started with Group Analytics.\n\nHere's a list of high-level product features:\n\n*   **Group Analytics Introduction:** Provides an introduction and overview of the Group Analytics feature.\n*   **Paygate Integration:** Integrates with the paygate system to restrict access to Group Analytics based on the user's plan.\n*   **Documentation Link:** Provides a direct link to the Group Analytics documentation for users to learn more.\n*   **Upgrade Prompt:** Prompts users to upgrade their plan if Group Analytics is not available on their current plan.\n*   **Getting Started Guide:** Provides a link to a getting started guide for users who have access to Group Analytics.\n"
    },
    {
        "path": "frontend/src/scenes/groups/groupDashboardLogic.ts",
        "summary": "This code defines a Kea logic module called `groupDashboardLogic` responsible for managing the group dashboard within the application. It connects to the `userLogic` to access user data and defines selectors to derive the group dashboard ID and the props needed to instantiate a dashboard logic module. The logic determines the group dashboard ID based on the user's scene personalization settings and provides the ID and placement information to be used by a dashboard component.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Personalized Group Dashboards:** Allows users to have a customized dashboard experience within the group context.\n*   **Dashboard ID Retrieval:** Fetches the correct dashboard ID for the group scene based on user preferences.\n*   **Dashboard Placement Context:** Provides context (placement) information to the dashboard component, indicating it's being displayed within the group scene.\n*   **User-Specific Dashboard Configuration:** Leverages user data to determine the appropriate dashboard to display.\n"
    },
    {
        "path": "frontend/src/scenes/groups/groupsListLogic.ts",
        "summary": "This code defines a Kea logic module called `groupsListLogic` responsible for managing the display of a list of groups within a PostHog application. It fetches data related to groups, including group types, aggregation labels, and whether groups are enabled. It also manages a query object that defines how the group data is fetched and displayed in a data table format. The logic allows for setting and updating the query used to retrieve and display the group data.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Displaying a list of groups:** Enables the presentation of a list of groups of a specific type within the PostHog UI.\n*   **Configurable data table:** Allows customization of the data table displaying the groups, including which columns are shown and how the data is filtered.\n*   **Dynamic data fetching:** Fetches group data based on the current team and group type index.\n*   **Integration with groups access control:** Respects group access control settings when displaying the list of groups.\n*   **Query management:** Provides functionality to set and update the query used to retrieve and display group data.\n"
    },
    {
        "path": "frontend/src/scenes/appContextLogic.ts",
        "summary": "This code defines the `appContextLogic` using Kea, a state management library. It aims to synchronize the application's context, particularly the user, organization, team, and project data, between a preloaded state (likely from the server) and the data fetched from the API. It checks for discrepancies between the preloaded user and the user data fetched from the API, and if a mismatch is detected, it logs an error to Sentry and updates the application state with the API data to ensure consistency. This logic is triggered after the component mounts.\n\nHere's a list of high-level product features related to this code:\n\n*   **User Context Synchronization:** Ensures the user information displayed in the application is consistent with the server-side data.\n*   **Organization Context Synchronization:** Ensures the organization information displayed in the application is consistent with the server-side data.\n*   **Team Context Synchronization:** Ensures the team information displayed in the application is consistent with the server-side data.\n*   **Project Context Synchronization:** Ensures the project information displayed in the application is consistent with the server-side data.\n*   **Error Reporting:** Detects and reports discrepancies between preloaded and API-fetched user data to Sentry for debugging.\n*   **State Management:** Utilizes Kea for managing and updating the application's context state.\n"
    },
    {
        "path": "frontend/src/scenes/groups/groupLogic.ts",
        "summary": "This code defines the logic for managing and displaying details for a specific group within PostHog. It handles fetching group data, managing group properties (editing, deleting), and displaying events associated with the group. It also manages the UI state for the group details page, including the active tab and breadcrumbs.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Group Details View:** Displays detailed information about a specific group, including its properties.\n*   **Group Property Management:** Allows users to edit and delete properties associated with a group.\n*   **Group Event Stream:** Displays a stream of events associated with a specific group.\n*   **Dynamic Breadcrumbs:** Generates breadcrumbs for easy navigation to the group details page.\n*   **URL-based Tab Navigation:** Allows users to navigate between different tabs within the group details page using the URL.\n"
    },
    {
        "path": "frontend/src/scenes/groups/RelatedGroups.tsx",
        "summary": "The `RelatedGroups` component displays a table of actors (either groups or persons) related to a specific group, identified by its `groupTypeIndex` and `id`. It fetches the related actors and their loading state using the `relatedGroupsLogic`. The table shows the type of actor (Group or Person) and its ID, with links to the respective group or person details pages. The component uses `LemonTable` for displaying the data with pagination, loading state, and an empty state message.\n\nHere's a list of high-level product features:\n\n*   **Display of Related Actors:** Shows a list of groups and/or persons related to a specific group.\n*   **Actor Type Identification:** Clearly indicates whether a related actor is a group or a person.\n*   **Navigation to Actor Details:** Provides links to the details page of each related group or person.\n*   **Loading State Indication:** Shows a loading indicator while fetching related actors.\n*   **Pagination:** Implements pagination for handling large lists of related actors.\n*   **Empty State Message:** Displays a message when no related actors are found.\n"
    },
    {
        "path": "frontend/src/scenes/groups/Group.tsx",
        "summary": "This code defines the `Group` component, a feature-rich view in PostHog for inspecting and interacting with group analytics data. It fetches group data based on the group type index and key from the URL parameters, displaying a detailed overview with several tabs. These tabs provide access to group properties, event history, session recordings, related people and groups, feature flags targeting, activity logs, and potentially customer success dashboards. The component uses LemonTabs for navigation and various PostHog UI components for data presentation and interaction.\n\nHere's a list of high-level product features implemented in the `Group` component:\n\n*   **Group Overview:** Displays key information about a specific group, including type, key, and creation date.\n*   **Properties Table:** Allows viewing, editing, and deleting properties associated with the group.\n*   **Event History:** Shows a stream of events associated with the group, powered by the Query component.\n*   **Session Recordings:** Enables viewing session recordings filtered to include events related to the group.\n*   **Related People & Groups:** Identifies and displays people and groups that have interacted with the current group.\n*   **Feature Flag Targeting:** Lists feature flags that target the group based on its properties.\n*   **Activity Log:** Tracks changes made to the group within PostHog.\n*   **Customer Success Dashboards (Conditional):** Displays dashboards tailored for customer success insights related to the group.\n*   **Notebook Integration:** Allows users to create or link existing notebooks to the group for documentation or analysis.\n*   **Copy to Clipboard:** Provides an easy way to copy the group key.\n"
    },
    {
        "path": "frontend/src/scenes/groups",
        "summary": "The provided code snippets collectively implement a comprehensive Group Analytics feature within PostHog, enabling users to analyze and manage groups of users or entities. This feature provides detailed overviews of individual groups, including their properties, event history, and related actors. It also allows for targeting feature flags to specific groups, tracking activity logs, and displaying customer success dashboards tailored to group insights. Furthermore, the system facilitates the creation and management of dashboards specific to group types and individual groups, ensuring data is filtered to the relevant context.\n\nHere's a list of high-level product features:\n\n*   **Group Overview:** Displays key information about a specific group, including properties, event history, and related actors.\n*   **Group Property Management:** Allows users to view, edit, and delete properties associated with a group.\n*   **Event History:** Shows a stream of events associated with the group.\n*   **Related People & Groups:** Identifies and displays people and groups that have interacted with the current group.\n*   **Feature Flag Targeting:** Lists feature flags that target the group based on its properties.\n*   **Activity Logging:** Tracks changes and actions performed on groups.\n*   **Customer Success Dashboards:** Displays dashboards tailored for customer success insights related to the group.\n*   **Group Type Dashboards:** Renders dashboards associated with specific group types, allowing for creation and customization.\n*   **Group-Specific Dashboards:** Displays dashboards tailored to a specific group, with automatic filtering based on the group's ID.\n*   **Group Management:** Enables users to query, filter, and manage groups based on specific criteria.\n*   **Access Control:** Restricts access to group management features based on user permissions.\n*   **Introduction/Onboarding:** Provides an introduction or onboarding experience for new users or when access is limited.\n*   **Notebook Integration:** Allows users to create or link existing notebooks to the group for documentation or analysis.\n"
    },
    {
        "path": "frontend/src/scenes/Unsubscribe/unsubscribeLogic.ts",
        "summary": "This code defines a Kea logic module named `unsubscribeLogic` responsible for handling the email unsubscription process. It extracts an unsubscription token from the URL's query parameters upon mounting. It then calls an API endpoint to process the unsubscription using the token. The logic uses a loader to manage the asynchronous API call and stores the success status of the unsubscription attempt.\n\n**Features:**\n\n*   **URL Parameter Extraction:** Extracts the unsubscription token from the URL query parameters.\n*   **API Integration:** Calls an API endpoint to process the unsubscription request using the provided token.\n*   **Asynchronous Operation Handling:** Uses a loader to manage the asynchronous API call and track its status.\n*   **Success Status Tracking:** Stores the success status of the unsubscription attempt.\n*   **Automatic Unsubscription Attempt:** Automatically attempts to unsubscribe the user when the component mounts, using the token from the URL.\n"
    },
    {
        "path": "frontend/src/scenes/Unsubscribe/Unsubscribe.tsx",
        "summary": "The `Unsubscribe.tsx` file defines the Unsubscribe scene, which is responsible for handling user unsubscriptions from email lists. It uses the `unsubscribeLogic` to manage the unsubscription process and displays different messages based on the status of the unsubscription. A loading spinner is shown while the unsubscription is in progress. Upon successful unsubscription, a confirmation message is displayed. If an error occurs, an error message is shown, indicating that the user may already be unsubscribed or the link is invalid.\n\nHere's a list of high-level product features:\n\n*   **Email Unsubscription:** Allows users to unsubscribe from specific email lists.\n*   **Loading State:** Displays a loading indicator during the unsubscription process.\n*   **Success Message:** Shows a confirmation message upon successful unsubscription.\n*   **Error Handling:** Displays an error message if the unsubscription fails.\n*   **Invalid Link Handling:** Informs the user if the unsubscription link is invalid.\n"
    },
    {
        "path": "frontend/src/scenes/Unsubscribe",
        "summary": "The Unsubscribe feature allows users to unsubscribe from email lists via a link. The frontend displays a loading state while processing the unsubscription, and upon completion, shows either a success message or an error message if the unsubscription fails or the link is invalid. The `unsubscribeLogic` handles extracting the unsubscription token from the URL, calling the API to process the unsubscription, and managing the asynchronous operation.\n\nHere's a list of high-level product features:\n\n*   Email Unsubscription: Allows users to unsubscribe from specific email lists.\n*   Loading State: Displays a loading indicator during the unsubscription process.\n*   Success Message: Shows a confirmation message upon successful unsubscription.\n*   Error Handling: Displays an error message if the unsubscription fails.\n*   Invalid Link Handling: Informs the user if the unsubscription link is invalid.\n*   URL Parameter Extraction: Extracts the unsubscription token from the URL query parameters.\n*   API Integration: Calls an API endpoint to process the unsubscription request using the provided token.\n*   Asynchronous Operation Handling: Uses a loader to manage the asynchronous API call and track its status.\n*   Success Status Tracking: Stores the success status of the unsubscription attempt.\n*   Automatic Unsubscription Attempt: Automatically attempts to unsubscribe the user when the component mounts, using the token from the URL.\n"
    },
    {
        "path": "frontend/src/scenes/persons-management/tabs/personsSceneLogic.ts",
        "summary": "This code defines the logic for the \"Persons\" management scene using the Kea framework. It manages the query used to fetch and display person data, storing it in the state and providing an action to update it. The initial query is set to a DataTableNode with a default ActorsQuery. The code also includes commented-out logic for synchronizing the query with the URL, allowing users to share and bookmark specific queries.\n\nHere's a list of high-level product features based on the code:\n\n*   **Person Data Display:** Displays a table of person data.\n*   **Customizable Queries:** Allows users to define and modify queries to filter and sort person data.\n*   **Default Query:** Provides a default query for displaying person data when no custom query is specified.\n*   **URL Synchronization (Potentially):** Enables sharing and bookmarking specific person data views via URL parameters (currently disabled).\n*   **Error Handling:** Includes error handling for invalid queries in the URL.\n"
    },
    {
        "path": "frontend/src/scenes/persons-management/tabs/Persons.tsx",
        "summary": "This code defines a React component called `Persons` that displays and manages a query related to persons. It utilizes the `kea` library for state management, specifically using `useValues` and `useActions` hooks to access and modify the query state managed by `personsSceneLogic`. The component renders a `Query` component, passing the current query state and a function to update it. The `Query` component is configured with a blocking refresh strategy and a data attribute for identification.\n\nHere's a list of high-level product features:\n\n*   **Persons Querying:** Allows users to query and filter a list of persons based on various criteria.\n*   **Query Management:** Provides functionality to set, update, and persist query parameters.\n*   **Data Display:** Renders the results of the person query in a tabular or list format (handled by the `Query` component).\n*   **Blocking Refresh:** Ensures data consistency by blocking further actions until the data is refreshed after a query change.\n"
    },
    {
        "path": "frontend/src/scenes/persons-management/tabs",
        "summary": "The provided code snippets detail the implementation of a \"Persons\" management scene within a larger application. This scene leverages the Kea framework for state management, focusing on enabling users to query, filter, and display person data. The system provides a default query, allows for customizable queries, and incorporates a blocking refresh mechanism to ensure data consistency. While currently disabled, the code also hints at the potential for synchronizing the query state with the URL, enabling shareable and bookmarkable views.\n\nHere's a list of high-level product features:\n\n*   Persons Querying: Allows users to query and filter a list of persons based on various criteria.\n*   Query Management: Provides functionality to set, update, and persist query parameters.\n*   Data Display: Renders the results of the person query in a tabular or list format.\n*   Blocking Refresh: Ensures data consistency by blocking further actions until the data is refreshed after a query change.\n*   Default Query: Provides a default query for displaying person data when no custom query is specified.\n*   URL Synchronization (Potentially): Enables sharing and bookmarking specific person data views via URL parameters.\n"
    },
    {
        "path": "frontend/src/scenes/persons-management/PersonsManagementScene.tsx",
        "summary": "The `PersonsManagementScene` component provides a user interface for managing persons, groups, and cohorts. It utilizes LemonTabs to organize different views into tabs, each with its own content and associated buttons in the page header. The scene dynamically adjusts its caption based on whether group options are enabled. The active tab is managed by the `personsManagementSceneLogic`, allowing users to switch between different management views.\n\n**Features:**\n\n*   **Tabbed Interface:** Organizes person, group, and cohort management into separate tabs.\n*   **Dynamic Page Header:** Displays a caption and buttons specific to the active tab.\n*   **Group Management Integration:** Adapts the UI based on the availability of group management options.\n*   **Cohort Management:** Provides tools for creating and managing cohorts.\n*   **Person Management:** Enables the management of identified persons.\n"
    },
    {
        "path": "frontend/src/scenes/persons-management/personsManagementSceneLogic.tsx",
        "summary": "This code defines the logic for the Persons Management scene in PostHog, using Kea for state management and routing. It manages different tabs related to people, cohorts, and groups, dynamically generating tabs for each group type. The logic handles URL-based navigation between tabs, sets breadcrumbs for navigation, and provides actions to set the active tab. It also includes a button to create a new cohort on the cohorts tab.\n\nHere's a list of high-level product features based on the code:\n\n*   **Persons Tab:** Displays and manages individual user data.\n*   **Cohorts Tab:** Displays and manages cohorts of users, with the ability to create new cohorts.\n*   **Groups Tab(s):** Displays and manages groups of users, with dynamic tabs generated for each group type.\n*   **Tab-based Navigation:** Allows users to switch between Persons, Cohorts, and Groups views.\n*   **URL-based Routing:** Enables navigation between tabs using URLs, allowing for direct linking and bookmarking.\n*   **Dynamic Group Tabs:** Automatically creates tabs for each defined group type.\n*   **Breadcrumbs:** Provides a navigation trail for users to easily understand their location within the application.\n"
    },
    {
        "path": "frontend/src/scenes/persons-management",
        "summary": "The Persons Management scene provides a comprehensive interface for managing users, cohorts, and groups within PostHog. It leverages a tabbed interface for easy navigation between different management views, including Persons, Cohorts, and dynamically generated Group tabs. The scene incorporates features for querying and filtering person data, managing cohorts, and handling group configurations, with URL-based routing and breadcrumbs for enhanced navigation and shareability.\n\nHere's a consolidated list of high-level product features:\n\n*   Persons Tab: Displays and manages individual user data, including querying and filtering capabilities.\n*   Cohorts Tab: Displays and manages cohorts of users, with the ability to create new cohorts.\n*   Groups Tab(s): Displays and manages groups of users, with dynamic tabs generated for each group type.\n*   Tab-based Navigation: Allows users to switch between Persons, Cohorts, and Groups views.\n*   URL-based Routing: Enables navigation between tabs using URLs, allowing for direct linking and bookmarking.\n*   Dynamic Group Tabs: Automatically creates tabs for each defined group type.\n*   Breadcrumbs: Provides a navigation trail for users to easily understand their location within the application.\n*   Query Management: Provides functionality to set, update, and persist query parameters for person data.\n*   Data Display: Renders the results of the person query in a tabular or list format.\n*   Blocking Refresh: Ensures data consistency by blocking further actions until the data is refreshed after a query change.\n*   Default Query: Provides a default query for displaying person data when no custom query is specified.\n"
    },
    {
        "path": "frontend/src/scenes/project-homepage/ProjectHomepage.tsx",
        "summary": "The `ProjectHomepage.tsx` file defines the main component for the project homepage in the PostHog application. It displays recent insights, recent persons, a \"Watch Next\" panel, and a customizable dashboard. The component also includes options to customize the homepage and invite team members. If a dashboard isn't configured for the homepage, it prompts the user to choose one.\n\nHere's a list of high-level product features implemented in this component:\n\n*   **Customizable Homepage Dashboard:** Allows users to select and display a dashboard on the project homepage.\n*   **Recent Insights Display:** Shows a list of recently viewed or created insights.\n*   **Recent Persons Display:** Shows a list of recently viewed or created persons.\n*   **\"Watch Next\" Panel:** Provides suggestions or guidance for the user's next actions.\n*   **Team Invitation:** Provides a button to invite new team members to the project.\n"
    },
    {
        "path": "frontend/src/scenes/project-homepage/projectHomepageLogic.tsx",
        "summary": "The `projectHomepageLogic` Kea logic module manages the state and data fetching for the project homepage scene. It connects to `teamLogic` and `projectLogic` to access the current team and project ID. It fetches the primary dashboard ID from the current team and prepares props for a dashboard logic instance. It also loads recent insights viewed by the user and a list of persons associated with the project.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Display of a primary dashboard:** Fetches and prepares data to display a primary dashboard on the project homepage.\n*   **Display of recently viewed insights:** Loads and displays a list of insights the user has recently viewed within the project.\n*   **Loading of project persons:** Loads and makes available a list of persons associated with the project.\n"
    },
    {
        "path": "frontend/src/scenes/project-homepage/ProjectHomePageCompactListItem.tsx",
        "summary": "This code defines a React component called `ProjectHomePageCompactListItem` that renders a compact list item for the project homepage. It's essentially a styled button (`LemonButton`) that displays a title, subtitle, optional prefix, and optional suffix. The component is designed to be used as a row in a list of recent items or similar content on the project homepage, providing a clickable link or action with supporting information.\n\nHere's a list of high-level features provided by the component:\n\n*   **Clickable List Item:** Renders a button-like list item that can be clicked to navigate to a specific URL or trigger an action.\n*   **Title Display:** Shows a primary title for the list item, typically representing the name of the item.\n*   **Subtitle Display:** Displays a secondary subtitle providing additional context or information about the item.\n*   **Prefix Icon/Element:** Allows for an optional prefix element (e.g., an icon) to be displayed at the beginning of the list item.\n*   **Suffix Element:** Supports an optional suffix element to be displayed at the end of the list item.\n*   **Text Truncation:** Ensures that long titles and subtitles are truncated to fit within the available space.\n*   **Full Width:** The list item stretches to fill the available width of its container.\n"
    },
    {
        "path": "frontend/src/scenes/project-homepage/WatchNextPanel.tsx",
        "summary": "The `WatchNextPanel` component displays a list of recommended session recordings on the project homepage. It fetches session recordings data using the `sessionRecordingsPlaylistLogic`, filtering for recordings with high activity scores and a duration under 60 seconds within the last 15 minutes. The component renders a `CompactList` of these recordings, each row displaying the user's profile picture, name, activity score, and recording duration. Clicking on a recording opens it in the session player modal. The panel also handles cases where recordings are not enabled or no recordings are available, providing helpful messages and links to enable recordings or learn more about setting up the JavaScript snippet.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Recommended Session Recordings:** Displays a curated list of session recordings based on activity score.\n*   **Activity Score Indicator:** Shows a visual representation of the activity level within each recording.\n*   **Session Recording Preview:** Provides a quick overview of each recording, including user information and duration.\n*   **Session Recording Playback:** Allows users to directly open and play session recordings from the list.\n*   **Recordings Enablement Guidance:** Guides users to enable session recordings if they are not already enabled.\n*   **JavaScript Snippet Setup Guidance:** Guides users to set up the JavaScript snippet if no recordings are available.\n*   **Filtering and Sorting:** Fetches recordings filtered by duration and date, and sorted by activity score.\n"
    },
    {
        "path": "frontend/src/scenes/project-homepage/RecentPersons.tsx",
        "summary": "This React component, `RecentPersons`, displays a compact list of recently seen people on the project homepage. It fetches the list of people and their loading state from the `projectHomepageLogic` using Kea. Each person is displayed with their name, a profile picture, and the time since they were first seen. Clicking on a person navigates to their details page and triggers an event tracking action. The component also handles the loading and empty state scenarios, providing a link to the documentation when no new people are found.\n\nHere's a list of high-level features:\n\n*   **Displays a list of recently seen people:** Shows a list of people who have recently interacted with the product.\n*   **Person details:** Displays the person's name, profile picture, and the time since they were first seen.\n*   **Navigation to person details page:** Allows users to click on a person to view their detailed information.\n*   **Loading state:** Shows a loading indicator while fetching the list of people.\n*   **Empty state:** Displays a message when there are no newly seen people, with a link to the documentation.\n*   **Event tracking:** Tracks when a user opens a person's details page from the list.\n*   **\"View All\" link:** Provides a link to view all people in the project.\n"
    },
    {
        "path": "frontend/src/scenes/project-homepage/RecentInsights.tsx",
        "summary": "This code defines a React component called `RecentInsights` that displays a list of recently viewed insights on the project homepage. It fetches the recent insights data using the `projectHomepageLogic` and renders them in a compact list format, including the insight's name, last modified date, and an icon. Users can click on an insight to view it, and the component tracks when an insight is opened from the recent insights list. The component also handles loading and empty state scenarios, providing appropriate messages and links to the saved insights page.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Display of Recently Viewed Insights:** Shows a list of the user's most recently accessed insights.\n*   **Insight Information:** Displays the insight's name (or a derived name if the name is not available) and the last modified date in a human-readable format.\n*   **Navigation to Insight:** Allows users to click on an insight to navigate to its detailed view.\n*   **Loading State:** Indicates when the recent insights data is being loaded.\n*   **Empty State Handling:** Displays a message and a link to the saved insights page when there are no recently viewed insights.\n*   **Usage Tracking:** Tracks when a user opens an insight from the recent insights list.\n*   **Limited Display:** Only shows a maximum of 5 recent insights.\n*   **Link to All Insights:** Provides a link to view all saved insights."
    },
    {
        "path": "frontend/src/scenes/project-homepage",
        "summary": "The project homepage provides a central hub for users to quickly access relevant information and navigate to key areas within the PostHog application. It features customizable dashboards, lists of recently viewed insights and people, and a \"Watch Next\" panel suggesting relevant session recordings. The homepage also guides users to enable session recordings, set up the JavaScript snippet, invite team members, and customize the displayed dashboard. Each element on the homepage is designed for quick access and provides contextual information to help users understand and interact with their data.\n\nHere's a list of high-level product features:\n\n*   Customizable Homepage Dashboard\n*   Recent Insights Display\n*   Recent Persons Display\n*   Recommended Session Recordings (\"Watch Next\" Panel)\n*   Activity Score Indicator for Session Recordings\n*   Session Recording Playback\n*   Recordings Enablement Guidance\n*   JavaScript Snippet Setup Guidance\n*   Team Invitation\n*   Navigation to detailed views for insights, people, and session recordings\n*   Loading and empty state handling for all components\n*   Event tracking for user interactions\n"
    },
    {
        "path": "frontend/src/scenes/cohorts/CohortFilters/CohortCriteriaRowBuilder.tsx",
        "summary": "This code defines the `CohortCriteriaRowBuilder` component, which is a key part of the cohort creation/editing interface. It allows users to define individual criteria for cohort membership based on behavioral events and properties. The component dynamically renders fields based on the selected filter type, handles user input, and provides actions for duplicating and removing criteria rows. It leverages Kea for state management and Lemon UI for styling and components.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Define Cohort Criteria:** Allows users to define specific criteria for cohort membership.\n*   **Behavioral Filtering:** Supports filtering users based on their behavior (e.g., performed a specific event).\n*   **Dynamic Field Rendering:** Renders input fields dynamically based on the selected filter type.\n*   **Criteria Duplication:** Allows users to duplicate existing criteria rows for faster configuration.\n*   **Criteria Removal:** Enables users to remove unwanted criteria rows.\n*   **Logical Grouping:** Supports logical grouping of criteria with operators like \"AND\" or \"OR\".\n*   **Error Handling:** Displays error messages for invalid criteria input.\n*   **Real-time Updates:** Updates the cohort definition in real-time as the user modifies the criteria.\n"
    },
    {
        "path": "frontend/src/scenes/cohorts/CohortFilters/CohortCriteriaGroups.tsx",
        "summary": "This code defines the `CohortCriteriaGroups` component, which is responsible for rendering and managing groups of criteria used to define a cohort in PostHog. It allows users to add, remove, duplicate, and modify criteria groups, as well as add individual criteria within each group. The component uses Kea logic for state management and form handling, and leverages Lemon UI components for a consistent user interface. Each criteria group is represented by a letter, and users can specify whether to match persons against \"any\" or \"all\" criteria within the group.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Grouping of Cohort Criteria:** Allows users to organize cohort definition criteria into logical groups.\n*   **AND/OR Logic within Groups:** Enables users to specify whether a person must match all or any of the criteria within a group to be included in the cohort.\n*   **Adding Criteria Groups:** Provides a button to add new, empty criteria groups to the cohort definition.\n*   **Adding Criteria to Groups:** Allows users to add individual criteria to existing criteria groups.\n*   **Duplicating Criteria Groups:** Enables users to duplicate existing criteria groups, including all their criteria.\n*   **Removing Criteria Groups:** Provides a way to remove entire criteria groups from the cohort definition.\n*   **Visual Representation of Groups:** Uses lettermarks to visually distinguish between different criteria groups.\n"
    },
    {
        "path": "frontend/src/scenes/cohorts/CohortFilters/cohortFieldLogic.ts",
        "summary": "This code defines a Kea logic module named `cohortFieldLogic` that manages the state and behavior of individual fields within a cohort filter. It handles changes to field values, provides options for selector fields based on available feature flags and group types, and resolves the display value of fields that reference cohorts or actions by name. The logic connects to other Kea models like `groupsModel`, `userLogic`, `actionsModel`, and `cohortsModel` to access relevant data.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dynamic Field Options:** Provides context-aware options for filter fields, adapting to feature flags (e.g., behavioral cohort filtering) and available group types.\n*   **Real-time Value Resolution:** Resolves and displays the names of cohorts and actions referenced by ID in filter fields, improving usability.\n*   **Loading State Management:** Indicates when cohort or action data is loading, preventing confusion and providing a better user experience.\n*   **Data Binding and Change Handling:** Manages the state of individual filter fields, propagating changes to a parent component.\n*   **Behavioral Cohort Filtering Support:** Enables advanced filtering options based on user behavior when the feature flag is enabled.\n"
    },
    {
        "path": "frontend/src/scenes/cohorts/CohortFilters/types.ts",
        "summary": "This code defines the types and interfaces used for creating cohort filters in the PostHog application. It includes definitions for various filter types (behavioral, aggregation, actors, etc.), field options, and data structures for representing filter rows and fields. It also defines props for different cohort field components, such as selectors, taxonomic fields, and fields for person properties, event filters, and time-based filters. Finally, it defines a set of client-side error messages related to cohort creation.\n\nHere's a list of high-level product features that can be inferred from the code:\n\n*   **Behavioral Cohort Filtering:** Allows filtering users based on their behavior, such as events performed, actions taken, or lifecycle stage.\n*   **Aggregation-Based Cohort Filtering:** Enables filtering users based on aggregated data, such as total events performed or average property values.\n*   **Actor-Based Cohort Filtering:** Supports filtering users based on specific actors or user segments.\n*   **Time-Based Cohort Filtering:** Provides options for filtering users based on time-related criteria, such as date ranges, relative time periods, or event sequences.\n*   **Property-Based Cohort Filtering:** Allows filtering users based on their properties, such as name, email, or custom attributes.\n*   **Event Filtering:** Enables filtering users based on specific events they have performed, including event properties and filters.\n*   **Cohort Composition:** Supports combining different filter criteria using logical operators (AND, OR, NOT) to create complex cohort definitions.\n*   **Cohort Validation:** Includes client-side validation to ensure that cohort definitions are valid and prevent common errors.\n"
    },
    {
        "path": "frontend/src/scenes/cohorts/CohortFilters/CohortField.tsx",
        "summary": "This code defines a set of React components used for filtering cohorts based on various criteria. It provides different field types for cohort filtering, including selectors, taxonomic filters, property value inputs, event filters, date filters, text fields, and number fields. Each component is designed to be configurable and integrates with a `cohortFieldLogic` to manage its state and interactions. The components leverage Lemon UI components for styling and functionality, and Kea for state management.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Cohort Selection:** Allows users to select existing cohorts as part of a cohort definition.\n*   **Event and Action Filtering:** Enables filtering cohorts based on specific events or actions.\n*   **Property-Based Filtering:** Supports filtering cohorts based on user or event properties, including text, number, and boolean values.\n*   **Taxonomic Filtering:** Provides a way to filter cohorts based on taxonomic data, such as event types or properties.\n*   **Date Range Filtering:** Allows filtering cohorts based on relative or exact time ranges.\n*   **Custom Event Property Filtering:** Allows users to define custom filters based on event properties.\n*   **Dynamic Field Rendering:** Renders different types of input fields based on the selected filter criteria.\n*   **Real-time Updates:** Updates the cohort definition in real-time as the user interacts with the filter fields.\n*   **Visual Configuration:** Provides a user-friendly interface for configuring cohort filters."
    },
    {
        "path": "frontend/src/scenes/cohorts/CohortFilters/constants.tsx",
        "summary": "This code defines the structure and options available for filtering cohorts in a product analytics platform. It breaks down cohort filters into rows, fields, and field values, providing a structured way to define complex user segments based on event behavior, properties, and lifecycle stages. The code defines constants for various field options, including event aggregation, property aggregation, actor types, behavioral events, time units, date operators, and math operators. It also defines the structure of rows for different behavioral event types, specifying the fields and their corresponding filter types.\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **Cohort Creation and Management:** Allows users to define and manage cohorts based on various criteria.\n*   **Behavioral Filtering:** Enables filtering users based on their event behavior, such as completing or not completing specific events.\n*   **Property-Based Filtering:** Supports filtering users based on their properties, including aggregation and comparison operators.\n*   **Lifecycle Stage Filtering:** Allows filtering users based on their lifecycle stages, such as first-time event completion or event cessation.\n*   **Time-Based Filtering:** Provides options for filtering users based on time intervals and date operators.\n*   **Event Sequencing:** Supports filtering users based on sequences of events they have completed or not completed.\n*   **Customizable Filter Logic:** Offers a flexible structure for defining complex filter logic using rows, fields, and field values.\n*   **Segmentation:** Enables users to segment their user base based on defined cohorts.\n*   **Aggregation:** Allows aggregating data based on different metrics like total count, unique users, and weekly/monthly active users."
    },
    {
        "path": "frontend/src/scenes/cohorts/CohortFilters",
        "summary": "The provided code collectively enables a comprehensive cohort creation and management experience within the PostHog product analytics platform. Users can define cohorts based on a wide range of criteria, including behavioral events, user properties, lifecycle stages, and time-based conditions. The interface allows for complex filter logic using groupings and AND/OR operators, dynamic field rendering based on selected criteria, and real-time updates to the cohort definition as changes are made. The system also provides helpful features such as criteria duplication, error handling, and visual cues to guide the user through the cohort definition process.\n\nHere's a list of high-level product features:\n\n*   **Cohort Creation and Management:** Define and manage cohorts based on various criteria.\n*   **Behavioral Filtering:** Filter users based on event behavior, actions taken, and event sequences.\n*   **Property-Based Filtering:** Filter users based on user properties, including aggregation and comparison operators.\n*   **Lifecycle Stage Filtering:** Filter users based on lifecycle stages.\n*   **Time-Based Filtering:** Filter users based on time intervals and date operators.\n*   **Logical Grouping of Criteria:** Organize cohort definition criteria into logical groups with AND/OR logic.\n*   **Dynamic Field Rendering:** Render input fields dynamically based on the selected filter type.\n*   **Real-time Updates:** Update the cohort definition in real-time as the user modifies the criteria.\n*   **Criteria Duplication and Removal:** Duplicate or remove existing criteria rows and groups for faster configuration.\n*   **Visual Configuration:** Provide a user-friendly interface for configuring cohort filters.\n"
    },
    {
        "path": "frontend/src/scenes/cohorts/Cohort.tsx",
        "summary": "The code defines a scene for managing cohorts in a web application. It utilizes a `CohortEdit` component for editing cohort details and connects it to `cohortSceneLogic` for managing the scene's logic. The scene is configured to accept a cohort ID as a parameter, which is then passed as a prop to the `CohortEdit` component. If the ID is \"new\", it indicates the creation of a new cohort.\n\nHere's a list of high-level product features:\n\n*   **Cohort Creation:** Allows users to create new cohorts.\n*   **Cohort Editing:** Enables users to modify existing cohort details.\n*   **Cohort Identification:** Uses a unique ID to identify and manage individual cohorts.\n*   **Scene Management:** Integrates with a scene management system for navigation and state management.\n"
    },
    {
        "path": "frontend/src/scenes/cohorts/cohortSceneLogic.ts",
        "summary": "This code defines the logic for the Cohorts scene in the frontend application using Kea. It manages the breadcrumbs displayed in the scene, dynamically generating them based on the current cohort ID and the available cohorts data fetched by `cohortsModel`. The breadcrumbs provide navigation to the \"People\" management section, the list of cohorts, and the specific cohort being viewed or edited.\n\n**Features:**\n\n*   **Dynamic Breadcrumb Generation:** Creates breadcrumbs for navigating to the \"People\" management section, the list of cohorts, and the specific cohort being viewed or edited.\n*   **Cohort Identification:** Determines the current cohort based on the `id` prop.\n*   **Cohort Name Display:** Displays the name of the cohort in the breadcrumb, or \"Untitled\" if the cohort is new or the name is not available.\n*   **Navigation:** Provides links to navigate between different sections of the application related to people and cohorts.\n"
    },
    {
        "path": "frontend/src/scenes/cohorts/Cohorts.tsx",
        "summary": "The `Cohorts` component in PostHog provides a user interface for managing cohorts, which are groups of users with shared characteristics. It displays a list of cohorts in a table with details like name, user count, creation information, and last calculation time. Users can search, edit, export, and delete cohorts. The component also includes a product introduction section with helpful information and a link to create new cohorts.\n\nHere's a list of high-level product features:\n\n*   **Cohort Listing:** Displays a paginated list of cohorts with key information.\n*   **Cohort Details:** Shows cohort name, description, and user count.\n*   **Cohort Search:** Allows users to search for cohorts by name.\n*   **Cohort Editing:** Provides a link to edit existing cohorts.\n*   **Cohort Export:** Enables exporting cohort data in CSV format (all columns or important columns only).\n*   **Cohort Deletion:** Allows users to delete cohorts.\n*   **Session Recording View:** Provides a link to view session recordings filtered by cohort membership.\n*   **Cohort Calculation Status:** Displays the status and last calculation time of cohorts.\n*   **Product Introduction:** Provides a brief overview of cohorts and links to relevant documentation.\n"
    },
    {
        "path": "frontend/src/scenes/cohorts/activityDescriptions.tsx",
        "summary": "This code defines a function `cohortActivityDescriber` that generates human-readable descriptions of activity log items related to cohorts. It handles the 'created', 'deleted', and 'updated' activities, displaying the user who performed the action and the name of the cohort, with a link to the cohort if available. If the activity is not one of these specific types, it falls back to a default description.\n\nHere's a list of high-level product features that can be derived from this code:\n\n*   **Cohort Creation Logging:** Tracks and displays when a new cohort is created, including the user who created it and the cohort's name.\n*   **Cohort Deletion Logging:** Tracks and displays when a cohort is deleted, including the user who deleted it and the cohort's name.\n*   **Cohort Update Logging:** Tracks and displays when a cohort is updated, including the user who updated it and the cohort's name.\n*   **Activity Log Display:** Presents a user-friendly activity log with humanized descriptions of cohort-related actions.\n*   **User Attribution:** Identifies and displays the user responsible for each cohort activity.\n*   **Cohort Linking:** Provides links from activity log entries to the corresponding cohort details page.\n"
    },
    {
        "path": "frontend/src/scenes/cohorts/cohortEditLogic.ts",
        "summary": "This code defines the logic for creating and editing cohorts in PostHog. It manages cohort data, including fetching, saving, duplicating, and deleting cohorts. The logic handles cohort criteria, allowing users to add, remove, duplicate, and modify filters. It also manages the calculation status of cohorts, polling the API until the calculation is complete. The code uses kea-forms for form management and validation, and kea-loaders for managing asynchronous operations.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Cohort Creation:** Allows users to create new cohorts based on defined criteria.\n*   **Cohort Editing:** Enables users to modify existing cohorts, including their name, criteria, and static/dynamic type.\n*   **Cohort Duplication:** Supports duplicating existing cohorts, either as static copies or dynamic copies.\n*   **Cohort Deletion:** Allows users to delete cohorts.\n*   **Cohort Criteria Management:** Provides a user interface for adding, removing, duplicating, and modifying cohort criteria (filters).\n*   **Real-time Calculation Status:** Displays the calculation status of cohorts and automatically updates the cohort data when the calculation is complete.\n*   **CSV Upload for Static Cohorts:** Supports uploading CSV files to define static cohorts.\n*   **Form Validation:** Validates cohort data before saving, ensuring required fields are filled and criteria are valid.\n"
    },
    {
        "path": "frontend/src/scenes/cohorts/cohortUtils.tsx",
        "summary": "This code provides utility functions for managing and validating cohort definitions in a PostHog application. It includes functions for cleaning criteria, validating cohort groups, creating form data for cohort creation/updates, and converting between different cohort criteria types. The code also handles validation of user inputs, including checks for negation criteria, time comparisons, and required fields.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Cohort Definition:** Allows users to define cohorts based on behavioral criteria, event properties, and user properties.\n*   **Cohort Grouping:** Enables users to group cohort criteria using logical operators (AND/OR) for complex cohort definitions.\n*   **Cohort Validation:** Provides real-time validation of cohort definitions, including checks for conflicting criteria, missing fields, and invalid time comparisons.\n*   **Behavioral Cohorts:** Supports the creation of cohorts based on user behavior, such as event sequences, event frequency, and lifecycle events.\n*   **Static Cohorts:** Supports the creation of cohorts based on a static list of users (e.g., uploaded CSV).\n*   **Form Data Handling:** Facilitates the creation of form data for cohort creation and updates, including proper encoding of file binaries.\n*   **Negation Criteria:** Supports the use of negation in cohort criteria (e.g., \"users who did NOT perform event X\").\n*   **Event Filters:** Supports the filtering of events based on properties within cohort criteria."
    },
    {
        "path": "frontend/src/scenes/cohorts/CohortEdit.tsx",
        "summary": "This code defines the `CohortEdit` component, which allows users to create and edit cohorts within the PostHog application. It provides a form for defining cohort properties such as name, description, and type (dynamic or static). For static cohorts, users can upload a CSV file containing a list of user distinct IDs. For dynamic cohorts, users can define matching criteria based on user properties and events. The component also handles actions such as saving, deleting, duplicating cohorts, and integrating with notebooks. It displays relevant information such as the last calculation time for dynamic cohorts and warnings if the cohort is used in an experiment.\n\nHere's a list of high-level product features:\n\n*   **Cohort Creation/Editing:** Allows users to define and modify cohorts based on various criteria.\n*   **Dynamic Cohorts:** Supports cohorts that automatically update based on defined user properties and event filters.\n*   **Static Cohorts:** Supports cohorts with a fixed list of users uploaded via CSV.\n*   **Cohort Type Selection:** Allows users to choose between dynamic and static cohort types.\n*   **CSV Upload for Static Cohorts:** Enables users to upload a CSV file containing user distinct IDs to populate static cohorts.\n*   **Cohort Description:** Allows users to add a description to cohorts for better organization and understanding.\n*   **Cohort Duplication:** Enables users to duplicate existing cohorts, either as dynamic or static cohorts.\n*   **Cohort Deletion:** Allows users to delete cohorts.\n*   **Notebook Integration:** Integrates with the notebook feature, allowing users to associate cohorts with notebooks.\n*   **Experiment Integration:** Displays warnings when editing cohorts that are used in experiments.\n*   **Real-time Calculation Status:** Shows the status of cohort calculations, including last calculation time and error indicators.\n*   **Matching Criteria Definition:** Allows users to define complex matching criteria for dynamic cohorts."
    },
    {
        "path": "frontend/src/scenes/cohorts",
        "summary": "The provided code collectively implements a comprehensive cohort management system within PostHog, enabling users to define and analyze groups of users based on shared characteristics. This system allows for the creation of both dynamic cohorts, which automatically update based on defined criteria, and static cohorts, populated via CSV upload. Users can define complex filtering logic based on user properties, event behavior, lifecycle stages, and time-based conditions, organized into logical groupings with AND/OR operators. The system provides real-time validation, calculation status updates, activity logging, and integration with other PostHog features like notebooks and experiments, all within a user-friendly interface.\n\nHere's a list of high-level product features:\n\n*   **Cohort Creation and Management:** Define, edit, duplicate, and delete cohorts based on various criteria.\n*   **Dynamic Cohorts:** Automatically update cohorts based on user properties, event behavior, and time-based conditions.\n*   **Static Cohorts:** Create cohorts from a fixed list of users uploaded via CSV.\n*   **Behavioral Filtering:** Filter users based on event behavior, actions taken, and event sequences.\n*   **Property-Based Filtering:** Filter users based on user properties, including aggregation and comparison operators.\n*   **Lifecycle Stage Filtering:** Filter users based on lifecycle stages.\n*   **Time-Based Filtering:** Filter users based on time intervals and date operators.\n*   **Logical Grouping of Criteria:** Organize cohort definition criteria into logical groups with AND/OR logic.\n*   **Real-time Validation:** Validate cohort definitions in real-time, ensuring criteria are valid and complete.\n*   **Real-time Calculation Status:** Display the calculation status of cohorts and automatically update the cohort data when the calculation is complete.\n*   **Activity Logging:** Track and display cohort-related activities, including creation, deletion, and updates.\n*   **Integration with Other Features:** Integrate cohorts with other PostHog features like notebooks, experiments, and session recordings.\n*   **Cohort Listing and Search:** Display a list of cohorts with key information and allow users to search for cohorts by name.\n*   **Cohort Export:** Enable exporting cohort data in CSV format.\n"
    },
    {
        "path": "frontend/src/scenes/max/MaxTool.tsx",
        "summary": "The `MaxTool` component is a wrapper that enables PostHog's AI assistant, Max, to interact with and enhance existing tools within the platform. It registers tools with Max, displays a special UI element (a burst-style profile picture button) when Max is available and the feature flag is enabled, and opens the Max side panel with a pre-defined prompt when the button is clicked. The component also provides a way to disable the Max integration and render the original tool without Max enhancements.\n\nHere's a list of high-level product features provided by the `MaxTool` component:\n\n*   **Tool Registration with Max:** Registers a tool with Max, making it available for Max to use and interact with.\n*   **Conditional UI Enhancement:** Displays a special UI element (burst-style profile picture button) to indicate Max integration is available.\n*   **Max Side Panel Integration:** Opens the Max side panel with a pre-defined prompt when the Max-related UI element is clicked.\n*   **Max Availability Check:** Checks if Max is available via a feature flag.\n*   **Fallback Rendering:** Renders the original tool without Max enhancements when Max is not available.\n*   **Tooltip Explanation:** Provides a tooltip to explain the Max integration and its functionality.\n*   **Visual Highlighting:** Adds a dashed border to visually highlight the tool when Max is open and focused on that tool.\n"
    },
    {
        "path": "frontend/src/scenes/max/Intro.tsx",
        "summary": "The `Intro` component in `frontend/src/scenes/max/Intro.tsx` displays an introductory message and a HedgehogBuddy avatar to welcome the user. The headline message is dynamically selected from a list of options to provide variety. The HedgehogBuddy is configured to be static and non-interactive, with a small chance of a fun animation when clicked. The component also includes an AIConsentPopoverWrapper, likely related to user consent for AI features.\n\nHere's a list of high-level product features:\n\n*   **Introductory Message:** Displays a dynamic headline to welcome the user.\n*   **HedgehogBuddy Avatar:** Shows a static HedgehogBuddy avatar as a visual element.\n*   **AI Consent:** Integrates with an AIConsentPopoverWrapper for managing user consent related to AI features.\n*   **Interactive Avatar:** Provides a small chance of a fun animation when the avatar is clicked.\n"
    },
    {
        "path": "frontend/src/scenes/max/utils.ts",
        "summary": "This code provides utility functions for working with messages and queries related to an assistant feature. It defines type guards to identify different types of messages (Reasoning, Visualization, Human, Assistant, ToolCall, and Failure) and functions to cast assistant-specific query types (Trends, Funnels, Retention, and HogQL) to their general query counterparts, ensuring type compatibility. The `castAssistantQuery` function acts as a central point for casting any of the assistant query types.\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **AI Assistant Integration:** The code suggests the presence of an AI assistant within the product.\n*   **Message Handling:** The system handles different types of messages from the assistant, including reasoning, visualizations, human input, assistant responses, tool calls, and failures.\n*   **Query Execution:** The assistant can execute different types of queries, including Trends, Funnels, Retention, and HogQL queries.\n*   **Type Compatibility:** The code ensures compatibility between assistant-specific query types and general query types.\n*   **Tool Call Support:** The assistant can invoke external tools and display their results.\n"
    },
    {
        "path": "frontend/src/scenes/max/QuestionInput.tsx",
        "summary": "The `QuestionInput` component provides a text area for users to input questions for the Max AI assistant. It features dynamic styling based on whether the input is in a floating context (part of a thread) or not. The component includes functionalities for submitting questions, stopping ongoing generation, and displaying relevant tools in context. It also handles auto-focusing the input field and provides keyboard shortcuts for submission.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Question Input:** Allows users to type and submit questions to Max.\n*   **Dynamic Styling:** Adapts its appearance based on context (floating/non-floating).\n*   **Thread Support:** Enables follow-up questions within a conversation thread.\n*   **Loading State:** Indicates when Max is processing a question.\n*   **Stop Generation:** Provides a way to halt ongoing AI responses.\n*   **Tool Context:** Displays the tools being used by Max to answer the question.\n*   **Auto-focus:** Automatically focuses the input field for immediate typing.\n*   **Keyboard Shortcut:** Supports submitting questions using the Enter key.\n"
    },
    {
        "path": "frontend/src/scenes/max/QuestionSuggestions.tsx",
        "summary": "The `QuestionSuggestions` component in `frontend/src/scenes/max/QuestionSuggestions.tsx` provides a user interface for interacting with the Max AI assistant. It displays suggested questions to the user, allowing them to initiate conversations with Max. If Max's core memory hasn't been initialized, it prompts the user to start the learning process. While suggestions are loading or core memory is being fetched, skeleton buttons are displayed as placeholders. Once loaded, the component renders a set of suggested questions as buttons. Users can click these buttons to ask Max the corresponding question. The component also includes options to shuffle the suggestions and edit Max's core memory via the settings panel.\n\nHere's a list of high-level product features:\n\n*   **Initial Core Memory Setup:** Prompts the user to initialize Max's core memory if it hasn't been done yet.\n*   **Question Suggestions:** Displays a set of suggested questions to the user.\n*   **Ask Max:** Allows users to ask Max a question by clicking on a suggestion.\n*   **Loading State:** Displays skeleton buttons while suggestions are loading or core memory is being fetched.\n*   **Shuffle Suggestions:** Provides an option to shuffle the displayed question suggestions.\n*   **Edit Core Memory:** Allows users to edit Max's core memory via the settings panel.\n*   **Data Processing Acceptance Check:** Disables interaction if the user hasn't accepted data processing.\n"
    },
    {
        "path": "frontend/src/scenes/max/Max.tsx",
        "summary": "The `Max.tsx` file defines the main component for the \"Max\" feature, an AI-powered assistant within the PostHog application. It checks for a feature flag to ensure the user has access to AI features. If the feature is enabled and Max is selected in the side panel, it displays a message prompting the user to move Max into the main view. Otherwise, it renders the main Max interface, which includes a page header with options to start a new conversation and access settings. The interface displays either an introductory screen with question suggestions or a thread of conversation with a question input for further interaction.\n\nHere's a list of high-level product features:\n\n*   **AI Assistant Interface:** Provides a user interface for interacting with an AI assistant.\n*   **Feature Flag Protection:** Restricts access to the AI assistant based on a feature flag.\n*   **Side Panel Integration:** Allows the AI assistant to be used within a side panel.\n*   **Conversation Management:** Enables users to start new conversations with the AI assistant.\n*   **Settings Access:** Provides access to settings related to the AI assistant.\n*   **Question Input:** Allows users to input questions or prompts for the AI assistant.\n*   **Question Suggestions:** Offers suggestions for questions to ask the AI assistant.\n*   **Conversation Thread Display:** Displays a thread of past conversations with the AI assistant.\n*   **Core Memory Settings:** Allows users to configure the AI assistant's core memory.\n"
    },
    {
        "path": "frontend/src/scenes/max/maxGlobalLogic.ts",
        "summary": "This code defines the `maxGlobalLogic` using the Kea framework, managing the global state and logic for the Max AI assistant. It handles user acceptance of data processing, registration and deregistration of tools for the AI assistant, and provides selectors to determine the data processing acceptance status, reasons for disabling data processing approval, and the list of registered tools. The logic connects to `organizationLogic` to access and update organization-level settings.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **AI Assistant Tool Registration:** Allows developers to register tools with the Max AI assistant, providing context and callbacks for execution.\n*   **Data Processing Consent Management:** Enables users to accept or decline data processing for AI assistant features at the organization level.\n*   **Admin-Restricted Data Processing Approval:** Restricts data processing approval to organization administrators and owners.\n*   **Contextual AI Suggestions:** Provides a mechanism for registered tools to suggest questions to the user based on the current context.\n*   **Dynamic Tool Management:** Supports dynamic registration and deregistration of tools, allowing for flexible extension of the AI assistant's capabilities.\n"
    },
    {
        "path": "frontend/src/scenes/max/maxLogic.ts",
        "summary": "This code defines the `maxLogic` Kea logic, which manages the state and behavior of a conversation thread with an AI assistant named Max. It handles user input, sends prompts to the backend for processing, manages the streaming responses from the assistant, and updates the UI with the conversation history. The logic also includes features for stopping generation, retrying messages, managing suggested questions, and handling errors. It integrates with other logics such as `projectLogic`, `maxGlobalLogic`, and `maxSettingsLogic` to access project-specific information, global settings, and core memory for the assistant.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **AI Assistant Conversation:** Allows users to have a conversation with an AI assistant (Max).\n*   **Real-time Streaming Responses:** Displays the assistant's responses in real-time as they are generated.\n*   **Contextual Tool Integration:** Enables the assistant to use external tools and display their results.\n*   **Error Handling and Retry:** Gracefully handles errors during generation and allows users to retry their last message.\n*   **Conversation Management:** Supports starting new conversations, resetting the thread, and managing conversation history.\n*   **Suggested Questions:** Provides users with a list of suggested questions to guide the conversation.\n*   **Core Memory Integration:** Leverages core memory to provide the assistant with contextual information.\n*   **Stop Generation:** Allows users to interrupt the assistant while it is generating a response.\n*   **Traceability:** Generates trace IDs for each conversation run for debugging and monitoring.\n"
    },
    {
        "path": "frontend/src/scenes/max/Thread.tsx",
        "summary": "This code defines the `Thread` component, which displays a conversation thread between a user and an AI assistant (Max). The thread is composed of message groups, each containing a series of messages from either the user or the AI. Different message types are rendered with specific templates, including human messages, AI-generated text answers, visualizations (charts/graphs), reasoning steps, and error messages. The component also includes interactive elements like buttons to retry failed messages, provide feedback (thumbs up/down), and open visualizations as new insights. It leverages Lemon UI components for styling and interactivity, and PostHog for capturing user feedback and trace metrics.\n\nHere's a list of high-level product features implemented in this code:\n\n*   **Conversation Thread Display:** Renders a chronological conversation between a user and an AI assistant.\n*   **Message Grouping:** Groups messages by sender (user or AI) for better readability.\n*   **Human Message Input:** Displays user-sent messages.\n*   **AI-Generated Text Answers:** Renders AI-generated responses, including handling of forms for further interaction.\n*   **Data Visualization Display:** Renders charts and graphs generated by the AI.\n*   **Reasoning Step Display:** Shows the AI's reasoning process in substeps.\n*   **Error Handling and Retries:** Displays error messages and allows users to retry failed AI responses.\n*   **User Feedback Collection:** Allows users to provide feedback on AI responses (thumbs up/down) and submit text feedback.\n*   **Insight Creation from Visualizations:** Enables users to open AI-generated visualizations as new insights.\n*   **Assistant Message Forms:** Displays interactive forms within the assistant's messages to guide the conversation."
    },
    {
        "path": "frontend/src/scenes/max",
        "summary": "The provided code snippets detail the implementation of \"Max,\" an AI assistant integrated into the PostHog platform. Max allows users to interact with their data through natural language, providing insights, visualizations, and automated analysis. The system manages user consent for data processing, registers tools for Max to utilize, and handles various message types within a conversation thread. Users can input questions, receive real-time streaming responses, provide feedback, and manage Max's core memory.\n\nHere's a list of high-level product features:\n\n*   AI Assistant Integration: Enables users to interact with an AI assistant (Max) to analyze data and gain insights.\n*   Natural Language Querying: Allows users to ask questions and interact with data using natural language.\n*   Data Visualization: Generates and displays charts and graphs based on AI analysis.\n*   Automated Analysis: Provides automated insights and analysis of user data.\n*   Real-time Streaming Responses: Displays AI responses in real-time as they are generated.\n*   Conversation Management: Supports starting new conversations, managing conversation history, and providing suggested questions.\n*   Tool Integration: Allows the AI assistant to utilize external tools and display their results.\n*   Data Processing Consent Management: Enables users to control data processing for AI features.\n*   User Feedback Collection: Gathers user feedback on AI responses to improve accuracy and relevance.\n*   Core Memory Management: Allows users to configure the AI assistant's core memory for contextual awareness.\n*   Error Handling and Retry: Provides error handling and allows users to retry failed AI responses.\n*   Contextual Tool Suggestions: Provides a mechanism for registered tools to suggest questions to the user based on the current context.\n*   Interactive Assistant Messages: Displays interactive forms within the assistant's messages to guide the conversation.\n"
    },
    {
        "path": "frontend/src/scenes/project/Create/index.tsx",
        "summary": "This code defines a React component, `ProjectCreate`, which is responsible for rendering either a warning banner or a modal for creating a new project. It checks if project creation is forbidden based on the `projectCreationForbiddenReason` from the `organizationLogic`. If it is forbidden, a warning banner is displayed with the reason. Otherwise, a `CreateProjectModal` is rendered inline, allowing the user to create a new project. The component is also exported as a scene for use within the application's routing or scene management system.\n\nHere's a list of high-level product features:\n\n*   **Project Creation:** Allows users to create new projects.\n*   **Project Creation Restriction:** Restricts project creation based on organizational settings or limits.\n*   **Warning Banner:** Displays a warning message if project creation is forbidden, providing a reason.\n*   **Modal Interface:** Provides a modal interface for creating projects.\n"
    },
    {
        "path": "frontend/src/scenes/project/CreateProjectModal.tsx",
        "summary": "This code defines a React component, `CreateProjectModal`, which is a modal window that allows users to create new projects within an organization. The modal includes a form for entering the project name, along with helpful tips and links to documentation. It leverages PostHog's Lemon UI components for styling and interacts with the `projectLogic` and `organizationLogic` to handle project creation and organization details. The modal also tracks project creation events using `eventUsageLogic`.\n\nHere's a list of high-level product features implemented by the code:\n\n*   **Project Creation:** Allows users to create new projects within their organization.\n*   **Project Naming:** Provides a text input field for users to enter a name for the new project.\n*   **Modal Interface:** Presents the project creation form within a modal window for a focused user experience.\n*   **Contextual Help:** Displays helpful tips and links to documentation to guide users in understanding projects.\n*   **Loading State:** Indicates when a project is being created to prevent multiple submissions.\n*   **Form Validation:** Disables the submit button when the project name is empty.\n*   **Event Tracking:** Tracks project creation events for usage analysis.\n*   **Automatic Modal Closure:** Closes the modal automatically after a new project is successfully created.\n*   **Cancel Action:** Allows users to cancel the project creation process.\n"
    },
    {
        "path": "frontend/src/scenes/project/Create",
        "summary": "The `ProjectCreate` component provides a user interface for creating new projects within an organization. It dynamically renders either a warning banner explaining why project creation is currently forbidden, or a modal that allows the user to input the necessary information and initiate the project creation process. This component handles the logic for checking project creation permissions and presenting the appropriate UI element.\n\nHere's a list of high-level product features:\n\n*   Project Creation: Enables users to initiate the creation of new projects.\n*   Project Creation Restriction: Implements organizational controls to restrict project creation based on predefined reasons.\n*   Warning Banner: Displays informative messages when project creation is restricted, explaining the reason for the restriction.\n*   Modal Interface: Provides a user-friendly modal window for inputting project details during the creation process.\n"
    },
    {
        "path": "frontend/src/scenes/project/CreateEnvironmentModal.tsx",
        "summary": "This code defines a modal component, `CreateEnvironmentModal`, which allows users to create new environments (teams) within a PostHog project. The modal includes a form with a single input field for the environment name. It provides feedback to the user during the creation process, such as loading states and validation messages. The modal also includes a link to the PostHog documentation for more information on environments.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Environment Creation:** Allows users to create new environments within a project.\n*   **Environment Naming:** Provides a text input field for users to specify the name of the new environment.\n*   **Loading State:** Displays a loading indicator while the environment is being created.\n*   **Input Validation:** Disables the submit button if the environment name is empty.\n*   **Modal Presentation:** Presents the environment creation form within a modal window.\n*   **Documentation Link:** Provides a link to the PostHog documentation for more information on environments.\n*   **Automatic Modal Closing:** Closes the modal automatically after a new environment is successfully created.\n*   **Cancel Action:** Allows users to cancel the environment creation process.\n*   **Keyboard Submission:** Allows users to submit the form by pressing the Enter key."
    },
    {
        "path": "frontend/src/scenes/project",
        "summary": "The provided code snippets detail the implementation of project and environment creation features within a PostHog application. Users can create new projects within an organization using a modal interface, complete with input validation, contextual help, and event tracking. Similarly, users can create new environments (teams) within a project, also through a modal, with loading states, input validation, and links to relevant documentation. The system also implements organizational controls to restrict project creation based on predefined reasons, displaying informative messages when restrictions are in place.\n\nHere's a list of high-level product features:\n\n*   Project Creation\n*   Project Naming\n*   Project Creation Restriction\n*   Environment Creation\n*   Environment Naming\n*   Modal Interface\n*   Contextual Help\n*   Loading State\n*   Form Validation\n*   Event Tracking\n*   Automatic Modal Closure\n*   Cancel Action\n*   Warning Banner\n*   Documentation Link\n*   Keyboard Submission\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/dashboardTemplateEditorLogic.ts",
        "summary": "This code defines the logic for a dashboard template editor in a PostHog application. It manages the state and actions related to creating, updating, deleting, and validating dashboard templates. The logic includes functionalities for handling the editor's value, managing validation errors, and interacting with the PostHog API to persist and retrieve dashboard templates. It also handles opening and closing the dashboard template editor modal and refreshing the list of available templates upon successful creation, update, or deletion.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dashboard Template Creation:** Allows users to create new dashboard templates.\n*   **Dashboard Template Editing:** Enables users to modify existing dashboard templates.\n*   **Dashboard Template Deletion:** Provides the ability to remove dashboard templates.\n*   **Dashboard Template Validation:** Validates the structure and content of dashboard templates, providing error messages.\n*   **JSON Editor:** Provides a JSON editor for creating and editing dashboard templates.\n*   **API Integration:** Interacts with the PostHog API to persist and retrieve dashboard templates.\n*   **Modal Interface:** Presents the dashboard template editor within a modal window.\n*   **Schema Retrieval:** Fetches the schema for dashboard templates from the API.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/dashboardCollaboratorsLogic.ts",
        "summary": "This code manages collaborators for a specific dashboard in a web application. It handles loading, adding, and deleting explicit collaborators, and combines these with project admins and other members to present a unified list of all collaborators with their respective permission levels. The logic also determines which members can be added as collaborators, excluding those already present.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dashboard Collaboration Management:** Allows users to manage who has access to a specific dashboard.\n*   **Explicit Collaborator Assignment:** Enables granting specific users \"Can Edit\" permissions on a dashboard, beyond the default project-level permissions.\n*   **Collaborator List Display:** Shows a combined list of all collaborators, including explicitly added users, project admins, and other members (depending on dashboard restriction level), with their respective roles (Owner, Project Admin, Can Edit).\n*   **Add Collaborator Functionality:** Provides a way to add new users as explicit collaborators to a dashboard.\n*   **Remove Collaborator Functionality:** Allows removing explicit collaborators from a dashboard.\n*   **Permission Level Indication:** Clearly displays the permission level (e.g., Owner, Project Admin, Can Edit) for each collaborator.\n*   **Searchable/Filterable Collaborator List:** (Implicit) The `addableMembers` selector suggests the possibility of a searchable or filterable list of members who can be added as collaborators.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/DashboardItems.tsx",
        "summary": "The `DashboardItems` component renders the tiles on a dashboard using `react-grid-layout`. It fetches dashboard data, tiles, layouts, and dashboard mode from `dashboardLogic` and uses `insightsModel` for insight-related actions. The component allows users to interact with dashboard items, including dragging, resizing (in edit mode), refreshing, duplicating, and removing tiles. It dynamically renders either an `InsightCard` for insights or a `TextCard` for text tiles, providing specific props and actions for each type. The component also handles visual states like loading, highlighting, and erroring, and manages drag interactions to prevent unintended link clicks.\n\nHere's a list of high-level product features implemented in the code:\n\n*   **Dashboard Tile Rendering:** Displays tiles (insights and text) on a dashboard.\n*   **Interactive Layout Management:** Supports dragging and resizing of tiles in edit mode using a grid layout.\n*   **Edit Mode:** Enables editing of the dashboard layout.\n*   **Tile Actions:** Provides actions for each tile, including refreshing, duplicating, and removing.\n*   **Insight Management:** Allows renaming and duplicating insights from the dashboard.\n*   **Visual States:** Displays loading, highlighting, and error states for tiles.\n*   **Responsive Design:** Adapts the layout to different screen sizes.\n*   **Contextual Controls:** Shows or hides editing controls based on the dashboard placement.\n*   **Move to Dashboard:** Allows moving tiles to other dashboards.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/addInsightToDashboardModalLogic.ts",
        "summary": "This code defines a Kea logic module named `addInsightToDashboardLogic` that manages the visibility state of an \"Add Insight to Dashboard\" modal. It includes actions to show and hide the modal, and a reducer to update the `addInsightToDashboardModalVisible` state, which is a boolean value indicating whether the modal is currently visible.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Display \"Add Insight to Dashboard\" Modal:** Allows users to view a modal interface for adding insights to a dashboard.\n*   **Hide \"Add Insight to Dashboard\" Modal:** Enables users to close or dismiss the \"Add Insight to Dashboard\" modal.\n*   **Manage Modal Visibility:** Internally tracks and controls whether the \"Add Insight to Dashboard\" modal is currently displayed or hidden.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/DuplicateDashboardModal.tsx",
        "summary": "This component implements a modal that allows users to duplicate an existing dashboard. The modal provides options to either duplicate the dashboard's tiles (insights and text) or attach them to the new dashboard. It includes buttons for canceling, duplicating and navigating to the new dashboard, and a simple duplicate action. The modal uses a form to manage the duplication options and provides visual feedback on the submission status.\n\nHere's a list of high-level product features:\n\n*   **Dashboard Duplication:** Allows users to create a copy of an existing dashboard.\n*   **Tile Duplication Option:** Provides the choice to duplicate the dashboard's tiles (insights and text) or attach them to the new dashboard.\n*   **Modal Interface:** Presents the duplication options within a modal window.\n*   **Submission Status Indication:** Displays a loading state during the duplication process.\n*   **Navigation to Duplicated Dashboard:** Option to navigate directly to the newly created dashboard after duplication.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/deleteDashboardLogic.ts",
        "summary": "This code defines the `deleteDashboardLogic` using Kea, a state management library. It manages the state and actions related to deleting a dashboard, including showing and hiding a confirmation modal, handling form submission for deleting the dashboard (with an option to delete associated insights), and redirecting the user to the dashboards list after a successful deletion. The logic interacts with the `dashboardsModel` to perform the actual deletion and uses `kea-router` to navigate the user.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dashboard Deletion Confirmation Modal:** Displays a modal to confirm the deletion of a dashboard.\n*   **Delete Insights Option:** Allows the user to choose whether to delete associated insights when deleting a dashboard.\n*   **Dashboard Deletion:** Enables the deletion of a dashboard via a form submission.\n*   **Redirection to Dashboards List:** Automatically redirects the user to the dashboards list page after a successful dashboard deletion.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/DashboardTemplateEditor.tsx",
        "summary": "This component, `DashboardTemplateEditor`, provides a modal interface for creating and editing dashboard templates. It leverages a code editor with JSON validation to ensure the template's integrity. The modal includes actions for creating or updating templates, with button states reflecting the validation status of the JSON content. The editor's content is managed via the `dashboardTemplateEditorLogic` kea logic.\n\nHere's a list of high-level product features:\n\n*   **Dashboard Template Creation:** Allows users to create new dashboard templates using a JSON editor.\n*   **Dashboard Template Editing:** Enables users to modify existing dashboard templates.\n*   **JSON Validation:** Provides real-time validation of the JSON template content within the editor.\n*   **Code Editor Integration:** Uses a code editor component for a better editing experience, including syntax highlighting and error display.\n*   **Modal Interface:** Presents the template editor within a modal dialog for a focused editing experience.\n*   **Error Display:** Shows validation errors to the user, preventing the creation or update of invalid templates.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/duplicateDashboardLogic.ts",
        "summary": "This code defines the logic for duplicating a dashboard in the PostHog application. It manages the state of a modal that allows users to configure the duplication process, including setting the new dashboard's name and choosing whether to duplicate the tiles (insights) within the dashboard. Upon successful duplication, the logic handles navigation to the new dashboard or back to the dashboards list, and updates insight counts if tiles were not duplicated.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dashboard Duplication:** Allows users to create a copy of an existing dashboard.\n*   **Customizable Dashboard Name:** Enables users to specify a new name for the duplicated dashboard.\n*   **Tile Duplication Option:** Provides the option to either duplicate the tiles (insights) from the original dashboard or create an empty dashboard.\n*   **Modal Interface:** Presents a modal dialog for configuring the duplication process.\n*   **Navigation Control:** After duplication, allows users to navigate directly to the new dashboard or remain on the dashboards list page.\n*   **Insight Count Management:** Updates insight counts to ensure proper turbo mode functionality when tiles are not duplicated.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/dashboards/Dashboards.tsx",
        "summary": "The `Dashboards` component in `Dashboards.tsx` provides a user interface for managing and creating dashboards within the application. It features a tabbed interface to switch between viewing existing dashboards and dashboard templates. Users can create new dashboards via a modal, duplicate existing ones, and delete dashboards. The component displays a table of dashboards or templates based on the selected tab, and provides a \"New dashboard\" button to trigger the creation flow. If no dashboards exist, it prompts the user to create their first dashboard using a template chooser.\n\nHere's a list of high-level product features:\n\n*   **Dashboard Listing:** Displays a list of existing dashboards with options to manage them.\n*   **Dashboard Templates:** Provides a library of pre-built dashboard templates for quick setup.\n*   **New Dashboard Creation:** Allows users to create new dashboards from scratch or using templates.\n*   **Dashboard Duplication:** Enables users to duplicate existing dashboards.\n*   **Dashboard Deletion:** Allows users to delete dashboards.\n*   **Tabbed Interface:** Organizes dashboards and templates into separate tabs for easy navigation.\n*   **Filtering:** Supports filtering of dashboards.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/DashboardEditBar.tsx",
        "summary": "The `DashboardEditBar` component provides a user interface for editing and filtering data displayed on a dashboard. It allows users to adjust the date range, apply property filters, and set a breakdown filter to refine the data presented in the dashboard. The component includes a popover that appears when filters have been updated, prompting the user to either apply the filters and preview the changes or cancel them. It also handles the transition to an \"Edit\" mode when filters are modified and provides visual cues to indicate when the dashboard is in edit mode.\n\nHere's a list of high-level product features implemented by the code:\n\n*   **Date Filtering:** Allows users to specify a date range for the dashboard data.\n*   **Property Filtering:** Enables users to filter data based on event, person, and feature flag properties.\n*   **Breakdown Filtering:** Provides the ability to break down data by specific properties or dimensions.\n*   **Temporary Filter Preview:** Allows users to preview filter changes before applying them to the dashboard.\n*   **Edit Mode:** Indicates when the dashboard is in edit mode and prompts users to apply or cancel changes.\n*   **Taxonomic Filtering:** Supports filtering based on various taxonomic groups like cohorts and elements.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/dashboards/templates/dashboardTemplatesLogic.tsx",
        "summary": "This code defines the logic for fetching and displaying dashboard templates in the PostHog application. It uses Kea to manage state, actions, and side effects. The logic fetches dashboard templates from the backend API, filters them based on a search term, and allows specifying a scope to limit the templates to global ones or those visible in the current team. It also handles debouncing the search filter to avoid excessive API calls.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dashboard Template Listing:** Displays a list of available dashboard templates.\n*   **Template Scope:** Filters templates based on scope (global or team-specific).\n*   **Template Search:** Allows users to search for templates by name or description.\n*   **Template Selection:** Enables users to select a template for use in their dashboard.\n*   **Debounced Search:** Optimizes search functionality by delaying API calls until the user stops typing.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/Dashboard.tsx",
        "summary": "The Dashboard component in `Dashboard.tsx` renders a dashboard view with various features depending on the dashboard's state, user permissions, and placement. It handles loading, error, and access denied states, and provides editing capabilities, hotkey support for edit and fullscreen modes, and options to add insights. The component also includes a header, edit bar, refresh actions, and displays the dashboard items themselves.\n\nHere's a list of high-level product features implemented in the Dashboard component:\n\n*   **Dashboard Display:** Renders a dashboard with tiles (insights) or an empty state.\n*   **Dashboard Editing:** Allows users with edit permissions to modify the dashboard.\n*   **Dashboard Modes:** Supports edit and fullscreen modes, toggled via UI or hotkeys.\n*   **Error Handling:** Displays error messages when the dashboard fails to load or access is denied.\n*   **Data Refresh:** Provides options to manually or automatically refresh dashboard data.\n*   **Hotkey Support:** Enables keyboard shortcuts for common actions like entering edit or fullscreen mode.\n*   **Insight Addition:** Allows users to add new insights to the dashboard.\n*   **Variable Support:** Allows dashboards to have variables that can be used in the underlying queries.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/NewDashboardModal.tsx",
        "summary": "This code defines a modal component, `NewDashboardModal`, that allows users to create new dashboards. The modal presents two primary states: a dashboard template chooser and a template variable selection interface. When no template is selected, the modal displays a list of available dashboard templates, allowing users to filter them using a search input. Once a template is selected, the modal transitions to a view where users can specify values for the template's variables (e.g., choosing specific events). The modal includes \"Back\" and \"Create\" buttons to navigate between the template selection and variable configuration stages, and to finalize the dashboard creation process.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Dashboard Creation Modal:** Provides a user interface for creating new dashboards.\n*   **Dashboard Template Selection:** Allows users to choose from a list of pre-defined dashboard templates.\n*   **Template Filtering:** Enables users to filter the list of available templates using a search input.\n*   **Template Variable Configuration:** Allows users to specify values for variables required by a selected template.\n*   **Dashboard Creation from Template:** Creates a new dashboard based on a selected template and configured variables.\n*   **Navigation between Template Selection and Configuration:** Provides \"Back\" and \"Create\" buttons for navigating between the template selection and variable configuration stages.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/tileLayouts.ts",
        "summary": "This code defines functions for managing the layout of dashboard tiles in a PostHog dashboard. It includes functions for sorting tiles based on their layout positions and calculating the optimal layout for different screen sizes (breakpoints). The layout calculation considers tile types (text, funnels, retention, paths, trends) and adjusts the default width and height accordingly. It also ensures that tiles are placed in the most efficient way, minimizing empty space and respecting column constraints for different breakpoints.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dashboard Tile Sorting:** Allows sorting of dashboard tiles based on their layout position for consistent rendering.\n*   **Responsive Dashboard Layout:** Calculates and adapts the dashboard layout for different screen sizes (breakpoints) to ensure optimal viewing on various devices.\n*   **Intelligent Tile Sizing:** Automatically adjusts the size of dashboard tiles based on their content type (e.g., text, funnels, retention, paths, trends) to improve readability and visual appeal.\n*   **Automated Tile Placement:** Automatically places tiles in the most efficient way, minimizing empty space and optimizing the use of available screen real estate.\n*   **Customizable Tile Layouts:** Supports custom layouts for each tile, allowing users to define specific positions and sizes.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/DashboardTemplateVariables.tsx",
        "summary": "The `DashboardTemplateVariables` component allows users to configure variables associated with a selected dashboard template. It dynamically renders input fields based on the template's defined variables, including name, description, and default values. Each variable is displayed with a label, description, and an `ActionFilter` component for setting the variable's value. The component utilizes kea-logic for managing the state of the variables and updating them based on user input.\n\nHere's a list of high-level product features:\n\n*   **Dashboard Template Variable Configuration:** Allows users to configure variables defined in dashboard templates.\n*   **Dynamic Input Rendering:** Renders input fields based on the variables defined in the selected dashboard template.\n*   **Variable Description Display:** Shows the name and description of each variable to guide the user.\n*   **Action Filter Integration:** Uses the `ActionFilter` component to allow users to select values for variables, likely events or actions.\n*   **State Management with Kea:** Manages the state of the variables using kea-logic for efficient updates and data flow.\n*   **Optional Variable Handling:** Indicates whether a variable is required or optional.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/dashboardTemplateVariablesLogic.ts",
        "summary": "This code defines the logic for managing dashboard template variables within a PostHog application. It handles setting, resetting, and iterating through variables, as well as integrating with the PostHog toolbar to capture user interactions and automatically populate variable values based on selected elements or actions. The logic also manages the state of element selection and custom event names associated with the variables.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dashboard Templating:** Allows users to create dashboards with dynamic variables that can be customized.\n*   **Variable Management:** Enables users to set, reset, and iterate through dashboard template variables.\n*   **Visual Element Selection:** Integrates with the PostHog toolbar to allow users to visually select elements on a page and automatically populate variable values based on those selections.\n*   **Action-Based Variable Setting:** Allows users to define variables based on existing PostHog actions.\n*   **Pageview and Screenview Variable Setting:** Supports setting variables based on pageview and screenview events, including URL matching.\n*   **Custom Event Name Management:** Manages custom event names associated with template variables.\n*   **Variable State Tracking:** Tracks whether a variable has been \"touched\" (i.e., customized by the user).\n*   **Guided Variable Configuration:** Provides a mechanism to guide users through configuring all template variables in a dashboard.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/dashboards/templates/DashboardTemplatesTable.tsx",
        "summary": "This component renders a table displaying dashboard templates, fetched using `dashboardTemplatesLogic`. The table includes columns for the template name, description, and type (Official/Team). For staff users, a \"More\" dropdown provides options to edit the template, change its visibility scope (global/team), and delete it (team templates only). The component also integrates with `DashboardTemplateEditor` for editing templates and uses `LemonDialog` for confirmation before deleting a template.\n\nHere's a list of high-level product features:\n\n*   **Display Dashboard Templates:** Shows a list of available dashboard templates in a table format.\n*   **Template Details:** Displays the name, description, and type (Official/Team) of each template.\n*   **Edit Template (Staff Only):** Allows staff users to modify existing dashboard templates.\n*   **Change Template Visibility (Staff Only):** Enables staff users to switch a template's scope between global (Official) and team-specific.\n*   **Delete Template (Staff Only, Team Templates Only):** Permits staff users to delete team-specific dashboard templates.\n*   **Confirmation Dialog:** Requires confirmation from the user before deleting a dashboard template.\n*   **Pagination:** Implements pagination for handling a large number of dashboard templates.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/dashboards/DashboardsTable.tsx",
        "summary": "The `DashboardsTable.tsx` file defines a component that renders a table of dashboards, allowing users to view, search, filter, and manage their dashboards. It fetches dashboard data and filters from kea logic, and displays them in a LemonTable component with features like pinning, sharing status, access control indicators, and actions for editing, duplicating, and deleting dashboards. The table also supports sorting, searching, and filtering by pinned status, shared status, and creator.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Dashboard Listing:** Displays a list of dashboards with key information like name, description, and sharing status.\n*   **Dashboard Pinning:** Allows users to pin dashboards for easy access.\n*   **Dashboard Sharing Status:** Indicates whether a dashboard is shared publicly.\n*   **Access Control Indication:** Shows access control status with a lock icon.\n*   **Dashboard Searching:** Enables users to search for dashboards by name.\n*   **Dashboard Filtering:** Allows users to filter dashboards by pinned status, shared status, and creator.\n*   **Dashboard Sorting:** Supports sorting dashboards by name and creation date.\n*   **Dashboard Actions:** Provides actions for viewing, editing, duplicating, and deleting dashboards.\n*   **Navigation to Dashboard:** Allows users to navigate to a specific dashboard.\n*   **Tagging:** Displays tags associated with dashboards (if the tagging feature is available).\n*   **Dashboard Creation Information:** Displays the creator and creation date of each dashboard.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/dashboards/templates",
        "summary": "The dashboard templates feature provides a user interface for managing and utilizing pre-designed dashboard layouts. Staff users can create, edit, and delete templates, as well as control their visibility scope (global or team-specific). All users can browse, search, and select templates to quickly create new dashboards. The system optimizes search functionality and requires confirmation before deleting templates to prevent accidental data loss.\n\n*   Display Dashboard Templates\n*   Template Details (Name, Description, Type)\n*   Edit Template (Staff Only)\n*   Change Template Visibility (Staff Only)\n*   Delete Template (Staff Only, Team Templates Only)\n*   Confirmation Dialog\n*   Pagination\n*   Template Scope (Global/Team)\n*   Template Search\n*   Template Selection\n*   Debounced Search\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/dashboards/dashboardsLogic.ts",
        "summary": "This code defines the logic for managing dashboards in the PostHog frontend. It handles filtering, sorting, and tab selection for displaying dashboards, leveraging kea for state management and fuse.js for searching. The logic connects to the dashboards model and user logic to fetch and display relevant dashboard data based on user-defined filters and preferences. It also integrates with the router to persist the current tab in the URL.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dashboard Tab Selection:** Allows users to switch between different dashboard views (e.g., \"Dashboards\" and \"Templates\").\n*   **Dashboard Search:** Enables users to search for dashboards by name, description, or tags.\n*   **Dashboard Filtering:** Allows users to filter dashboards based on criteria like pinned status, shared status, and creator.\n*   **Dashboard Sorting:** Enables users to sort dashboards by different columns (e.g., name) in ascending or descending order.\n*   **URL Persistence:** Persists the selected dashboard tab in the URL, allowing users to share specific dashboard views.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/dashboards",
        "summary": "The dashboard management system provides a comprehensive interface for users to organize, create, and utilize dashboards and templates. Users can view and interact with existing dashboards through a sortable, filterable, and searchable table, with options to pin, share, edit, duplicate, and delete dashboards. A tabbed interface allows users to switch between viewing existing dashboards and a library of pre-built dashboard templates, which staff users can create, edit, and manage. The system also persists the selected dashboard tab in the URL, enabling easy sharing of specific views.\n\n*   Dashboard Listing\n*   Dashboard Templates Library\n*   New Dashboard Creation (from scratch or template)\n*   Dashboard Editing\n*   Dashboard Duplication\n*   Dashboard Deletion\n*   Dashboard Pinning\n*   Dashboard Sharing Status\n*   Access Control Indication\n*   Dashboard Searching\n*   Dashboard Filtering\n*   Dashboard Sorting\n*   Tabbed Interface (Dashboards/Templates)\n*   Template Management (Staff Only: Create, Edit, Delete, Visibility)\n*   URL Persistence of Tab Selection\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/EmptyDashboardComponent.tsx",
        "summary": "The `EmptyDashboardComponent` is displayed when a dashboard is empty. It shows a message prompting the user to add insights, along with a button to open the \"Add Insight\" modal. While the dashboard is loading, skeleton placeholders are displayed to indicate loading state. The component also disables the \"Add insight\" button if the user does not have edit permissions for the dashboard, showing a message explaining why.\n\nHere's a list of high-level product features:\n\n*   **Empty State Display:** Shows a user-friendly message when a dashboard is empty.\n*   **Add Insight Call-to-Action:** Provides a button to easily add insights to the dashboard.\n*   **Loading State Indication:** Displays skeleton placeholders while the dashboard is loading.\n*   **Edit Permission Check:** Disables the \"Add insight\" button and displays a message if the user lacks edit permissions.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/DeleteDashboardModal.tsx",
        "summary": "This React component, `DeleteDashboardModal`, implements a modal for deleting a dashboard. It utilizes the `deleteDashboardLogic` to manage the deletion process, including displaying the modal, handling submission, and managing loading states. The modal includes a checkbox that allows the user to optionally delete the dashboard's insights, provided they are not used in other dashboards. The modal provides \"Cancel\" and \"Delete dashboard\" buttons, with appropriate loading and disabled states during the deletion process.\n\nHere's a list of high-level product features:\n\n*   **Dashboard Deletion:** Allows users to delete dashboards.\n*   **Confirmation Modal:** Presents a modal to confirm the deletion action.\n*   **Insight Deletion Option:** Provides an option to delete insights associated with the dashboard.\n*   **Dependency Check:** Checks if insights are used in other dashboards before allowing deletion.\n*   **Loading State:** Displays a loading state during the deletion process.\n*   **Cancellation:** Allows users to cancel the deletion process.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/AddInsightToDashboardModal.tsx",
        "summary": "This React component, `AddInsightToDashboardModal`, renders a modal that allows users to add existing saved insights to a dashboard. It leverages several Kea logics to manage state and actions related to the modal's visibility, the current dashboard, and the process of adding saved insights. The modal includes a list of saved insights (handled by the `AddSavedInsightsToDashboard` component) and provides options to either cancel the operation or create a new insight directly within the dashboard.\n\nHere's a list of high-level product features:\n\n*   **Modal Interface:** Displays a modal for adding insights to a dashboard.\n*   **Saved Insight Selection:** Allows users to select from a list of existing saved insights to add to the dashboard.\n*   **Dashboard Association:** Associates the selected insight with a specific dashboard.\n*   **Cancel Action:** Provides a button to cancel the add insight operation.\n*   **New Insight Creation:** Offers a button to create a new insight directly within the context of the dashboard.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/DashboardReloadAction.tsx",
        "summary": "This React component, `DashboardReloadAction`, provides a user interface element for refreshing dashboard items. It allows users to manually refresh the dashboard, view the last refresh time, and enable/disable automatic refreshing at specified intervals. The component uses the `dashboardLogic` kea logic to manage the refreshing state and actions. It also leverages Lemon UI components for styling and interactivity, including a button with a dropdown menu for configuring auto-refresh settings.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Manual Dashboard Refresh:** Allows users to manually trigger a refresh of all dashboard items.\n*   **Automatic Dashboard Refresh:** Enables automatic refreshing of the dashboard at configurable intervals.\n*   **Configurable Refresh Interval:** Provides options to set the interval for automatic refreshing (e.g., 30 minutes, 1 hour).\n*   **Last Refresh Time Display:** Shows the time elapsed since the last dashboard refresh.\n*   **Refreshing Status Indication:** Displays a loading indicator and progress information during the refresh process.\n*   **Refresh Blocking:** Prevents excessive refreshing by blocking manual refreshes until a certain time has passed.\n*   **Page Visibility Awareness:** Pauses or resumes automatic refreshing based on whether the page is visible."
    },
    {
        "path": "frontend/src/scenes/dashboard/DashboardTemplateChooser.tsx",
        "summary": "The `DashboardTemplateChooser` component allows users to create new dashboards from pre-built templates or start with a blank dashboard. It fetches available templates, filters them based on availability contexts, and displays them as clickable items. When a template is selected, the component handles the creation of a new dashboard, either directly from the template or by prompting the user to select variables if the template requires them. The component also handles loading states and redirects the user after dashboard creation.\n\nHere's a list of high-level product features:\n\n*   **Dashboard Creation from Templates:** Users can create dashboards using pre-designed templates.\n*   **Blank Dashboard Creation:** Users can create a new, empty dashboard.\n*   **Template Filtering:** Templates are filtered based on context, allowing for tailored template options.\n*   **Variable Selection for Templates:** If a template requires variables, the user is prompted to select them before dashboard creation.\n*   **Loading State Management:** Visual feedback is provided during template loading and dashboard creation.\n*   **Template Preview:** Users can see a preview image, name, description, and tags for each template.\n*   **Template Tags:** Templates can be tagged for better organization and discoverability.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/DashboardHeader.tsx",
        "summary": "This code defines the `DashboardHeader` component, which renders the header section of a dashboard page in a web application. It includes functionalities for editing the dashboard layout, toggling full-screen mode, pinning/unpinning the dashboard, managing subscriptions, exporting the dashboard, duplicating the dashboard, creating a notebook from the dashboard, and managing dashboard permissions. The header dynamically adjusts its content based on the current dashboard mode (edit, fullscreen, or default) and the user's permissions.\n\nHere's a list of high-level product features implemented in the `DashboardHeader` component:\n\n*   **Dashboard Editing:** Allows users with edit permissions to modify the layout and content of the dashboard.\n*   **Full-Screen Mode:** Enables users to view the dashboard in full-screen for presentations or focused analysis.\n*   **Dashboard Pinning:** Allows users to pin dashboards for easy access.\n*   **Subscription Management:** Enables users to subscribe to dashboard updates and notifications.\n*   **Dashboard Export:** Provides options to export the dashboard in various formats (PNG, JSON).\n*   **Dashboard Duplication:** Allows users to create copies of existing dashboards.\n*   **Notebook Creation:** Enables users to create a notebook directly from a dashboard.\n*   **Permission Management:** Provides access to manage dashboard permissions and sharing settings.\n*   **Template Saving:** Allows staff users to save a dashboard as a template for future use.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/DashboardCollaborators.tsx",
        "summary": "This code defines the `DashboardCollaboration` component, which manages dashboard access control and collaborator settings. It allows users to set the dashboard's restriction level (who can edit), add explicit collaborators, and remove existing collaborators. The component also handles displaying existing collaborators and their access levels, differentiating between explicitly invited users and those with implicit access due to project roles. The component integrates with feature flags to enable new access control systems and displays appropriate banners for legacy dashboards.\n\nHere's a list of high-level product features implemented in the code:\n\n*   **Dashboard Restriction Level:** Allows setting the level of access restriction for a dashboard (e.g., everyone in the project can edit, only invited collaborators can edit).\n*   **Explicit Collaborator Management:** Enables adding and removing specific users as collaborators on a dashboard.\n*   **Collaborator Access Level Display:** Shows a list of current collaborators and their respective access levels (e.g., can edit, owner, project admin).\n*   **User Search and Selection:** Provides a search input to find and select users to add as collaborators.\n*   **Integration with Role-Based Access Control (RBAC):** Supports a new access control system based on roles and displays warnings for dashboards using legacy systems.\n*   **Permission Checks:** Enforces permission checks to ensure only authorized users can modify dashboard settings and collaborator lists.\n*   **PayGate Integration:** Restricts access to advanced permission features based on the user's subscription level.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/newDashboardLogic.ts",
        "summary": "This code defines the `newDashboardLogic` Kea logic for creating new dashboards in the PostHog application. It manages the state and actions related to the new dashboard creation process, including displaying a modal, handling form submissions, applying templates, and creating dashboards from templates. The logic interacts with the PostHog API to create dashboards and updates the dashboards model upon successful creation. It also handles URL routing to show and hide the new dashboard modal.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dashboard Creation:** Allows users to create new dashboards with a name, description, and restriction level.\n*   **Dashboard Templates:** Supports creating dashboards from pre-defined templates, including the ability to define and apply variables within the templates.\n*   **Template Variable Handling:** Provides a mechanism to handle variables within dashboard templates, allowing users to customize the templates with specific values.\n*   **Modal Management:** Manages the visibility of the new dashboard creation modal.\n*   **Form Handling:** Handles form submission and validation for the new dashboard creation form.\n*   **API Integration:** Integrates with the PostHog API to create dashboards.\n*   **URL Routing:** Enables showing and hiding the new dashboard modal via URL parameters.\n*   **Dashboard Restriction Levels:** Allows setting restriction levels for dashboards (e.g., who can edit).\n*   **Success and Error Handling:** Provides feedback to the user upon successful dashboard creation or in case of errors.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard/dashboardLogic.tsx",
        "summary": "This code defines the logic for a dashboard feature in a web application. It uses the Kea framework to manage state, actions, and side effects related to dashboards, including loading, updating, refreshing, and filtering dashboard items (tiles). The logic handles user interactions such as updating layouts, colors, and filters, as well as managing auto-refresh settings and error states. It also integrates with an API to fetch and update dashboard data, and includes features for access control, reporting usage, and managing variables.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dashboard Loading and Display:** Loads dashboard data, including tiles (insights, text, etc.) and their layouts, from the API and renders them on the screen.\n*   **Dashboard Editing:** Allows users to modify dashboard layouts (resize, move tiles), update tile colors, and add/remove tiles.\n*   **Dashboard Filtering:** Enables users to apply filters (date ranges, properties, breakdowns) to the entire dashboard, affecting all relevant tiles.\n*   **Real-time Data Refresh:** Supports automatic refreshing of dashboard tiles at a configurable interval.\n*   **Variable Management:** Allows users to define and manage variables that can be used in dashboard queries and visualizations.\n*   **Access Control:** Enforces access control policies to ensure that only authorized users can view and modify dashboards.\n*   **Dashboard Sharing and Collaboration:** Supports moving tiles between dashboards.\n*   **Performance Optimization:** Implements mechanisms to limit concurrent API requests and abort long-running queries.\n*   **Dashboard Subscriptions:** Supports subscribing to dashboards.\n*   **Text Tile Editing:** Supports editing text tiles.\n"
    },
    {
        "path": "frontend/src/scenes/dashboard",
        "summary": "This collection of code files implements a comprehensive dashboarding solution with features for creating, managing, and collaborating on dashboards. Users can create dashboards from scratch or leverage pre-built templates, customize the layout and content with various tiles (insights and text), and filter data to focus on relevant information. The system supports real-time data refresh, access control, and collaboration features, allowing teams to share and work together on data analysis. Dashboard templates can be created and managed by staff users, providing a standardized approach to dashboard creation.\n\nHere's a list of high-level product features:\n\n*   Dashboard Creation (from scratch or templates)\n*   Dashboard Editing (layout, content, filters)\n*   Dashboard Templates (creation, management, application)\n*   Dashboard Collaboration (access control, sharing)\n*   Dashboard Tile Management (adding, removing, resizing, duplicating)\n*   Data Filtering (date ranges, properties, breakdowns)\n*   Real-time Data Refresh\n*   Dashboard Duplication\n*   Dashboard Deletion\n*   Dashboard Pinning\n*   Dashboard Export\n*   Dashboard Variable Management\n*   Responsive Layout\n*   User Permission Management\n*   Visual Element Selection for Variables\n*   Integration with PostHog Toolbar\n*   Notebook Creation from Dashboard\n*   Template Tagging\n*   Dashboard Sharing Status\n*   Access Control Indication\n*   Dashboard Searching\n*   Dashboard Filtering\n*   Dashboard Sorting\n*   Tabbed Interface (Dashboards/Templates)\n*   Template Management (Staff Only: Create, Edit, Delete, Visibility)\n*   URL Persistence of Tab Selection\n"
    },
    {
        "path": "frontend/src/scenes/annotations/annotationModalLogic.ts",
        "summary": "This code defines the logic for managing an annotation modal within a PostHog application. It handles the creation and editing of annotations, allowing users to add context and notes to specific points in time, insights, dashboards, projects, or the entire organization. The logic manages the modal's state, form validation, API interactions for creating and updating annotations, and integrates with the router to open the modal based on a URL. It also handles pre-filling the form when editing an existing annotation or creating a new one from a specific insight or dashboard.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Annotation Creation:** Allows users to create new annotations with a date, scope (insight, dashboard, project, organization), and content.\n*   **Annotation Editing:** Enables users to modify existing annotations, updating their date, scope, and content.\n*   **Annotation Scope:** Supports different scopes for annotations, allowing them to be associated with specific insights, dashboards, projects, or the entire organization.\n*   **Modal Management:** Controls the opening and closing of the annotation modal.\n*   **Form Validation:** Validates the annotation content to ensure it's not empty.\n*   **Date and Time Handling:** Uses Dayjs for date and time management, including timezone support.\n*   **URL-Based Modal Opening:** Allows opening the annotation modal directly from a URL, pre-filled with the annotation's data.\n*   **Integration with Insights and Dashboards:** Enables creating annotations directly from insights and dashboards, pre-filling the relevant IDs.\n*   **Empty State Handling:** Displays a message when there are no annotations available."
    },
    {
        "path": "frontend/src/scenes/annotations/index.ts",
        "summary": "The code exports the `Annotations` component from the `./Annotations` file, making it available for use in other parts of the application. This suggests the existence of a feature related to annotations within the application.\n\n**Features:**\n\n*   **Annotations:** Provides a user interface and functionality for creating, viewing, and managing annotations within the application.\n"
    },
    {
        "path": "frontend/src/scenes/annotations/AnnotationModal.tsx",
        "summary": "This code defines a modal for creating and editing annotations within the PostHog application. The modal allows users to specify the date and time, scope (Insight, Dashboard, Project, or Organization), and content of the annotation. It includes features for creating new annotations, editing existing ones, and deleting annotations. The modal also provides helpful tooltips and disabled states to guide the user in selecting the appropriate scope for the annotation.\n\nHere's a list of high-level product features:\n\n*   **Annotation Creation:** Allows users to create new annotations with a date, scope, and content.\n*   **Annotation Editing:** Enables users to modify existing annotations.\n*   **Annotation Deletion:** Provides a way to remove annotations.\n*   **Annotation Scope Selection:** Allows users to define the scope of the annotation (Insight, Dashboard, Project, or Organization).\n*   **Date and Time Selection:** Provides a calendar input for specifying the date and time of the annotation.\n*   **Content Input:** Includes a text area for entering the annotation's content.\n*   **Contextual Guidance:** Offers tooltips and disabled states to assist users in selecting the correct scope.\n*   **Integration with Insights and Dashboards:** Links annotations to specific insights and dashboards.\n"
    },
    {
        "path": "frontend/src/scenes/annotations/Annotations.tsx",
        "summary": "The `Annotations.tsx` file defines the Annotations scene, which allows users to create and view annotations that mark significant events and their impact on metrics. It displays a table of annotations with details like content, date/time, scope (e.g., insight, dashboard, project, organization), creator, and creation date. Users can create new annotations via a modal, and the table supports sorting, pagination, and links to individual annotation details. The scene also includes an introductory section with a description, documentation link, and a call to action to create an annotation.\n\nHere's a list of high-level product features implemented in the code:\n\n*   **Annotation Creation:** Allows users to create annotations to mark significant events.\n*   **Annotation Listing:** Displays a table of existing annotations with key details.\n*   **Annotation Scoping:** Supports annotations scoped to insights, dashboards, projects, or the entire organization.\n*   **Annotation Details:** Provides links to view individual annotation details.\n*   **Annotation Sorting:** Enables sorting of annotations by date/time, scope, and creator.\n*   **Annotation Pagination:** Implements pagination for large lists of annotations.\n*   **User Attribution:** Displays the creator of each annotation with profile pictures.\n*   **Empty State Handling:** Shows a helpful message and introduction when no annotations exist.\n*   **External Links:** Links annotations scoped to insights to the insight view.\n*   **Documentation Link:** Provides a link to the annotations documentation.\n*   **Git Annotation Support:** Supports annotations created by GitHub Actions."
    },
    {
        "path": "frontend/src/scenes/annotations",
        "summary": "This collection of files implements a comprehensive annotation system within the PostHog application, enabling users to mark significant events and their impact on metrics. The system allows for the creation, editing, and deletion of annotations, which can be scoped to specific insights, dashboards, projects, or the entire organization. Users can access and manage annotations through a dedicated scene, complete with a table view, sorting, pagination, and links to individual annotation details. The system also features a modal for creating and editing annotations, providing contextual guidance and integration with insights and dashboards.\n\nHere's a list of high-level product features:\n\n*   **Annotation Creation:** Users can create new annotations with a date, scope (insight, dashboard, project, organization), and content.\n*   **Annotation Editing:** Existing annotations can be modified, updating their date, scope, and content.\n*   **Annotation Deletion:** Provides a way to remove annotations.\n*   **Annotation Listing:** Displays a table of existing annotations with key details, including content, date/time, scope, creator, and creation date.\n*   **Annotation Scoping:** Annotations can be associated with specific insights, dashboards, projects, or the entire organization.\n*   **Annotation Details:** Provides links to view individual annotation details.\n*   **Annotation Sorting:** Enables sorting of annotations by date/time, scope, and creator.\n*   **Annotation Pagination:** Implements pagination for large lists of annotations.\n*   **Modal Management:** Controls the opening and closing of the annotation modal.\n*   **Form Validation:** Validates the annotation content to ensure it's not empty.\n*   **Date and Time Handling:** Uses Dayjs for date and time management, including timezone support.\n*   **URL-Based Modal Opening:** Allows opening the annotation modal directly from a URL, pre-filled with the annotation's data.\n*   **Integration with Insights and Dashboards:** Enables creating annotations directly from insights and dashboards, pre-filling the relevant IDs.\n*   **User Attribution:** Displays the creator of each annotation with profile pictures.\n*   **Empty State Handling:** Shows a helpful message and introduction when no annotations exist.\n*   **External Links:** Links annotations scoped to insights to the insight view.\n*   **Documentation Link:** Provides a link to the annotations documentation.\n*   **Git Annotation Support:** Supports annotations created by GitHub Actions.\n"
    },
    {
        "path": "frontend/src/scenes/sites/siteLogic.ts",
        "summary": "This code defines a Kea logic module named `siteLogic` for managing site-related data in a web application. It takes a URL as a prop and provides a selector to generate breadcrumbs based on the current site URL. The breadcrumbs are used for navigation, showing the user's current location within the site.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Site Navigation:** Provides breadcrumbs for navigating within a specific site.\n*   **URL-Based Context:** Uses the URL to determine the current site context.\n*   **Dynamic Breadcrumb Generation:** Generates breadcrumbs dynamically based on the provided URL.\n"
    },
    {
        "path": "frontend/src/scenes/sites/Site.tsx",
        "summary": "This code defines a React component called `Site` that renders an iframe. The iframe displays a website based on a URL parameter passed to the component. The URL is decoded and then passed to a `launchUrl` function (provided by `authorizedUrlListLogic`) which likely sanitizes or transforms the URL before it's used as the `src` attribute of the iframe. The iframe has a sandbox attribute with various permissions enabled, including `allow-same-origin`, which is crucial for certain functionalities like `redirect_to_site` but also requires careful consideration of security implications.\n\nHere's a list of high-level product features:\n\n*   **Website Embedding:** Allows users to embed external websites within the application using an iframe.\n*   **URL Parameterization:** The embedded website's URL can be dynamically set via a URL parameter.\n*   **URL Sanitization/Transformation:** The URL is processed by a `launchUrl` function, likely for security or modification purposes.\n*   **Iframe Sandboxing:** Implements iframe sandboxing with specific permissions to control the embedded website's capabilities.\n*   **Authorized URL Management:** Integrates with a system (`authorizedUrlListLogic`) for managing and authorizing URLs that can be embedded.\n"
    },
    {
        "path": "frontend/src/scenes/sites",
        "summary": "The provided code snippets detail the implementation of site-related features within a web application. The `siteLogic` module manages site navigation by dynamically generating breadcrumbs based on the current URL, providing users with a clear understanding of their location within the site. The `Site` component enables the embedding of external websites via iframes, with URL parameterization, sanitization, and sandboxing implemented for security and control. This allows users to view and interact with external content seamlessly within the application's context.\n\nHere's a list of high-level product features:\n\n*   Site Navigation: Breadcrumbs for navigating within a specific site.\n*   Website Embedding: Allows users to embed external websites within the application using an iframe.\n*   URL Parameterization: The embedded website's URL can be dynamically set via a URL parameter.\n*   URL Sanitization/Transformation: Processing of URLs for security or modification purposes.\n*   Iframe Sandboxing: Implements iframe sandboxing with specific permissions to control the embedded website's capabilities.\n*   Authorized URL Management: Integrates with a system for managing and authorizing URLs that can be embedded.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/configuration/alerting/ErrorTrackingAlerting.tsx",
        "summary": "The `ErrorTrackingAlerting` component leverages the `LinkedHogFunctions` component to manage and display a list of linked Hog Functions specifically for error tracking. It configures the `LinkedHogFunctions` component to display internal destination Hog Functions associated with the \"error-tracking\" sub-template. The component filters the Hog Functions based on an empty filter object, implying that all Hog Functions of the specified type and sub-template are displayed.\n\nHere's a list of high-level product features:\n\n*   **Display Linked Hog Functions:** Shows a list of Hog Functions linked to error tracking.\n*   **Filter Hog Functions:** Allows filtering of Hog Functions (currently no filters are applied).\n*   **Internal Destination Support:** Specifically displays Hog Functions of the \"internal_destination\" type.\n*   **Error Tracking Sub-template:** Focuses on Hog Functions related to the \"error-tracking\" sub-template.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/configuration/alerting/ErrorTrackingAlert.tsx",
        "summary": "This code defines a scene for configuring error tracking alerts within a PostHog application. It uses Kea logic to manage the scene's state and provides breadcrumbs for navigation. The scene leverages the `HogFunctionConfiguration` component to handle the alert configuration, allowing users to create new alerts or edit existing ones. It also supports pre-defined templates for popular communication platforms like Slack, Discord, and Microsoft Teams.\n\n**Features:**\n\n*   **Error Tracking Alert Configuration:** Allows users to create and modify alerts for error tracking.\n*   **Pre-defined Alert Templates:** Offers templates for Slack, Discord, and Microsoft Teams to quickly set up alerts.\n*   **Navigation Breadcrumbs:** Provides clear navigation within the error tracking alert configuration flow.\n*   **HogFunction Integration:** Leverages the `HogFunctionConfiguration` component for managing alert settings.\n*   **Alert Editing:** Supports editing existing error tracking alerts.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/ErrorTrackingIssueScene.tsx",
        "summary": "The `ErrorTrackingIssueScene` component provides a detailed view for individual error tracking issues within PostHog. It fetches and displays issue metadata, stack traces, and related events, allowing users to investigate and resolve errors. Users can assign issues to team members, change the status of an issue (active, resolved, suppressed), and filter related events for deeper analysis. The scene also includes a setup prompt to guide users through the initial error tracking configuration.\n\nHere's a list of high-level product features:\n\n*   **Issue Details Display:** Shows metadata related to the error.\n*   **Stacktrace Analysis:** Displays and allows analysis of the error's stacktrace.\n*   **Event Timeline:** Lists events related to the error, with filtering capabilities.\n*   **Issue Assignment:** Allows assigning the issue to a specific user.\n*   **Issue Status Management:** Enables changing the status of an issue (e.g., active, resolved, suppressed).\n*   **Error Tracking Setup Prompt:** Guides users through the initial setup of error tracking.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/assigneeSelectLogic.tsx",
        "summary": "This code defines a Kea logic module named `assigneeSelectLogic` for managing the selection of an assignee for error tracking issues. It fetches and filters organization members and user groups, providing a unified interface for searching and displaying potential assignees. The logic handles loading states, search input, and transforms user and group data into a consistent `AssigneeDisplayType` for UI consumption, including a default \"Unassigned\" option.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Assignee Selection:** Allows users to assign error tracking issues to specific users or user groups.\n*   **User and Group Search:** Enables searching for users and user groups to quickly find the desired assignee.\n*   **Loading State Management:** Provides visual feedback on the loading status of user and group data.\n*   **Unified Display:** Presents users and groups in a consistent format with icons and display names.\n*   **\"Unassigned\" Option:** Includes an option to mark an issue as unassigned.\n*   **Me First Ordering:** Prioritizes the current user in the list of potential assignees.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/OccurrenceSparkline.tsx",
        "summary": "This code defines a React component called `OccurrenceSparkline` that displays a sparkline chart visualizing error occurrence data over time. It utilizes the `Sparkline` component from the `lib/components` library and leverages `chart.js` for charting functionality. The component takes error occurrence values, a time unit (e.g., hour, day), and an interval as input to render the sparkline. It also formats the X-axis labels based on the time unit and provides dark/light mode support for the sparkline colors. The `useSparklineData` hook is used to extract the data, time unit, and interval from the error tracking logic, and the `wrapDataWithColor` function formats the data for the `Sparkline` component.\n\nHere's a list of high-level product features:\n\n*   **Error Occurrence Visualization:** Displays a sparkline chart representing the number of error occurrences over a specified time period.\n*   **Time Unit Granularity:** Supports different time units for the sparkline, such as hours, days, weeks, and months.\n*   **Customizable Time Range:** Allows users to select a predefined time range (e.g., 24 hours, 30 days) or define a custom time range for the sparkline.\n*   **Dynamic X-Axis Labels:** Formats the X-axis labels of the sparkline based on the selected time unit.\n*   **Dark/Light Mode Support:** Adapts the sparkline colors to the current theme (dark or light mode).\n*   **Data Aggregation:** Provides a hook (`useSparklineData`) to fetch and aggregate error occurrence data for the sparkline.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/configuration/alerting",
        "summary": "The error tracking alerting feature in PostHog allows users to configure and manage alerts for error tracking events. This includes creating new alerts, editing existing ones, and utilizing pre-defined templates for popular communication platforms like Slack, Discord, and Microsoft Teams. The system leverages Hog Functions to define alert destinations and provides a clear interface for managing these linked functions, focusing on internal destinations associated with the \"error-tracking\" sub-template.\n\nHere's a list of high-level product features:\n\n*   Error Tracking Alert Configuration\n*   Pre-defined Alert Templates (Slack, Discord, Microsoft Teams)\n*   Display Linked Hog Functions for Error Tracking\n*   Filter Hog Functions (currently no filters are applied)\n*   Support for Editing Existing Alerts\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/configuration/ErrorTrackingConfigurationScene.tsx",
        "summary": "This code defines a React scene for configuring error tracking within a larger application, likely PostHog. It utilizes the `kea` library for state management and defines breadcrumbs for navigation. The scene renders an `ErrorTrackingSetupPrompt` component, which likely guides the user through the initial setup of error tracking. Inside the prompt, a `Settings` component is used to manage specific error tracking settings, such as automatic exception capture.\n\nHere's a list of high-level product features:\n\n*   **Error Tracking Configuration:** Allows users to configure error tracking settings.\n*   **Error Tracking Setup Prompt:** Guides users through the initial setup of error tracking.\n*   **Automatic Exception Capture:** Enables automatic capture of exceptions for error tracking.\n*   **Breadcrumbs Navigation:** Provides breadcrumbs for easy navigation within the error tracking configuration section.\n*   **Settings Management:** Manages and persists error tracking settings.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/configuration/symbol-sets/errorTrackingSymbolSetLogic.tsx",
        "summary": "This code defines the logic for managing symbol sets in the error tracking configuration section of the PostHog application. It handles loading, deleting, and uploading symbol sets, which are used to de-obfuscate error stack traces. The logic includes actions, reducers, loaders, selectors, and forms to manage the state and interact with the PostHog API. It also defines breadcrumbs for navigation and provides validation for symbol set uploads.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Symbol Set Management:** Allows users to view a list of existing symbol sets.\n*   **Symbol Set Upload:** Enables users to upload new symbol sets (minified code and source maps).\n*   **Symbol Set Deletion:** Allows users to delete existing symbol sets.\n*   **Symbol Set Validation:** Validates that both minified code and source map files are selected before upload.\n*   **Error Tracking Configuration Navigation:** Provides breadcrumbs for easy navigation within the error tracking configuration section.\n*   **Symbol Set Status Indication:** Differentiates between valid and missing symbol sets.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/configuration/symbol-sets/SymbolSetUploadModal.tsx",
        "summary": "This code defines a modal component, `SymbolSetUploadModal`, for uploading JavaScript symbol sets to aid in error tracking. The modal allows users to upload both a minified JavaScript file and its corresponding source map. It uses drag-and-drop or a file browser for file selection. The upload button is disabled until both files are selected, and a loading state is shown during the upload process.\n\nHere's a list of high-level product features:\n\n*   **Modal Interface:** Provides a modal for uploading symbol sets.\n*   **File Upload:** Allows users to upload minified JavaScript files.\n*   **Source Map Upload:** Enables users to upload corresponding source map files.\n*   **Drag and Drop Support:** Supports drag-and-drop functionality for file selection.\n*   **File Browser Integration:** Integrates with the file browser for file selection.\n*   **Upload Validation:** Validates that both minified JavaScript and source map files are selected before enabling the upload button.\n*   **Loading State:** Displays a loading state during the upload process.\n*   **Cancel Functionality:** Allows users to cancel the upload process.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/configuration/symbol-sets/ErrorTrackingSymbolSets.tsx",
        "summary": "This code defines the `ErrorTrackingSymbolSets` component, which manages and displays symbol sets used for demangling minified code in exception stack traces. It fetches and displays both valid and missing symbol sets, allowing users to upload missing sets or replace existing ones. The component also provides functionality to delete symbol sets and view detailed information about stack frames associated with each set, including their contents and context.\n\nHere's a list of high-level product features:\n\n*   **Display of Valid and Missing Symbol Sets:** Shows a list of symbol sets, differentiating between those that are valid and those that are missing.\n*   **Symbol Set Upload:** Allows users to upload new symbol sets to resolve missing source maps.\n*   **Symbol Set Replacement:** Enables users to replace existing symbol sets with updated versions.\n*   **Symbol Set Deletion:** Provides a way to delete symbol sets that are no longer needed.\n*   **Stack Frame Inspection:** Allows users to view the stack frames associated with a symbol set, including their contents and context.\n*   **Failure Reason Display:** Shows the reason why a symbol set is missing or invalid.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/configuration/symbol-sets",
        "summary": "The provided code collectively implements a comprehensive symbol set management system within an error tracking configuration interface. This system enables users to upload, manage, and utilize symbol sets to de-obfuscate error stack traces, improving the readability and debuggability of error reports. The system includes features for displaying symbol set status, uploading new sets with validation, deleting existing sets, inspecting stack frames, and providing clear navigation within the configuration interface.\n\n*   **Symbol Set Management:** View, upload, replace, and delete symbol sets.\n*   **Symbol Set Upload:** Upload minified JavaScript files and corresponding source maps via drag-and-drop or file browser.\n*   **Symbol Set Validation:** Ensure both minified code and source map files are selected before upload.\n*   **Stack Frame Inspection:** View stack frames associated with a symbol set, including contents and context.\n*   **Status Indication:** Differentiate between valid and missing symbol sets, displaying failure reasons.\n*   **User Interface:** Modal interface for uploading, breadcrumbs for navigation, and loading state during upload.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/configuration",
        "summary": "The error tracking configuration features in PostHog provide a comprehensive suite of tools for managing and monitoring errors within an application. Users can configure alerts for error events, utilizing pre-defined templates for popular communication platforms and leveraging Hog Functions for alert destinations. The system guides users through initial setup, allows for managing error tracking settings like automatic exception capture, and provides breadcrumbs for easy navigation. A robust symbol set management system enables users to upload, manage, and validate symbol sets to de-obfuscate error stack traces, improving the readability and debuggability of error reports.\n\nHere's a list of high-level product features:\n\n*   Error Tracking Alert Configuration: Create, edit, and manage alerts for error tracking events.\n*   Pre-defined Alert Templates: Utilize templates for Slack, Discord, and Microsoft Teams.\n*   Symbol Set Management: Upload, manage, and validate symbol sets for de-obfuscating stack traces.\n*   Error Tracking Setup Prompt: Guide users through the initial setup of error tracking.\n*   Automatic Exception Capture: Enable automatic capture of exceptions for error tracking.\n*   Stack Frame Inspection: View stack frames associated with a symbol set.\n*   Settings Management: Manage and persist error tracking settings.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/errorTrackingLogic.ts",
        "summary": "This code defines the logic for the error tracking feature in PostHog. It manages the state and behavior of the error tracking interface, including date range selection, assignee management, search queries, filtering, and sparkline configuration. It also handles the loading of exception event definitions and provides selectors for deriving sparkline options and configurations.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Date Range Selection:** Allows users to filter errors by a specific date range.\n*   **Assignee Management:** Enables users to assign errors to specific team members.\n*   **Search Functionality:** Provides a search bar to find errors based on keywords.\n*   **Filtering:** Allows users to filter errors based on various criteria.\n*   **Sparkline Visualization:** Displays a sparkline chart showing the trend of errors over time, with configurable periods.\n*   **Test Account Filtering:** Allows users to exclude test accounts from error tracking.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/ErrorTrackingFilters.tsx",
        "summary": "The `ErrorTrackingFilters` component provides a set of filters for narrowing down error tracking data. It includes a date range selector, a universal filter group for filtering by event properties, person properties, cohorts, and HogQL expressions, a search input for free-text search, and a test accounts filter to exclude internal accounts. The universal filter group allows for nested filtering with AND/OR logic.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Date Range Filtering:** Allows users to filter errors by a specific date range.\n*   **Universal Filtering:** Enables filtering errors based on event properties, person properties, cohorts, and HogQL expressions.\n*   **Nested Filter Groups:** Supports creating complex filter logic using nested AND/OR groups.\n*   **Free-Text Search:** Provides a search input to filter errors based on a text query.\n*   **Internal Accounts Filtering:** Allows excluding errors originating from internal test accounts.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/issue/tabs/EventsTab.tsx",
        "summary": "The `EventsTab` component displays a list of events related to an error tracking issue. It leverages the `Query` component to fetch and render these events based on a query defined in `errorTrackingIssueSceneLogic`. The component configures the `Query` component with a specific context, including custom columns (specifically a \"Recording\" button) and disabling the open editor button. It also passes insight properties for potential dashboard integration.\n\nHere's a list of high-level product features:\n\n*   **Display Error Tracking Issue Events:** Shows a list of events associated with a specific error tracking issue.\n*   **Customizable Event Table:** Allows for defining custom columns in the event table, such as a \"Recording\" button to link to session recordings.\n*   **Session Recording Integration:** Provides a direct link to session recordings from the event list.\n*   **Query-Based Event Fetching:** Fetches events based on a query, enabling flexible filtering and sorting.\n*   **Dashboard Integration:** Supports integration with dashboards for visualizing error tracking data.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/ErrorTrackingListOptions.tsx",
        "summary": "The `ErrorTrackingListOptions` component provides a set of controls for filtering, sorting, and managing error tracking issues. It includes bulk actions for selected issues, a status filter, sorting options (by last seen, first seen, occurrences, users, or sessions in ascending or descending order), and an assignee filter. These options allow users to efficiently organize and prioritize error issues within the error tracking scene.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Bulk Actions:** Perform actions on multiple selected error tracking issues.\n*   **Status Filtering:** Filter issues based on their status (all, active, resolved, suppressed).\n*   **Sorting:** Sort issues by last seen, first seen, occurrences, users, or sessions.\n*   **Order Direction:** Sort issues in ascending or descending order.\n*   **Assignee Filtering:** Filter issues by assignee (any user or a specific user).\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/errorTrackingDataNodeLogic.tsx",
        "summary": "This code defines the `errorTrackingDataNodeLogic` Kea logic, which manages the state and actions related to error tracking issues. It connects to a `dataNodeLogic` to fetch and update error tracking data. The logic provides functionality to merge, resolve, suppress, activate, and assign error tracking issues, both individually and in bulk. It also includes optimistic updates to the UI and integrates with the PostHog API to track user actions.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Error Issue Management:** Allows users to view and manage error tracking issues.\n*   **Issue Merging:** Enables users to merge duplicate or related error issues into a single primary issue.\n*   **Issue Status Updates:** Provides functionality to resolve, suppress, and activate error issues.\n*   **Issue Assignment:** Allows users to assign error issues to specific team members.\n*   **Bulk Actions:** Supports performing actions (resolve, suppress, activate, assign) on multiple issues simultaneously.\n*   **Real-time Updates:** Optimistically updates the UI to reflect changes before the API request completes.\n*   **Activity Tracking:** Tracks user actions related to error tracking issues using PostHog."
    },
    {
        "path": "frontend/src/scenes/error-tracking/errorTrackingSceneLogic.ts",
        "summary": "This code defines the logic for the error tracking scene in the PostHog frontend. It manages the state and behavior of the error tracking page, including fetching and displaying error data, filtering, sorting, and persisting user preferences in the URL. It uses kea-router to synchronize the UI state with the URL, allowing for shareable links and bookmarking. The logic connects to the errorTrackingLogic, which likely handles the actual data fetching and processing.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Error List Display:** Displays a list of errors with key metrics like volume, occurrences, sessions, and users.\n*   **Filtering:** Allows users to filter errors by date range, assignee, test accounts, and custom filter groups.\n*   **Status Filtering:** Allows users to filter errors by status (e.g., active, resolved).\n*   **Search:** Enables users to search for specific errors.\n*   **Sorting:** Supports sorting errors by various columns (e.g., last seen, volume) in ascending or descending order.\n*   **Assignee Management:** Allows users to view and filter errors by assignee.\n*   **URL Persistence:** Persists the current filter and sorting settings in the URL, enabling shareable links and bookmarking.\n*   **Issue Selection:** Allows users to select specific issues.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/AssigneeSelect.tsx",
        "summary": "The `AssigneeSelect` component provides a dropdown menu for assigning or unassigning users or user groups to error tracking issues. It allows users to search for assignees, view them in categorized sections (Users and Groups), and select or remove an assignee. The component also handles loading states and empty search results, providing a user-friendly experience.\n\nHere's a list of high-level product features:\n\n*   **Assignee Selection:** Allows users to assign an issue to a specific user or user group.\n*   **Assignee Search:** Enables users to search for users or groups to assign.\n*   **Categorized Assignee Lists:** Displays assignees in sections for Users and Groups.\n*   **Unassign Functionality:** Provides an option to remove the current assignee.\n*   **Loading States:** Shows loading indicators while fetching user and group data.\n*   **Empty State Handling:** Displays appropriate messages when no assignees are found or search yields no results.\n*   **User Group Creation Link:** Provides a direct link to create new user groups if none exist.\n*   **Visual Display of Assignee:** Displays the current assignee with an icon and name.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/issue/tabs/BreakdownsTab.tsx",
        "summary": "The `BreakdownsTab` component in the error tracking section of the application provides a way to analyze error occurrences based on different properties. It displays breakdowns of errors by device, user, and URL, allowing users to investigate patterns and identify potential causes. The component uses segmented buttons to select the property to breakdown by, and dynamically adjusts the layout based on screen size. It fetches and displays data using the `Query` component and the `errorTrackingIssueBreakdownQuery` based on the selected property and filters.\n\nHere's a list of high-level product features:\n\n*   **Error Breakdown by Device:** Allows users to view error occurrences segmented by browser, device type, and operating system.\n*   **Error Breakdown by User:** Enables users to analyze errors based on user ID and IP address.\n*   **Error Breakdown by URL:** Provides insights into error occurrences based on the URL path.\n*   **Dynamic Layout:** Adapts the layout of the breakdowns based on screen size for optimal viewing experience.\n*   **Property Selection:** Uses segmented buttons to allow users to select the property to breakdown by.\n*   **Data Fetching and Display:** Fetches and displays error breakdown data based on selected properties and filters.\n*   **Filtering:** Applies date range and test account filters to the error breakdown data.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/queries.ts",
        "summary": "This code defines several queries related to error tracking in a PostHog application. It includes queries for fetching a list of errors with filtering and sorting options, retrieving details for a specific error issue, fetching events associated with an error issue, and generating a breakdown of error issues based on a specified property. These queries are structured using a node-based system, where each query is represented as a node with specific configurations and data sources.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Error List View:** Display a list of errors with sorting, filtering (by status, assignee, date range, etc.), and search capabilities.\n*   **Error Details View:** Show detailed information about a specific error issue, including its properties and associated events.\n*   **Event Association:** Link error issues to specific events, allowing users to investigate the context in which the error occurred.\n*   **Error Breakdown Analysis:** Provide insights into the distribution of errors based on different properties (e.g., browser, operating system).\n*   **Customizable Error Volume:** Allow users to define custom metrics for error volume.\n*   **Test Account Filtering:** Exclude test accounts from error tracking data.\n*   **Issue Assignment:** Assign issues to specific users.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/ErrorTrackingSetupPrompt.tsx",
        "summary": "The `ErrorTrackingSetupPrompt` component in `ErrorTrackingSetupPrompt.tsx` guides users through setting up error tracking in PostHog. It checks for feature flag access, existing exception events, and autocapture settings before rendering its children. If error tracking is not enabled, it displays a beta access banner. If no exception events have been captured and autocapture is disabled, it prompts the user to enable exception autocapture with a button and provides a link to the documentation. The component uses `ProductIntroduction` to display relevant information and actions.\n\nHere's a list of high-level product features:\n\n*   **Error Tracking Setup Prompt:** Guides users through the error tracking setup process.\n*   **Beta Access Banner:** Displays a banner for users who have not yet been granted access to the error tracking feature.\n*   **Exception Autocapture Enablement:** Prompts users to enable exception autocapture if no exceptions have been captured and autocapture is disabled.\n*   **Documentation Link:** Provides a link to the error tracking documentation.\n*   **Loading State:** Displays a loading spinner while checking for feature flags, existing exception events, and autocapture settings.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/ErrorTrackingScene.tsx",
        "summary": "The `ErrorTrackingScene` component provides a user interface for viewing, filtering, and managing error tracking issues within PostHog. It leverages Lemon UI components, Kea logic, and custom components to display error data, sparklines for volume trends, assignee selection, and configuration options. The scene also includes setup prompts and ingestion status checks to guide users through the error tracking setup process.\n\n**Features:**\n\n*   **Error Issue List:** Displays a list of error tracking issues with details like name, description, status, and timestamps.\n*   **Filtering and Sorting:** Allows users to filter and sort error issues based on various criteria.\n*   **Issue Assignment:** Enables assigning issues to specific users for resolution.\n*   **Issue Details:** Provides a detailed view of individual error issues, accessible via a link.\n*   **Volume Trend Visualization:** Shows a sparkline graph representing the volume of occurrences for each issue over time.\n*   **Configuration Options:** Provides access to error tracking configuration settings.\n*   **Setup and Ingestion Guidance:** Guides users through the error tracking setup process and checks for proper event ingestion.\n*   **Real-time Refresh:** Automatically refreshes the error data.\n*   **Bulk Selection:** Allows users to select multiple issues.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/errorTrackingIssueSceneLogic.ts",
        "summary": "This code defines the logic for displaying and managing a specific error tracking issue in a PostHog application. It fetches issue details from the API, allows updating the issue's status and assignee, and provides data for displaying related events. The logic also manages the display of breadcrumbs and side panel context, and handles redirection in case of issue ID changes. It uses Kea for state management, loaders for asynchronous data fetching, and connects to other logics for shared state like date range and filters.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Error Issue Details View:** Displays detailed information about a specific error tracking issue.\n*   **Issue Status Management:** Allows users to update the status of an error tracking issue (e.g., open, resolved, ignored).\n*   **Issue Assignment:** Enables assigning an error tracking issue to a specific user.\n*   **Related Events Display:** Fetches and displays events related to the error tracking issue.\n*   **Filtering and Date Range:** Supports filtering events by test accounts, groups, and date ranges.\n*   **Breadcrumb Navigation:** Provides breadcrumbs for easy navigation within the error tracking section.\n*   **Side Panel Context:** Provides context for the side panel, allowing for related activities and information.\n*   **Issue Redirection:** Handles redirection to the correct issue ID if it changes.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/utils.ts",
        "summary": "This code provides utility functions for handling error tracking data, specifically focusing on processing and merging error tracking issues and extracting relevant attributes from error exceptions. It includes functions for merging multiple error issues into a single issue, calculating aggregated metrics like occurrences, users, and sessions, and determining the first and last seen times. Additionally, it offers functions to extract exception attributes from event properties, determine if an error is a third-party script error, check for stacktraces and in-app frames, and generate labels for sparkline charts representing error volume over time.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Error Issue Merging:** Combine similar error issues into a single, aggregated issue for easier management.\n*   **Error Aggregation:** Calculate and display aggregated metrics (occurrences, users, sessions) for error issues.\n*   **Exception Attribute Extraction:** Extract key attributes (type, value, library, browser, OS, etc.) from error exceptions for detailed analysis.\n*   **Session Identification:** Identify the session associated with an error event.\n*   **Stacktrace Analysis:** Determine if an error has a stacktrace and if it contains in-app frames.\n*   **Third-Party Error Detection:** Identify errors originating from third-party scripts.\n*   **Sparkline Chart Labels:** Generate labels for sparkline charts to visualize error volume trends over time.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/issue/tabs",
        "summary": "The error tracking feature provides comprehensive tools for analyzing and understanding errors within an application. It displays a list of events associated with a specific error tracking issue, allowing for customizable event tables with features like a \"Recording\" button to link to session recordings. Additionally, it offers error breakdowns by device, user, and URL, enabling users to investigate patterns and identify potential causes. The feature dynamically adjusts the layout based on screen size and allows users to select the property to breakdown by, fetching and displaying error breakdown data based on selected properties and filters.\n\nHere's a list of high-level product features:\n\n*   Display Error Tracking Issue Events\n*   Customizable Event Table\n*   Session Recording Integration\n*   Query-Based Event Fetching\n*   Dashboard Integration\n*   Error Breakdown by Device\n*   Error Breakdown by User\n*   Error Breakdown by URL\n*   Dynamic Layout\n*   Property Selection\n*   Data Fetching and Display\n*   Filtering\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/issue/GenericSelect.tsx",
        "summary": "This code defines a generic select component called `GenericSelect` built using PostHog's Lemon UI library. It's a reusable component that allows users to select a value from a predefined list of options. The component takes in a list of possible values, a currently selected value, a callback function to handle changes, a placeholder text, and a function to render the display value for each option. It maps the provided values to LemonSelect options, using the renderValue function to generate the label for each option.\n\nHere's a list of high-level features:\n\n*   **Generic Data Type Support:** Supports string, number, boolean, and null data types for selectable values.\n*   **Customizable Display:** Allows custom rendering of option labels using a `renderValue` function.\n*   **Controlled Component:** The selected value is managed externally via the `current` prop and `onChange` callback.\n*   **Placeholder Support:** Displays a placeholder text when no value is selected.\n*   **Size Options:** Offers different size options (xsmall, small, medium, large) for the select component.\n*   **Lemon UI Integration:** Built on top of PostHog's Lemon UI library for consistent styling and behavior.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/issue/BulkActions.tsx",
        "summary": "This React component, `BulkActions`, provides a set of actions that can be performed on selected error tracking issues. It allows users to unselect all currently selected issues, merge multiple issues into one, change the status of multiple issues at once (active, resolved, or suppressed), and assign issues to a specific user. If no issues are selected, it provides an option to select all issues. The component uses Lemon UI components for buttons and dialogs, and leverages kea-logic for state management and actions.\n\nHere's a list of the high-level product features implemented by this component:\n\n*   **Issue Selection/Deselection:** Allows users to select and deselect individual or all issues for bulk actions.\n*   **Issue Merging:** Enables merging of multiple selected issues into a single issue.\n*   **Bulk Status Updates:** Facilitates changing the status of multiple issues simultaneously (e.g., resolving, suppressing, or activating).\n*   **Bulk Assignment:** Allows assigning multiple selected issues to a specific user.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/issue/Indicator.tsx",
        "summary": "This code defines React components for displaying status indicators and labels within an error tracking system. It provides a `LabelIndicator` component that combines a LemonBadge (a status indicator) with a text label, and a `StatusIndicator` component that uses `LabelIndicator` to display the status of an error tracking issue (active, archived, resolved, pending release, or suppressed) with corresponding colors, labels, and optional tooltips. The components are configurable in size and appearance.\n\n**Features:**\n\n*   **Status Indicators:** Displays the status of an error tracking issue using a badge and label.\n*   **Multiple Statuses:** Supports \"active\", \"archived\", \"resolved\", \"pending_release\", and \"suppressed\" statuses.\n*   **Customizable Appearance:** Offers different sizes (xsmall, small, medium, large) and intents (colors) for the indicators.\n*   **Tooltips:** Provides optional tooltips to explain the meaning of each status.\n*   **Reusable Components:** Exposes `LabelIndicator` for general-purpose label and badge combinations.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/issue/Metadata.tsx",
        "summary": "The `Metadata` component displays key information about an error tracking issue, including its description, first and last seen timestamps, number of occurrences, sessions, and users affected. It also includes a sparkline chart visualizing the occurrence trend over time. The component handles loading states by displaying skeleton placeholders when data is not yet available. Additionally, it provides a tooltip explaining the absence of session data when applicable.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Issue Description Display:** Shows a brief description of the error issue.\n*   **First and Last Seen Timestamps:** Displays when the error was first and last observed.\n*   **Occurrence Count:** Shows the total number of times the error has occurred.\n*   **Session Count:** Displays the number of sessions affected by the error.\n*   **User Count:** Shows the number of unique users affected by the error.\n*   **Occurrence Sparkline Chart:** Visualizes the trend of error occurrences over time.\n*   **Loading State Handling:** Displays skeleton loaders while data is being fetched.\n*   **Missing Session Data Indication:** Provides a tooltip explaining the absence of session data.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/issue/panels/RecordingPanel.tsx",
        "summary": "This code defines a panel component for displaying a session recording within an error tracking issue view. It leverages the `SessionRecordingPlayer` component to play the recording associated with the issue's session ID. The player is configured to autoplay, hide metadata and borders, disable the inspector, and highlight events matching the name '$exception'. The panel is only displayed if a recording exists for the issue.\n\n**Features:**\n\n*   **Session Recording Playback:** Allows users to view session recordings directly within the error tracking issue view.\n*   **Automatic Playback:** Starts playing the session recording automatically when the panel is opened.\n*   **Exception Highlighting:** Highlights '$exception' events within the session recording for easy identification of error occurrences.\n*   **Conditional Display:** Only shows the recording panel if a session recording exists for the issue.\n*   **Clean UI:** Hides metadata and borders for a cleaner user interface.\n*   **Inspector Disabled:** Disables the inspector tool within the session recording player.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/issue/Events.tsx",
        "summary": "This code defines a React component called `Stacktrace` that displays stack traces associated with an error tracking issue. It utilizes the `kea` library for state management and imports components from other modules, including `ChainedStackTraces` for rendering the stack traces and `stackFrameLogic` for controlling the display of stack frames. The component retrieves issue properties and determines whether to show all stack frames based on the presence of in-app frames. It also defines types for error tracking issue events and panels, outlining the structure for displaying different types of event content related to an error issue, such as stack traces and recordings.\n\nHere's a list of high-level product features:\n\n*   **Stack Trace Display:** Renders and displays stack traces associated with error tracking issues.\n*   **In-App Frame Detection:** Detects and highlights in-app frames within the stack trace.\n*   **Stack Frame Control:** Allows users to control the display of stack frames (e.g., showing all frames or only relevant ones).\n*   **Error Event Panel Definition:** Defines a structure for displaying different types of event content related to an error issue, such as stack traces and recordings.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/issue/panels/StacktracePanel.tsx",
        "summary": "The `StacktracePanel.tsx` file defines a component for displaying stack trace information within an error tracking issue. It leverages Lemon UI components and Kea logic for state management. The panel conditionally renders either a chained stack trace view, a banner explaining third-party script errors, or nothing, depending on the presence of stack traces and the origin of the error. It also includes a segmented button to toggle between showing only in-app frames or the full stack trace, if applicable.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Stack Trace Display:** Shows the stack trace of an error, allowing developers to understand the sequence of function calls that led to the error.\n*   **In-App vs. Full Stack Trace Filtering:** Allows users to filter the stack trace to show only in-app frames, reducing noise from third-party libraries.\n*   **Third-Party Script Error Handling:** Provides a specific message and link to documentation for errors originating from third-party scripts.\n*   **Conditional Rendering:** Dynamically renders different content based on the availability of stack traces and the origin of the error.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/issue/panels",
        "summary": "The code provides two panels within an error tracking issue view: one for displaying session recordings and another for displaying stack trace information. The session recording panel allows users to view recordings, automatically plays them, highlights exception events, and offers a clean UI by hiding metadata and disabling the inspector. The stack trace panel displays the stack trace, allows filtering to show only in-app frames, handles third-party script errors with specific messaging, and conditionally renders content based on the error's origin and available data.\n\n**Features:**\n\n*   Session Recording Playback with Autoplay and Exception Highlighting\n*   Stack Trace Display with In-App Frame Filtering\n*   Third-Party Script Error Handling\n*   Conditional Rendering of Error Information\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/issue/Overview.tsx",
        "summary": "The `Overview` component in the error tracking issue scene displays key properties of an error issue in a grid format. It fetches issue properties and a loading state from the `errorTrackingIssueSceneLogic` using the `useValues` hook. While loading, it shows a skeleton UI. Once loaded, it displays attributes like level, synthetic, library, unhandled status, browser, OS, and URL in a two-column grid, filtering out undefined values.\n\nHere's a list of high-level product features:\n\n*   **Display Issue Properties:** Shows key attributes of an error issue, such as level, synthetic, library, unhandled status, browser, OS, and URL.\n*   **Loading State:** Displays a skeleton UI while issue properties are being fetched.\n*   **Attribute Filtering:** Hides attributes with undefined values.\n*   **Grid Layout:** Presents issue properties in a structured two-column grid.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/issue/widgets/DetailsWidget.tsx",
        "summary": "The `DetailsWidget` component is a LemonWidget in the PostHog frontend that displays detailed information about an error tracking issue. It fetches issue properties and a session ID using the `errorTrackingIssueSceneLogic`. The widget's primary function is to provide an overview of the issue and includes a \"View Recording\" button that, when clicked, allows users to view a recording associated with the issue, if available. The button is disabled if no session ID is found.\n\nHere's a list of high-level product features:\n\n*   **Issue Details Display:** Shows detailed information and properties related to a specific error tracking issue.\n*   **Session Recording Integration:** Provides a button to view session recordings associated with the error, enabling visual debugging.\n*   **Recording Availability Indicator:** Disables the \"View Recording\" button and provides a reason if no recording is available for the issue.\n*   **Overview Section:** Displays an overview of the error within the details widget.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/issue/widgets/StacktraceWidget.tsx",
        "summary": "The `StacktraceWidget` component displays stacktrace information for error tracking issues within PostHog. It fetches issue properties and loading state from the `errorTrackingIssueSceneLogic`. The component conditionally renders the stacktrace, an empty message if no stacktrace is available, or a loading skeleton while data is being fetched. It provides actions to reverse the frame order (displaying either the first or last call first) and to filter the stacktrace to show only \"in-app\" frames or the full stacktrace. The `ChainedStackTraces` component is used to display the actual stacktrace information.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Stacktrace Display:** Shows the stacktrace associated with an error tracking issue.\n*   **Frame Order Reversal:** Allows users to reverse the order of frames in the stacktrace, showing either the first or last call first.\n*   **In-App Frame Filtering:** Enables users to filter the stacktrace to display only frames that are considered \"in-app\".\n*   **Loading State:** Displays a loading skeleton while the stacktrace data is being fetched.\n*   **Empty State:** Shows a helpful message when no stacktrace is available for an issue, guiding the user to check documentation.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/issue/widgets",
        "summary": "The error tracking issue view in PostHog provides detailed insights into errors, aiding in debugging and resolution. The stacktrace widget displays and manipulates stacktrace information, allowing users to reverse frame order and filter to in-app frames, while the details widget presents an overview of the issue and integrates with session recordings for visual debugging.\n\n*   Stacktrace Display: Shows the stacktrace associated with an error tracking issue.\n*   Frame Order Reversal: Allows users to reverse the order of frames in the stacktrace.\n*   In-App Frame Filtering: Enables users to filter the stacktrace to display only frames that are considered \"in-app\".\n*   Issue Details Display: Shows detailed information and properties related to a specific error tracking issue.\n*   Session Recording Integration: Provides a button to view session recordings associated with the error.\n*   Recording Availability Indicator: Disables the \"View Recording\" button if no recording is available.\n*   Loading and Empty States: Displays appropriate messages and skeletons while data is loading or unavailable.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/issue",
        "summary": "The error tracking feature provides a comprehensive suite of tools for diagnosing and resolving application errors. It offers detailed views of individual issues, including metadata, stack traces, session recordings, and occurrence trends. Users can perform bulk actions on issues, customize the display of events, and filter stack traces to focus on in-app frames. The system also provides error breakdowns by device, user, and URL, enabling users to identify patterns and potential causes.\n\nHere's a list of high-level product features:\n\n*   Error Tracking Issue Display: Displays detailed information about individual error tracking issues.\n*   Stack Trace Analysis: Renders, filters, and manipulates stack traces.\n*   Session Recording Integration: Links error issues to session recordings for visual debugging.\n*   Bulk Actions: Enables users to perform actions on multiple issues simultaneously.\n*   Customizable Event Table: Allows users to customize the display of events associated with an issue.\n*   Error Breakdown: Provides error breakdowns by device, user, and URL.\n*   Status Indicators: Displays the status of an error tracking issue with customizable indicators.\n*   Issue Property Display: Shows key attributes of an error issue in a structured format.\n*   Generic Select Component: Provides a reusable select component for choosing from a list of options.\n*   Loading State Handling: Displays skeleton loaders while data is being fetched.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/AssigneeDisplay.tsx",
        "summary": "The `AssigneeDisplay` component is a React component that takes an `assignee` object (likely representing an assignee for an error tracking issue) and a render prop function as input. It uses the `assigneeSelectLogic` to compute a `displayAssignee` object based on the provided `assignee`. The component then renders the children function, passing the `displayAssignee` object as a prop, allowing the child component to display assignee information in a customized way.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Assignee Display:** Enables displaying information about who is assigned to an error tracking issue.\n*   **Customizable Assignee Rendering:** Allows for flexible rendering of assignee information through a render prop pattern.\n*   **Assignee Computation Logic:** Uses a dedicated logic (`assigneeSelectLogic`) to compute the assignee information for display.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking/errorTrackingActivityDescriber.tsx",
        "summary": "This code defines a function `errorTrackingActivityDescriber` that generates human-readable descriptions of changes made to error tracking issues within a PostHog application. It leverages an `ActivityLogItem` to determine the scope and details of the activity, then uses a mapping (`errorTrackingIssueActionsMapping`) to handle specific field changes like assignee and status. The function constructs sentences describing these changes, including links to the affected issue and displaying assignee information. If the activity is an update or assignment, it iterates through the changes, generating descriptions for each relevant field. Otherwise, it falls back to a default description.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Activity Logging for Error Tracking Issues:** Provides a detailed history of changes made to error tracking issues.\n*   **Human-Readable Activity Descriptions:** Translates technical activity logs into easy-to-understand sentences.\n*   **Issue Assignment Tracking:** Records and describes changes to issue assignees, including who assigned the issue to whom.\n*   **Status Change Tracking:** Logs and describes changes to the status of error tracking issues.\n*   **User Attribution:** Identifies the user responsible for each change in the activity log.\n*   **Issue Linking:** Provides direct links from activity log entries to the corresponding error tracking issue.\n*   **Assignee Display:** Shows the assignee's name and icon in the activity log.\n"
    },
    {
        "path": "frontend/src/scenes/error-tracking",
        "summary": "The provided code snippets collectively define a comprehensive error tracking system within PostHog, enabling users to effectively monitor, diagnose, and resolve application errors. The system offers features for visualizing error trends, managing individual issues, assigning ownership, configuring alerts, and analyzing stack traces. It also includes tools for filtering, sorting, and searching errors, as well as integrating with other PostHog features like session recordings and activity logs. The system guides users through the initial setup process and provides a user-friendly interface for managing error tracking settings.\n\nHere's a list of high-level product features:\n\n*   **Error List View:** Display a list of errors with sorting, filtering (by status, assignee, date range, etc.), and search capabilities.\n*   **Error Details View:** Show detailed information about a specific error issue, including its properties and associated events.\n*   **Error Occurrence Visualization:** Displays a sparkline chart representing the number of error occurrences over a specified time period.\n*   **Issue Assignment:** Allows assigning the issue to a specific user or user group.\n*   **Issue Status Management:** Enables changing the status of an issue (e.g., active, resolved, suppressed).\n*   **Error Tracking Alert Configuration:** Create, edit, and manage alerts for error tracking events.\n*   **Stacktrace Analysis:** Displays and allows analysis of the error's stacktrace.\n*   **Session Recording Integration:** Links error issues to session recordings for visual debugging.\n*   **Bulk Actions:** Perform actions on multiple selected error tracking issues.\n*   **Error Breakdown Analysis:** Provide insights into the distribution of errors based on different properties (e.g., browser, operating system).\n*   **Activity Logging for Error Tracking Issues:** Provides a detailed history of changes made to error tracking issues.\n*   **Error Tracking Setup Prompt:** Guides users through the initial setup of error tracking.\n*   **Symbol Set Management:** Upload, manage, and validate symbol sets for de-obfuscating stack traces.\n*   **URL Persistence:** Persists the current filter and sorting settings in the URL, enabling shareable links and bookmarking.\n"
    },
    {
        "path": "frontend/src/scenes/toolbar-launch/ToolbarLaunch.tsx",
        "summary": "This code defines the `ToolbarLaunch` component, a page within the PostHog application that serves as a central hub for launching the PostHog toolbar directly within a user's application or website. It displays a list of authorized URLs for launching the toolbar, allowing users to add and manage these URLs. The page also highlights key features accessible through the toolbar, such as Heatmaps, Actions, Feature Flags, Inspect, Web Vitals, and Experiments (if the `WEB_EXPERIMENTS` feature flag is enabled). The component encourages users to use the latest `posthog-js` version or the HTML snippet for optimal performance.\n\nHere's a list of the high-level product features highlighted by this component:\n\n*   **Authorized URL Management:** Allows users to add and manage URLs authorized to launch the PostHog toolbar.\n*   **Heatmaps:** Provides insights into user interaction hotspots on a website.\n*   **Actions:** Enables visual creation of actions based on website elements.\n*   **Feature Flags:** Allows toggling feature flags directly within the application.\n*   **Inspect:** Facilitates inspection of clickable elements on a website.\n*   **Web Vitals:** Measures and displays website performance metrics.\n*   **Experiments (A/B Testing):** Enables running experiments and A/B tests on a website (controlled by a feature flag).\n"
    },
    {
        "path": "frontend/src/scenes/toolbar-launch",
        "summary": "The `ToolbarLaunch` component in PostHog serves as a central launchpad for the PostHog toolbar, enabling users to seamlessly integrate and utilize PostHog's features within their own applications or websites. It provides a user-friendly interface for managing authorized URLs, ensuring that the toolbar can only be launched on designated domains. The component also showcases the key functionalities accessible through the toolbar, encouraging users to leverage PostHog's capabilities for enhanced product insights and optimization.\n\nHere's a list of the high-level product features highlighted by this component:\n\n*   Authorized URL Management\n*   Heatmaps\n*   Actions\n*   Feature Flags\n*   Inspect\n*   Web Vitals\n*   Experiments (A/B Testing)\n"
    },
    {
        "path": "frontend/src/scenes/trends/mathsLogic.tsx",
        "summary": "This code defines the logic and data structures for handling different mathematical operations and aggregations used in PostHog insights, particularly within the Trends feature. It categorizes these operations (Event Count, Session Count, Actor Count, Property Value, HogQL Expression, Event Count per Actor) and provides detailed definitions for each, including their name, short name, description, and category. The code also includes functions for serializing and deserializing math selector values, facilitating the interaction between the frontend and the API.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Event Counting:** Allows users to count the total number of events, unique users, weekly/monthly active users, and unique sessions.\n*   **Funnel Analysis:** Supports funnel analysis by allowing users to define how events are counted towards funnel steps (e.g., any event match, first time for user).\n*   **Property Value Aggregation:** Enables users to calculate the average, sum, minimum, maximum, median, and various percentiles of event properties.\n*   **HogQL Expressions:** Provides the ability to use custom SQL expressions for advanced data aggregation.\n*   **Event Count per Actor Aggregation:** Supports calculating the average, minimum, maximum, median, and various percentiles of event counts per actor.\n*   **Group Analytics:** Provides support for group analytics, allowing users to aggregate data based on groups of users.\n*   **Customizable Metrics:** Offers a wide range of pre-defined metrics and allows users to define custom metrics using HogQL.\n*   **Insight Customization:** Enables users to customize insights by selecting different mathematical operations and aggregations.\n"
    },
    {
        "path": "frontend/src/scenes/trends/types.ts",
        "summary": "This code defines the data structures used for representing trend analysis results in the frontend. It includes interfaces for the overall trend response, individual trend results with indexing and color information, and the actors (users or entities) associated with specific data points in the trend. These interfaces are used to manage and display trend data, including sorting, filtering, and pagination of results, as well as associating actors with specific data points for deeper analysis.\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **Trend Analysis:** Visualizing trends in data over time.\n*   **Data Filtering:** Applying filters to trend data.\n*   **Pagination:** Loading trend data in chunks.\n*   **Data Indexing:** Indexing and sorting trend results for visualization.\n*   **Actor Identification:** Identifying actors associated with trend data points.\n*   **Data Breakdown:** Breaking down trend data by specific values.\n*   **Funnel Analysis:** Analyzing trends within funnels.\n*   **Path Analysis:** Analyzing user paths and drop-off points.\n*   **Cross-Dataset Comparison:** Comparing trends across different datasets.\n"
    },
    {
        "path": "frontend/src/scenes/trends/persons-modal/persons-modal-utils.tsx",
        "summary": "This code provides utility functions for generating titles and cleaning query options specifically for a \"Persons Modal\" within a trends analysis feature. It focuses on displaying information about user behavior within funnels and paths, including completion and drop-off rates at different steps. The code also adjusts series names in query options for better readability.\n\nHere's a list of high-level product features supported by this code:\n\n*   **Funnel Analysis Visualization:** Displaying titles for funnel steps, indicating completion or drop-off rates.\n*   **Path Analysis Visualization:** Displaying titles for path steps, indicating completion, drop-off, or continuation.\n*   **Dynamic Title Generation:** Generating titles that include step numbers, event labels, and breakdown values.\n*   **Query Option Cleaning and Formatting:** Cleaning and formatting query options for the Persons Modal, including adjusting series names for clarity.\n*   **Property Key Information Display:** Displaying information about properties associated with events in the funnel or path.\n"
    },
    {
        "path": "frontend/src/scenes/trends/persons-modal/SaveCohortModal.tsx",
        "summary": "This code defines a modal component, `SaveCohortModal`, used for creating and saving cohorts. It includes a text input field for the user to enter a cohort title and save and cancel buttons. The save button is disabled until a title is entered. Upon saving, the entered title is passed to the `onSave` prop function, and the input field is cleared.\n\nHere's a list of high-level product features:\n\n*   **Modal Display:** Presents a modal window for cohort creation.\n*   **Cohort Title Input:** Allows users to input a title for the new cohort.\n*   **Save Action:** Saves the cohort with the provided title.\n*   **Cancel Action:** Cancels the cohort creation process.\n*   **Input Validation:** Disables the save button until a cohort title is provided.\n"
    },
    {
        "path": "frontend/src/scenes/trends/persons-modal/personsModalLogic.ts",
        "summary": "This code defines a Kea logic module named `personsModalLogic` that manages the state and behavior of a modal displaying a list of actors (persons or groups) related to insights, funnels, or correlations. It handles loading actors from an API, searching, pagination, and saving the actor list as a cohort. The logic also supports fetching additional data for each actor and allows for customization of the displayed data through query parameters.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Displaying a list of actors:** Shows a modal with a list of persons or groups related to a specific analysis.\n*   **Loading actors from API:** Fetches actor data from the backend based on a provided URL or query.\n*   **Searching actors:** Allows users to search for specific actors within the modal.\n*   **Pagination:** Implements pagination for large lists of actors.\n*   **Saving as cohort:** Enables users to save the current list of actors as a static cohort.\n*   **Customizable actor data:** Supports fetching and displaying additional data fields for each actor.\n*   **Error handling:** Displays error messages if loading actors fails.\n*   **Integration with Insights:** Allows users to explore the data in the actor list further in the Insights tool.\n*   **Group Support:** Handles both person and group actors, displaying appropriate labels and properties.\n"
    },
    {
        "path": "frontend/src/scenes/trends/persons-modal/PersonsModal.tsx",
        "summary": "This code defines a `PersonsModal` component in a React application, likely for a product analytics platform. The modal displays a list of actors (persons or groups) related to a specific data point in an insight or trend. It allows users to search, filter, and explore these actors, as well as export them as a CSV or save them as a cohort. The modal also handles errors and loading states, providing a user-friendly experience.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Actor List Display:** Displays a list of persons or groups (actors) related to a specific data point.\n*   **Actor Search:** Allows users to search for actors by email, name, or ID.\n*   **Actor Filtering:** Enables filtering of actors based on query parameters and breakdowns.\n*   **Data Export:** Provides the ability to export the list of actors as a CSV file.\n*   **Cohort Creation:** Allows users to save the list of actors as a cohort for further analysis.\n*   **Event Exploration:** Provides a link to view events related to the selected actors.\n*   **Insight Exploration:** Offers a link to explore the data point in a new insight.\n*   **Properties Timeline:** Displays a timeline of property changes for a selected actor (if person_on_events_querying_enabled).\n*   **Error Handling:** Displays error messages and validation errors related to the data being displayed.\n*   **Loading State:** Shows a loading indicator while fetching actor data.\n"
    },
    {
        "path": "frontend/src/scenes/trends/persons-modal",
        "summary": "The provided code collectively implements a comprehensive \"Persons Modal\" feature within a product analytics platform, designed to provide users with detailed insights into the actors (persons or groups) behind trends, funnels, and paths. This modal allows users to explore, filter, and analyze these actors, offering functionalities such as searching, pagination, and the ability to export data or save actors as cohorts. The system also supports dynamic title generation, error handling, and loading states to ensure a user-friendly experience.\n\nHere's a list of high-level product features:\n\n*   **Actor List Display:** Shows a list of persons or groups related to a specific analysis.\n*   **Actor Search and Filtering:** Enables users to search and filter actors by various criteria.\n*   **Data Export:** Allows exporting the list of actors as a CSV file.\n*   **Cohort Creation:** Enables saving the list of actors as a static cohort.\n*   **Pagination:** Implements pagination for large lists of actors.\n*   **Dynamic Title Generation:** Generates titles that include step numbers, event labels, and breakdown values.\n*   **Error Handling and Loading States:** Provides error messages and loading indicators for a smooth user experience.\n*   **Funnel and Path Analysis Visualization:** Displays titles for funnel and path steps, indicating completion or drop-off rates.\n*   **Customizable Actor Data:** Supports fetching and displaying additional data fields for each actor.\n"
    },
    {
        "path": "frontend/src/scenes/trends/viz/index.ts",
        "summary": "The code exports three React components related to visualizing trends: `ActionsHorizontalBar`, `ActionsLineGraph`, and `ActionsPie`. These components likely provide different ways to represent data related to user actions or events, using horizontal bar charts, line graphs, and pie charts respectively.\n\nHere's a list of high-level product features based on this code:\n\n*   **Horizontal Bar Chart Visualization:** Display trends using horizontal bar charts.\n*   **Line Graph Visualization:** Display trends using line graphs.\n*   **Pie Chart Visualization:** Display trends using pie charts.\n"
    },
    {
        "path": "frontend/src/scenes/trends/viz/datasetToActorsQuery.ts",
        "summary": "This code defines a function `datasetToActorsQuery` that transforms a `GraphDataset` object into an `InsightActorsQuery` object. It extracts relevant properties from the dataset, such as breakdown values, compare labels, status, and action order, and maps them to the corresponding fields in the `InsightActorsQuery` schema. The function also handles cases where breakdown values or compare labels are arrays, selecting the appropriate element based on the provided index. Finally, it sets the `includeRecordings` flag to true.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Data Transformation:** Converts graph datasets into a query format suitable for fetching actor-related insights.\n*   **Breakdown Support:** Extracts and includes breakdown values from the dataset for more granular analysis.\n*   **Comparison Support:** Extracts and includes comparison labels from the dataset for comparing different data segments.\n*   **Status Tracking:** Preserves the status of the dataset in the generated query.\n*   **Action Ordering:** Includes action order information from the dataset.\n*   **Recording Inclusion:** Enables the inclusion of recordings related to the actors.\n"
    },
    {
        "path": "frontend/src/scenes/trends/viz/ActionsHorizontalBar.tsx",
        "summary": "The `ActionsHorizontalBar` component visualizes trends data as a horizontal bar graph. It fetches and processes data from various sources, including insights, cohorts, and property definitions, to create a dataset suitable for the `LineGraph` component. The component handles displaying aggregated values for different actions, formatting labels, and opening a persons modal to show detailed information about the data points when clicked. It also supports custom click handlers and displays an empty state when no data is available.\n\nHere's a list of high-level product features implemented by the code:\n\n*   **Horizontal Bar Graph Visualization:** Displays trends data as a horizontal bar graph.\n*   **Data Aggregation and Formatting:** Fetches, aggregates, and formats data from various sources for visualization.\n*   **Interactive Data Points:** Allows users to click on data points to view detailed information in a modal.\n*   **Custom Click Handling:** Supports custom click handlers for data points.\n*   **Empty State Display:** Shows an empty state when no data is available.\n*   **Label Formatting:** Formats labels for the graph based on breakdown filters and property definitions.\n*   **Color Coding:** Applies color coding to the bars in the graph based on trends data.\n*   **Tooltip Display:** Displays tooltips on hover with relevant information.\n"
    },
    {
        "path": "frontend/src/scenes/trends/viz/ActionsLineGraph.tsx",
        "summary": "The `ActionsLineGraph` component visualizes trends data as a line or bar graph, handling various display types like line, bar, and area graphs, and supporting features like stickiness and lifecycle views. It fetches data and configurations from multiple logics, including `trendsDataLogic` and `insightAlertsLogic`, and renders the graph using the `LineGraph` component. The component also handles empty state displays, legend customization, and user interactions such as clicking on data points to open a modal showing relevant persons.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Data Visualization:** Displays trends data as a line or bar graph.\n*   **Multiple Chart Types:** Supports line, bar, and area graph display types.\n*   **Stickiness and Lifecycle Views:** Handles specific data views for stickiness and lifecycle insights.\n*   **Empty State Handling:** Shows a user-friendly message when there is no data to display.\n*   **Customizable Legends:** Allows customization of the graph legend, especially for lifecycle views.\n*   **Data Point Interaction:** Enables users to click on data points to view associated persons in a modal.\n*   **Alert Threshold Visualization:** Displays alert threshold lines on the graph.\n*   **Goal Line Visualization:** Displays goal lines on the graph.\n*   **Percent Stack View:** Supports displaying data as a percentage stack.\n*   **Multiple Y-Axes:** Supports displaying data with multiple Y-axes.\n"
    },
    {
        "path": "frontend/src/scenes/trends/viz/ActionsPie.tsx",
        "summary": "The `ActionsPie` component visualizes trends data as a pie chart, allowing users to understand the distribution of different actions or events. It fetches and formats data from various sources, including cohorts and property definitions, and handles user interactions such as clicking on pie slices to view related persons or data points. The component supports customization options like showing values and labels on the series, displaying data in percent stack view, and disabling hover offset. It also displays an aggregated value representing the total count of the displayed actions.\n\nHere's a list of high-level product features:\n\n*   **Pie Chart Visualization:** Displays trends data as a pie chart for easy comparison of different actions or events.\n*   **Data Fetching and Formatting:** Fetches data from various sources, including cohorts and property definitions, and formats it for display in the pie chart.\n*   **User Interaction:** Allows users to click on pie slices to view related persons or data points in a modal.\n*   **Customization Options:** Supports customization options like showing values and labels on the series, displaying data in percent stack view, and disabling hover offset.\n*   **Aggregation Display:** Displays an aggregated value representing the total count of the displayed actions.\n*   **Data Warehouse Series Support:** Handles data from data warehouses, disabling click interactions for these series.\n*   **Empty State Handling:** Displays a message when no matching actions are found.\n"
    },
    {
        "path": "frontend/src/scenes/trends/viz",
        "summary": "The provided code implements a suite of data visualization tools for analyzing trends, primarily focusing on user actions and events. These tools offer a variety of chart types, including line graphs, bar charts (horizontal and vertical), and pie charts, each designed to highlight different aspects of the data. The components support interactive elements like clickable data points for detailed information, customizable legends and labels, and the ability to handle various data sources and formats. Furthermore, the system includes features for data transformation, aggregation, and empty state handling to ensure a user-friendly experience even when data is limited.\n\nHere's a list of high-level product features:\n\n*   Data Visualization: Offers multiple chart types (line, bar, pie) to visualize trends data.\n*   Interactive Data Points: Enables users to click on data points to view detailed information.\n*   Customizable Charts: Provides options for customizing legends, labels, and display settings.\n*   Data Aggregation and Formatting: Fetches, aggregates, and formats data from various sources.\n*   Data Transformation: Converts graph datasets into query formats for fetching actor-related insights.\n*   Empty State Handling: Displays user-friendly messages when no data is available.\n*   Breakdown and Comparison Support: Allows for granular analysis and comparison of data segments.\n*   Alert and Goal Line Visualization: Displays alert threshold and goal lines on graphs.\n*   Percent Stack View: Supports displaying data as a percentage stack.\n*   Multiple Y-Axes: Supports displaying data with multiple Y-axes.\n"
    },
    {
        "path": "frontend/src/scenes/trends/Trends.tsx",
        "summary": "The `TrendInsight` component is a React component that renders different visualizations for trend insights based on the `display` type. It utilizes kea-logic for state management and data fetching. The component supports various chart types including line graphs, bold numbers, tables, pie charts, horizontal bar charts, and world maps. It also handles breakdown limits and provides a button to increase the limit. The component adapts its rendering based on whether it's embedded in a card or displayed as a main insight view, and whether it's in shared mode.\n\nHere's a list of high-level product features implemented by the code:\n\n*   **Trend Visualization:** Renders various chart types (line graph, bold number, table, pie chart, horizontal bar, world map) to visualize trends data.\n*   **Breakdown Analysis:** Supports breakdown filtering and limiting, with an option to increase the breakdown limit.\n*   **Contextual Rendering:** Adapts rendering based on context (embedded, shared mode, edit mode).\n*   **Data Fetching and State Management:** Uses kea-logic for data fetching and state management related to trends data and insight properties.\n*   **User Interaction:** Provides a button to increase the breakdown limit, enhancing user control over data analysis.\n*   **Person Modal Integration:** Integrates with a person modal to show details about users related to the data points.\n"
    },
    {
        "path": "frontend/src/scenes/trends/trendsDataLogic.ts",
        "summary": "This code defines the `trendsDataLogic` Kea logic, which manages the data and state for trend insights in the PostHog frontend. It connects to `insightVizDataLogic` to inherit and extend its functionality, providing selectors and reducers for managing trend-specific data like results, breakdown values, and display options. The logic handles loading more breakdown values, toggling hidden legend indexes, and indexing results for chart display. It also determines the appropriate label group type, calculates the incompleteness offset, and provides options for pie chart visualizations. Additionally, it manages the visibility of legend items and provides functions for retrieving color tokens and colors for trend results based on the current theme and result customizations.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Trend Insights:** Visualizing trends in data over time.\n*   **Breakdown Analysis:** Breaking down trends by different properties or categories.\n*   **Legend Management:** Hiding and showing specific series in the trend chart.\n*   **Chart Display Options:** Customizing the chart type (e.g., line, bar, pie) and display settings.\n*   **Lifecycle Analysis:** Analyzing user behavior across different lifecycle stages.\n*   **Data Aggregation:** Grouping data based on aggregation types (e.g., people).\n*   **Color Customization:** Customizing the colors of trend lines based on result customizations.\n*   **Alert Series:** Ability to set alerts on specific series within the trend insight.\n*   **Loading State Management:** Displaying loading indicators while fetching data.\n*   **Fractional Number Handling:** Correctly displaying data points that may contain fractional numbers.\n"
    },
    {
        "path": "frontend/src/scenes/trends",
        "summary": "The provided code collectively implements a comprehensive trend analysis feature within a product analytics platform. This feature allows users to visualize and analyze trends in their data over time, offering a variety of chart types, interactive data points, and customizable display settings. Users can break down trends by different properties or categories, manage the visibility of specific series, and drill down into the actors (users or entities) behind the data. The platform also supports advanced features such as funnel analysis, path analysis, cohort creation, and custom metrics using HogQL expressions.\n\nHere's a list of high-level product features:\n\n*   Trend Visualization: Offers multiple chart types (line, bar, pie, world map) to visualize trends data.\n*   Breakdown Analysis: Supports breakdown filtering and limiting, with an option to increase the breakdown limit.\n*   Actor Analysis: Provides detailed insights into the actors (persons or groups) behind trends, funnels, and paths.\n*   Data Aggregation and Formatting: Fetches, aggregates, and formats data from various sources.\n*   Customizable Metrics: Offers a wide range of pre-defined metrics and allows users to define custom metrics using HogQL.\n*   Interactive Data Points: Enables users to click on data points to view detailed information.\n*   Cohort Creation: Enables saving the list of actors as a static cohort.\n*   Funnel and Path Analysis: Analyzing trends within funnels and user paths.\n*   Data Export: Allows exporting the list of actors as a CSV file.\n*   Alerts and Goals: Ability to set alerts on specific series within the trend insight and visualize goal lines.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/filters/DurationTypeSelect.tsx",
        "summary": "The `DurationTypeSelect` component provides a dropdown menu for selecting the type of duration to filter session recordings by. It allows users to choose between \"total duration\", \"active duration\", and \"inactive duration\". When a user selects an option, the component triggers an `onChange` event, updating the filter and also capturing an analytics event to PostHog. The component uses LemonSelect for the dropdown and defaults to \"total duration\" if no value is provided.\n\nHere's a list of high-level features:\n\n*   **Duration Type Selection:** Allows users to filter session recordings based on different duration types.\n*   **Total Duration Filter:** Filters recordings by the total length of the session.\n*   **Active Duration Filter:** Filters recordings by the amount of time the user was actively engaged.\n*   **Inactive Duration Filter:** Filters recordings by the amount of time the user was inactive.\n*   **Analytics Tracking:** Tracks user interactions with the duration type filter using PostHog.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/filters/ReplayTaxonomicFilters.tsx",
        "summary": "The `ReplayTaxonomicFilters` component provides a user interface for filtering session recordings based on replay properties, log entry properties, and person properties. It displays a list of predefined replay and log entry properties as buttons, which, when clicked, trigger a filter change. Additionally, it allows users to pin and unpin person properties for quick filtering, providing a customizable list of frequently used person properties. The component utilizes `TaxonomicFilter` to enable users to add new person properties to the pinned list.\n\nHere's a list of high-level product features:\n\n*   **Predefined Replay and Log Entry Property Filters:** Allows users to quickly filter session recordings based on predefined properties like visited page, snapshot source, log level, and log message.\n*   **Customizable Pinned Person Property Filters:** Enables users to pin frequently used person properties for quick access and filtering.\n*   **Pin/Unpin Person Properties:** Provides the ability to add or remove person properties from the pinned list.\n*   **Add New Person Properties:** Allows users to add new person properties to the pinned list using a taxonomic filter.\n*   **Filter Change Callback:** Notifies the parent component when a filter is selected, providing the selected value and property type.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/filters/DurationFilter.tsx",
        "summary": "This code defines a React component, `DurationFilter`, which allows users to filter session recordings based on their duration. It provides a user interface for selecting a duration operator (greater than or less than), specifying a duration value using a duration picker, and choosing the type of duration to filter on (total duration, active seconds, or inactive seconds). The component displays the currently selected filter criteria in a human-readable format within a button, and a popover appears when the button is clicked, revealing the filter configuration options.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Session Recording Duration Filtering:** Allows users to filter session recordings based on their duration.\n*   **Duration Operator Selection:** Enables users to choose whether to filter for recordings with durations greater than or less than a specified value.\n*   **Duration Value Input:** Provides a duration picker component for users to easily specify the desired duration value.\n*   **Duration Type Selection:** Allows users to filter based on total duration, active seconds, or inactive seconds.\n*   **Human-Readable Filter Display:** Displays the currently selected filter criteria in a clear and understandable format.\n*   **Interactive Filter Configuration:** Provides a popover interface for configuring the duration filter options.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/filters/RecordingsUniversalFilters.tsx",
        "summary": "This React component, `RecordingsUniversalFilters`, provides a comprehensive filtering interface for session recordings. It allows users to narrow down recordings based on various criteria such as date range, duration, user behavior (events, actions, cohorts), session properties, and even custom HogQL expressions or feature flags. The component integrates with PostHog's Max tool for AI-powered search, offers options to hide viewed recordings, and allows users to customize the timestamp format displayed in the playlist. The filters are presented in an expandable panel with options to reset, and the component utilizes Lemon UI components for a consistent user experience.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Advanced Filtering:** Filter recordings by date, duration, events, actions, cohorts, session properties, HogQL expressions, and feature flags.\n*   **AI-Powered Search:** Use PostHog's Max tool to search recordings using natural language queries.\n*   **Hide Viewed Recordings:** Option to hide recordings already viewed by the current or any user.\n*   **Customizable Timestamp Format:** Choose between UTC, Device, or Relative timestamp formats for the playlist.\n*   **Test Account Filtering:** Filter out recordings from test accounts.\n*   **Filter Grouping with AND/OR Logic:** Combine filters using AND/OR logic for more precise targeting.\n*   **Reset Filters:** Easily reset all applied filters to the default state.\n*   **Expandable Filter Panel:** Collapsible panel to show/hide filters for a cleaner UI.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/filters",
        "summary": "The session recording filter system provides a comprehensive suite of tools for users to efficiently narrow down recordings based on a wide array of criteria. Users can leverage advanced filtering options, AI-powered search, and customizable displays to find the recordings most relevant to their needs. The system also supports filtering by duration, replay properties, log entry properties, and person properties, offering a granular level of control over the search process.\n\nHere's a list of high-level product features:\n\n*   Advanced Filtering: Filter recordings by date, duration, events, actions, cohorts, session properties, HogQL expressions, and feature flags.\n*   AI-Powered Search: Use PostHog's Max tool to search recordings using natural language queries.\n*   Hide Viewed Recordings: Option to hide recordings already viewed by the current or any user.\n*   Customizable Timestamp Format: Choose between UTC, Device, or Relative timestamp formats for the playlist.\n*   Test Account Filtering: Filter out recordings from test accounts.\n*   Filter Grouping with AND/OR Logic: Combine filters using AND/OR logic for more precise targeting.\n*   Reset Filters: Easily reset all applied filters to the default state.\n*   Expandable Filter Panel: Collapsible panel to show/hide filters for a cleaner UI.\n*   Duration Type Selection: Allows users to filter session recordings based on different duration types (total, active, inactive).\n*   Session Recording Duration Filtering: Allows users to filter session recordings based on their duration, with operator selection and value input.\n*   Predefined Replay and Log Entry Property Filters: Allows users to quickly filter session recordings based on predefined properties.\n*   Customizable Pinned Person Property Filters: Enables users to pin frequently used person properties for quick access and filtering.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/settings/SessionRecordingsSettingsScene.tsx",
        "summary": "The `SessionRecordingsSettingsScene` component provides a settings interface for session recordings within the PostHog application. It utilizes LemonTabs for navigation between different replay tabs and embeds the `Settings` component to manage specific settings related to session replay. The scene also defines breadcrumbs for navigation within the application.\n\n**Features:**\n\n*   **Tabbed Navigation:** Uses LemonTabs to allow users to switch between different replay-related settings sections.\n*   **Settings Management:** Integrates the `Settings` component to handle and display various settings related to session recordings.\n*   **Breadcrumb Navigation:** Provides breadcrumbs to help users navigate back to the main Replay page and other relevant sections.\n*   **URL Routing:** Updates the URL based on the selected tab, enabling direct linking to specific settings sections.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/settings",
        "summary": "The SessionRecordingsSettingsScene component offers a user-friendly interface for managing session recording settings within PostHog. It leverages tabbed navigation powered by LemonTabs to organize different settings sections, embedding the Settings component to handle the display and modification of individual settings. Breadcrumb navigation is implemented to ensure users can easily navigate back to the main Replay page or other relevant areas of the application. The component also updates the URL based on the selected tab, enabling direct linking to specific settings sections for easy sharing and access.\n\n**Features:**\n\n*   Tabbed Navigation for settings sections\n*   Settings Management via the Settings component\n*   Breadcrumb Navigation for easy orientation\n*   URL Routing for direct linking to specific settings\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/playlist/playlistLogic.ts",
        "summary": "The `playlistLogic.ts` file defines a Kea logic module for managing the state of a playlist component within a session recordings feature. It handles the expansion state of the playlist itself and the expansion state of the filters associated with the playlist. The logic module includes actions to set these expansion states and reducers to update the corresponding state variables.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Playlist Expansion Control:** Allows users to expand or collapse the playlist view.\n*   **Filter Expansion Control:** Enables users to expand or collapse the filter options associated with the playlist.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/playlist/SessionRecordingsPlaylistTroubleshooting.tsx",
        "summary": "This component, `SessionRecordingsPlaylistTroubleshooting`, is displayed when no matching session recordings are found in the playlist. It provides a list of potential reasons why recordings might be missing, along with links to relevant documentation for troubleshooting. It also allows the user to toggle the \"hide viewed recordings\" setting if that is the reason recordings are not being displayed.\n\nHere's a list of high-level features:\n\n*   **Displays a \"No matching recordings\" message:** Informs the user when no recordings are found.\n*   **Provides a list of potential reasons for missing recordings:** Helps the user understand why recordings might not be available.\n*   **Links to documentation for troubleshooting:** Offers direct access to relevant help resources.\n*   **Allows toggling the \"hide viewed recordings\" setting:** Enables users to quickly show or hide recordings they have already viewed.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/playlist/SessionRecordingsPlaylistScene.tsx",
        "summary": "The `SessionRecordingsPlaylistScene` component provides a user interface for viewing and managing session recording playlists. It allows users to view a list of session recordings, edit playlist details such as the description, duplicate or delete playlists, pin/unpin playlists, and save changes to the playlist filters. The component also handles loading states and not found scenarios, providing a smooth user experience.\n\nHere's a list of high-level product features implemented in the code:\n\n*   **Playlist Viewing:** Displays a list of session recordings within a playlist.\n*   **Playlist Editing:** Allows users to edit the playlist description.\n*   **Playlist Duplication:** Enables users to create a copy of an existing playlist.\n*   **Playlist Pinning:** Allows users to pin or unpin playlists for easier access.\n*   **Playlist Deletion:** Enables users to delete a playlist.\n*   **Filter Management:** Allows users to modify and save filters applied to the playlist.\n*   **User Activity Tracking:** Displays the last modified date and user who modified the playlist.\n*   **Loading State Handling:** Provides visual feedback during playlist loading.\n*   **\"Not Found\" Handling:** Displays a \"Not Found\" message when the playlist doesn't exist.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/playlist/playlistUtils.ts",
        "summary": "This code provides utility functions for managing session recording playlists in a PostHog application. It includes functions for summarizing playlist filters, retrieving, updating, duplicating, creating, and deleting playlists via the PostHog API. The code also handles billing limitations, displays success messages, and manages routing after playlist creation.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Playlist Filter Summarization:** Summarizes complex filter configurations for session recording playlists into human-readable strings.\n*   **Playlist Retrieval:** Fetches playlist details from the API using a short ID.\n*   **Playlist Updating:** Modifies existing playlists and saves the changes to the API.\n*   **Playlist Duplication:** Creates a copy of an existing playlist with a modified name.\n*   **Playlist Creation:** Creates new playlists with default filters and handles redirection to the new playlist.\n*   **Playlist Deletion:** Deletes playlists with undo functionality.\n*   **Billing Management:** Handles billing limitations related to the number of playlists and prompts users to upgrade.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/playlist/sessionRecordingsPlaylistSceneLogic.ts",
        "summary": "This code defines the logic for managing session recording playlists in a PostHog application. It handles fetching, updating, duplicating, and deleting playlists, as well as managing pinned recordings within a playlist. The logic also manages filters applied to the playlist, providing functionality to update and persist them. It also handles UI elements such as breadcrumbs and confirmation messages when navigating away from a playlist with unsaved changes.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Playlist Management:** Create, read, update, and delete session recording playlists.\n*   **Playlist Filtering:** Apply and modify filters to session recordings within a playlist.\n*   **Pinned Recordings:** Pin specific session recordings within a playlist for easy access.\n*   **Playlist Duplication:** Duplicate existing playlists.\n*   **Playlist Renaming:** Rename playlists.\n*   **Unsaved Changes Warning:** Warn users about unsaved changes when navigating away from a playlist.\n*   **Breadcrumb Navigation:** Provide breadcrumb navigation for easy navigation within the playlist feature.\n*   **Playlist Viewing Tracking:** Track when a playlist is viewed.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/playlist/sessionRecordingsListPropertiesLogic.ts",
        "summary": "This code defines a Kea logic module, `sessionRecordingsListPropertiesLogic`, responsible for efficiently fetching and caching properties associated with a list of session recordings. It fetches properties like geoip country code, browser, device type, OS, referring domain, and entry URL for each session recording by querying the events table using HogQL. The logic avoids redundant API calls by checking if properties for a session already exist in the cache before initiating a fetch. The fetched properties are then stored in a reducer, `recordingPropertiesById`, for quick access.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Session Recording Property Enrichment:** Fetches and displays key properties (e.g., location, browser, device) associated with session recordings.\n*   **Efficient Data Loading:** Avoids redundant API calls by caching fetched session recording properties.\n*   **Improved Session Recording List Performance:** Optimizes the loading of session recording lists by fetching properties in batches and caching the results.\n*   **Data-Driven Session Analysis:** Provides access to session recording properties for filtering, segmentation, and analysis.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/playlist/SessionRecordingsPlaylistSettings.tsx",
        "summary": "This file defines the `SessionRecordingsPlaylistTopSettings` component, which provides settings for the session recordings playlist. It includes a sorting menu (`SortedBy`) that allows users to sort recordings based on various criteria such as start time, activity score, error count, duration, and activity metrics (clicks, keystrokes, mouse activity). Additionally, it offers an autoplay setting, allowing users to control the direction of autoplay (off, newer recordings, or older recordings). The component utilizes PostHog's UI components like `SettingsBar` and `SettingsMenu` to present these settings in a user-friendly manner.\n\nHere's a list of high-level product features:\n\n*   **Session Recording Sorting:** Allows users to sort session recordings based on various criteria.\n*   **Sorting Criteria:** Includes sorting by latest, activity score, errors, duration, and activity metrics (clicks, keystrokes, mouse activity).\n*   **Autoplay Control:** Enables users to control the autoplay behavior of session recordings.\n*   **Autoplay Direction:** Supports autoplaying newer recordings, older recordings, or disabling autoplay.\n*   **Settings Menu UI:** Provides a user-friendly interface for accessing and modifying playlist settings.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/playlist/SessionRecordingPreview.tsx",
        "summary": "This code defines the `SessionRecordingPreview` component, which provides a concise summary of a session recording within a playlist or list view. It displays key information such as the user associated with the recording, the recording's duration, the number of clicks and key presses, the first URL visited, and device/location properties. The component also indicates if the recording is ongoing, pinned, or unwatched, and allows users to drag the recording to a notebook. The component uses tooltips to provide additional context for each piece of information.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Session Recording Summary:** Displays a preview of a session recording with key information.\n*   **User Identification:** Shows the user associated with the session recording.\n*   **Recording Duration Display:** Shows the duration of the session recording.\n*   **Interaction Metrics:** Displays the number of clicks and key presses within the recording.\n*   **First URL Tracking:** Shows the first URL visited during the session.\n*   **Device and Location Information:** Displays device and location properties associated with the recording.\n*   **Ongoing Recording Indicator:** Indicates if a recording is still in progress.\n*   **Pinned Recording Indicator:** Indicates if a recording is pinned to the list.\n*   **Unwatched Recording Indicator:** Indicates if a recording has not been viewed yet.\n*   **Drag to Notebook:** Allows users to drag the recording to a notebook for further analysis.\n*   **Error Count:** Displays the number of console errors in the recording.\n*   **Active/Inactive Time:** Displays the active or inactive time of the recording.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/playlist/Playlist.tsx",
        "summary": "The `Playlist` component is a versatile UI element designed for displaying a list of session recordings and related content. It supports grouping recordings into sections, each with its own title and content, and allows for interactive selection of recordings. The component handles loading states, empty states, and scrolling, and provides hooks for external actions like selecting an item or changing the active sections. It's responsive and can be embedded in other parts of the application, offering a flexible way to present session recording data.\n\nHere's a list of high-level product features provided by the `Playlist` component:\n\n*   **Sectioned Playlists:** Group session recordings into collapsible sections with titles.\n*   **Interactive Recording Selection:** Allows users to select a recording from the list, triggering an action.\n*   **Loading and Empty States:** Provides visual feedback during data loading and when no recordings are available.\n*   **Scrolling with Edge Detection:** Detects when the user scrolls to the top or bottom of the list, enabling features like infinite scrolling.\n*   **Responsive Layout:** Adapts to different screen sizes for optimal viewing on various devices.\n*   **Customizable Content Display:** Supports rendering custom content alongside the playlist, which can be dependent on the selected recording.\n*   **Header and Footer Actions:** Allows adding custom actions to the header and footer of the playlist.\n*   **Drag and Drop to Notebook:** Supports dragging the playlist to a notebook feature.\n*   **Controlled and Uncontrolled Active Item:** Supports both controlled and uncontrolled modes for managing the active item.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/playlist/SessionRecordingsPlaylist.tsx",
        "summary": "The `SessionRecordingsPlaylist` component provides a user interface for viewing and interacting with session recordings. It allows users to filter recordings, pin important ones, and play them back within the same view. The component fetches and displays recordings in a playlist format, with options to load more recordings and handle empty states or errors gracefully. It integrates with a player component to display the selected recording and provides settings to manage filters and pinned recordings.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Session Recording Playback:** Plays back session recordings with controls and event matching.\n*   **Playlist Management:** Organizes recordings into a playlist with sections for pinned recordings and filtered results.\n*   **Filtering:** Allows users to filter recordings based on various criteria, including HogQL and feature flags.\n*   **Pinning:** Enables users to pin important recordings for easy access.\n*   **Loading and Pagination:** Loads recordings in batches with pagination for efficient browsing.\n*   **Empty State Handling:** Displays informative messages when no recordings match the current filters or when no recording is selected.\n*   **Error Handling:** Displays error messages when there are issues loading recordings.\n*   **Settings:** Provides settings for managing filters and other playlist options.\n*   **Notebook Integration:** Integrates with notebooks, allowing users to embed the playlist and filter recordings based on notebook context.\n*   **Troubleshooting:** Provides troubleshooting guidance when no recordings are found.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/playlist/sessionRecordingsPlaylistLogic.ts",
        "summary": "This code defines the `sessionRecordingsPlaylistLogic` Kea logic, which manages the state and behavior of a session recordings playlist. It handles loading, filtering, and navigating through session recordings based on various criteria, including universal filters, legacy filters, and person UUID. The logic also manages pinned recordings, filter visibility, and settings. It converts filters into a format suitable for API requests, handles responses, and sorts recordings based on specified order.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Session Recording Playback:** Enables users to view a playlist of session recordings.\n*   **Filtering:** Allows users to filter session recordings based on various criteria (events, actions, properties, date ranges, duration, test accounts, console logs).\n*   **Advanced Filtering:** Supports both simple and advanced filtering options.\n*   **Sorting:** Enables sorting of session recordings by start time or duration.\n*   **Pagination:** Loads session recordings in batches with \"load more\" functionality.\n*   **Pinned Recordings:** Allows users to pin important session recordings for easy access.\n*   **Navigation:** Provides navigation between recordings in the playlist (next/previous).\n*   **Test Account Filtering:** Filters out recordings from test accounts.\n*   **URL Synchronization:** (Potentially, based on `kea-router`) Synchronizes the playlist state with the URL for shareable links.\n*   **Event Association:** Determines if events have a session ID associated with them.\n*   **Autoplay:** Supports autoplaying of recordings with configurable direction.\n*   **Hide Viewed Recordings:** Allows users to hide recordings they have already viewed.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/playlist",
        "summary": "The session recording playlist feature in PostHog provides a comprehensive suite of tools for managing, analyzing, and interacting with user session recordings. Users can organize recordings into playlists, apply filters to narrow down specific sessions, and pin important recordings for easy access. The system efficiently loads and caches recording properties, allowing for quick previews and detailed summaries of each session, including user information, duration, interaction metrics, and device/location details. Furthermore, the feature supports playlist editing, duplication, deletion, and sharing, along with settings for sorting, autoplay, and hiding viewed recordings, ensuring a tailored and efficient user experience for session replay analysis.\n\nHere's a list of high-level product features:\n\n*   Session Recording Playback & Navigation\n*   Playlist Creation, Editing, Duplication, Deletion, Pinning & Sharing\n*   Advanced Filtering & Sorting\n*   Session Recording Summaries & Previews\n*   User Identification & Activity Metrics\n*   Efficient Data Loading & Caching\n*   Error & Empty State Handling\n*   Autoplay Control & Hide Viewed Recordings\n*   Notebook Integration\n*   Troubleshooting Guidance\n*   Unsaved Changes Warning\n*   Breadcrumb Navigation\n*   Billing Management\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/file-playback/types.ts",
        "summary": "This code defines TypeScript types for representing exported session recording files in two different versions. Version 1 (`ExportedSessionRecordingFileV1`) includes the recording's person and snapshots organized by window ID. Version 2 (`ExportedSessionRecordingFileV2`) includes the recording's ID, person, and a flat array of recording snapshots. These types are used for handling session recording data when exporting or importing recordings.\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **Session Recording Export:** The ability to export session recordings.\n*   **Session Recording Import:** The ability to import session recordings.\n*   **User Identification in Recordings:** Associate recordings with specific users.\n*   **Multi-Window Recording Support:** Handle recordings that span multiple browser windows (version 1).\n*   **Snapshot Management:** Store and manage individual snapshots of the recording.\n*   **Versioned Data Format:** Support different versions of the exported recording format.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/file-playback/SessionRecordingFilePlaybackScene.tsx",
        "summary": "This code defines a scene in PostHog for playing back session recordings from uploaded files. It handles loading recording files, displaying a player for the recording, and managing the UI for file selection and loading states. If the user doesn't have the `RECORDINGS_FILE_EXPORT` feature enabled, a paygate is displayed.\n\nHere's a list of high-level product features:\n\n*   **Session Recording File Upload:** Allows users to upload session recording files (JSON format).\n*   **Drag and Drop Support:** Enables users to drag and drop recording files for upload.\n*   **Session Recording Playback from File:** Plays back session recordings loaded from uploaded files.\n*   **Loading State Indication:** Displays a spinner overlay while the recording file is being processed.\n*   **Paygate Integration:** Restricts access to the feature based on user's plan and displays a paygate if the feature is not enabled.\n*   **Reset Recording:** Allows users to clear the currently loaded recording and load a different one.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/file-playback/sessionRecordingFilePlaybackSceneLogic.ts",
        "summary": "This code defines the logic for handling session recording file playback in the PostHog frontend. It allows users to upload a session recording file, parse its contents, and play it back within the PostHog replay interface. The logic handles file loading, data parsing, snapshot processing, and integration with the existing session recording data logic to enable playback. It also includes features like handling different file versions, displaying breadcrumbs for navigation, and prompting the user before leaving the page to prevent data loss.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Session Recording File Upload:** Allows users to upload session recording files from their local machine.\n*   **Session Recording File Parsing:** Parses the uploaded file, handling different file versions and extracting relevant data.\n*   **Session Recording Playback:** Enables playback of the session recording within the PostHog replay interface.\n*   **Snapshot Processing:** Deduplicates and transforms snapshots from the file for smooth playback.\n*   **Data Integration:** Integrates the loaded file data with the existing session recording data logic.\n*   **Navigation Breadcrumbs:** Provides breadcrumbs for easy navigation within the replay interface.\n*   **Data Loss Prevention:** Prompts the user before leaving the page to prevent accidental data loss.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/file-playback",
        "summary": "The provided code collectively implements a feature for uploading and playing back session recordings from files within PostHog. This includes handling different file versions, parsing the file contents, managing snapshots, and integrating the data with the existing session recording playback interface. The feature also incorporates UI elements for file selection, loading state indication, navigation, and data loss prevention, with access potentially restricted by a paygate based on the user's plan.\n\n**Features:**\n\n*   Session Recording File Upload\n*   Session Recording File Parsing\n*   Session Recording Playback from File\n*   Session Recording Export\n*   Session Recording Import\n*   Drag and Drop Support\n*   Loading State Indication\n*   Snapshot Management\n*   Data Integration\n*   Navigation Breadcrumbs\n*   Data Loss Prevention\n*   Paygate Integration\n*   User Identification in Recordings\n*   Multi-Window Recording Support\n*   Versioned Data Format\n*   Reset Recording\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/apm/waterfall/NetworkBar.tsx",
        "summary": "The `NetworkBar` component visualizes a single network request within a waterfall chart for performance monitoring. It uses percentages to position and size a colored bar representing the request's duration relative to the overall timeline. A tooltip provides a detailed `TimeLineView` of the performance event on hover. The color of the bar is determined by the initiator type of the network request.\n\n**Features:**\n\n*   **Visual Representation of Network Requests:** Displays network requests as colored bars in a waterfall chart.\n*   **Relative Positioning and Sizing:** Positions and sizes bars based on the request's start time and duration relative to the overall timeline.\n*   **Color-Coded by Initiator Type:** Uses different colors to represent different types of network request initiators.\n*   **Detailed Tooltip Information:** Provides a tooltip with a detailed timeline view of the performance event on hover.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/apm/waterfall/TimeLineView.tsx",
        "summary": "The `TimeLineView.tsx` file defines a React component, `TimeLineView`, that visualizes the performance metrics of a given `PerformanceEvent` in a waterfall-like timeline. It processes the event to extract relevant timing information, calculates performance measures, and renders a series of `TimingBar` components representing network and server timings. The component filters out the server timing section initially, then renders it separately with a divider and title if server timings are present. A utility function `convertForTimelineView` is used to prepare the `PerformanceEvent` data for display.\n\nHere's a list of high-level product features:\n\n*   **Performance Event Visualization:** Displays performance events as a waterfall timeline.\n*   **Network Timing Breakdown:** Shows a breakdown of network timings within a performance event.\n*   **Server Timing Breakdown:** Shows a breakdown of server timings within a performance event.\n*   **Data Conversion:** Converts raw performance event data into a format suitable for timeline display.\n*   **Tooltip Descriptions:** Provides descriptions for server timings via tooltips.\n*   **Filtering of Empty Data:** Handles cases where performance measures are missing or empty, preventing errors.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/apm/networkViewLogic.ts",
        "summary": "This code defines the logic for the network view within a session recording player, specifically for APM (Application Performance Monitoring) data. It manages the display of performance events related to network requests within the recording, organizing them into pages based on navigation events. The logic handles pagination, loading of session and snapshot data, and formatting of event durations. It also calculates the position of each event within the waterfall view based on its timing relative to the navigation events.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Network Request Waterfall View:** Visualizes network requests as a waterfall chart within a session recording.\n*   **Pagination of Network Events:** Allows users to navigate through network events page by page, grouped by navigation events.\n*   **Performance Event Details:** Displays details of individual performance events, including timing information.\n*   **Event Duration Formatting:** Formats event durations into a human-readable format.\n*   **Relative Positioning of Events:** Calculates and provides the position of each event within the waterfall view relative to the page's navigation events.\n*   **Loading State Management:** Manages and indicates loading states for session and snapshot data.\n*   **Session Recording Integration:** Integrates with the session recording player to display network performance data synchronized with the recording.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/sessionReplaySceneLogic.ts",
        "summary": "This code defines the logic for the Session Replay scene in the PostHog frontend, managing the active tab (Recordings, Playlists, Templates, Settings), handling URL routing and updates, and providing breadcrumbs for navigation. It also manages a \"new badge\" for the Templates tab and enforces a limit on the number of free playlists. The logic connects the URL to the active tab and vice versa, ensuring the UI reflects the current route. It also provides context for a side panel when a session recording ID is present in the URL.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Tabbed Navigation:** Allows users to switch between different sections within the Session Replay feature (Recordings, Playlists, Templates, Settings).\n*   **URL-Based Navigation:** The active tab is reflected in the URL, enabling direct linking and bookmarking.\n*   **Breadcrumbs:** Provides a clear navigation path for users to understand their location within the Session Replay feature.\n*   **\"New\" Badge for Templates:** Highlights the Templates tab when there are new or unviewed templates.\n*   **Session Recording Side Panel Context:** Enables a side panel to display information related to a specific session recording when its ID is present in the URL.\n*   **Playlist Limit Enforcement:** Restricts the number of saved playlists for free users.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/apm/waterfall/TimingBar.tsx",
        "summary": "This code defines the `TimingBar` component, which is used to visualize the different stages of a network request's lifecycle within a waterfall chart. It calculates and displays the duration of various performance metrics such as redirect time, DNS lookup, connection time, request queuing, waiting for first byte, receiving response, and document processing. It also handles server timings, which are backend-reported durations. The component calculates the start and width percentages of each timing section relative to the total event range, and renders a colored bar representing the duration of each stage, along with a label and tooltip providing a description of the timing.\n\nHere's a list of high-level product features that can be derived from this code:\n\n*   **Waterfall Chart Visualization:** Displays a waterfall chart to visualize the timing of different stages in a network request.\n*   **Performance Metrics Breakdown:** Breaks down network request performance into key metrics like redirect time, DNS lookup, connection time, and more.\n*   **Server Timing Support:** Visualizes backend server timings reported by the server.\n*   **Tooltip Descriptions:** Provides detailed descriptions of each performance metric via tooltips.\n*   **Duration Display:** Shows the duration of each stage in a human-readable format.\n*   **Percentage-Based Representation:** Calculates and displays the start and width of each timing section as a percentage of the total event range.\n*   **Color-Coded Stages:** Uses different colors to visually distinguish between different performance stages."
    },
    {
        "path": "frontend/src/scenes/session-recordings/apm/waterfall",
        "summary": "The provided code snippets detail the implementation of a waterfall chart visualization for performance monitoring within a session recording tool. This visualization breaks down network requests and server responses into their constituent timings, allowing users to quickly identify performance bottlenecks. The system uses color-coding, tooltips, and percentage-based sizing to present a clear and informative view of each request's lifecycle.\n\nHere's a list of high-level product features:\n\n*   **Waterfall Chart Visualization:** Displays network requests and server responses as interactive waterfall charts.\n*   **Performance Metrics Breakdown:** Provides a detailed breakdown of network and server timings, including redirect time, DNS lookup, connection time, request queuing, waiting for first byte, receiving response, document processing, and backend server timings.\n*   **Color-Coded Stages:** Uses color to visually distinguish between different performance stages and initiator types.\n*   **Relative Positioning and Sizing:** Positions and sizes timing bars based on their duration relative to the overall timeline.\n*   **Detailed Tooltip Information:** Offers tooltips with detailed descriptions and durations for each timing stage.\n*   **Data Conversion and Filtering:** Converts raw performance event data into a suitable format for display and handles cases where data is missing or empty.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/apm/components/AssetProportions.tsx",
        "summary": "The `AssetProportions` component visualizes the breakdown of asset sizes for a given set of assets, displaying each asset's proportion of the total size. It takes a data object where keys are asset labels and values contain size information (bytes). The component calculates the percentage each asset contributes to the total size and renders a horizontal bar representing this proportion, colored according to the asset type. Tooltips provide detailed size information when the bar is too small to display the information directly.\n\nHere's a list of high-level product features:\n\n*   **Asset Size Visualization:** Displays a breakdown of asset sizes, showing the proportion each asset contributes to the total size.\n*   **Asset Type Coloring:** Colors assets based on their type for easy visual identification.\n*   **Dynamic Display:** Adjusts the displayed information based on available space, showing detailed information when possible and using tooltips when space is limited.\n*   **Tooltip Information:** Provides detailed asset size information (bytes and percentage) via tooltips.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/apm/NetworkView.tsx",
        "summary": "The `NetworkView` component provides a detailed view of network requests made during a session recording. It fetches and displays performance events, focusing on network-related data like URLs, timings, and status codes. The component includes a waterfall diagram visualizing the timing of each request, a table summarizing the network activity, and metadata about the current page being viewed, including performance scores and asset proportions. Navigation controls allow users to step through different pages within the recording.\n\nHere's a list of high-level product features:\n\n*   **Network Request Visualization:** Displays a waterfall diagram to visualize the timing and duration of network requests.\n*   **Detailed Network Table:** Presents a table with information about each network request, including URL, timings, status, and duration.\n*   **URL Inspection:** Allows users to inspect full URLs with protocol, hostname, pathname, search parameters, and hash.\n*   **Page Navigation:** Provides controls to navigate between different pages within the session recording.\n*   **Performance Metrics:** Shows performance scores and asset proportions for the currently viewed page.\n*   **Status and Method Indicators:** Displays status codes and HTTP methods for each network request.\n*   **Time Display:** Shows the timestamp and time in recording for each network request.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/apm/components/PerformanceCard.tsx",
        "summary": "The `PerformanceCard.tsx` component provides a way to display and analyze web performance metrics within a session recording context. It fetches and presents key performance indicators (KPIs) like First Contentful Paint (FCP), Largest Contentful Paint (LCP), Cumulative Layout Shift (CLS), Interaction to Next Paint (INP), DOM Interactive, and Page Loaded times. The component visualizes these metrics, compares them against predefined benchmarks, and provides links to external resources for further information about each metric. It uses color-coding to indicate whether the performance is good, needs improvement, or is poor based on the benchmarks.\n\nHere's a list of high-level product features:\n\n*   **Performance Metric Display:** Shows key web performance metrics (FCP, LCP, CLS, INP, DOM Interactive, Page Loaded) for a given session recording.\n*   **Benchmark Comparison:** Compares performance metrics against predefined benchmarks to highlight potential issues.\n*   **Visual Performance Indicators:** Uses color-coding (green, yellow, red) to visually represent performance relative to benchmarks.\n*   **Metric Definitions:** Provides descriptions and links to external resources (e.g., MDN Web Docs, web.dev) to explain each performance metric.\n*   **Loading Indicators:** Displays loading spinners when performance data is still being fetched.\n*   **Detailed Descriptions:** Offers expanded descriptions of each metric, including its impact and how to improve it.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/apm/performance-event-utils.ts",
        "summary": "This code provides utility functions for processing and visualizing performance events captured during session recordings. It defines mappings between numerical or string keys and PerformanceEvent properties, facilitating the extraction and interpretation of performance data from different sources (PostHog and rrweb network plugins). The code also includes functions to determine colors for different initiator types and asset types, as well as functions to calculate and format size-related information for performance events, including compression percentages. Finally, it extracts performance events from rrweb snapshots, handling both PostHog and rrweb network plugin event formats, and maps rrweb network requests to PerformanceEvent objects.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Performance Monitoring:** Captures and processes performance metrics from user sessions.\n*   **Session Recording Enrichment:** Integrates performance data into session recordings for enhanced analysis.\n*   **Resource Timing Visualization:** Displays resource loading times and network requests within session recordings.\n*   **Asset Type Identification:** Categorizes and visualizes different types of assets (CSS, JS, Images, etc.) loaded during a session.\n*   **Data Size Analysis:** Calculates and displays the size of network requests and responses, including compression information.\n*   **Network Request Inspection:** Provides detailed information about network requests, including headers and bodies.\n*   **Server Timing Support:** Captures and displays server timing information associated with network requests.\n*   **Performance Event Normalization:** Maps performance data from different sources (PostHog and rrweb) to a common format.\n*   **Cache Detection:** Identifies resources loaded from the local cache.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/apm/components",
        "summary": "The session recording analysis tool provides users with insights into web performance and asset loading. It displays key performance metrics with visual indicators and benchmark comparisons, offering links to external resources for deeper understanding. Additionally, it visualizes the proportion of different asset types contributing to the overall page size, using color-coding and tooltips for detailed information.\n\nHere's a list of high-level product features:\n\n*   Performance Metric Display: Shows key web performance metrics (FCP, LCP, CLS, INP, DOM Interactive, Page Loaded) for a given session recording.\n*   Benchmark Comparison: Compares performance metrics against predefined benchmarks to highlight potential issues.\n*   Visual Performance Indicators: Uses color-coding (green, yellow, red) to visually represent performance relative to benchmarks.\n*   Metric Definitions: Provides descriptions and links to external resources (e.g., MDN Web Docs, web.dev) to explain each performance metric.\n*   Loading Indicators: Displays loading spinners when performance data is still being fetched.\n*   Detailed Descriptions: Offers expanded descriptions of each metric, including its impact and how to improve it.\n*   Asset Size Visualization: Displays a breakdown of asset sizes, showing the proportion each asset contributes to the total size.\n*   Asset Type Coloring: Colors assets based on their type for easy visual identification.\n*   Dynamic Display: Adjusts the displayed information based on available space, showing detailed information when possible and using tooltips when space is limited.\n*   Tooltip Information: Provides detailed asset size information (bytes and percentage) via tooltips.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/apm/performanceEventDataLogic.ts",
        "summary": "This code defines a Kea logic module named `performanceEventDataLogic` that processes and enriches performance event data for session recordings. It fetches performance events from session recording data and web vitals events, then filters, deduplicates, sorts, and matches paint and web vitals events to navigation events. The logic also calculates a size breakdown of assets based on initiator type. The resulting data is used to provide insights into the performance of the recorded session.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Performance Monitoring:** Captures and processes performance metrics from session recordings.\n*   **Event Filtering:** Filters out irrelevant performance events (e.g., navigations to \"about:blank\").\n*   **Event Deduplication:** Removes duplicate performance events captured during initial requests.\n*   **Event Sorting:** Sorts performance events by timestamp for chronological analysis.\n*   **Paint Event Matching:** Associates paint events (e.g., first contentful paint) with corresponding navigation events.\n*   **Web Vitals Integration:** Links web vitals events to navigation events for comprehensive performance analysis.\n*   **Asset Size Breakdown:** Provides a breakdown of asset sizes by type (e.g., script, image) to identify potential optimization opportunities.\n*   **Session Recording Enhancement:** Enriches session recording data with performance-related information.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/apm",
        "summary": "The provided code collectively implements a comprehensive Application Performance Monitoring (APM) system integrated within a session recording tool. This system captures, processes, and visualizes performance data, providing users with detailed insights into the performance of their web applications during recorded sessions. The system focuses on network requests, resource loading, and web vitals, presenting this information through interactive waterfall charts, detailed tables, and visual performance indicators. The goal is to enable users to quickly identify performance bottlenecks, understand asset loading behavior, and optimize their applications for improved user experience.\n\nHere's a list of high-level product features:\n\n*   **Session Recording Integration:** Seamlessly integrates APM data with session recordings for contextual performance analysis.\n*   **Network Request Waterfall View:** Visualizes network requests and server responses as interactive waterfall charts, highlighting timing breakdowns and potential bottlenecks.\n*   **Performance Metrics Dashboard:** Displays key web performance metrics (FCP, LCP, CLS, INP, etc.) with benchmark comparisons and visual indicators.\n*   **Detailed Network Table:** Presents a comprehensive table with information about each network request, including URL, timings, status, and size.\n*   **Asset Size Breakdown:** Provides a breakdown of asset sizes by type (script, image, CSS, etc.) to identify optimization opportunities.\n*   **Page Navigation:** Allows users to navigate through network events page by page, grouped by navigation events within the session recording.\n*   **Performance Event Processing:** Captures, filters, deduplicates, sorts, and enriches performance events from various sources (PostHog, rrweb, web vitals).\n*   **Resource Timing Visualization:** Displays resource loading times and network requests within session recordings.\n*   **URL Inspection:** Allows users to inspect full URLs with protocol, hostname, pathname, search parameters, and hash.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/saved-playlists/SavedSessionRecordingPlaylistsEmptyState.tsx",
        "summary": "This component, `SavedSessionRecordingPlaylistsEmptyState`, is displayed when there are no saved session recording playlists to show, potentially due to applied filters. It informs the user that no playlists match the current filters and prompts them to create a new playlist using a button. If loading the playlists fails, an error banner is displayed instead.\n\nHere's a list of high-level product features:\n\n*   **Empty State Display:** Shows a user-friendly message when no saved playlists are available.\n*   **Playlist Creation Prompt:** Encourages users to create a new playlist via a button.\n*   **Error Handling:** Displays an error message if loading playlists fails.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/saved-playlists/savedSessionRecordingPlaylistsLogic.ts",
        "summary": "This code defines a Kea logic module for managing saved session recording playlists in a PostHog application. It handles fetching, filtering, updating, deleting, and duplicating playlists, as well as managing pagination and URL synchronization. The logic also tracks usage of playlist counts via PostHog events.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Playlist Management:** Allows users to create, view, edit, duplicate, and delete session recording playlists.\n*   **Filtering and Sorting:** Enables users to filter playlists by various criteria such as creator, date range, search terms, and pinned status, and sort them by different columns.\n*   **Pagination:** Provides pagination for large lists of playlists, allowing users to navigate through them efficiently.\n*   **URL Synchronization:** Keeps the playlist filters and pagination state synchronized with the URL, enabling shareable links and bookmarking.\n*   **Usage Tracking:** Tracks usage of playlist counts to understand feature adoption and identify areas for improvement.\n*   **Playlist Duplication:** Allows users to easily duplicate existing playlists.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/saved-playlists/SavedSessionRecordingPlaylists.tsx",
        "summary": "This code defines the `SavedSessionRecordingPlaylists` component, which displays a list of saved session recording playlists in a table format. It allows users to view, search, filter, sort, and manage their playlists. The component fetches playlist data, including name, description, pinned status, recording counts, creator, and last modified date. Users can interact with the playlists through actions like pinning, duplicating, and deleting. The component also provides filtering options based on search terms, pinned status, date range, and creator.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Playlist Listing:** Displays a paginated list of saved session recording playlists.\n*   **Playlist Details:** Shows playlist name, description, creator, and last modified date.\n*   **Playlist Pinning:** Allows users to pin playlists for easy access.\n*   **Playlist Recording Count:** Displays the number of recordings in each playlist, including watched and unwatched counts.\n*   **Playlist Searching:** Enables users to search for playlists by name.\n*   **Playlist Filtering:** Provides filtering options based on pinned status, date range, and creator.\n*   **Playlist Sorting:** Allows users to sort playlists by different columns (e.g., last modified date).\n*   **Playlist Management:** Enables users to duplicate and delete playlists.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/saved-playlists",
        "summary": "The provided code collectively implements a comprehensive saved session recording playlist management system within a PostHog application. This system allows users to organize, access, and analyze session recordings more efficiently. Key functionalities include displaying playlists in a structured format, enabling users to filter, sort, and search for specific playlists, and providing tools for managing playlists through actions like pinning, duplicating, and deleting. The system also incorporates usage tracking and URL synchronization for enhanced usability and feature adoption insights.\n\nHere's a list of high-level product features:\n\n*   Playlist Listing and Details\n*   Playlist Creation, Editing, Duplication, and Deletion\n*   Playlist Pinning\n*   Playlist Recording Count (Watched/Unwatched)\n*   Playlist Searching and Filtering (by name, creator, date range, pinned status)\n*   Playlist Sorting\n*   Pagination for Large Playlists\n*   URL Synchronization for Shareable Links\n*   Usage Tracking\n*   Empty State Display with Playlist Creation Prompt\n*   Error Handling for Loading Failures\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/utils.ts",
        "summary": "This code provides utility functions for managing session recording filters and masking configurations. It includes functions to determine if a filter set is using the universal filter format, extract filter values from universal filter groups, and convert between masking levels (total privacy, free love, normal) and their corresponding masking configurations. The code also defines a mapping for timestamp formats to labels.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Session Recording Filters:** Allows users to filter session recordings based on various criteria.\n*   **Universal Filter Support:** Supports a new, more flexible filter format for session recordings.\n*   **Session Recording Masking:** Provides different levels of masking for sensitive data in session recordings.\n*   **Privacy Control:** Enables users to control the level of privacy in session recordings through masking configurations.\n*   **Timestamp Formatting:** Allows users to view timestamps in different formats (relative, UTC, device).\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/replayPaletteCommands.ts",
        "summary": "This code defines a command palette entry for PostHog that allows users to quickly find and watch session recordings based on different criteria. The command, triggered by the `WATCH_RECORDINGS_OF_KEY`, analyzes the user's input to determine the search type. It can identify keywords like \"web\" or \"mobile\" to filter recordings by snapshot source, URLs to find recordings of visits to specific pages, or UUIDs to directly access a specific session recording. The command then navigates the user to the appropriate replay tab with the specified filters or directly to the single recording view.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Search recordings by snapshot source:** Allows users to find recordings based on the source (e.g., \"web\" or \"mobile\").\n*   **Search recordings by visited URL:** Enables users to find recordings of sessions where a specific URL was visited.\n*   **Direct access to recordings by UUID:** Provides a way to quickly access a specific session recording if the UUID is known.\n*   **Command Palette Integration:** Integrates the above features into PostHog's command palette for quick access.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/components/AiRegexHelper/aiRegexHelperLogic.ts",
        "summary": "This code defines a Kea logic module named `aiRegexHelperLogic` that manages the state and actions for an AI-powered regex helper component. It handles opening and closing the helper, managing user input, generating regex patterns using an API call, displaying the generated regex or any errors, and copying the regex to the clipboard. The logic also tracks loading state and captures analytics events using PostHog.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Open/Close AI Regex Helper:** Allows users to open and close the AI regex helper interface.\n*   **Input Field:** Provides a text input field for users to enter the text they want to generate a regex for.\n*   **Regex Generation:** Uses an AI-powered API to generate a regex pattern based on the user's input.\n*   **Loading State:** Indicates when the regex generation process is in progress.\n*   **Display Generated Regex:** Shows the generated regex pattern to the user.\n*   **Error Handling:** Displays error messages if the regex generation fails.\n*   **Copy to Clipboard:** Allows users to easily copy the generated regex to their clipboard.\n*   **Analytics Tracking:** Tracks usage of the AI regex helper using PostHog.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/components/AiRegexHelper/AiRegexHelper.tsx",
        "summary": "The `AiRegexHelper` component provides a modal interface that leverages AI to generate regular expressions based on natural language input. Users can input a description of the desired regex, and the component uses the Max AI service to generate a corresponding regex. The generated regex is displayed in a banner, and users can copy it to the clipboard or apply it to a specific setting. The component handles AI availability checks, data processing agreement requirements, loading states, and error messages. A button is also provided to open the modal.\n\nHere's a list of high-level product features:\n\n*   **AI-Powered Regex Generation:** Generates regular expressions from natural language descriptions using AI.\n*   **Natural Language Input:** Accepts user input in natural language to describe the desired regex.\n*   **Regex Display and Copy:** Displays the generated regex in a banner and allows users to copy it to the clipboard.\n*   **Apply Regex:** Allows users to apply the generated regex to a specific setting.\n*   **AI Availability Check:** Checks if the AI service is available based on environment variables.\n*   **Data Processing Agreement Check:** Ensures users have accepted the data processing agreement before using AI features.\n*   **Loading State:** Displays a loading indicator while the regex is being generated.\n*   **Error Handling:** Displays error messages if there are issues with the AI service or input.\n*   **Modal Interface:** Provides a modal interface for interacting with the AI regex helper.\n*   **Usage Tracking:** Tracks when the AI regex helper is opened and when a generated regex is applied.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/components/AiRegexHelper",
        "summary": "The AI Regex Helper feature provides a user-friendly modal interface that leverages AI to generate regular expressions from natural language descriptions. Users can input their desired regex criteria in plain English, and the system utilizes an AI-powered API to generate a corresponding regex pattern. The generated regex is then displayed, allowing users to easily copy it to their clipboard or apply it directly to a specific setting. The feature also incorporates error handling, loading states, and analytics tracking to ensure a smooth and informative user experience.\n\nHere's a list of high-level product features:\n\n*   AI-Powered Regex Generation from Natural Language\n*   Modal Interface for User Interaction\n*   Regex Display and Copy to Clipboard\n*   Apply Regex to Specific Settings\n*   AI Availability and Data Processing Agreement Checks\n*   Loading State Indicators\n*   Error Handling and Display\n*   Analytics Tracking of Usage\n*   Open/Close AI Regex Helper\n*   Input Field for Natural Language Descriptions\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/components/SimpleTimeLabel.tsx",
        "summary": "The `SimpleTimeLabel` component is a React component that displays a formatted timestamp, specifically designed for session recordings. It handles formatting the time based on user preferences (UTC or local timezone) and the desired level of detail (time only or full date and time). The component also includes a tooltip to show the full date and time when only the time is displayed due to size constraints. To optimize performance, the component is memoized, preventing unnecessary re-renders by comparing truncated (to the nearest second) start times and other relevant props.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Timestamp Formatting:** Displays timestamps in a user-friendly format, including options for UTC or local timezone.\n*   **Time Precision:** Formats timestamps to the nearest second.\n*   **Contextual Display:** Adapts the displayed information (time only or full date and time) based on available space.\n*   **Tooltip for Full Information:** Provides a tooltip to display the full date and time when only the time is shown.\n*   **Performance Optimization:** Memoized component to prevent unnecessary re-renders, improving performance in dynamic environments.\n*   **Customizable Appearance:** Allows customization of text size and muted state.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/components/ItemTimeDisplay.tsx",
        "summary": "This component, `ItemTimeDisplay`, is responsible for displaying the timestamp of an event within a session recording. It offers flexibility in how the timestamp is presented, allowing users to choose between absolute (UTC or local time) and relative (time elapsed since the recording started) formats. The component also handles cases where an event occurs before the recording's start, indicating it happened during page load. The display adapts based on the recording's duration, showing hours only if the recording exceeds one hour.\n\nHere's a list of high-level product features related to this component:\n\n*   **Timestamp Display:** Shows the timestamp of an event.\n*   **Timestamp Formatting:** Allows users to choose between different timestamp formats (UTC, local time, relative time).\n*   **Relative Time Display:** Displays the time elapsed since the recording started.\n*   **Pre-Recording Event Handling:** Indicates when an event occurred before the recording started.\n*   **Adaptive Time Unit Display:** Adjusts the displayed time units (hiding hours for shorter recordings).\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/components/OverviewGrid.tsx",
        "summary": "This code defines two React components, `OverviewGrid` and `OverviewGridItem`, designed for displaying session recording overview information in a structured grid format. `OverviewGrid` acts as a container, arranging `OverviewGridItem` components in a responsive grid layout that adapts to different screen sizes. `OverviewGridItem` represents a single piece of overview information, displaying a label (potentially with an icon and tooltip) and a corresponding value (also potentially with a tooltip). The grid items are designed to handle overflowing content by enabling horizontal scrolling.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Structured Data Display:** Presents key session recording information in a clear, organized grid.\n*   **Responsive Layout:** Adapts the grid layout to different screen sizes for optimal viewing on various devices.\n*   **Informative Tooltips:** Provides additional context and details for both labels and values through tooltips.\n*   **Customizable Content:** Supports various types of content within grid items, including text, properties, and custom components.\n*   **Overflow Handling:** Manages long values by enabling horizontal scrolling within grid items.\n*   **Icon Support:** Allows for the inclusion of icons alongside labels for visual clarity.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/components/PanelSettings.tsx",
        "summary": "This code defines React components for creating settings panels within a session recording interface. It provides a `SettingsBar` component for structuring the settings area, a `SettingsMenu` component for dropdown menus of settings, and `SettingsButton` and `SettingsToggle` components for individual settings controls. The components leverage the Lemon UI library for styling and functionality, offering customizable buttons, menus, and tooltips. The components are designed to be flexible and reusable, allowing developers to easily create a variety of settings panels with different layouts and controls.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Settings Bar:** Provides a container for organizing settings controls.\n*   **Dropdown Menus:** Allows grouping related settings options into menus.\n*   **Toggleable Settings:** Enables users to switch settings on or off.\n*   **Customizable Buttons:** Offers various button styles and sizes for settings controls.\n*   **Tooltips:** Provides contextual information about settings options.\n*   **Disabled State with Reasons:** Communicates why a setting is unavailable.\n*   **Active State Highlighting:** Visually indicates when a setting is active.\n*   **Rounded or Square Button Styles:** Provides options for visual customization.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/components",
        "summary": "The provided code snippets collectively contribute to a comprehensive session recording feature set, focusing on enhancing user experience through AI-powered assistance, clear timestamp presentation, customizable settings panels, and structured data display. These components work together to provide users with the tools they need to effectively analyze and understand session recordings.\n\nHere's a list of high-level product features:\n\n*   **AI-Powered Regex Generation:** Generate regular expressions from natural language descriptions for advanced filtering and analysis.\n*   **Timestamp Management & Display:** Display and format timestamps in various formats (UTC, local, relative) with tooltips for detailed information.\n*   **Customizable Settings Panels:** Provide a flexible interface for users to adjust settings related to session recordings.\n*   **Structured Overview Grids:** Organize and display key session recording information in a clear and responsive grid layout.\n*   **Event Timestamping:** Display the timestamp of events within a session recording, handling pre-recording events.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/detail/sessionRecordingDetailLogic.ts",
        "summary": "This code defines a Kea logic module named `sessionRecordingDetailLogic` responsible for managing the state and logic related to a single session recording detail view. It takes a session recording ID as a prop and provides a selector to generate breadcrumbs for navigation. The breadcrumbs include a link to the main Replay page and a link to the specific session recording detail page, using the session recording ID in the URL.\n\n**Features:**\n\n*   **Breadcrumb Generation:** Creates breadcrumbs for navigating to the session recording detail view.\n*   **Navigation:** Provides links to the main Replay page and the specific session recording detail page.\n*   **Session Recording ID Handling:** Accepts a session recording ID as a prop and uses it to construct the breadcrumb links.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/detail/SessionRecordingDetail.tsx",
        "summary": "The `SessionRecordingDetail.tsx` file defines the Session Recording Detail scene, which displays a specific session recording. It checks if session recordings are enabled for the current project/environment and prompts the user to enable them in project settings if they are not. If a session recording ID is provided, it renders the `SessionRecordingPlayer` component to play the recording. If no ID is provided, it displays a \"Recording Not Found\" message. The scene utilizes `kea` for state management, `LemonBanner` for displaying messages, and `PageHeader` for the page title.\n\nHere's a list of high-level product features:\n\n*   **Session Recording Playback:** Allows users to play back recorded user sessions.\n*   **Session Recording Enablement Check:** Verifies if session recordings are enabled for the current project/environment.\n*   **Project Settings Link:** Provides a direct link to the project settings page where users can enable/disable session recordings.\n*   **\"Recording Not Found\" Message:** Displays a user-friendly message when a session recording with the specified ID is not found.\n*   **Environment/Project Level Settings:** Respects whether session recording settings are configured at the environment or project level.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/detail",
        "summary": "The Session Recording Detail view allows users to view and interact with recordings of user sessions. The system checks if session recordings are enabled and prompts users to enable them if necessary, providing a direct link to project settings. If a recording ID is provided, the recording is played; otherwise, a \"Recording Not Found\" message is displayed. Breadcrumbs are generated to facilitate navigation between the main Replay page and specific session recording detail pages.\n\nHere's a list of high-level product features:\n\n*   Session Recording Playback\n*   Session Recording Enablement Check\n*   Project Settings Link\n*   \"Recording Not Found\" Message\n*   Environment/Project Level Settings\n*   Breadcrumb Generation\n*   Navigation\n*   Session Recording ID Handling\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/templates/sessionRecordingTemplatesLogic.tsx",
        "summary": "This code defines a Kea logic module for managing session recording templates in a PostHog application. It handles the state and actions related to template variables, allowing users to customize and apply filters based on these variables. The logic connects to the teamLogic to access the current team and persists variable states in local storage. It also provides selectors to derive filter groups from the variables and determine if the filters can be applied. When a template is used, it captures an event in PostHog and navigates the user to the replay tab with the applied filters.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Session Recording Template Management:** Allows users to create and manage templates for filtering session recordings.\n*   **Variable Customization:** Enables users to customize template variables such as pageviews, feature flags, and event properties.\n*   **Filter Application:** Applies filters to session recordings based on the customized template variables.\n*   **Persistent Variable State:** Saves the state of template variables in local storage for each team and template.\n*   **Navigation to Replay Tab:** Navigates the user to the session replay tab with the applied filters.\n*   **Usage Tracking:** Tracks the usage of session replay templates in PostHog.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/templates/availableTemplates.tsx",
        "summary": "This code defines a set of replay templates for session recordings. These templates provide pre-configured filters and variables to help users quickly find and analyze recordings relevant to specific user flows or behaviors. Each template includes a name, description, icon, category, and a list of variables that can be customized to match the user's specific needs. The templates cover common scenarios such as signup flows, pricing page interactions, feature usage, purchase flows, A/B test results, and more.\n\nHere's a list of high-level product features based on the code:\n\n*   **Pre-built Session Recording Templates:** Offer a library of templates for common user flows and behaviors.\n*   **Customizable Variables:** Allow users to customize the templates with specific URLs, events, and properties.\n*   **Categorized Templates:** Organize templates into categories like B2B, B2C, and More for easy browsing.\n*   **Template Descriptions:** Provide clear descriptions of each template's purpose and how to use it.\n*   **Template Icons:** Use icons to visually represent each template.\n*   **Filtering by Rageclicks:** Provide a template to filter sessions based on rageclick events.\n*   **Filtering by Person Property:** Provide a template to filter sessions based on user properties.\n*   **Filtering by Mobile Devices:** Provide a template to filter sessions based on mobile device usage.\n*   **Sorting by Activity Score:** Allow users to sort recordings by activity score to find the most active sessions.\n*   **Sorting by Start Time:** Allow users to sort recordings by start time to see the most recent sessions.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/templates/SessionRecordingTemplates.tsx",
        "summary": "This code defines a React component, `SessionRecordingTemplates`, that displays a collection of templates for filtering session recordings. These templates are categorized and presented as cards, each offering a description and the ability to define variables to customize the filtering. The component leverages Lemon UI components for styling and Kea logic for state management and actions. Users can apply these templates to navigate to session recordings filtered according to the template's criteria and the user-defined variable values.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Template-based Session Recording Filters:** Provides pre-defined templates to quickly filter session recordings based on common use cases.\n*   **Categorized Template Display:** Organizes templates into categories for easy browsing and discovery.\n*   **Variable Input for Templates:** Allows users to customize templates by defining values for variables like pageviews, events, flags, and person properties.\n*   **Dynamic Filter Application:** Applies the selected template and variable values to filter session recordings.\n*   **Lemon UI Integration:** Uses Lemon UI components for a consistent and visually appealing user interface.\n*   **Nested Filter Groups:** Supports complex filtering logic with nested filter groups for events, flags, and person properties.\n*   **Universal Filters Component:** Reuses a universal filters component for defining filter criteria.\n*   **Action and State Management with Kea:** Uses Kea logic for managing component state and actions.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/templates",
        "summary": "The session recording templates feature allows users to quickly filter and analyze session recordings based on pre-defined templates tailored to common user flows and behaviors. Users can customize these templates by defining values for variables such as pageviews, events, feature flags, and user properties, enabling them to target specific scenarios. The templates are organized into categories for easy browsing and discovery, and the system tracks template usage for insights. Applying a template navigates the user to the session replay tab with the filters automatically applied, streamlining the process of finding relevant recordings.\n\n*   Pre-built Session Recording Templates\n*   Customizable Template Variables\n*   Categorized Template Display\n*   Dynamic Filter Application\n*   Persistent Variable State\n*   Usage Tracking\n*   Navigation to Replay Tab with Applied Filters\n*   Sorting and Filtering Options (e.g., by rage clicks, activity score, start time)\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/sidebar/PlayerSidebarTab.tsx",
        "summary": "This code defines the `PlayerSidebarTab` component, which dynamically renders different tabs within a session recording player's sidebar based on the currently active tab. It uses the `playerSidebarLogic` to determine which tab is active and then renders the corresponding component. The available tabs include an overview, an inspector, a debugger, and a network waterfall view.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Session Recording Overview Tab:** Provides a general summary or overview of the session recording.\n*   **Session Recording Inspector Tab:** Allows users to inspect the details of elements within the session recording.\n*   **Session Recording Debugger Tab:** Offers debugging tools for analyzing the session recording.\n*   **Session Recording Network Waterfall Tab:** Displays a network waterfall view to analyze network requests and responses during the session.\n*   **Dynamic Tab Switching:** Enables users to switch between different tabs in the session recording player sidebar.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/sidebar/playerSidebarLogic.ts",
        "summary": "This code defines the `playerSidebarLogic` using Kea, a state management library. It manages the active tab in the session recording player's sidebar. The logic allows setting the active tab and synchronizes the tab state with the URL, enabling users to navigate between tabs using the URL and persist their tab selection across reloads. The default tab is the Inspector tab.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Sidebar Tab Navigation:** Allows users to switch between different tabs within the session recording player's sidebar (e.g., Inspector, Console, etc.).\n*   **URL-Based Tab State:** The selected tab is reflected in the URL, enabling direct linking to specific tabs and preserving the user's selection across page reloads.\n*   **Default Tab:** The Inspector tab is the default tab when no tab is specified in the URL.\n*   **Tab Persistence:** The last selected tab is remembered and restored when the user returns to the session recording player.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/sidebar/PlayerSidebarDebuggerTab.tsx",
        "summary": "The `PlayerSidebarDebuggerTab` component provides a debugging interface for session recording playback. It allows users to filter snapshots based on their type and incremental source, navigate between snapshots using a slider and previous/next buttons, and inspect the details of the previous, current, and next snapshots in a collapsible JSON viewer. This component enhances the debugging experience by providing granular control over snapshot selection and detailed information about each snapshot.\n\nHere's a list of high-level product features:\n\n*   **Snapshot Filtering:** Filter snapshots by type (e.g., FullSnapshot, IncrementalSnapshot) and incremental source (e.g., Mutation, MouseMove).\n*   **Snapshot Navigation:** Navigate between snapshots using \"Previous\" and \"Next\" buttons.\n*   **Snapshot Slider:** A slider to quickly jump to a specific snapshot in the recording.\n*   **Snapshot Inspection:** View detailed information about the previous, current, and next snapshots in a JSON format.\n*   **Snapshot Summary:** Display a summary of each snapshot, including timestamp, type, and source.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/sidebar/PlayerSidebarOverviewOtherWatchers.tsx",
        "summary": "This component displays information about other users who have watched the current session recording. It shows a loading state while the data is being fetched, a display of profile bubbles and a count of other viewers if there are any, and a message indicating that nobody else has watched the recording if there are no other viewers. The component utilizes the `sessionRecordingPlayerLogic` to access the session recording metadata and loading state.\n\nHere's a list of high-level product features:\n\n*   **Display of other viewers:** Shows profile bubbles of other users who have watched the recording.\n*   **Viewer count:** Displays the number of other users who have watched the recording.\n*   **Loading state:** Shows a loading indicator while the viewer data is being fetched.\n*   **\"Nobody else has watched\" message:** Displays a message when no other users have watched the recording.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/sidebar/PlayerSidebarOverviewGrid.tsx",
        "summary": "This component displays an overview grid in the session recording player sidebar, showing key information about the recording. It fetches overview items and a loading state from the `playerMetaLogic` using `kea`. While loading, it displays a skeleton UI. Once loaded, it renders an `OverviewGrid` with `OverviewGridItem` components for each item, displaying the item's label, value (with an optional property icon), and tooltips.\n\nHere's a list of high-level product features:\n\n*   **Session Recording Overview:** Displays key information about a session recording in a structured grid format.\n*   **Dynamic Data Fetching:** Fetches and displays session recording metadata dynamically.\n*   **Loading State:** Provides a visual loading indicator while fetching data.\n*   **Property Icons:** Displays icons alongside property values for enhanced clarity.\n*   **Tooltips:** Provides additional context for labels, values, and keys via tooltips.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/sidebar/PlayerSidebarSessionSummary.tsx",
        "summary": "This component, `PlayerSidebarSessionSummary`, displays an AI-generated summary of a session recording within the player sidebar. It conditionally renders a button to load the summary, a loading state with a spinner, or the summary itself. Once loaded, users can provide feedback on the summary's quality using thumbs up/down buttons. The entire feature is wrapped in a feature flag, `AI_SESSION_SUMMARY`, allowing it to be enabled or disabled.\n\nHere's a list of high-level product features:\n\n*   **AI Session Summary Generation:** Uses AI to automatically generate a summary of a session recording.\n*   **Session Summary Display:** Displays the generated summary to the user.\n*   **Loading State:** Shows a loading indicator while the summary is being generated.\n*   **User Feedback on Summary:** Allows users to provide feedback (thumbs up/down) on the quality of the generated summary.\n*   **Feature Flag Control:** Enables/disables the AI session summary feature via a feature flag.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/sidebar/PlayerSidebarOverviewTab.tsx",
        "summary": "This React component, `PlayerSidebarOverviewTab`, provides an overview of a session recording within a sidebar. It displays information about the person associated with the session, a grid of key session details, a list of other users currently watching the recording, and a summary of the session itself. The component leverages Kea logic hooks to access session and player metadata, and presents the information in a structured, visually appealing manner within a scrollable container.\n\n**Features:**\n\n*   **Person Display:** Shows information about the user whose session is being recorded, including their name and potentially other identifying details.\n*   **Session Details Grid:** Presents key session metrics and information in a grid format for easy consumption.\n*   **Other Watchers List:** Displays a list of other users who are currently viewing the same session recording.\n*   **Session Summary:** Provides a concise summary of the session recording, highlighting important events or actions.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/SessionRecordings.tsx",
        "summary": "The `SessionRecordings.tsx` file defines the main component for the session recordings feature in PostHog. It provides a user interface for viewing, managing, and analyzing user session recordings. The component includes features such as creating and saving playlists of recordings, viewing recent recordings based on applied filters, and accessing pre-built recording templates. It also handles scenarios where session recordings are disabled, prompting users to enable them and configure authorized domains. The UI includes warnings, banners, and product introductions to guide the user.\n\nHere's a list of high-level product features:\n\n*   **Session Recording Playlists:** Create, save, and manage playlists of session recordings based on filters or custom criteria.\n*   **Recent Recordings:** View a list of recent session recordings, filterable by various criteria.\n*   **Recording Templates:** Utilize pre-built templates for common session recording scenarios.\n*   **File Playback:** Playback session recordings from PostHog JSON files.\n*   **Session Recording Enablement:** Guide users to enable session recordings and configure authorized domains.\n*   **Notebook Integration:** Save session recording playlists to notebooks.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/sidebar",
        "summary": "The session recording player sidebar provides a comprehensive suite of tools for analyzing and understanding user sessions. It offers dynamic tab navigation, allowing users to switch between different views such as an overview of the session, a detailed inspector, a debugger for examining snapshots, and a network waterfall for analyzing network requests. The sidebar also includes features like AI-generated session summaries with user feedback, display of other viewers, snapshot filtering and navigation, and URL-based tab state persistence.\n\nHere's a list of high-level product features:\n\n*   **Sidebar Tab Navigation:** Allows users to switch between different tabs within the session recording player's sidebar (e.g., Inspector, Console, Overview, Debugger, Network).\n*   **Session Recording Overview:** Displays key information about a session recording in a structured format, including user details, session metrics, and other viewers.\n*   **Session Recording Inspector:** Allows users to inspect the details of elements within the session recording.\n*   **Session Recording Debugger:** Offers debugging tools for analyzing the session recording, including snapshot filtering, navigation, and inspection.\n*   **Session Recording Network Waterfall:** Displays a network waterfall view to analyze network requests and responses during the session.\n*   **AI Session Summary Generation:** Uses AI to automatically generate a summary of a session recording, with user feedback mechanism.\n*   **Display of other viewers:** Shows profile bubbles and count of other users who have watched the recording.\n*   **URL-Based Tab State:** The selected tab is reflected in the URL, enabling direct linking to specific tabs and preserving the user's selection across page reloads.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/eventIndex.ts",
        "summary": "This code defines the `EventIndex` class, which is responsible for indexing and filtering events within a session recording. It allows for efficient retrieval of specific event types, such as page changes and screen resolution changes, based on the player time. The class utilizes caching to optimize filtering operations. Additionally, the code provides a `findCurrent` function to locate the event that corresponds to a given player time.\n\n**Features:**\n\n*   **Event Indexing:** Creates an index of events from a session recording for efficient access.\n*   **Event Filtering:** Filters events based on specific criteria, such as page changes (href) and screen resolution.\n*   **Caching:** Caches filtered event lists to improve performance.\n*   **Time-Based Event Retrieval:** Retrieves the event that is currently active at a given player time.\n*   **Duration Calculation:** Calculates the total duration of the recording.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/RecordingNotFound.tsx",
        "summary": "The `RecordingNotFound.tsx` component displays a \"Recording Not Found\" message to the user when a requested session recording cannot be found. It suggests possible reasons for the missing recording, such as processing delays, deletion due to age, or disabled recording settings. The component also provides a direct link to the project settings page, allowing users to quickly verify and adjust their recording configurations.\n\n**Features:**\n\n*   **Displays a \"Recording Not Found\" message:** Informs the user that the requested recording is unavailable.\n*   **Provides possible reasons for the missing recording:** Helps the user understand why the recording might be missing (processing, deletion, disabled settings).\n*   **Links to project settings:** Allows users to quickly access and modify recording settings.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/utils/segmenter.ts",
        "summary": "This code segments session recording snapshots into meaningful intervals for playback. It analyzes user activity within the recording, defining activity based on events like mouse movements, scrolls, and input. The code groups snapshots by window ID and creates segments based on activity thresholds, window changes, and gaps in the recording. It also handles cases where the recording has gaps or extends beyond the available snapshots, creating \"gap\" and \"buffer\" segments to ensure continuous playback.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Session Recording Segmentation:** Divides session recordings into segments based on user activity and window changes.\n*   **Activity Detection:** Identifies active periods within a recording based on user interactions.\n*   **Gap Handling:** Inserts \"gap\" segments to represent periods of inactivity or navigation between windows.\n*   **Buffer Handling:** Adds \"buffer\" segments to fill the time between the last recorded event and the end of the session.\n*   **Window ID Tracking:** Groups snapshots by window ID to maintain context across different browser windows or tabs.\n*   **Dynamic Playback:** Enables playback of session recordings in a way that reflects user activity and navigation.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/utils/playerUtils.ts",
        "summary": "This code provides utility functions for a session recording player, focusing on user interactions and playlist management. It includes functions to handle touch and mouse events for UI interactions, specifically to determine the X position of the event. Additionally, it offers asynchronous functions to add or remove recordings from playlists and to delete recordings, with optional success notifications displayed using lemonToast. The playlist actions also include a button to navigate to the playlist view.\n\nHere's a list of high-level product features supported by this code:\n\n*   **Touch and Mouse Event Handling:** Enables interaction with the player using both touch and mouse input.\n*   **Add Recording to Playlist:** Allows users to add a session recording to a specific playlist.\n*   **Remove Recording from Playlist:** Allows users to remove a session recording from a specific playlist.\n*   **Delete Recording:** Enables users to delete a session recording.\n*   **Success Notifications:** Provides visual feedback to the user upon successful playlist or deletion actions.\n*   **Playlist Navigation:** Offers a quick way to navigate to a playlist after adding a recording.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/PlayerSidebar.tsx",
        "summary": "This code defines the `PlayerSidebar` component for a session recording player in a web application. It provides a collapsible sidebar with multiple tabs, including Overview, Inspector, Network Waterfall, and optionally Debugger (depending on feature flags and session context). The sidebar's orientation (vertical or horizontal) is configurable, and its size can be adjusted by the user. The component utilizes Lemon UI components for tabs and buttons, and Kea logic for state management.\n\n**Features:**\n\n*   **Collapsible Sidebar:** Allows users to show or hide the sidebar to maximize screen space.\n*   **Configurable Orientation:** Supports both vertical (docked to the top) and horizontal (docked to the left) orientations for the sidebar.\n*   **Resizable Sidebar:** Enables users to adjust the width or height of the sidebar.\n*   **Tabbed Interface:** Provides multiple tabs for different types of information and tools related to the session recording.\n*   **Overview Tab:** Displays general information about the session recording.\n*   **Inspector Tab:** Allows users to inspect elements within the session recording.\n*   **Network Waterfall Tab:** Visualizes the network requests made during the session.\n*   **Debugger Tab:** Provides debugging tools for the session recording (conditionally displayed).\n*   **Docking Control:** Allows users to switch the sidebar between vertical and horizontal docking.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/sessionRecordingDataLogic.ts",
        "summary": "This code defines the `sessionRecordingDataLogic` Kea logic for handling session recording data in the PostHog frontend. It's responsible for fetching, parsing, and processing session recording snapshots, including handling compressed events, mobile-specific transformations, and patching missing meta events. The logic also includes functionality for chunking large mutation snapshots, deduplicating snapshots, and creating segments for the recording. It handles various data formats and potential errors during parsing, reporting unparseable lines to PostHog for analysis.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Session Recording Playback:** Enables users to play back recorded user sessions.\n*   **Snapshot Parsing and Processing:** Parses and processes raw session recording data into a usable format.\n*   **Compressed Event Handling:** Decompresses session recording events that have been compressed for efficient storage and transmission.\n*   **Mobile Recording Support:** Transforms and adapts session recordings from mobile devices for playback in the web frontend.\n*   **Error Handling and Reporting:** Detects and reports errors during snapshot parsing, such as unparseable lines.\n*   **Snapshot Deduplication:** Removes duplicate snapshots from the recording data to ensure accurate playback.\n*   **Mutation Chunking:** Chunks large mutation snapshots to improve performance and prevent browser crashes.\n*   **Session Recording Segmentation:** Creates segments within the recording for easier navigation and analysis.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/sessionRecordingPlayerLogic.ts",
        "summary": "This code defines the `sessionRecordingPlayerLogic` Kea logic, which manages the state and behavior of a session recording player. It handles loading and managing recording snapshots, controlling playback (play, pause, seek, speed), handling buffering, managing player errors, and providing functionalities like exporting the recording to a file and deleting the recording. It also integrates with other logics such as `sessionRecordingDataLogic`, `playerSettingsLogic`, `userLogic`, and `featureFlagLogic` to provide a comprehensive session recording player experience.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Session Recording Playback:** Play, pause, seek, and control the playback speed of session recordings.\n*   **Snapshot Management:** Load and manage recording snapshots for efficient playback.\n*   **Buffering Handling:** Manage buffering states to ensure smooth playback.\n*   **Error Handling:** Detect and handle player errors, providing a robust playback experience.\n*   **Recording Export:** Export session recordings to a file for offline access or sharing.\n*   **Recording Deletion:** Delete session recordings.\n*   **Inactivity Skipping:** Automatically skip inactive periods in the recording.\n*   **Scale Adjustment:** Adjust the scale/zoom level of the recording.\n*   **Full-Screen Mode:** Toggle full-screen mode for an immersive viewing experience.\n*   **Event Exploration:** Explore events within the session recording.\n*   **Masking Window:** Mask sensitive information displayed in the recording.\n*   **Similar Recording Discovery:** Load and display similar recordings.\n*   **Next Recording Confirmation:** Confirm before automatically playing the next recording.\n*   **Debug Tools:** Debug snapshot types and incremental sources."
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/utils",
        "summary": "The provided code snippets enable several key features for a session recording player. The first focuses on intelligent segmentation of recordings based on user activity, window changes, and handling gaps or buffers in the data. The second provides utilities for user interaction, playlist management, and recording deletion, complete with notifications and navigation.\n\nHere's a list of high-level product features:\n\n*   Session Recording Segmentation\n*   Activity Detection\n*   Gap Handling\n*   Buffer Handling\n*   Window ID Tracking\n*   Dynamic Playback\n*   Touch and Mouse Event Handling\n*   Add Recording to Playlist\n*   Remove Recording from Playlist\n*   Delete Recording\n*   Success Notifications\n*   Playlist Navigation\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/view-explorer/SessionRecordingPlayerExplorer.tsx",
        "summary": "The `SessionRecordingPlayerExplorer` component provides a way to view and interact with a snapshot of a web page captured during a session recording. It renders the HTML content within an iframe, scaling it to fit the available space. The component includes a settings bar with options to reset the iframe (reloading the original HTML) and close the explorer. An informational banner is displayed to inform the user about the limitations of interacting with the snapshot and suggests using browser developer tools for inspection.\n\nHere's a list of high-level product features:\n\n*   **HTML Snapshot Display:** Renders a static HTML snapshot of a web page within an iframe.\n*   **Scaling:** Dynamically scales the iframe content to fit the available screen space.\n*   **Reset Functionality:** Provides a button to reset the iframe, reloading the original HTML content.\n*   **Close Functionality:** Allows the user to close the explorer view.\n*   **Informational Banner:** Displays a banner explaining the limitations of the snapshot and suggesting the use of browser developer tools.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/view-explorer",
        "summary": "The SessionRecordingPlayerExplorer component offers users the ability to examine a captured HTML snapshot from a session recording within an interactive iframe. It dynamically scales the content to fit the screen and includes controls for resetting the iframe to its original state and closing the explorer view. An informational banner alerts users to the limitations of interacting with the snapshot and suggests using browser developer tools for deeper inspection.\n\nHere's a list of high-level product features:\n\n*   **HTML Snapshot Display:** Renders a static HTML snapshot of a web page within an iframe.\n*   **Scaling:** Dynamically scales the iframe content to fit the available screen space.\n*   **Reset Functionality:** Provides a button to reset the iframe, reloading the original HTML content.\n*   **Close Functionality:** Allows the user to close the explorer view.\n*   **Informational Banner:** Displays a banner explaining the limitations of the snapshot and suggesting the use of browser developer tools.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/PlayerFrame.tsx",
        "summary": "The `PlayerFrame` component is responsible for rendering the actual frame where the session recording is played. It dynamically adjusts the scale of the recording based on the available space and the recording's original dimensions, ensuring it fits within the container while maintaining aspect ratio. It uses `rrweb`'s replayer to handle resizing events and updates the player's scale accordingly. The component also handles window resize events to recalculate and adjust the player dimensions when the browser window is resized.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Dynamic Scaling:** Automatically scales the session recording to fit the available space while preserving aspect ratio.\n*   **Responsive Playback:** Adapts the player size when the browser window is resized, ensuring a consistent viewing experience.\n*   **Frame Rendering:** Renders the actual frame where the session recording is displayed.\n*   **Masking Window Support:** Supports a masking window feature, potentially for privacy or focus purposes.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/controller/PlayerController.tsx",
        "summary": "The `PlayerController.tsx` file defines the controls for a session recording player. It includes functionality for play/pause, seeking forward and backward, displaying timestamps, toggling fullscreen mode, and integrating with a playlist for playing subsequent recordings. The component utilizes Kea logic for state management and actions, and leverages custom hooks for responsive breakpoints and keyboard shortcuts.\n\nHere's a list of high-level product features implemented in this file:\n\n*   **Play/Pause Control:** Allows users to start and stop the session recording playback.\n*   **Seek Functionality:** Enables users to skip forward or backward in the recording.\n*   **Timestamp Display:** Shows the current playback time of the recording.\n*   **Fullscreen Mode:** Provides a fullscreen viewing experience for the recording.\n*   **Playlist Integration:** Supports playing a sequence of recordings.\n*   **Keyboard Shortcuts:** Enables users to control the player using keyboard shortcuts.\n*   **Responsive Layout:** Adapts the player controls to different screen sizes.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/controller/seekbarLogic.ts",
        "summary": "This code defines the logic for a seekbar component used in a session recording player. It manages the position of the seekbar thumb, handles user interactions like dragging and clicking, and communicates with the main player logic to seek to specific times in the recording. The logic also handles buffering and scrubbing functionality, ensuring smooth navigation through the session recording.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Playback Navigation:** Allows users to navigate through session recordings using a visual seekbar.\n*   **Precise Seeking:** Enables users to jump to specific points in the recording by clicking or dragging the seekbar thumb.\n*   **Scrubbing:** Provides a scrubbing feature that allows users to preview the recording at different speeds by dragging the seekbar thumb.\n*   **Buffering Indication:** Displays the buffered percentage of the recording on the seekbar.\n*   **Real-time Thumb Position Updates:** Updates the thumb position on the seekbar in real-time as the recording plays.\n*   **Touch and Mouse Interaction:** Supports both touch and mouse interactions for controlling the seekbar.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/controller/UserActivity.tsx",
        "summary": "This component visualizes user activity within a session recording on the seekbar. It receives user activity data per second, calculates the corresponding x and y coordinates to represent the activity as a filled area on the seekbar, and displays it. The opacity of the activity visualization is controlled by the hover state of the seekbar, making it visible only when the user hovers over the seekbar. The height of the component is dynamically adjusted based on whether there is any activity data to display.\n\nHere's a list of high-level product features:\n\n*   **User Activity Visualization:** Displays a visual representation of user activity (e.g., clicks, scrolls) over time within a session recording.\n*   **Seekbar Integration:** Integrates the activity visualization directly into the seekbar for easy navigation and context.\n*   **Hover-Based Visibility:** Shows the activity visualization only when the user hovers over the seekbar, reducing visual clutter.\n*   **Dynamic Height Adjustment:** Adapts the height of the activity visualization area based on the presence of activity data.\n*   **Activity Intensity Mapping:** Maps the intensity of user activity to the height of the visualized area, providing a sense of activity volume.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/controller/PlayerSeekbarPreview.tsx",
        "summary": "This code defines a React component, `PlayerSeekbarPreview`, that displays a preview tooltip when hovering over the session recording player's seekbar. The tooltip shows the timestamp at the hovered position and, if the recording is short enough (less than 20 minutes), a preview frame of the recording at that point. The component uses debounced seeking to avoid excessive calls to the player when the user is scrubbing through the seekbar. It leverages Kea logic for state management and uses custom hooks for hover detection.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Seekbar Preview:** Displays a tooltip with the timestamp at the hovered position on the seekbar.\n*   **Frame Preview:** Shows a preview frame of the recording at the hovered timestamp (for recordings shorter than 20 minutes).\n*   **Debounced Seeking:** Implements debounced seeking to prevent excessive API calls while scrubbing.\n*   **Timestamp Formatting:** Supports relative and absolute timestamp formats (UTC and local).\n*   **Hover Detection:** Uses a custom hook to detect when the user is hovering over the seekbar.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/controller/PlayerSeekbarTicks.tsx",
        "summary": "This code defines the `PlayerSeekbarTicks` component, which is responsible for rendering visual markers (ticks) on the session recording player's seekbar. These ticks represent events or comments within the recording, allowing users to quickly navigate to specific points of interest. The component receives a list of `seekbarItems` (events or comments), the total recording duration (`endTimeMs`), and a function to seek to a specific time (`seekToTime`). Each tick is positioned on the seekbar according to its timestamp within the recording. When a tick is clicked, the player seeks to the corresponding time. The component also includes a `UserActivity` component, likely visualizing user interactions over time.\n\nHere's a list of high-level product features related to this code:\n\n*   **Seekbar Event Markers:** Display visual markers on the seekbar representing events (e.g., autocaptured events, pageviews) that occurred during the session recording.\n*   **Seekbar Comment Markers:** Display visual markers on the seekbar representing comments added to the session recording.\n*   **Event/Comment Navigation:** Allow users to click on event/comment markers to quickly navigate to that point in the session recording.\n*   **Event Information Display:** Show event details (e.g., event name, URL for pageviews) when hovering over or clicking on an event marker.\n*   **Comment Information Display:** Show comment text when hovering over or clicking on a comment marker.\n*   **User Activity Visualization:** Display a visual representation of user activity over time on the seekbar.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/controller/PlayerControllerTime.tsx",
        "summary": "This code defines React components for displaying and controlling the timestamp and seeking functionality within a session recording player. It includes components for displaying the current timestamp in either relative or absolute formats, as well as buttons for skipping forward or backward in the recording by a specified duration or by a single frame. The components leverage Kea logic for state management and actions, and utilize tooltips and keyboard shortcuts to enhance the user experience.\n\n**Features:**\n\n*   **Timestamp Display:** Displays the current timestamp of the session recording, with options for relative or absolute time formats.\n*   **Relative Timestamp:** Shows the elapsed time relative to the start of the recording, along with the total duration.\n*   **Absolute Timestamp:** Displays the actual date and time of the recording at the current point.\n*   **Seek Skip:** Allows users to skip forward or backward in the recording by a configurable duration.\n*   **Frame-by-Frame Stepping:** Enables users to move forward or backward by a single frame.\n*   **Keyboard Shortcuts:** Provides keyboard shortcuts for seeking and frame-by-frame stepping.\n*   **Customizable Jump Time:** Allows configuration of the jump time for seek skip functionality.\n*   **Tooltip Information:** Displays helpful tooltips with information about the seek skip duration and keyboard shortcuts.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/controller/Seekbar.tsx",
        "summary": "This code defines the Seekbar component for a session recording player. The Seekbar allows users to scrub through a recording, visualizing active and inactive periods as segments on the bar. It also displays buffer progress, a current time indicator, and optional preview thumbnails at specific points in the recording. The component uses several Kea logics to manage state and actions related to the player, data, settings, inspector, and the seekbar itself. It also handles mouse and touch events for scrubbing functionality.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Visual Scrubbing:** Allows users to navigate through the session recording by dragging a thumb along a timeline.\n*   **Active/Inactive Segment Visualization:** Displays periods of activity and inactivity within the recording as distinct segments on the seekbar.\n*   **Buffering Indication:** Shows the loading progress of the recording via a buffer bar.\n*   **Time Display:** Indicates the current playback time.\n*   **Seekbar Ticks:** Displays interactive ticks on the seekbar to jump to specific points in the recording.\n*   **Preview Thumbnails:** Shows preview images at different points in the recording when scrubbing (if snapshots are available).\n*   **Timestamp Formatting:** Allows the user to configure the timestamp format.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/controller",
        "summary": "The session recording player features a comprehensive suite of controls and visualizations designed to enhance user experience and facilitate efficient analysis of recorded sessions. These features include precise playback navigation, visual representations of user activity and key events, and customizable display options. The player integrates seamlessly with playlists and offers responsive design and keyboard shortcuts for optimal usability across devices.\n\nHere's a list of high-level product features:\n\n*   **Playback Navigation:** Allows users to play, pause, seek, and scrub through session recordings.\n*   **Visual Scrubbing:** Enables users to navigate through the session recording by dragging a thumb along a timeline.\n*   **Active/Inactive Segment Visualization:** Displays periods of activity and inactivity within the recording as distinct segments on the seekbar.\n*   **User Activity Visualization:** Displays a visual representation of user activity (e.g., clicks, scrolls) over time within a session recording.\n*   **Seekbar Event/Comment Markers:** Display visual markers on the seekbar representing events and comments, allowing for quick navigation to specific points of interest.\n*   **Seekbar Preview:** Displays a tooltip with the timestamp and a preview frame at the hovered position on the seekbar.\n*   **Timestamp Display:** Shows the current playback time of the recording in relative or absolute formats.\n*   **Seek Skip:** Allows users to skip forward or backward in the recording by a configurable duration or by a single frame.\n*   **Fullscreen Mode:** Provides a fullscreen viewing experience for the recording.\n*   **Playlist Integration:** Supports playing a sequence of recordings.\n*   **Keyboard Shortcuts:** Enables users to control the player using keyboard shortcuts.\n*   **Responsive Layout:** Adapts the player controls to different screen sizes.\n*   **Buffering Indication:** Shows the loading progress of the recording via a buffer bar.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/SessionRecordingNextConfirmation.tsx",
        "summary": "This React component, `SessionRecordingNextConfirmation`, is a modal that appears after a user finishes watching a session recording. It asks the user if they would like to mark similar recordings as viewed. The modal displays a list of similar recordings with links to view each one. Users can choose to either mark the similar recordings as viewed or dismiss the modal.\n\nHere's a list of high-level product features:\n\n*   **Confirmation Modal:** Displays a modal to confirm if the user wants to mark similar recordings as viewed.\n*   **Similar Recordings List:** Shows a list of similar recordings within the modal.\n*   **View Recording Links:** Provides links to view each similar recording in the list.\n*   **Mark as Viewed Action:** Allows the user to mark all similar recordings as viewed.\n*   **Dismiss Action:** Allows the user to dismiss the modal without marking recordings as viewed.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/rrweb/canvas/deserialize-canvas-args.ts",
        "summary": "This code provides a function, `deserializeCanvasArg`, that is responsible for converting serialized canvas arguments back into their original JavaScript objects during the replay of a recorded session. It handles various data types, including images, blobs, and other complex objects, by recursively deserializing their properties. It also manages a map of WebGL variables to maintain state across different canvas operations. The function is designed to be used within a rrweb replayer to accurately reproduce canvas drawings and animations.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Canvas Recording and Replay:** Enables the recording of canvas elements and their subsequent playback in session recordings.\n*   **WebGL Support:** Allows for the accurate recording and replay of WebGL-based graphics and animations.\n*   **Image and Blob Handling:** Supports the serialization and deserialization of images and blobs used within canvas operations.\n*   **Complex Object Deserialization:** Handles the conversion of serialized complex JavaScript objects back into their original form for accurate replay.\n*   **State Management:** Maintains the state of WebGL variables across different canvas operations during replay.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/rrweb/canvas/canvas-plugin.ts",
        "summary": "This code implements a plugin for the rrweb (record and replay web) library that enables the replay of canvas mutations within a recorded web session. It intercepts canvas-related events, deserializes canvas commands and arguments, and applies these mutations to a cloned canvas element during replay. The plugin optimizes performance by preloading and buffering canvas events, and it handles synchronous scrubbing by processing only the most recent event. It also converts the canvas into an image for display.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Canvas Recording and Replay:** Records and replays canvas drawings and animations within user sessions.\n*   **Asynchronous Canvas Command Deserialization:** Deserializes canvas commands asynchronously to avoid blocking the main thread.\n*   **Canvas Preloading and Buffering:** Preloads and buffers canvas events to improve replay performance and smoothness.\n*   **Synchronous Scrubbing Support:** Handles scrubbing through the recording by processing only the most recent canvas event.\n*   **Canvas to Image Conversion:** Converts the canvas element into an image for display during replay.\n*   **Error Handling:** Catches and reports errors during canvas mutation processing.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/SessionRecordingPlayer.tsx",
        "summary": "The `SessionRecordingPlayer` component provides a comprehensive interface for viewing and interacting with session recordings. It includes features for playback control, speed adjustment, full-screen mode, event exploration, and integration with notebooks. The player adapts to different screen sizes and offers a sidebar for additional settings and information. It also handles cases where the recording is not found or is still being processed.\n\nHere's a list of high-level product features:\n\n*   **Session Recording Playback:** Plays back user session recordings with controls for play/pause, seeking, and speed adjustment.\n*   **Full-Screen Mode:** Allows users to view recordings in full-screen mode.\n*   **Event Exploration:** Provides a way to explore events within the session recording.\n*   **Notebook Integration:** Enables users to drag and drop session recordings into notebooks.\n*   **Responsive Design:** Adapts the player layout to different screen sizes.\n*   **Player Sidebar:** Offers a sidebar for additional settings and information related to the recording.\n*   **Keyboard Hotkeys:** Supports keyboard shortcuts for playback control and other actions.\n*   **Loading and Error Handling:** Handles cases where the recording is not found or is still being processed.\n*   **Playback Speed Control:** Allows users to adjust the playback speed of the recording.\n*   **Session Recording Metadata:** Displays metadata associated with the session recording.\n*   **Next Session Confirmation:** Confirms with the user before playing the next session in a playlist.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/rrweb/canvas",
        "summary": "This code enables comprehensive canvas recording and replay functionality within session recordings. It achieves this by intercepting and deserializing canvas commands, handling various data types including images, blobs, and WebGL elements, and applying these mutations to a cloned canvas during replay. The system optimizes performance through preloading, buffering, and asynchronous processing, while also supporting synchronous scrubbing and converting the canvas to an image for display.\n\nHere's a list of high-level product features enabled by this code:\n\n*   Canvas Recording and Replay\n*   WebGL Support\n*   Image and Blob Handling\n*   Complex Object Deserialization\n*   State Management\n*   Asynchronous Canvas Command Deserialization\n*   Canvas Preloading and Buffering\n*   Synchronous Scrubbing Support\n*   Canvas to Image Conversion\n*   Error Handling\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/rrweb/index.ts",
        "summary": "This code provides plugins and configurations for the rrweb replay player used in PostHog session recordings. It includes a `CorsPlugin` to handle cross-origin resource loading issues by proxying font, JavaScript, and CSS URLs. The `WindowTitlePlugin` extracts and updates the window title during replay, enabling dynamic title tracking. The `HLSPlayerPlugin` integrates HLS.js to support playing HLS video streams within the replay. Finally, it defines default style rules and a common replayer configuration to enhance the replay experience.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Cross-Origin Resource Handling:** Enables replay of sessions that load resources from different domains, resolving CORS issues.\n*   **Dynamic Window Title Tracking:** Accurately displays and updates the window title during session replay.\n*   **HLS Video Playback:** Supports playback of HLS video streams within session recordings.\n*   **Enhanced Replay Styling:** Provides default styles and fixes to improve the visual fidelity of session replays.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/rrweb",
        "summary": "The provided code snippets enable a robust session recording and replay experience within PostHog, focusing on accurate reproduction of user interactions. This is achieved through features like canvas recording and replay with WebGL support, handling of various data types, and asynchronous processing for performance optimization. Additionally, the system addresses cross-origin resource loading, dynamically updates window titles, supports HLS video playback, and provides enhanced styling for improved visual fidelity.\n\nHere's a list of high-level product features:\n\n*   Canvas Recording and Replay with WebGL Support\n*   Cross-Origin Resource Handling (CORS)\n*   Dynamic Window Title Tracking\n*   HLS Video Playback Support\n*   Enhanced Replay Styling\n*   Synchronous Scrubbing Support\n*   Canvas to Image Conversion\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/icons.tsx",
        "summary": "This code defines a React component called `IconWindow` that displays a value (number or string) inside a colored circle. The component is designed to be used as an icon, and its appearance can be customized with different sizes (small or medium) and additional CSS classes. The value displayed is either the number itself or the first character of the string.\n\nHere's a list of high-level product features that can be derived from this code:\n\n*   **Icon Display:** Ability to display icons with a value inside a circle.\n*   **Customizable Size:** Option to render the icon in different sizes (small, medium).\n*   **Text Representation:** Display either a number or the first character of a string inside the icon.\n*   **Styling:** Customizable styling through CSS classes.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/player-meta/PlayerPersonMeta.tsx",
        "summary": "This React component, `PlayerPersonMeta`, displays a user's icon or a loading skeleton within the session recording player. Clicking the icon opens the player sidebar, specifically setting the active tab to the \"Overview\" tab. This allows users to quickly access and view details related to the person associated with the session recording.\n\n**Features:**\n\n*   **Person Icon Display:** Shows the icon of the user associated with the session recording.\n*   **Loading State:** Displays a skeleton loader while the user's information is being fetched.\n*   **Sidebar Navigation:** Clicking the icon opens the session recording player sidebar.\n*   **Overview Tab Activation:** Automatically sets the sidebar tab to \"Overview\" when the icon is clicked.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/player-meta/PlayerMetaBottomSettings.tsx",
        "summary": "This component, `PlayerMetaBottomSettings`, renders the settings controls at the bottom of the session recording player. It includes features for adjusting playback speed, setting the timestamp format (UTC, Device, Relative), toggling the skipping of inactive periods in the recording, and inspecting the DOM at a specific point in the recording. It also includes a button to open the player inspector. The layout adapts to different screen sizes, with some settings being moved into a dropdown menu on smaller screens.\n\nHere's a list of the high-level product features implemented in this component:\n\n*   **Playback Speed Control:** Allows users to adjust the playback speed of the session recording.\n*   **Timestamp Format Selection:** Enables users to choose the timestamp format (UTC, Device, or Relative) displayed during playback.\n*   **Skip Inactivity Toggle:** Lets users skip over periods of inactivity in the recording.\n*   **DOM Inspection:** Provides a tool to inspect the DOM at a specific point in the session recording.\n*   **Player Inspector:** Opens a panel with more detailed information and controls for the session recording player.\n*   **Show Mouse Tail:** Toggles the display of a tail following the mouse cursor.\n*   **Responsive Layout:** Adapts the layout of the settings controls to different screen sizes."
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/player-meta/PlayerMetaLinks.tsx",
        "summary": "This code defines the UI components for the session recording player's meta information section, specifically the links and actions available to the user. It includes features for pinning recordings to playlists, adding comments to notebooks, sharing recordings, downloading recording data, and deleting recordings. The UI adapts based on screen size and user permissions, offering different options and layouts for different contexts.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Pin to Playlist:** Allows users to pin or unpin session recordings to/from a playlist.\n*   **Add to Notebook:** Enables users to add session recordings or comments about specific timestamps within the recording to a notebook.\n*   **Share Recording:** Provides functionality to share the current session recording.\n*   **Download Recording Data:** Allows users to download the session recording data as a JSON file.\n*   **Delete Recording:** Enables users to delete the session recording.\n*   **Mobile Recording Export (Debug):** Provides a debug option (only visible to PostHog staff) to export the untransformed mobile recording data.\n*   **Contextual UI:** Adapts the available actions and layout based on the screen size and the current mode of the session recording player.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/player-meta/PlayerMeta.tsx",
        "summary": "The `PlayerMeta.tsx` component provides a user interface for displaying and interacting with metadata related to a session recording player. It shows information such as the current URL or screen being viewed, the resolution and scale of the recording, and allows users to select which window to track in multi-window recordings. It also integrates with the PostHog toolbar, allowing users to drag the recording to a notebook. The component adapts its layout based on screen size and player mode (standard or sharing).\n\nHere's a list of high-level product features implemented by the code:\n\n*   **Display Current URL/Screen:** Shows the URL or screen name being viewed in the recording.\n*   **Window Tracking:** Allows users to select and follow a specific window in multi-window session recordings.\n*   **Resolution and Scale Information:** Displays the original resolution of the recording and the current scale being viewed.\n*   **Session Recording Metadata:** Provides a container for all session recording metadata.\n*   **Adaptable Layout:** Adjusts the layout based on screen size (small/normal) and player mode (standard/sharing).\n*   **Notebook Integration:** Allows users to drag the recording to a PostHog notebook.\n*   **Whitelabel Support:** Hides the PostHog logo in sharing mode when whitelabeling is enabled.\n*   **Copy URL to Clipboard:** Allows users to copy the current URL to their clipboard.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/player-meta/playerMetaLogic.tsx",
        "summary": "This code defines the `playerMetaLogic` Kea logic for managing and displaying metadata related to a session recording player. It fetches and processes data about the recording, including its duration, start time, event counts (clicks, keypresses, errors), and properties of the associated person and recording. The logic provides selectors to format and present this information in a user-friendly way, such as displaying the resolution, scale, and start/end times of the recording. It also handles session summary requests and feedback.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Display Session Recording Metadata:** Shows key information about a session recording, such as start time, duration, and event counts (clicks, keypresses, console errors).\n*   **Show Person and Recording Properties:** Displays relevant properties associated with the user and the recording itself, including OS, browser, device type, and location data.\n*   **Dynamic Resolution and Scale Display:** Presents the current resolution and scale of the recording player, updating as the player progresses.\n*   **Session Summary:** Provides a summarized textual overview of the session recording.\n*   **Tracked Window Management:** Manages and displays information related to the tracked window within the session recording.\n*   **Geographic Location Display:** Shows the geographic location (country, region, city) of the user during the recording.\n*   **URL Tracking:** Displays the last visited URL during the session recording.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/player-meta",
        "summary": "The session recording player metadata components provide a comprehensive suite of features for analyzing and interacting with session recordings. These components display key information about the recording, such as timestamps, duration, resolution, and user properties, and offer tools for controlling playback, inspecting the DOM, and sharing or managing the recording. The UI adapts to different screen sizes and user roles, ensuring a consistent and user-friendly experience.\n\nHere's a list of the high-level product features:\n\n*   Playback Speed Control\n*   Timestamp Format Selection (UTC, Device, Relative)\n*   Skip Inactivity Toggle\n*   DOM Inspection\n*   Player Inspector\n*   Show Mouse Tail\n*   Display Session Recording Metadata (start time, duration, event counts)\n*   Show Person and Recording Properties (OS, browser, device, location)\n*   Dynamic Resolution and Scale Display\n*   Session Summary\n*   Tracked Window Management\n*   Geographic Location Display\n*   URL Tracking\n*   Display Current URL/Screen\n*   Window Tracking (multi-window recordings)\n*   Notebook Integration\n*   Pin to Playlist\n*   Add to Notebook (comments at specific timestamps)\n*   Share Recording\n*   Download Recording Data\n*   Delete Recording\n*   Person Icon Display with Sidebar Navigation to Overview\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/playlist-popover/playlistPopoverLogic.ts",
        "summary": "This code defines the logic for a playlist popover component within a session recording player. It manages the display of existing playlists, allows users to create new playlists, and enables adding or removing the current session recording from those playlists. The logic handles searching for playlists, loading playlists associated with a recording, and managing the state of the popover's visibility and new playlist form. It also tracks usage events related to pinning recordings to playlists and creating new playlists.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Playlist Management:** Allows users to create, view, and search for session recording playlists.\n*   **Session Recording Pinning:** Enables users to add or remove the current session recording from existing playlists.\n*   **Playlist Creation from Popover:** Provides a form within the popover to create new playlists directly.\n*   **Searchable Playlists:** Allows users to search for playlists by name.\n*   **Contextual Playlists:** Loads and displays playlists that already contain the current session recording.\n*   **UI State Management:** Manages the visibility of the playlist popover and the new playlist form.\n*   **Usage Tracking:** Tracks user interactions such as pinning recordings to playlists and creating new playlists.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/playlist-popover/PlaylistPopover.tsx",
        "summary": "This code defines a `PlaylistPopoverButton` component for a session recording player. This component allows users to manage playlists associated with a session recording. Users can create new playlists, search existing playlists, and add or remove the current session recording from those playlists. The popover displays a list of playlists with checkboxes to indicate whether the current recording is in each playlist. It also provides a link to open the playlist in a new tab. The component handles loading states and displays appropriate messages when no playlists are found.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Playlist Creation:** Allows users to create new playlists directly from the session recording player.\n*   **Playlist Search:** Enables users to search for existing playlists to quickly find and manage them.\n*   **Session Recording Assignment to Playlists:** Allows users to add or remove the current session recording from multiple playlists.\n*   **Playlist Navigation:** Provides a direct link to open a selected playlist in a new tab.\n*   **Loading State Management:** Displays loading indicators while fetching or modifying playlists.\n*   **Empty State Handling:** Shows a message when no playlists are found.\n*   **Pinning in Current Playlist:** Allows pinning/unpinning the current session recording in the currently viewed playlist."
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/playlist-popover",
        "summary": "The provided code implements a playlist popover component within a session recording player, enabling users to manage playlists associated with the current recording. This includes creating new playlists, searching existing ones, and adding or removing the current session recording from those playlists. The component provides a user-friendly interface with loading states, empty state handling, and direct links to open playlists in a new tab, enhancing the overall session recording management experience.\n\nHere's a list of high-level product features:\n\n*   Playlist Creation: Allows users to create new playlists directly from the session recording player.\n*   Playlist Management: Allows users to create, view, and search for session recording playlists.\n*   Playlist Search: Enables users to search for existing playlists to quickly find and manage them.\n*   Session Recording Assignment to Playlists: Allows users to add or remove the current session recording from multiple playlists.\n*   Playlist Navigation: Provides a direct link to open a selected playlist in a new tab.\n*   Loading State Management: Displays loading indicators while fetching or modifying playlists.\n*   Empty State Handling: Shows a message when no playlists are found.\n*   Pinning in Current Playlist: Allows pinning/unpinning the current session recording in the currently viewed playlist.\n*   Contextual Playlists: Loads and displays playlists that already contain the current session recording.\n*   UI State Management: Manages the visibility of the playlist popover and the new playlist form.\n*   Usage Tracking: Tracks user interactions such as pinning recordings to playlists and creating new playlists.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/modal/sessionPlayerModalLogic.ts",
        "summary": "This code defines a Kea logic module called `sessionPlayerModalLogic` that manages the state and behavior of a session recording player modal. It handles opening and closing the modal, storing the active session recording and initial timestamp, and synchronizing the modal's state with the URL using `kea-router`. This allows users to share and bookmark specific session recordings and timestamps.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Open Session Recording Player Modal:** Allows users to open a modal to view a specific session recording.\n*   **Close Session Recording Player Modal:** Allows users to close the session recording player modal.\n*   **Specify Initial Timestamp:** Allows users to specify a timestamp to start the session recording from.\n*   **URL Synchronization:** Synchronizes the session recording ID and timestamp with the URL, enabling sharing and bookmarking.\n*   **Maintains Active Session Recording:** Stores the currently active session recording in the logic.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/modal/SessionPlayerModal.tsx",
        "summary": "The `SessionPlayerModal` component provides a modal interface for playing session recordings within the PostHog application. It leverages the `SessionRecordingPlayer` component and associated logic to display and control the playback of a selected session recording. The modal dynamically adjusts its size and controls based on the playback state, including full-screen mode. It also displays metadata about the recording via the `PlayerMeta` component. The modal is designed to be instantiated once within the application to avoid playback conflicts.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Session Recording Playback:** Plays back user session recordings.\n*   **Modal Interface:** Presents the session recording player within a modal window.\n*   **Fullscreen Support:** Allows users to view session recordings in fullscreen mode.\n*   **Session Metadata Display:** Shows relevant metadata about the session recording, such as user properties and timestamps.\n*   **Automatic Playback:** Autoplays the session recording when the modal is opened.\n*   **Event Matching:** Highlights specific events within the session recording based on UUIDs.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/modal",
        "summary": "The `SessionPlayerModal` component and its associated logic provide a comprehensive modal interface for playing session recordings within PostHog. It manages the modal's state, including opening, closing, and synchronizing with the URL for sharing and bookmarking. The modal features a session recording player with fullscreen support, automatic playback, and the ability to highlight specific events. It also displays relevant metadata about the session recording.\n\nHere's a list of high-level product features:\n\n*   Session Recording Playback\n*   Modal Interface\n*   Fullscreen Support\n*   Session Metadata Display\n*   Automatic Playback\n*   Event Matching\n*   Open Session Recording Player Modal\n*   Close Session Recording Player Modal\n*   Specify Initial Timestamp\n*   URL Synchronization\n*   Maintains Active Session Recording\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/share/PlayerShareMenu.tsx",
        "summary": "The `PlayerShareMenu` component provides a dropdown menu within the session recording player that allows users to share the current recording via different methods. It leverages the `sessionRecordingPlayerLogic` to access the current recording ID and player time, and to control the player state (pause, fullscreen). When a share option is selected, it opens a share dialog with the current timestamp, recording ID, and selected share type.\n\nHere's a list of the high-level product features:\n\n*   **Share Private Link:** Generates a shareable link that requires authentication to view the session recording.\n*   **Share Public Link:** Generates a shareable link that is publicly accessible without authentication.\n*   **Share to Linear:** Integrates with Linear (a project management tool) to share the session recording to a Linear issue.\n*   **Timestamped Sharing:** Shares the recording with a link that starts at the current playback time.\n*   **Pause on Share:** Automatically pauses the recording when a share option is selected.\n*   **Exit Fullscreen on Share:** Automatically exits fullscreen mode when a share option is selected.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/share/PlayerShare.tsx",
        "summary": "This code defines the `PlayerShare` component, which provides different ways to share a session recording from PostHog. It offers options to share a private link (accessible only to users with access to the PostHog project), a public link (accessible to anyone), or to create a Linear issue with a link to the recording. The component includes forms for customizing the shared link, such as specifying a start time. It uses Lemon UI components for the UI elements and kea for state management.\n\nHere's a list of high-level product features:\n\n*   **Private Link Sharing:** Generates a shareable link to the recording that requires PostHog project access.\n*   **Public Link Sharing:** Generates a shareable link to the recording that is accessible to anyone.\n*   **Linear Integration:** Creates a Linear issue with a link to the session recording.\n*   **Timestamp Support:** Allows specifying a start time for the recording in the shared link.\n*   **Customizable Issue Creation:** Allows users to customize the title and description of the Linear issue.\n*   **Copy to Clipboard:** Provides a button to easily copy the private link to the clipboard.\n*   **Sharing Modal:** Provides a modal for sharing the recording with different options.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/PlayerUpNext.tsx",
        "summary": "The `PlayerUpNext` component in the session recordings player provides a user interface element to automatically or manually play the next recording in a playlist. It displays a \"Play Next\" button with an animation that triggers when the current recording ends and there are no similar recordings. The component also handles keyboard shortcuts for navigating to the next recording and includes a tooltip to inform the user about the keyboard shortcut. The animation can be interrupted if the user interacts with the player.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Automatic Playback of Next Recording:** Automatically transitions to the next recording in the playlist when the current recording ends (if no similar recordings are available).\n*   **Manual Navigation to Next Recording:** Provides a button to manually skip to the next recording in the playlist.\n*   **Keyboard Shortcut for Next Recording:** Implements a keyboard shortcut (\"n\") to quickly navigate to the next recording.\n*   **Visual Cue for Automatic Playback:** Displays an animation to indicate that the next recording will play automatically.\n*   **Tooltip with Keyboard Shortcut Information:** Shows a tooltip on the \"Play Next\" button, displaying the keyboard shortcut for easy discovery.\n*   **Animation Interruption:** Stops the automatic playback animation if the user interacts with the player.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/playerSettingsLogic.ts",
        "summary": "This code defines a Kea logic module called `playerSettingsLogic` that manages persistent settings for the session recording player. It includes actions to modify settings like playback speed, timestamp format, autoplay direction, visibility of viewed recordings, and UI preferences such as sidebar stacking and filter visibility. The logic persists these settings using the `persist: true` option in the reducers, ensuring they are retained across sessions. It also tracks user interactions with speed and skip inactivity settings via PostHog and provides URL integration for debugging purposes.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Playback Speed Control:** Allows users to adjust the playback speed of session recordings.\n*   **Timestamp Formatting:** Enables users to choose between relative, UTC, or device-based timestamp formats.\n*   **Autoplay Direction:** Lets users configure the direction in which recordings are automatically played (older or newer).\n*   **Viewed Recordings Filtering:** Provides options to hide recordings that have been viewed by the current user or any user.\n*   **UI Customization:** Allows users to customize the player's UI, including sidebar stacking (horizontal or vertical), filter visibility, and the visibility of the mouse tail.\n*   **Quick Filters:** Enables users to quickly filter recordings based on predefined properties.\n*   **Skip Inactivity:** Allows users to skip periods of inactivity in the recording.\n*   **Playlist Management:** Allows users to open and close the playlist.\n*   **Sidebar Management:** Allows users to open and close the sidebar.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/share/playerShareLogic.ts",
        "summary": "This code defines a Kea logic module called `playerShareLogic` that manages the state and logic for generating shareable links for session recordings. It uses Kea Forms to handle form state and validation for both private and Linear (issue tracking) link generation. The logic takes a session recording ID and current time (in seconds) as props, and provides selectors to generate the final URLs with appropriate query parameters. The private link allows sharing a recording with a specific timestamp, while the Linear link generates a URL pre-filled with the recording link, title, and description for creating a new issue.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Private Link Generation:** Creates a shareable link to a specific session recording.\n*   **Timestamped Sharing:** Allows including a specific timestamp in the shared link, enabling viewers to jump directly to that point in the recording.\n*   **Form Validation:** Validates the timestamp input to ensure it's in the correct format.\n*   **Linear Integration:** Generates a pre-filled URL for creating a new issue in Linear, including the session recording link, title, and description.\n*   **Customizable Issue Details:** Allows users to specify the title and description for the Linear issue.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/share",
        "summary": "The session recording player offers comprehensive sharing capabilities, allowing users to easily distribute recordings with colleagues or integrate them into their workflow. Users can generate private links for internal sharing, create public links for broader access, or seamlessly create Linear issues pre-populated with recording details. The sharing process supports specifying timestamps to highlight specific moments and automatically pauses the recording and exits fullscreen mode for a streamlined experience.\n\nHere's a list of high-level product features:\n\n*   Private Link Sharing: Generates shareable links accessible only to users with project access.\n*   Public Link Sharing: Creates shareable links accessible to anyone.\n*   Linear Integration: Enables creating Linear issues with pre-filled session recording details.\n*   Timestamp Support: Allows specifying a start time for shared recordings.\n*   Customizable Issue Creation: Provides options to customize the title and description of Linear issues.\n*   Copy to Clipboard: Simplifies sharing by providing a button to copy links.\n*   Sharing Modal: Offers a centralized interface for selecting sharing options.\n*   Pause on Share: Automatically pauses the recording when sharing.\n*   Exit Fullscreen on Share: Automatically exits fullscreen mode when sharing.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player/PlayerFrameOverlay.tsx",
        "summary": "The `PlayerFrameOverlay` component provides a visual overlay on the session recording player, displaying different content based on the player's current state. It handles states like buffering, error, paused, and skipping inactivity, providing appropriate icons and messages to the user. It also includes functionality to reload the recording or contact support in case of an error. The overlay includes a play/pause toggle on click.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Buffering Indication:** Displays a \"Buffering…\" message when the recording is loading.\n*   **Error Handling:** Shows an error message with options to reload the recording or contact support if the recording fails to play.\n*   **Play/Pause Indication:** Displays a play or pause icon based on the player's state.\n*   **Skip Inactivity Indication:** Shows a \"Skipping inactivity\" message when the player is skipping periods of inactivity.\n*   **End Reached Indication:** Displays a sync icon when the end of the recording is reached.\n*   **Play/Pause Toggle:** Toggles the play/pause state of the recording when the overlay is clicked.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings/player",
        "summary": "The session recording player provides a comprehensive suite of tools for analyzing user behavior, debugging issues, and sharing insights. It offers features such as dynamic playback control, detailed session overviews, AI-powered summaries, and network analysis tools. The player also supports customizable settings, responsive design, and integrations with other platforms like Linear and notebooks, ensuring a seamless and efficient user experience.\n\nHere's a list of high-level product features:\n\n*   **Session Recording Playback:** Play, pause, seek, control speed, and skip inactivity in session recordings.\n*   **Session Analysis Tools:** Includes an inspector, debugger, network waterfall, and AI-generated summaries.\n*   **Session Overview:** Displays key information about a session, including user details and session metrics.\n*   **Event Indexing and Filtering:** Efficiently retrieve and filter events based on time and criteria.\n*   **Error Handling and Reporting:** Detects and reports errors during playback and data processing.\n*   **Customizable Settings:** Adjust playback speed, timestamp format, UI preferences, and more.\n*   **Sharing and Collaboration:** Generate private or public links, integrate with Linear, and add comments to specific timestamps.\n*   **Playlist Management:** Create, manage, and navigate playlists of session recordings.\n*   **Responsive Design:** Adapts to different screen sizes and devices.\n*   **Keyboard Shortcuts:** Control the player using keyboard shortcuts.\n*   **Snapshot Management:** Load, parse, and process recording snapshots.\n*   **Mobile Recording Support:** Transforms and adapts session recordings from mobile devices.\n*   **Visualizations:** Displays user activity, events, and comments on the seekbar.\n*   **Full-Screen Mode:** Provides an immersive viewing experience.\n*   **Notebook Integration:** Enables users to drag and drop session recordings into notebooks.\n*   **Similar Recording Discovery:** Load and display similar recordings.\n*   **Masking Window:** Mask sensitive information displayed in the recording.\n*   **Dynamic Scaling:** Automatically scales the session recording to fit the available space.\n*   **Canvas Recording and Replay with WebGL Support**\n*   **Playlist Management:** Allows users to create, view, and search for session recording playlists.\n*   **Session Recording Segmentation**\n*   **HTML Snapshot Display:** Renders a static HTML snapshot of a web page within an iframe.\n"
    },
    {
        "path": "frontend/src/scenes/session-recordings",
        "summary": "The PostHog session recording feature provides a comprehensive suite of tools for capturing, analyzing, and managing user session recordings, enabling users to gain deep insights into user behavior and application performance. This includes advanced filtering, AI-powered search, customizable playlists, and detailed session analysis tools, all designed to streamline the process of identifying and resolving issues, optimizing user experiences, and improving overall application performance. The system supports various data sources, including web and mobile applications, and offers features for masking sensitive data, sharing recordings, and integrating with other platforms like Linear and notebooks.\n\nHere's a list of high-level product features:\n\n*   Session Recording Playback & Navigation: Play, pause, seek, control speed, and skip inactivity in session recordings.\n*   Advanced Filtering & Search: Filter recordings by date, duration, events, actions, cohorts, session properties, HogQL expressions, feature flags, and use AI-powered search with natural language queries.\n*   Playlist Management: Create, edit, duplicate, delete, pin, and share playlists of session recordings.\n*   Session Analysis Tools: Includes an inspector, debugger, network waterfall, AI-generated summaries, and APM integration for detailed performance analysis.\n*   Customizable Settings: Adjust playback speed, timestamp format, UI preferences, masking levels, and more.\n*   Sharing & Collaboration: Generate private or public links, integrate with Linear, and add comments to specific timestamps.\n*   File Upload & Playback: Upload and play back session recordings from files.\n*   Template-Based Analysis: Utilize pre-built templates for common session recording scenarios and customize them with variables.\n*   User Identification & Activity Metrics: Display user details, session metrics, and activity indicators within recordings.\n*   Integration with Other Tools: Seamlessly integrate with PostHog notebooks and other platforms.\n*   Mobile Recording Support: Transforms and adapts session recordings from mobile devices.\n*   Session Recording Segmentation: Segment session recordings based on various criteria.\n*   Command Palette Integration: Quickly find and watch session recordings based on different criteria using the command palette.\n*   Session Recording Masking: Provides different levels of masking for sensitive data in session recordings.\n*   Timestamp Formatting: Allows users to view timestamps in different formats (relative, UTC, device).\n"
    },
    {
        "path": "frontend/src/scenes/instance/AsyncMigrations/asyncMigrationParameterFormLogic.ts",
        "summary": "This code defines a Kea logic module named `asyncMigrationParameterFormLogic` responsible for managing a form related to async migration parameters. It utilizes the `kea-forms` plugin to handle form state and submission. The form's default values are dynamically populated based on the migration's parameter definitions and existing parameters, prioritizing existing values if available. On form submission, the `updateMigrationStatus` action from the `asyncMigrationsLogic` is called to update the migration with the new parameter values.\n\nHere's a list of high-level product features related to this code:\n\n*   **Async Migration Parameter Editing:** Allows users to modify parameters associated with an asynchronous migration.\n*   **Dynamic Form Generation:** Creates a form based on the parameter definitions of a specific migration.\n*   **Default Parameter Values:** Pre-populates the form with default parameter values, using existing values if available.\n*   **Migration Status Updates:** Triggers an update to the migration's status, including the new parameter values, upon form submission.\n"
    },
    {
        "path": "frontend/src/scenes/instance/AsyncMigrations/SettingUpdateField.tsx",
        "summary": "This React component, `SettingUpdateField`, provides a user interface for viewing and updating individual instance settings within an async migrations management tool. It displays the setting's key, description, an input field pre-filled with the current setting value, and an \"Update\" button. The button is disabled unless the input value has been changed from the original setting value. Clicking the \"Update\" button triggers an action to persist the new value for the setting.\n\nHere's a list of high-level product features:\n\n*   **Setting Display:** Displays the key and description of an instance setting.\n*   **Value Input:** Provides an input field to view and edit the current value of the setting.\n*   **Update Action:** Allows users to update the setting's value with a dedicated \"Update\" button.\n*   **Update Button Disabling:** Disables the \"Update\" button when the input value is the same as the current setting value, preventing unnecessary updates.\n"
    },
    {
        "path": "frontend/src/scenes/instance/AsyncMigrations/AsyncMigrationDetails.tsx",
        "summary": "This React component, `AsyncMigrationDetails`, displays detailed information about a specific asynchronous migration, focusing on presenting any errors encountered during the migration process. It fetches and displays a table of errors associated with the given `asyncMigration`, including the error description and the time it occurred. The component also provides a button to refresh the error list, showing a spinner while the data is loading.\n\nHere's a list of high-level product features:\n\n*   **Error Display:** Shows a list of errors associated with an asynchronous migration.\n*   **Error Description:** Displays the description of each error.\n*   **Error Timestamp:** Shows the timestamp of when each error occurred.\n*   **Error Refresh:** Allows users to refresh the error list to see the latest errors.\n*   **Loading Indication:** Provides visual feedback (spinner) while the error list is loading.\n"
    },
    {
        "path": "frontend/src/scenes/instance/AsyncMigrations/AsyncMigrations.tsx",
        "summary": "This code defines the `AsyncMigrations` component, a feature for managing and monitoring asynchronous database migrations within a PostHog instance. It provides a user interface for viewing migration status, progress, and logs, as well as triggering, resuming, rolling back, and stopping migrations. The component is accessible only to staff users and includes tabs for managing active migrations, viewing future migrations, and configuring settings. It fetches and displays data about each migration, including its name, description, progress, status, and associated errors.\n\nHere's a list of high-level product features:\n\n*   **Migration Management:** Allows staff users to view and manage asynchronous database migrations.\n*   **Migration Status Monitoring:** Displays the status, progress, and details of each migration.\n*   **Migration Control:** Enables staff users to trigger, resume, rollback, and stop migrations.\n*   **Error Logging:** Provides access to error logs associated with migrations.\n*   **Configuration Settings:** Allows configuration of async migration settings.\n*   **Future Migrations Preview:** Displays a list of upcoming migrations.\n*   **User Access Control:** Restricts access to migration management features to staff users only.\n"
    },
    {
        "path": "frontend/src/scenes/instance/AsyncMigrations/AsyncMigrationParametersModal.tsx",
        "summary": "This React component, `AsyncMigrationParametersModal`, provides a modal interface for configuring and running advanced async migrations. It leverages the `kea-forms` library to manage form state and submission. The modal displays a collapsible section containing configurable parameters for the selected async migration, allowing users to tune the migration process. Each parameter is rendered as a `LemonInput` field, dynamically adjusting the input type based on the default value. Users can cancel or submit the form to run the migration with the specified parameters.\n\nHere's a list of high-level product features:\n\n*   **Modal Interface:** Presents a modal for configuring async migration parameters.\n*   **Configurable Parameters:** Allows users to tune parameters used in async migrations.\n*   **Dynamic Input Types:** Adjusts input types (text or number) based on parameter default values.\n*   **Collapsible Advanced Configuration:** Hides advanced configuration options behind a collapsible section.\n*   **Form Management:** Uses `kea-forms` for form state management and submission.\n*   **Cancel and Submit Actions:** Provides buttons to cancel or run the migration with the configured parameters.\n"
    },
    {
        "path": "frontend/src/scenes/instance/AsyncMigrations/asyncMigrationsLogic.ts",
        "summary": "This code defines the logic for managing asynchronous database migrations within a PostHog instance. It handles loading, triggering, resuming, rolling back, and force-stopping migrations. It also manages settings related to async migrations and displays errors associated with specific migrations. The logic includes fetching data from the API, updating the UI based on migration status, and providing actions to interact with the migrations. It also handles routing and tab management for the async migrations page.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **View Async Migrations:** Display a list of asynchronous database migrations with their status, progress, and other relevant details.\n*   **Trigger/Resume Migrations:** Allow administrators to start or resume asynchronous migrations.\n*   **Rollback Migrations:** Enable administrators to rollback asynchronous migrations that have encountered issues.\n*   **Force Stop Migrations:** Provide the ability to forcefully stop running migrations, with or without rollback.\n*   **View Migration Errors:** Display errors associated with specific asynchronous migrations for debugging purposes.\n*   **Manage Async Migration Settings:** Allow administrators to configure settings related to asynchronous migrations.\n*   **Filter Migrations:** Display future migrations that are not yet available.\n*   **Tabbed Navigation:** Organize the async migrations page into tabs for management, future migrations, and settings.\n"
    },
    {
        "path": "frontend/src/scenes/FeatureFlagPermissions.tsx",
        "summary": "This code defines a React component, `FeatureFlagPermissions`, that manages role-based access control for feature flags within PostHog. It allows administrators to define which roles have edit or view access to specific feature flags. The component leverages Lemon UI components for a consistent user experience and integrates with PostHog's feature flag system and role-based access control system. It handles both organization-wide default permissions and custom role assignments for individual feature flags.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Role-Based Access Control (RBAC) for Feature Flags:** Allows administrators to control who can view or edit specific feature flags based on their assigned roles.\n*   **Organization-Wide Default Permissions:** Inherits default permissions from organization-level roles, providing a baseline access level for all feature flags.\n*   **Custom Role Assignments:** Enables assigning specific roles to a feature flag, overriding the organization-wide defaults for granular control.\n*   **Role Selection UI:** Provides a user-friendly interface for searching and selecting roles to grant access to a feature flag.\n*   **Permission Management UI:** Displays a table of roles with their corresponding access levels (edit/view) for a given feature flag.\n*   **Role Removal:** Allows administrators to remove custom role assignments from a feature flag, reverting to the organization-wide defaults.\n*   **Integration with Feature Flag System:** Seamlessly integrates with PostHog's feature flag system, ensuring that access control is enforced when evaluating feature flags.\n*   **PayGate Integration:** Integrates with PayGate to restrict access to the feature based on the user's subscription.\n"
    },
    {
        "path": "frontend/src/scenes/instance/AsyncMigrations",
        "summary": "The provided code collectively implements a comprehensive feature for managing asynchronous database migrations within a PostHog instance. This includes functionalities for viewing, triggering, monitoring, and controlling migrations, along with managing their associated settings and errors. The system provides a user interface accessible to staff users, allowing them to configure migration parameters, view detailed status and progress information, and take actions such as rolling back or force-stopping migrations. The system also includes features for viewing future migrations and managing instance-level settings related to async migrations.\n\nHere's a list of high-level product features:\n\n*   **Async Migration Management:** Allows staff users to view, manage, and control asynchronous database migrations.\n*   **Migration Status Monitoring:** Displays the status, progress, and details of each migration.\n*   **Migration Control Actions:** Enables triggering, resuming, rolling back, and stopping migrations.\n*   **Configurable Migration Parameters:** Provides a modal interface for configuring parameters used in async migrations.\n*   **Error Logging and Display:** Shows a list of errors associated with each migration, including descriptions and timestamps.\n*   **Settings Management:** Allows administrators to configure settings related to asynchronous migrations.\n*   **Future Migrations Preview:** Displays a list of upcoming migrations.\n*   **User Access Control:** Restricts access to migration management features to staff users only.\n"
    },
    {
        "path": "frontend/src/scenes/instance/DeadLetterQueue/DeadLetterQueue.tsx",
        "summary": "The `DeadLetterQueue` component provides a user interface for managing an instance's dead letter queue. It restricts access to staff users only, displaying a message to non-staff users with instructions on how to gain access. For staff users, it presents a tabbed interface, currently featuring a \"Metrics\" tab, built with LemonTabs, to display relevant metrics related to the dead letter queue. The active tab is controlled by the `deadLetterQueueLogic`.\n\nHere's a list of high-level product features:\n\n*   **Restricted Access:** Limits access to the dead letter queue management interface to staff users.\n*   **Informative Messaging:** Displays helpful messages to non-staff users explaining access restrictions and how to gain access.\n*   **Tabbed Interface:** Organizes dead letter queue management tools into tabs for easy navigation.\n*   **Metrics Display:** Provides a \"Metrics\" tab to visualize and monitor key metrics related to the dead letter queue.\n"
    },
    {
        "path": "frontend/src/scenes/instance/DeadLetterQueue/MetricsTab.tsx",
        "summary": "The `MetricsTab` component in the Dead Letter Queue feature provides a staff-only view of key performance indicators and metrics related to the queue's operation. It displays single-value metrics in a summarized format and presents more detailed metrics in tabular form, with the ability to load additional rows for each table. The component also includes a refresh button to update the displayed metrics and uses a loading indicator while data is being fetched.\n\nHere's a list of high-level product features:\n\n*   **Display of Single-Value Metrics:** Shows summarized key performance indicators (KPIs) related to the Dead Letter Queue.\n*   **Tabular Metric Display:** Presents detailed metrics in a table format with sortable columns.\n*   **Data Refresh:** Allows users to manually refresh the displayed metrics.\n*   **Loading Indicator:** Provides visual feedback during data loading.\n*   **Pagination/Load More:** Enables loading additional rows of data in the tables.\n*   **Staff-Only Access:** Restricts access to the metrics tab to staff users only."
    },
    {
        "path": "frontend/src/scenes/instance/DeadLetterQueue/deadLetterQueueLogic.ts",
        "summary": "This code defines the logic for a Dead Letter Queue (DLQ) management interface within a larger application. It uses the Kea framework for state management, handling actions, reducers, loaders, listeners, and selectors to manage the state and behavior of the DLQ interface. The logic fetches and displays metrics related to the DLQ, allows users to switch between different tabs (Metrics, Management, Settings), and supports loading more data for table-based metrics. It also restricts access to the DLQ metrics to staff users only.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **DLQ Metrics Display:** Displays key metrics related to the Dead Letter Queue.\n*   **Tabbed Interface:** Provides a tabbed interface for navigating between different DLQ sections (Metrics, Management, Settings).\n*   **Data Loading and Pagination:** Supports loading and displaying large datasets of DLQ metrics with pagination.\n*   **Role-Based Access Control:** Restricts access to DLQ metrics based on user roles (staff only).\n*   **Real-time Metric Updates:** Enables real-time updates of DLQ metrics.\n*   **Detailed Metric Views:** Provides detailed views for individual metrics, including tabular data.\n"
    },
    {
        "path": "frontend/src/scenes/instance/DeadLetterQueue",
        "summary": "The Dead Letter Queue (DLQ) management interface provides staff users with tools to monitor and manage messages that have failed processing. The interface is organized into tabs, including a Metrics tab, which displays key performance indicators (KPIs) and detailed metrics in both summarized and tabular formats. The system incorporates role-based access control, restricting access to sensitive data and management functions to authorized personnel. Data is loaded and displayed efficiently, with features like pagination and refresh options to ensure users have access to the most up-to-date information.\n\nHere's a list of high-level product features:\n\n*   **Restricted Access:** Limits access to the dead letter queue management interface to staff users.\n*   **Informative Messaging:** Displays helpful messages to non-staff users explaining access restrictions and how to gain access.\n*   **Tabbed Interface:** Organizes dead letter queue management tools into tabs for easy navigation (Metrics, Management, Settings).\n*   **DLQ Metrics Display:** Displays key metrics related to the Dead Letter Queue.\n*   **Display of Single-Value Metrics:** Shows summarized key performance indicators (KPIs) related to the Dead Letter Queue.\n*   **Tabular Metric Display:** Presents detailed metrics in a table format with sortable columns.\n*   **Data Loading and Pagination:** Supports loading and displaying large datasets of DLQ metrics with pagination.\n*   **Data Refresh:** Allows users to manually refresh the displayed metrics.\n*   **Loading Indicator:** Provides visual feedback during data loading.\n"
    },
    {
        "path": "frontend/src/scenes/instance/SystemStatus/OverviewTab.tsx",
        "summary": "The `OverviewTab` component displays system status information in a table format using LemonTable. It fetches data from `systemStatusLogic` and presents metrics with their corresponding values. Some metrics have links to internal PostHog pages. The table supports expandable rows to show subrows of data for certain metrics, providing a more detailed view of the system's status.\n\n**Features:**\n\n*   **System Status Table:** Displays key system metrics and their values.\n*   **Metric Links:** Provides links to internal PostHog pages for specific metrics.\n*   **Expandable Rows:** Allows users to expand rows to view subrows of data for detailed information.\n*   **Loading Indicator:** Shows a loading state while fetching system status data.\n"
    },
    {
        "path": "frontend/src/scenes/instance/SystemStatus/staffUsersLogic.ts",
        "summary": "This code defines a Kea logic module named `staffUsersLogic` responsible for managing the staff user status within the application. It fetches all users, allows adding and removing staff privileges, and updates the user interface accordingly. The logic interacts with the backend API to persist these changes and updates the currently logged-in user's information if their staff status is modified.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **View All Users:** Fetches and displays a list of all users in the system.\n*   **Assign Staff Privileges:** Allows administrators to grant staff privileges to users.\n*   **Revoke Staff Privileges:** Allows administrators to remove staff privileges from users.\n*   **Real-time Updates:** Updates the user interface and user session when staff privileges are changed, including redirecting the user to the homepage if their staff status is revoked.\n*   **Differentiate Staff and Non-Staff Users:** Provides a way to filter and display users based on their staff status.\n"
    },
    {
        "path": "frontend/src/scenes/instance/SystemStatus/StaffUsersTab.tsx",
        "summary": "This code defines the `StaffUsersTab` component, which allows administrators to manage staff users for a PostHog instance. It displays a list of current staff users in a table, provides a way to add new staff users via a select input, and allows for the removal of existing staff users with a confirmation modal. The component ensures that at least one staff user remains at all times.\n\n**Features:**\n\n*   **Display Staff Users:** Shows a table of current staff users, including their profile picture, name, and email.\n*   **Add Staff Users:** Allows administrators to add existing users as staff users via a select input.\n*   **Remove Staff Users:** Enables administrators to remove staff users with a confirmation modal to prevent accidental removal.\n*   **\"Me\" Tag:** Indicates the currently logged-in user in the staff user list.\n*   **Minimum Staff User Enforcement:** Prevents the removal of the last staff user to ensure instance manageability.\n*   **Informative Tooltips:** Provides tooltips explaining why a staff user cannot be removed when it would leave the instance with no staff users.\n*   **Confirmation Modal:** Requires confirmation before removing a staff user.\n*   **Self Removal:** Allows a user to remove themselves as a staff user, with a warning that another staff user will need to re-add them.\n"
    },
    {
        "path": "frontend/src/scenes/instance/SystemStatus/InstanceConfigTab.tsx",
        "summary": "The `InstanceConfigTab` component provides a user interface for viewing and editing PostHog instance settings. It displays editable instance settings in a table, allowing users to modify values and save or discard changes. It also shows environment configuration settings, which are read-only and configurable via environment variables. The component includes features for editing, saving, and discarding changes to instance settings, along with links to PostHog documentation for more information. A modal is used to confirm saving the configuration.\n\nHere's a list of high-level product features:\n\n*   **View Instance Configuration:** Displays a table of editable instance settings with their keys, descriptions, and values.\n*   **Edit Instance Settings:** Allows users to modify the values of editable instance settings.\n*   **Save Instance Configuration:** Saves the modified instance settings.\n*   **Discard Instance Configuration Changes:** Discards any unsaved changes to instance settings.\n*   **View Environment Configuration:** Displays a table of environment configuration settings and their values (read-only).\n*   **Keyboard Hotkeys:** Provides keyboard shortcuts for editing, saving, and discarding changes.\n*   **Confirmation Modal:** Displays a modal to confirm saving the instance configuration.\n"
    },
    {
        "path": "frontend/src/scenes/instance/SystemStatus/InstanceConfigSaveModal.tsx",
        "summary": "This code defines a modal component, `InstanceConfigSaveModal`, that allows users to review and confirm changes to their PostHog instance configuration. It displays a list of configuration changes, highlighting the old and new values for each setting. The modal also includes warning banners for specific settings like recordings TTL, informing the user about potential implications of the changes. Upon confirmation, the changes are applied to the instance.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Configuration Change Preview:** Displays a clear comparison of old and new values for instance configuration settings.\n*   **Confirmation Step:** Requires users to confirm changes before they are applied.\n*   **Warning Banners:** Provides context-specific warnings for certain configuration changes, such as those related to email settings or recordings TTL.\n*   **Loading State:** Indicates when changes are being saved.\n*   **Success Message:** Notifies the user when changes have been successfully applied.\n*   **Secret Handling:** Hides the values of secret configuration settings to protect sensitive information.\n"
    },
    {
        "path": "frontend/src/scenes/instance/SystemStatus/InternalMetricsTab.tsx",
        "summary": "The `InternalMetricsTab` component provides a user interface for viewing the status of internal database queries, specifically for PostgreSQL and Clickhouse. It allows users to inspect currently running queries and slow query logs, offering insights into database performance and potential bottlenecks. The component uses collapsable sections to organize the information and includes features for filtering idle PostgreSQL queries and reloading query data. The data is displayed in a table format, with columns for duration and query, and dynamically adds additional columns based on the query data.\n\nHere's a list of high-level product features:\n\n*   **Real-time Query Monitoring:** Displays currently running queries for PostgreSQL and Clickhouse databases.\n*   **Slow Query Log Analysis:** Provides access to Clickhouse slow query logs for performance troubleshooting.\n*   **Idle Query Filtering:** Allows users to filter out idle PostgreSQL queries for focused analysis.\n*   **Data Refresh:** Enables users to manually reload query data to get the latest status.\n*   **Collapsible Sections:** Organizes query information into collapsible sections for better readability.\n*   **Dynamic Table Columns:** Automatically adjusts table columns based on the available query data.\n*   **Sortable Columns:** Allows users to sort the table by duration to identify long-running queries.\n"
    },
    {
        "path": "frontend/src/scenes/instance/SystemStatus/index.tsx",
        "summary": "This code defines the System Status scene in the PostHog frontend, providing a centralized location for staff users to monitor and manage their PostHog instance. It displays critical runtime details, settings, and internal metrics. The scene utilizes tabs to organize information into Overview, Internal Metrics, Instance Configuration (settings), and Staff Users sections. It also includes banners to display errors and warnings, such as a misconfigured SITE_URL.\n\nHere's a list of high-level product features:\n\n*   **System Overview:** Provides a summary of the PostHog instance's status, cached for a short period.\n*   **Internal Metrics:** Displays internal performance metrics for staff users.\n*   **Instance Configuration:** Allows staff users to modify instance settings (Beta).\n*   **Staff Users Management:** Enables staff users to manage other staff user accounts.\n*   **Error and Warning Banners:** Displays error messages and warnings related to the instance's configuration or health.\n*   **Tabbed Navigation:** Organizes the system status information into separate tabs for easy navigation.\n"
    },
    {
        "path": "frontend/src/scenes/instance/SystemStatus/RenderMetricValueEdit.tsx",
        "summary": "This React component, `RenderMetricValueEdit`, provides an interface for editing metric values based on their type. It handles boolean values with a checkbox and numeric or text values with an input field. For boolean values, a LemonTag displays \"Yes\" or \"No\" based on the boolean state. If the value is a secret, the input field will mask the existing value and allow the user to keep the existing secret value. The component takes a callback function `onValueChanged` to propagate changes to the parent component.\n\nHere's a list of high-level features:\n\n*   **Boolean Value Editing:** Allows users to toggle boolean metric values using a checkbox.\n*   **Numeric and Text Value Editing:** Provides an input field for editing numeric and text-based metric values.\n*   **Secret Value Masking:** Masks secret values in the input field, providing an option to keep the existing secret.\n*   **Real-time Updates:** Uses a callback function to notify the parent component of value changes.\n*   **Dynamic Input Type:** Dynamically renders input fields as either text or number based on the metric value type.\n"
    },
    {
        "path": "frontend/src/scenes/instance/SystemStatus/RenderMetricValue.tsx",
        "summary": "The `RenderMetricValue` component is responsible for displaying system status metrics in a user-friendly format. It handles different data types and special cases, such as timestamps, boolean values, secrets, and null/undefined values. It uses LemonTag components to display boolean values as \"Yes\" or \"No\" and to indicate secret values. Timestamps are formatted using the TZLabel component, and null/undefined values are displayed as \"Unknown\" or a custom label. Integer values are formatted with commas for readability.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Display of System Status Metrics:** Renders various system status metrics with appropriate formatting.\n*   **Secret Value Masking:** Masks sensitive information like secrets with a \"Secret\" tag and lock icon.\n*   **Timestamp Formatting:** Converts and displays timestamps in a user-friendly format with timezone information.\n*   **Boolean Value Representation:** Displays boolean values as \"Yes\" or \"No\" using LemonTag components with success/danger styling.\n*   **Null/Undefined Value Handling:** Displays a default \"Unknown\" label or a custom label for null, undefined, or empty values.\n*   **Integer Formatting:** Formats integer values with commas for improved readability.\n"
    },
    {
        "path": "frontend/src/scenes/instance/SystemStatus/systemStatusLogic.ts",
        "summary": "This code defines the `systemStatusLogic` using Kea, a state management library. It manages the state and logic for the instance system status page, including fetching and displaying system status information, instance settings, and query results. It also handles editing and saving instance configuration settings, managing UI state like the active tab and open sections, and persisting some UI state to local storage. The logic also integrates with the router to update the URL based on the selected tab and vice versa.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **System Status Overview:** Displays a summary of the system's health and performance.\n*   **Metrics Display:** Shows detailed metrics about the PostHog instance.\n*   **Instance Settings Management:** Allows administrators to view and edit various instance-level settings.\n*   **Staff User Management:** Provides a view of staff users.\n*   **UI State Management:** Manages the active tab, open sections, and editing state of the configuration settings.\n*   **Configuration Editing:** Enables editing of specific instance configuration settings with validation and saving capabilities.\n*   **URL Routing:** Updates the URL based on the selected tab for easy sharing and navigation.\n*   **Data Loading:** Fetches system status, instance settings, and query results from the API.\n*   **User Feedback:** Provides success messages upon saving configuration changes.\n"
    },
    {
        "path": "frontend/src/scenes/instance/SystemStatus",
        "summary": "The System Status scene provides a comprehensive suite of tools for PostHog staff users to monitor, manage, and configure their instances. It offers real-time insights into system performance, database queries, and internal metrics, alongside the ability to modify instance settings and manage staff user privileges. The scene is organized into tabs for easy navigation and includes features for displaying errors and warnings, masking sensitive information, and providing context-specific guidance.\n\nHere's a list of high-level product features:\n\n*   System Overview: Provides a summary of the PostHog instance's status, cached for a short period.\n*   Internal Metrics: Displays internal performance metrics for staff users, including real-time query monitoring and slow query log analysis.\n*   Instance Configuration: Allows staff users to modify instance settings, including viewing, editing, saving, and discarding changes, with a confirmation modal.\n*   Staff Users Management: Enables staff users to manage other staff user accounts, including assigning and revoking staff privileges.\n*   Error and Warning Banners: Displays error messages and warnings related to the instance's configuration or health.\n*   Tabbed Navigation: Organizes the system status information into separate tabs for easy navigation.\n*   Real-time Query Monitoring: Displays currently running queries for PostgreSQL and Clickhouse databases.\n*   Slow Query Log Analysis: Provides access to Clickhouse slow query logs for performance troubleshooting.\n*   Metric Links: Provides links to internal PostHog pages for specific metrics.\n*   Configuration Change Preview: Displays a clear comparison of old and new values for instance configuration settings.\n*   Secret Value Masking: Masks sensitive information like secrets.\n"
    },
    {
        "path": "frontend/src/scenes/instance",
        "summary": "The provided code snippets describe several key features for managing a PostHog instance, primarily focused on providing staff users with the tools to monitor, control, and configure various aspects of the system. These features include managing asynchronous database migrations, monitoring and managing the dead letter queue, and providing a comprehensive system status overview with configuration options and user management capabilities. The system emphasizes role-based access control, informative user interfaces, and efficient data handling.\n\nHere's a list of high-level product features:\n\n*   **Asynchronous Migration Management:** View, trigger, monitor, and control database migrations.\n*   **Dead Letter Queue Management:** Monitor and manage failed message processing with metrics and management tools.\n*   **System Status Overview:** Comprehensive view of instance health, performance metrics, and configuration settings.\n*   **Instance Configuration:** Modify instance settings with change previews and secret masking.\n*   **Staff User Management:** Manage staff user accounts and privileges.\n*   **Real-time Monitoring:** Monitor database queries and analyze slow query logs.\n*   **Error and Warning Display:** Display system errors and warnings.\n*   **Role-Based Access Control:** Restrict access to sensitive features and data to authorized personnel.\n"
    },
    {
        "path": "frontend/src/scenes/actions/hints.tsx",
        "summary": "The code defines a constant `URL_MATCHING_HINTS` which is an object containing hints for different URL matching strategies used in the application. The hints provide guidance on how to use exact matching, wildcard matching using the `%` character, and regular expression matching, with a link to the RE2 syntax documentation.\n\n**Features:**\n\n*   **URL Matching Strategies:** Supports exact, contains (wildcard), and regular expression based URL matching.\n*   **Wildcard Support:** Provides wildcard matching using the `%` character.\n*   **Regular Expression Support:** Supports regular expression matching using RE2 syntax.\n*   **RE2 Syntax Documentation Link:** Links to the RE2 syntax documentation for regular expression matching.\n"
    },
    {
        "path": "frontend/src/scenes/actions/actionLogic.ts",
        "summary": "This code defines the `actionLogic` Kea logic for managing actions within the PostHog application. It handles loading, updating, and monitoring the status of actions, particularly in the context of data management. It fetches action details from the API, manages a poll timeout for checking action completion, and provides breadcrumbs for navigation. The logic also determines if an action has cohort filters and provides context for side panel display.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Action Management:** Allows users to view, edit, and manage actions within PostHog.\n*   **Action Status Monitoring:** Tracks the progress and completion status of actions, providing real-time updates.\n*   **Data Management Integration:** Provides a seamless integration with the data management section of PostHog.\n*   **Cohort Filter Detection:** Identifies actions that utilize cohort filters.\n*   **Side Panel Context:** Provides context for displaying relevant information in the side panel, such as activity related to a specific action.\n*   **Breadcrumb Navigation:** Enables easy navigation to and from action details within the application.\n"
    },
    {
        "path": "frontend/src/scenes/actions/Action.tsx",
        "summary": "This code defines the `Action` component, which is responsible for displaying and editing action details within the PostHog application. It fetches action data using `actionLogic` and displays a loading state, a \"not found\" message if the action doesn't exist, or the `ActionEdit` component for editing the action. Additionally, it shows a list of matching events for the action, either displaying a data table of recent events or a loading spinner while the action is being calculated.\n\nHere's a list of high-level product features:\n\n*   **Action Details View:** Displays detailed information about a specific action.\n*   **Action Editing:** Allows users to modify the properties and settings of an action.\n*   **Loading State:** Provides visual feedback while action data is being fetched.\n*   **\"Not Found\" Handling:** Displays a user-friendly message when an action cannot be found.\n*   **Matching Events Display:** Shows a list of recent events that match the action's criteria.\n*   **Real-time Calculation Indicator:** Informs users that the action is being calculated and the matching events are not yet available.\n"
    },
    {
        "path": "frontend/src/scenes/actions/EventName.tsx",
        "summary": "This code defines a React component called `LemonEventName` that provides a user interface for selecting an event name. It leverages the `TaxonomicPopover` component to display a searchable list of events. The component supports different configurations, including the ability to disable the input, customize the placeholder text, and include an option for \"All events\" either as an explicit item or a clear button. It uses `PropertyKeyInfo` to render the selected event name with additional information.\n\nHere's a list of high-level product features:\n\n*   **Event Name Selection:** Allows users to select an event name from a list of available events.\n*   **Searchable Event List:** Provides a searchable interface for easily finding specific events.\n*   **\"All Events\" Option:** Supports including an \"All events\" option, either as a selectable item or a clear button.\n*   **Customizable Placeholder:** Allows customization of the placeholder text displayed in the input field.\n*   **Disabled State:** Enables disabling the input field to prevent user interaction.\n*   **Event Information Display:** Renders the selected event name with additional information using the `PropertyKeyInfo` component.\n"
    },
    {
        "path": "frontend/src/scenes/actions/NewActionButton.tsx",
        "summary": "This code defines a React component called `NewActionButton` that renders a button which, when clicked, opens a modal for creating a new action. The modal presents two options: \"Inspect element on your site\" which displays a list of authorized URLs for inspection, and \"From event or pageview\" which navigates the user to a create action page. The modal also includes \"Back\" and \"Cancel\" buttons for navigation and closing the modal.\n\nHere's a list of high-level product features:\n\n*   **New Action Creation:** Allows users to create new actions within the application.\n*   **Modal Interface:** Provides a modal window for a focused action creation experience.\n*   **Inspect Element Option:** Enables users to create actions by inspecting elements on their website.\n*   **Authorized URL List:** Displays a list of authorized URLs for element inspection.\n*   **Event/Pageview Option:** Enables users to create actions based on existing events or pageviews.\n*   **Navigation:** Provides \"Back\" and \"Cancel\" buttons for easy navigation within the modal.\n"
    },
    {
        "path": "frontend/src/scenes/actions/ActionHogFunctions.tsx",
        "summary": "This code defines a React component, `ActionHogFunctions`, that displays information about connected destinations (HogFunctions) for a specific action within PostHog. It fetches the current action and checks for cohort filters or unsaved changes. It renders a list of linked HogFunctions (destinations) and displays a warning banner if adding a cohort filter will disable connected destinations. The component also provides a reason why a new destination might be disabled, based on whether the action has cohort filters or hasn't been saved yet.\n\nHere's a list of high-level product features:\n\n*   **Display Connected Destinations:** Shows a list of HogFunctions (destinations) connected to a specific action.\n*   **Cohort Filter Warning:** Displays a warning message when a cohort filter is added, indicating that it will disable connected destinations.\n*   **Destination Creation Restriction:** Prevents the creation of new destinations if the action has cohort filters or hasn't been saved.\n*   **Action as Filter for Destinations:** Allows actions to be used as filters for destinations like Slack or Webhook delivery.\n"
    },
    {
        "path": "frontend/src/scenes/actions/actionsLogic.ts",
        "summary": "This code defines the logic for managing actions within a data management context. It utilizes the kea framework for state management, connecting to the actions model to fetch action data and user logic to access user information. The logic provides functionality for filtering actions based on ownership (\"all\" or \"me\") and searching actions by name, description, or tags using Fuse.js for fuzzy searching. It also manages breadcrumbs for navigation and determines when to display an empty state message.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Action Listing:** Displays a list of actions fetched from the backend.\n*   **Action Filtering:** Allows users to filter actions to show either all actions or only actions created by the current user.\n*   **Action Search:** Enables users to search for actions by name, description, or tags.\n*   **Fuzzy Search:** Implements fuzzy search using Fuse.js to provide more flexible and forgiving search results.\n*   **Breadcrumbs Navigation:** Provides breadcrumbs for easy navigation back to the data management section.\n*   **Empty State Handling:** Displays a helpful message when there are no actions to show, improving the user experience.\n"
    },
    {
        "path": "frontend/src/scenes/actions/ActionEdit.tsx",
        "summary": "This code defines the `ActionEdit` component, which allows users to create and edit actions within the PostHog application. It provides a form for defining action properties such as description and tags, and most importantly, defining match groups (action steps) that trigger the action. The component includes features for saving, deleting, and canceling actions, as well as viewing recordings related to the action. It leverages Kea logic for state management and form handling, and utilizes various Lemon UI components for a consistent user interface.\n\nHere's a list of high-level product features implemented in the code:\n\n*   **Action Creation/Editing:** Allows users to define new actions or modify existing ones.\n*   **Action Description:** Enables users to add a description to the action.\n*   **Action Tagging:** Supports tagging actions for better organization and filtering.\n*   **Match Group Definition (Action Steps):** Provides a mechanism to define the criteria (match groups) that trigger the action. Users can add multiple match groups.\n*   **Action Saving:** Saves the action with its defined properties and match groups.\n*   **Action Deletion:** Deletes an existing action.\n*   **Action Cancellation:** Cancels the action creation/editing process.\n*   **View Recordings:** Links to session recordings related to the action for debugging and analysis.\n"
    },
    {
        "path": "frontend/src/scenes/actions/ActionStep.tsx",
        "summary": "This code defines the `ActionStep` component, which is a key part of defining actions within PostHog. It allows users to define how events are matched to an action, using various criteria such as event name, URL, element text, HTML selectors, and custom properties. The component provides a flexible interface for configuring these matching rules, including options for different matching types (exact, regex, contains) and the ability to combine multiple criteria with \"and\" or \"or\" logic. It also includes specific handling for autocapture events, allowing users to select elements on their site and define actions based on user interactions with those elements.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Define Actions Based on Event Matching:** Allows users to create actions triggered by specific events.\n*   **Autocapture Event Support:** Enables actions to be defined based on automatically captured user interactions with website elements.\n*   **URL Matching:** Allows actions to be triggered based on specific URLs or URL patterns.\n*   **HTML Selector Matching:** Enables actions to be triggered based on user interactions with specific HTML elements, identified by selectors.\n*   **Property Filtering:** Allows actions to be triggered only when events have specific properties that match defined criteria.\n*   **Combining Matching Criteria:** Supports combining multiple matching criteria with logical operators (\"and\", \"or\") for more complex action definitions.\n*   **String Matching Options:** Provides options for exact, regex, and \"contains\" matching for strings like URLs and element text.\n*   **Visual Element Selection:** Provides a visual interface for selecting elements on a website to define autocapture actions.\n"
    },
    {
        "path": "frontend/src/scenes/actions/actionEditLogic.tsx",
        "summary": "This code defines the logic for creating and editing actions within the PostHog application. It manages the state of an action being edited, handles form submission for creating or updating actions via the API, and manages deletion of actions. The logic also handles URL-based action creation (copying existing actions) and provides a warning to the user if they attempt to navigate away from the page with unsaved changes. It also manages loading and reloading event definitions and tags to keep the application data up to date.\n\nHere's a list of high-level product features supported by this code:\n\n*   **Action Creation:** Allows users to create new actions with defined steps and properties.\n*   **Action Editing:** Enables users to modify existing actions, including their name, steps, and associated properties.\n*   **Action Deletion:** Provides functionality to delete actions with an undo option.\n*   **Action Cloning:** Supports creating a copy of an existing action with a modified name.\n*   **Form Management:** Handles form state, validation, and submission for action creation and editing.\n*   **Data Persistence:** Interacts with the PostHog API to save and update actions in the backend.\n*   **Real-time Updates:** Reloads event definitions and tags after an action is saved to ensure data consistency.\n*   **Navigation Management:** Uses the router to navigate users to the action list or the newly created/edited action.\n*   **Unsaved Changes Warning:** Alerts users if they attempt to leave the action edit page with unsaved changes.\n*   **Cohort Filter Handling:** Warns users about potential incompatibilities when adding cohort filters to actions that didn't previously have them.\n"
    },
    {
        "path": "frontend/src/scenes/actions",
        "summary": "The provided code collectively implements a comprehensive action management system within the PostHog application. This system allows users to define and manage actions based on various event properties and user interactions, enabling powerful analytics and automation capabilities. Users can create, edit, delete, and clone actions, define complex matching criteria using event names, URLs, HTML selectors, and custom properties, and combine these criteria with logical operators. The system also provides features for visualizing matching events, monitoring action status, and integrating with other PostHog features like HogFunctions (destinations) and cohort filters.\n\nHere's a list of high-level product features:\n\n*   Action Creation, Editing, Deletion, and Cloning\n*   Event-Based Action Definition with Flexible Matching Criteria (Event Name, URL, HTML Selectors, Properties)\n*   Autocapture Event Support with Visual Element Selection\n*   Logical Combination of Matching Criteria (AND/OR)\n*   Action Tagging and Description\n*   Action Filtering and Search\n*   Real-time Action Status Monitoring\n*   Integration with HogFunctions (Destinations) and Cohort Filters\n*   Unsaved Changes Warning\n*   Navigation Management and Breadcrumbs\n*   Display of Matching Events\n*   URL Matching Strategies (Exact, Wildcard, Regex)\n*   Inspect Element on Site Action Creation\n*   Authorized URL Management for Element Inspection\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/WebAnalyticsMenu.tsx",
        "summary": "The `WebAnalyticsMenu` component in `WebAnalyticsMenu.tsx` provides a dropdown menu for web analytics features. It includes a link to the Session Attribution Explorer and a toggle to filter out test accounts from the displayed data. The menu is triggered by an ellipsis icon button.\n\nHere's a list of the high-level product features:\n\n*   **Session Attribution Explorer:** Navigates the user to a dedicated page for exploring session attribution data.\n*   **Test Account Filtering:** Allows users to toggle the inclusion/exclusion of test accounts in web analytics data.\n*   **Dropdown Menu:** Provides a user interface element to access the above features.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/liveWebAnalyticsLogic.tsx",
        "summary": "This code defines the logic for displaying live web analytics, specifically the number of active users on the product. It uses the `kea` library for state management and data fetching. The logic polls a `/stats` endpoint periodically to retrieve the number of active users and updates the UI accordingly. It also manages the current time to calculate how long ago the user count was last updated.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Live User Count:** Displays the number of users currently active on the product.\n*   **Real-time Updates:** Periodically polls a backend endpoint to update the live user count.\n*   **Last Updated Time:** Calculates and displays how long ago the user count was last updated.\n*   **Error Handling:** Includes error handling for failed API requests.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/PageReports.tsx",
        "summary": "The `PageReports.tsx` file defines the UI components for displaying and filtering page-specific web analytics reports. It allows users to select a specific page URL from a searchable dropdown, strip query parameters from URLs for broader matching, and filter data by date range and comparison periods. If no page URL is selected, a message prompts the user to select one. Once a page is selected, the component displays a set of tiles representing key performance metrics for that page.\n\nHere's a list of high-level product features:\n\n*   **Page URL Selection:** Allows users to select a specific page URL to analyze.\n*   **Searchable Page List:** Provides a searchable dropdown to find and select page URLs.\n*   **Query Parameter Stripping:** Option to strip query parameters from URLs for more general matching.\n*   **Date Filtering:** Allows users to filter the data by a specific date range.\n*   **Comparison Filtering:** Allows users to compare data across different time periods.\n*   **Performance Metric Tiles:** Displays key performance metrics for the selected page in a tile-based layout.\n*   **No URL Selected Message:** Displays a helpful message when no page URL is selected."
    },
    {
        "path": "frontend/src/scenes/web-analytics/CrossSellButtons/ReplayButton.tsx",
        "summary": "The `ReplayButton` component in `ReplayButton.tsx` provides a button that links from web analytics insights to session replays, pre-filtering replays based on the selected breakdown in web analytics. It handles different breakdown types, such as device type, page, browser, OS, UTM parameters, and viewport, mapping them to corresponding property filters for session replay. When clicked, the button navigates the user to the session replay tab with the appropriate filters applied, enabling them to view recordings relevant to the selected web analytics breakdown. It also tracks product intent for cross-selling between web analytics and session replay.\n\nHere's a list of high-level product features:\n\n*   **Cross-Product Navigation:** Seamlessly navigate from web analytics insights to session replays.\n*   **Contextual Filtering:** Automatically filter session replays based on web analytics breakdowns (e.g., device type, page, UTM parameters).\n*   **Breakdown Support:** Handles various breakdown types, including device, page, browser, OS, UTM parameters, and viewport.\n*   **Product Intent Tracking:** Tracks user intent when navigating between web analytics and session replay for cross-selling purposes.\n*   **Direct Link to Session Replay:** Provides a direct link to the session replay tab with pre-applied filters.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/CrossSellButtons/HeatmapButton.tsx",
        "summary": "This component, `HeatmapButton`, is a button that navigates the user to a heatmap view for a specific page, based on web analytics data. The button's visibility and behavior depend on the selected domain and feature flags. If no domain is selected, the button is disabled with a tooltip prompting the user to select a domain. When a domain is selected, the button links to either a new heatmap UI or launches the user's website with a heatmap toolbar, depending on the `HEATMAPS_UI` feature flag. Clicking the button also triggers a product intent event for cross-selling purposes.\n\nHere's a list of high-level product features:\n\n*   **Heatmap Integration:** Provides a button to directly access heatmaps for specific pages from web analytics data.\n*   **Domain Filtering:** Respects the selected domain filter in web analytics to generate the correct heatmap URL.\n*   **Feature Flag Control:** Uses a feature flag (`HEATMAPS_UI`) to determine whether to use a new heatmap UI or the existing toolbar-based approach.\n*   **Cross-Sell Tracking:** Tracks user intent to use heatmaps from the web analytics interface.\n*   **Disabled State with Tooltip:** Provides a disabled state with a helpful tooltip when a domain is not selected.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/WebAnalyticsFilters.tsx",
        "summary": "This code defines the `WebAnalyticsFilters` component, which provides a set of filters and controls for analyzing web analytics data. It includes features for selecting date ranges, comparing data, setting conversion goals, sorting tables, toggling path cleaning, filtering by domain and device type, and selecting web vitals percentiles. The component is responsive, adapting its layout for different screen sizes, and includes tooltips and links to settings for further customization.\n\nHere's a list of the high-level product features implemented in this component:\n\n*   **Date Range Selection:** Allows users to specify a date range for analysis.\n*   **Data Comparison:** Enables users to compare data across different time periods.\n*   **Conversion Goal Setting:** Allows users to define and track web conversion goals.\n*   **Table Sorting:** Provides controls for sorting data tables.\n*   **Path Cleaning Toggle:** Enables or disables path cleaning to standardize URLs.\n*   **Domain Filtering:** Allows users to filter data by domain.\n*   **Device Type Filtering:** Enables users to filter data by device type (desktop or mobile).\n*   **Web Vitals Percentile Selection:** Allows users to select a percentile for web vitals metrics.\n*   **Live User Count:** Displays the current number of active users.\n*   **Domain Selection:** Allows users to select a specific domain to view analytics for.\n*   **Reload Data:** Allows users to reload all data.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/WebAnalyticsDashboard.tsx",
        "summary": "This code defines the Web Analytics Dashboard, a React component that displays various web analytics data in a grid of tiles. The dashboard is highly configurable, allowing for different types of tiles including query tiles (displaying data from a query), tabs tiles (grouping queries into tabs), and tiles for recordings and error tracking. The dashboard also includes filters, health checks, and a modal for displaying more detailed information. It supports opening tiles as new insights in the product analytics section and allows users to toggle between table and graph visualizations for certain tiles.\n\nHere's a list of high-level product features:\n\n*   **Configurable Dashboard:** Allows users to arrange and customize the display of web analytics data through a grid of tiles.\n*   **Query Tiles:** Displays data visualizations based on user-defined queries.\n*   **Tabbed Tiles:** Organizes related queries into a tabbed interface for easier navigation.\n*   **Recordings Tile:** Integrates with session recordings for visual analysis of user behavior.\n*   **Error Tracking Tile:** Displays error tracking data to identify and address website issues.\n*   **Filters:** Provides filtering options to refine the displayed data.\n*   **Health Checks:** Monitors the health and performance of the web analytics setup.\n*   **Modal View:** Offers a detailed view of individual tiles in a modal window.\n*   **Insight Integration:** Enables users to open tiles as new insights in the product analytics section.\n*   **Visualization Toggle:** Allows users to switch between table and graph visualizations for supported tiles.\n*   **Page Reports:** Displays aggregated reports about page views and user interactions.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/CrossSellButtons",
        "summary": "The provided code describes two React components, `HeatmapButton` and `ReplayButton`, designed to enhance the user experience by integrating web analytics with other product features. The `HeatmapButton` allows users to quickly access heatmaps for specific pages, adapting its behavior based on feature flags and providing helpful guidance when no domain is selected. The `ReplayButton` facilitates seamless navigation from web analytics insights to session replays, automatically filtering replays based on the selected breakdown for contextual analysis. Both components track user intent for cross-selling purposes, promoting the adoption of related features.\n\nHere's a list of high-level product features:\n\n*   **Heatmap Integration:** Direct access to heatmaps from web analytics, with feature flag control for UI variations.\n*   **Session Replay Integration:** Seamless navigation from web analytics to session replays with contextual filtering based on breakdowns.\n*   **Contextual Filtering:** Automatic filtering of session replays based on web analytics breakdowns (e.g., device type, page, UTM parameters).\n*   **Cross-Sell Tracking:** Tracks user intent when navigating between web analytics, heatmaps, and session replay.\n*   **Domain Filtering (Heatmaps):** Respects the selected domain filter in web analytics to generate the correct heatmap URL.\n*   **Disabled State with Tooltip (Heatmaps):** Provides a disabled state with a helpful tooltip when a domain is not selected for heatmaps.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/pageReportsLogic.ts",
        "summary": "This code defines the `pageReportsLogic` Kea logic, which manages the state and behavior for displaying web analytics reports for individual pages. It handles fetching page URLs, managing search terms, and constructing queries for various analytics tiles based on the selected page URL. The logic also provides selectors to derive data for rendering the UI, including queries for paths, sources, devices, and geography, as well as combined metrics. It utilizes HogQL queries to retrieve data and provides functionality to strip query parameters from URLs for more accurate matching.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Page-Specific Analytics:** View analytics data filtered to a specific page URL.\n*   **URL Search:** Search for specific page URLs to analyze.\n*   **Query Parameter Handling:** Option to strip query parameters from URLs for more generalized matching.\n*   **Data Visualization:** Display analytics data in various tiles, including paths, sources, devices, and geography.\n*   **Combined Metrics Chart:** Display a chart with combined metrics like unique visitors, page views, and sessions.\n*   **Customizable Tile Visualizations:** Allow users to customize the visualization type for individual tiles.\n*   **Test Account Filtering:** Respect the global test account filtering setting.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/tiles/WebAnalyticsErrorTracking.tsx",
        "summary": "This code defines a React component, `WebAnalyticsErrorTrackingTile`, which displays a tile within a web analytics dashboard. The tile shows a table of error tracking issues, including their name, description, last seen time, number of users affected, and number of occurrences. It uses a custom column component to render the error name and description as a link to the full error tracking issue details. The tile also includes a \"View all\" button that navigates the user to the full error tracking page, triggering a product intent event for cross-selling purposes. The component utilizes PostHog's query system to fetch and display the error data.\n\nHere's a list of high-level product features:\n\n*   **Error Tracking Tile:** Displays a summary of error tracking issues within a web analytics dashboard.\n*   **Error Issue List:** Shows a table of errors with key information like name, description, last seen time, users affected, and occurrences.\n*   **Error Details Link:** Links error names to detailed error tracking issue pages.\n*   **\"View All\" Navigation:** Provides a button to navigate to the full error tracking page.\n*   **Cross-Selling Product Intent:** Tracks user navigation to the error tracking feature from web analytics to suggest related products.\n*   **Customizable Layout:** Allows for flexible placement and sizing of the tile within the dashboard.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/tiles/WebAnalyticsRecordings.tsx",
        "summary": "This component, `WebAnalyticsRecordingsTile`, displays a list of session recordings within a web analytics dashboard. It fetches recordings based on applied filters and displays a maximum of 5 recordings. If no recordings are found, it shows an appropriate empty state message, guiding the user to enable recordings, adjust filters, or learn more about setting up the recording snippet. A \"View all\" button navigates the user to the full session replay view, potentially triggering a product intent cross-sell event. The tile adapts its layout based on screen size and provides loading skeletons while data is being fetched.\n\nHere's a list of high-level product features:\n\n*   **Display Session Recordings:** Shows a list of relevant session recordings within the web analytics dashboard.\n*   **Filter-Based Recordings:** Fetches and displays recordings based on existing web analytics filters.\n*   **Empty State Handling:** Provides informative messages and actions when no recordings are available (e.g., recordings disabled, no matching filters, incorrect setup).\n*   **Loading State:** Displays loading skeletons while fetching recording data.\n*   **Navigation to Full Replay View:** Allows users to navigate to the full session replay view with applied filters.\n*   **Cross-Sell Product Intent:** Tracks user intent to navigate to session replay from web analytics for potential cross-selling opportunities.\n*   **Responsive Layout:** Adapts the tile's layout based on screen size.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/tiles/WebAnalyticsTile.tsx",
        "summary": "This code defines the `WebAnalyticsTile` component, which is responsible for displaying web analytics data in a tabular format. It fetches and presents data related to website traffic, user behavior, and conversions, allowing users to analyze trends and patterns. The component provides features such as sorting, comparison with previous periods, breakdown by various dimensions (e.g., page, browser, country), and visualization of geographical data. It also includes cross-sell buttons for related features like heatmaps and session replays.\n\nHere's a list of high-level product features implemented in this code:\n\n*   **Data Table Display:** Renders web analytics data in a sortable and filterable table.\n*   **Trend Analysis:** Compares current data with previous periods and displays trends (increase/decrease).\n*   **Data Breakdown:** Allows users to break down data by various dimensions like page, browser, OS, country, etc.\n*   **Geographical Data Visualization:** Displays country flags and names for location-based breakdowns.\n*   **Conversion Tracking:** Shows conversion metrics like total conversions, unique conversions, and conversion rate.\n*   **Scroll Depth Analysis:** Provides metrics related to user scrolling behavior (average scroll, deep scroll rate).\n*   **Cross-Selling:** Integrates buttons to promote related features like heatmaps and session replays.\n*   **Path Cleaning:** Cleans and aliases paths to improve readability.\n*   **Sorting:** Allows users to sort the data table by different metrics.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/tiles",
        "summary": "The provided code snippets describe several React components designed as tiles within a web analytics dashboard. These tiles offer a summarized view of different aspects of web analytics, including error tracking, general website traffic and user behavior, and session recordings. They aim to provide quick insights and facilitate navigation to more detailed views and related product features.\n\n**Features:**\n\n*   **Error Tracking Summary:** Displays a table of error tracking issues with key metrics and links to detailed error pages.\n*   **Web Analytics Data Table:** Presents website traffic, user behavior, and conversion data in a sortable and filterable table with trend analysis and breakdown options.\n*   **Session Recording List:** Shows a list of relevant session recordings based on applied filters with navigation to the full session replay view.\n*   **Cross-Selling Integration:** Includes buttons and event tracking to promote related features like heatmaps, session replays, and error tracking.\n*   **Responsive Design:** Adapts the tile layouts based on screen size.\n*   **Empty State Handling:** Provides informative messages and actions when no data is available.\n*   **Loading State Indicators:** Displays loading skeletons while fetching data.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/WebAnalyticsScene.tsx",
        "summary": "The `WebAnalyticsScene` component renders a page displaying web analytics data. It includes a `PageHeader` with a `WebAnalyticsMenu` for user interaction and a `WebAnalyticsDashboard` to visualize the analytics. The scene is also associated with `webAnalyticsLogic` for managing the scene's state and behavior.\n\nHere's a list of high-level product features:\n\n*   **Web Analytics Dashboard:** Displays key metrics and visualizations related to website traffic and user behavior.\n*   **Web Analytics Menu:** Provides options and controls for interacting with the web analytics dashboard (e.g., filtering, exporting, settings).\n*   **Page Header:** A standard header component for the web analytics page, likely containing title and potentially other global actions.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/WebAnalyticsModal.tsx",
        "summary": "This code defines a `WebAnalyticsModal` component in a React application. The modal displays web analytics data based on a query, allows filtering by web property and date range, and provides an option to open the data as a new insight in the product analytics section. The modal is controlled by the `webAnalyticsLogic` Kea logic hook, which manages the modal's visibility, data, and date range.\n\nHere's a list of high-level product features:\n\n*   **Web Analytics Data Display:** Shows web analytics data in a modal.\n*   **Web Property Filtering:** Allows filtering the data based on web property.\n*   **Date Range Filtering:** Enables filtering the data by a specific date range.\n*   **Open as New Insight:** Provides a button to open the current data as a new insight in the product analytics section.\n*   **Modal Management:** Controls the opening, closing, and content of the web analytics modal.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/WebConversionGoal.tsx",
        "summary": "This React component, `WebConversionGoal`, renders a taxonomic popover that allows users to select a conversion goal for web analytics. The component displays a popover that lets users choose between custom events and defined actions as conversion goals. The selected conversion goal is then used in the web analytics product tab. The component dynamically adjusts its placeholder text based on the window size.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Conversion Goal Selection:** Allows users to define a specific event or action as a conversion goal.\n*   **Taxonomic Popover Interface:** Provides a user-friendly interface for browsing and selecting conversion goals from custom events and predefined actions.\n*   **Dynamic Placeholder Text:** Adapts the placeholder text based on the screen size for better user experience.\n*   **Action and Custom Event Support:** Supports both predefined actions and custom events as conversion goals.\n*   **Clear Selection:** Allows users to clear the selected conversion goal.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/WebAnalyticsLiveUserCount.tsx",
        "summary": "This component displays the current number of active users on a website or application in real-time. It fetches the live user count and the time since the last update from the `liveEventsTableLogic` and the current team from `teamLogic`. The component then formats this information into a user-friendly string, including the number of users, the team they are in (if applicable), and the time since the last update. This information is displayed as both a prominent number and a tooltip providing more detailed context.\n\n**Features:**\n\n*   **Real-time User Count:** Displays the number of users currently active on the website.\n*   **Live Updates:** Shows how recently the user count was updated.\n*   **Team Context:** Indicates the team the users belong to (if applicable).\n*   **User-Friendly Formatting:** Presents the user count in a human-readable format (e.g., using abbreviations for large numbers).\n*   **Tooltip Information:** Provides detailed information about the user count, including the team and update time, in a tooltip.\n*   **Visual Indicator:** Uses a visual indicator to show if users are online.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/TableSortingIndicator.tsx",
        "summary": "This component, `TableSortingIndicator`, is a button that displays the current sorting criteria applied to a web analytics table. It uses the `webAnalyticsLogic` to access the current sorting order and the active product tab. The button shows the field being sorted by (e.g., Visitors, Views) and the sort direction (ascending or descending) using an icon. Clicking the button clears the sorting, reverting the table to its default order. The component is only rendered when a sorting order is applied and the active tab is the \"Analytics\" tab.\n\nHere's a list of high-level product features related to this component:\n\n*   **Table Sorting:** Allows users to sort web analytics data tables by different metrics (Visitors, Views, etc.).\n*   **Sort Order Indication:** Visually indicates the current sorting criteria (field and direction) applied to the table.\n*   **Clear Sorting:** Provides a way to remove the current sorting and revert to the default table order.\n*   **Tab-Specific Sorting:** Sorting is only applied and visible within the \"Analytics\" tab.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/WebPropertyFilters.tsx",
        "summary": "This React component, `WebPropertyFilters`, provides a user interface for filtering web analytics data based on event, person, and session properties. It utilizes a popover to display a `PropertyFilters` component, allowing users to define and manage filters. The selected filters are then applied to the web analytics data. The component uses kea logic to manage the state of the filters and the popover's visibility.\n\nHere's a list of high-level product features:\n\n*   **Filter Web Analytics Data:** Allows users to filter web analytics data to focus on specific subsets of data.\n*   **Filter by Event, Person, and Session Properties:** Supports filtering based on event properties, user properties, and session properties.\n*   **Interactive Filter Management:** Provides a popover interface for adding, modifying, and removing filters.\n*   **Visual Filter Count:** Displays a count of the number of active filters.\n*   **Pageview Event Filtering:** Preconfigures the filter component to use `$pageview` events.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/WebAnalyticsHealthCheck.tsx",
        "summary": "The `WebAnalyticsHealthCheck` component in `WebAnalyticsHealthCheck.tsx` displays warning banners to the user if certain conditions related to web analytics data collection are not met. These warnings guide the user to take corrective actions, such as configuring authorized domains, setting up web vitals, or ensuring that `$pageview`, `$pageleave`, and custom events with `$session_id` are being sent correctly. The component checks for the presence of authorized domains, the sending of web vitals events, and the sending of pageview and pageleave events, displaying relevant warnings with links to documentation if any of these are missing.\n\nHere's a list of high-level product features:\n\n*   **Authorized Domains Check:** Warns if no authorized domains are configured, impacting web analytics filters.\n*   **Web Vitals Check:** Warns if no `$web_vitals` events are being received, affecting Web Vitals functionality.\n*   **Pageview and Pageleave Event Check:** Warns if no `$pageview` or `$pageleave` events are being received, impacting core web analytics functionality like bounce rate and session duration.\n*   **Custom Event Session ID Check:** Warns if custom events used as conversion goals are missing `$session_id`, affecting query accuracy.\n*   **In-app Documentation Links:** Provides direct links to relevant documentation for resolving identified issues.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/webAnalyticsLogic.tsx",
        "summary": "This code defines the kea logic for the web analytics feature in PostHog. It manages the state and actions related to web analytics dashboards, including filtering, tab selection, and data fetching for various tiles like overview, graphs, paths, sources, devices, geography, retention, replays, error tracking, and goals. It also handles web vitals and page reports. The logic connects to other kea logics like feature flags, team, user, and preflight to determine available features and team settings. It defines various enums for tabs, tiles, and breakdowns, along with interfaces for tile layouts and data structures.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Web Analytics Dashboard:** Provides a central hub for web analytics data.\n*   **Customizable Tiles:** Allows users to arrange and configure various data visualizations (tiles) on the dashboard.\n*   **Overview Tile:** Displays a summary of key web analytics metrics.\n*   **Graphs Tile:** Visualizes trends in user behavior and website performance.\n*   **Paths Tile:** Analyzes user navigation paths through the website.\n*   **Sources Tile:** Identifies the sources of website traffic (e.g., channels, referrers, UTM parameters).\n*   **Devices Tile:** Provides insights into the devices used to access the website (e.g., browsers, operating systems, device types).\n*   **Geography Tile:** Visualizes website traffic by geographic location (e.g., countries, regions, cities).\n*   **Retention Tile:** Tracks user retention rates over time.\n*   **Session Replay Tile:** Integrates with session replay functionality to observe user behavior.\n*   **Error Tracking Tile:** Displays website errors and their impact on user experience.\n*   **Goals Tile:** Tracks the achievement of predefined conversion goals.\n*   **Web Vitals Tile:** Monitors key web performance metrics (e.g., loading speed, interactivity, visual stability).\n*   **Page Reports:** Provides detailed analytics for individual pages, including traffic sources, device information, and geography.\n*   **Filtering:** Enables users to filter data based on various properties and criteria.\n*   **Tabbed Navigation:** Organizes data into different tabs for graphs, sources, devices, paths, and geography.\n*   **Domain Filtering:** Allows users to focus on specific domains.\n*   **Device Type Filtering:** Enables users to filter data by device type (desktop or mobile).\n*   **Data Visualization Options:** Supports both table and graph visualizations.\n*   **Conversion Goal Tracking:** Allows users to define and track custom conversion goals.\n*   **Session Attribution Explorer:** Provides tools to analyze session attribution."
    },
    {
        "path": "frontend/src/scenes/web-analytics/SessionAttributionExplorer/sessionAttributionExplorerLogic.ts",
        "summary": "This code defines the logic for a Session Attribution Explorer feature, allowing users to analyze how different sources and channels contribute to user sessions. It manages the state of the explorer, including session properties, date ranges, and grouping criteria. The logic also handles synchronization of the explorer's state with the URL, enabling shareable and bookmarkable configurations. It constructs a query based on the selected filters and groupings to fetch and display session attribution data.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Session Property Filtering:** Allows users to filter sessions based on session properties.\n*   **Date Range Selection:** Enables users to specify a date range for analyzing session attribution.\n*   **Grouping by Attribution Channels:** Allows users to group session data by source, medium, channel type, and referring domain.\n*   **Data Visualization:** Presents session attribution data in a tabular format.\n*   **URL Synchronization:** Persists and restores the explorer's state via the URL, enabling sharing and bookmarking.\n*   **Query Building:** Constructs a query based on selected filters and groupings to fetch session attribution data.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/SessionAttributionExplorer/SessionAttributionExplorerScene.tsx",
        "summary": "The Session Attribution Explorer scene provides a user interface for analyzing how user sessions are attributed to different channels. It allows users to group sessions by various attribution factors like channel type, referring domain, UTM parameters, and ad IDs. The scene displays the data in a table format with expandable cells for detailed information, and it integrates with PostHog's preflight checks and support system to provide feedback options. Users can customize the query through property filters and date ranges.\n\nHere's a list of high-level product features:\n\n*   **Session Attribution Analysis:** Analyze how user sessions are attributed to different channels.\n*   **Grouping by Attribution Factors:** Group sessions by channel type, referring domain, UTM parameters (source, medium, campaign), ad IDs, and entry URL.\n*   **Data Table Display:** Display session attribution data in a tabular format.\n*   **Expandable Data Cells:** Provide expandable cells in the data table for detailed information on attribution factors.\n*   **Property Filters:** Allow users to filter sessions based on properties.\n*   **Date Range Selection:** Allow users to specify a date range for session analysis.\n*   **Feedback Mechanism:** Integrate with PostHog's support system to collect user feedback on session attribution accuracy.\n*   **Channel Type Definition Link:** Provide a link to PostHog's documentation on channel types.\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics/SessionAttributionExplorer",
        "summary": "The Session Attribution Explorer empowers users to dissect how different sources and channels contribute to user sessions through an interactive interface. Users can filter sessions based on properties and date ranges, group data by attribution channels like source, medium, and referring domain, and visualize the results in a detailed table with expandable cells. The explorer also supports URL synchronization for easy sharing and bookmarking of specific configurations, and integrates with PostHog's support system for feedback.\n\nHere's a list of high-level product features:\n\n*   Session Attribution Analysis\n*   Grouping by Attribution Factors (channel type, referring domain, UTM parameters, ad IDs, entry URL)\n*   Session Property Filtering\n*   Date Range Selection\n*   Data Table Display with Expandable Data Cells\n*   URL Synchronization\n*   Query Building\n*   Feedback Mechanism\n*   Channel Type Definition Link\n"
    },
    {
        "path": "frontend/src/scenes/web-analytics",
        "summary": "The web analytics suite provides a comprehensive platform for understanding user behavior and website performance. It offers a customizable dashboard with various tiles displaying key metrics, visualizations, and session recordings. Users can filter data by date range, properties, and device type, and define conversion goals to track progress. The suite also includes features for analyzing page-specific performance, session attribution, and identifying website health issues. Cross-selling integrations with heatmaps and session replays provide deeper insights, while real-time user counts offer immediate awareness of website activity.\n\n*   Configurable Dashboard with Customizable Tiles\n*   Real-time User Count\n*   Session Attribution Explorer\n*   Page-Specific Analytics\n*   Conversion Goal Tracking\n*   Data Filtering (Date Range, Properties, Device Type, Domain)\n*   Session Replay Integration\n*   Heatmap Integration\n*   Error Tracking\n*   Web Vitals Monitoring\n*   Health Checks and Issue Detection\n*   Data Visualization (Graphs, Tables)\n*   User Path Analysis\n*   Source and Channel Analysis\n*   Device and Geography Analysis\n*   Retention Analysis\n*   Test Account Filtering\n*   Data Comparison\n*   Table Sorting\n*   URL Parameter Stripping\n*   Authorized Domains Check\n*   Insight Integration\n*   Cross-Sell Tracking\n*   Live User Count\n*   Web Property Filtering\n*   Table Sorting\n*   Session Attribution Analysis\n*   Query Building\n*   Feedback Mechanism\n"
    },
    {
        "path": "frontend/src/scenes/surveys/SurveyAPIEditor.tsx",
        "summary": "The `SurveyAPIEditor` component is a React component that displays a survey object as a JSON code snippet. It takes a survey object as a prop and transforms it into a format suitable for the API, including fields like `id`, `name`, `description`, `type`, `linked_flag_key`, `targeting_flag_key`, `questions`, `conditions`, `start_date`, and `end_date`. The component then uses the `CodeSnippet` component to render the JSON string with proper formatting and syntax highlighting.\n\nHere's a list of high-level features provided by this component:\n\n*   **Survey Object Visualization:** Displays a survey object in a human-readable JSON format.\n*   **API-Friendly Formatting:** Transforms the survey object into a format suitable for API consumption.\n*   **Code Syntax Highlighting:** Uses a `CodeSnippet` component to provide syntax highlighting for the JSON code.\n*   **Data Transformation:** Extracts and formats relevant survey properties, including linked and targeting flag keys.\n"
    },
    {
        "path": "frontend/src/scenes/surveys/SurveyWidgetCustomization.tsx",
        "summary": "This code defines the `SurveyWidgetCustomization` component, which allows users to customize the appearance and behavior of a survey widget. Users can select the type of feedback button (embedded tab or custom selector), and then configure properties specific to that type. For the embedded tab, users can set the button label and background color. For the custom selector, users can specify a CSS selector. Additionally, users can choose whether to always display the feedback button, regardless of how many times it has been shown.\n\nHere's a list of high-level product features:\n\n*   **Feedback Button Type Selection:** Allows users to choose between an embedded tab or a custom CSS selector for the feedback button.\n*   **Embedded Tab Customization:**\n    *   **Button Label Configuration:** Allows users to set the text displayed on the embedded feedback button.\n    *   **Background Color Configuration:** Allows users to set the background color of the embedded feedback button.\n*   **Custom Selector Configuration:**\n    *   **CSS Selector Input:** Allows users to specify a CSS selector to target a custom element for the feedback button.\n*   **Display Frequency Control:** Allows users to configure whether the feedback button is always displayed or shown only once.\n"
    },
    {
        "path": "frontend/src/scenes/surveys/SurveyResponsesCollection.tsx",
        "summary": "This code defines a React component called `SurveyResponsesCollection` that renders a LemonSwitch component. This switch controls whether partial survey responses are stored, even if the user doesn't complete the survey. Enabling this feature requires a minimum version of the posthog-js library. The component uses kea-logic to connect to the surveyLogic, allowing it to access the current survey object and update the `enable_partial_responses` property.\n\nHere's a list of high-level product features:\n\n*   **Enable Partial Survey Responses:** Allows capturing and storing survey responses even if the user doesn't finish the survey.\n*   **Toggle Control:** Provides a switch to enable or disable the partial responses feature.\n*   **Tooltip Explanation:** Offers a tooltip explaining the feature and its requirements (minimum posthog-js version).\n*   **Real-time Survey Configuration:** Updates the survey configuration in real-time when the switch is toggled.\n"
    },
    {
        "path": "frontend/src/scenes/surveys/SurveyAppearancePreview.tsx",
        "summary": "This component, `SurveyAppearancePreview`, is responsible for rendering a preview of a survey's appearance. It utilizes the `posthog-js` library to render both a standard survey preview and a feedback widget preview. The component takes a survey object, a preview page index, and an optional submit handler as props. It sanitizes the survey's appearance and then renders the previews within designated div elements using refs. The rendering is triggered as a side effect within a `useEffect` hook, which depends on the survey object, the preview page index, and a flag indicating whether HTML rendering is available.\n\nHere's a list of high-level product features:\n\n*   **Survey Appearance Preview:** Allows users to preview how their survey will look to end-users.\n*   **Feedback Widget Preview:** Enables users to see how the survey will appear when rendered as a feedback widget.\n*   **HTML Rendering Control:** Provides a mechanism to enable or disable HTML rendering in the survey preview, likely for compatibility or security reasons.\n*   **Page-Specific Preview:** Supports previewing specific pages within a multi-page survey.\n*   **Submit Handler Simulation:** Allows simulating survey submissions within the preview environment.\n"
    },
    {
        "path": "frontend/src/scenes/surveys/SurveySettings.tsx",
        "summary": "The `SurveySettings.tsx` file provides a user interface for configuring survey settings within PostHog. It allows users to enable/disable surveys for their team and customize the appearance of new surveys. The appearance settings include colors for various elements like background, border, rating buttons, and submit button, as well as placeholder text. The component also displays a preview of the survey with the applied appearance settings. The settings can be accessed as a modal or as a dedicated settings page.\n\nHere's a list of high-level product features:\n\n*   **Enable/Disable Surveys:** Allows users to opt-in or opt-out of using surveys for their team.\n*   **Global Survey Appearance Customization:** Enables users to customize the appearance (colors, text) of new surveys.\n*   **Real-time Survey Appearance Preview:** Provides a live preview of the survey appearance as changes are made.\n*   **Input Validation:** Validates color inputs to ensure they are in the correct format.\n*   **Settings Persistence:** Saves the survey appearance settings for the team.\n*   **Modal Settings:** Provides a modal for quick access to survey settings.\n"
    },
    {
        "path": "frontend/src/scenes/surveys/SurveyDragHandle.tsx",
        "summary": "The `SurveyDragHandle.tsx` component provides a drag handle for reordering survey questions within a survey creation or editing interface. It leverages the `@dnd-kit/core` library for drag-and-drop functionality and displays a drag icon from `lib/lemon-ui/icons`. The component conditionally renders the drag handle only when there are multiple questions in the survey, preventing it from appearing when there's only one question.\n\nHere's a list of high-level product features related to this component:\n\n*   **Drag and Drop Question Reordering:** Allows users to change the order of questions in a survey using a drag-and-drop interface.\n*   **Visual Drag Handle:** Provides a visual cue (drag icon) to indicate that a question can be dragged and reordered.\n*   **Conditional Display:** Only shows the drag handle when there are multiple questions, preventing unnecessary UI elements.\n*   **Accessibility:** Uses appropriate ARIA attributes (via `listeners`) to ensure the drag-and-drop functionality is accessible to users with disabilities.\n"
    },
    {
        "path": "frontend/src/scenes/surveys/SurveyRepeatSchedule.tsx",
        "summary": "This code defines the `SurveyRepeatSchedule` component, which allows users to configure how often a survey should be displayed to users. It provides options for displaying the survey once, repeating it on a schedule, or making it always visible (for feedback surveys). When the \"Repeat on a schedule\" option is selected, users can specify the number of times the survey should be repeated and the frequency (in days) between each iteration. The component also handles cases where the survey is triggered by specific events, in which case the repeat schedule settings are not applicable, and the user is prompted to remove the event targeting if they want to use the schedule.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Survey Scheduling:** Allows users to define when and how often a survey is displayed.\n*   **Iteration Control:** Enables users to specify the number of times a survey should be repeated.\n*   **Frequency Control:** Allows users to set the time interval between survey iterations.\n*   **Conditional Scheduling:** Adapts the scheduling options based on whether the survey is triggered by specific events.\n*   **Feedback Survey Option:** Provides an option to make surveys always visible, specifically for feedback collection.\n*   **Plan-Based Restrictions:** Restricts the \"Repeat on a schedule\" feature based on the user's subscription plan.\n*   **Input Validation:** Enforces minimum and maximum values for iteration count and frequency.\n"
    },
    {
        "path": "frontend/src/scenes/surveys/SurveyFormAppearance.tsx",
        "summary": "The `SurveyFormAppearance` component provides the UI for configuring the appearance of a survey. It renders either a `SurveyAppearancePreview` component for non-API surveys, allowing users to preview and interact with the survey flow, or a `SurveyAPIEditor` for API surveys. For non-API surveys, it also includes a `LemonSelect` dropdown to navigate between survey questions and the confirmation message (if enabled). The component handles updating the selected page index in the preview based on user interaction and branching logic.\n\nHere's a list of high-level product features:\n\n*   **Survey Preview:** Allows users to preview the survey as it will appear to respondents.\n*   **Question Navigation:** Enables users to navigate between different questions in the survey.\n*   **Conditional Logic Preview:** Simulates survey branching logic based on responses.\n*   **Confirmation Message Preview:** Shows the confirmation message displayed at the end of the survey.\n*   **API Survey Editor:** Provides a dedicated editor for configuring API-based surveys.\n"
    },
    {
        "path": "frontend/src/scenes/surveys/SurveyAppearanceUtils.tsx",
        "summary": "This code provides UI components for configuring the appearance of surveys. It includes a `PresentationTypeCard` component for selecting survey presentation styles and an `HTMLEditor` component that allows users to edit survey text using either a plain text editor or an HTML editor. The HTML editor conditionally renders a `PayGateMini` component if the user's plan doesn't include HTML editing capabilities. A warning banner is displayed if the HTML contains `<script>` tags, informing the user that scripts will be removed.\n\nHere's a list of high-level product features:\n\n*   **Survey Presentation Style Selection:** Allows users to choose from different visual styles for their surveys.\n*   **Text-based Survey Content Editing:** Provides a simple text editor for creating survey questions and descriptions.\n*   **HTML-based Survey Content Editing (Conditional):** Offers an HTML editor for more advanced customization of survey content, potentially gated behind a paywall.\n*   **Code Editor:** Provides a code editor component for editing HTML.\n*   **Script Tag Removal Warning:** Alerts users that `<script>` tags will be removed from survey content to prevent security issues.\n"
    },
    {
        "path": "frontend/src/scenes/surveys/SurveyCustomization.tsx",
        "summary": "The `SurveyCustomization.tsx` file provides a React component for customizing the appearance and behavior of surveys within PostHog. It allows users to modify various visual aspects such as background color, border color, button colors, and font, as well as functional aspects like survey position, placeholder text, question shuffling, and popup delay. The component integrates with PostHog's feature flagging and upgrade mechanisms to control access to certain customization options based on the user's plan. It also handles validation and displays errors for invalid input.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Visual Customization:**\n    *   Background color selection\n    *   Border color selection\n    *   Button color customization (submit button, rating buttons)\n    *   Font selection\n    *   Survey position adjustment (left, center, right)\n    *   Placeholder text customization\n    *   Z-index adjustment for survey form\n*   **Behavioral Customization:**\n    *   Question shuffling (with branching logic conflict resolution)\n    *   Survey popup delay\n*   **Branding Control:**\n    *   White labeling (hiding PostHog branding)\n*   **Feature Gating:**\n    *   Restricting customization options based on the user's PostHog plan (e.g., styling, white labeling)\n*   **Input Validation:**\n    *   Displaying validation errors for invalid customization values"
    },
    {
        "path": "frontend/src/scenes/surveys/SurveySQLHelper.tsx",
        "summary": "The `SurveySQLHelper` component provides a modal that displays SQL queries for retrieving survey responses from the `events` table. It generates two types of queries: one for retrieving all questions in a survey and another for retrieving responses to individual questions. The queries handle both older (index-based) and newer (UUID-based) question identification methods. Users can view the generated SQL queries and open them as new insights in PostHog for further analysis. The component also displays a disclaimer about the query's limitations regarding additional property filters.\n\nHere's a list of high-level product features:\n\n*   **SQL Query Generation:** Automatically generates SQL queries to retrieve survey response data.\n*   **Full Survey Query:** Generates a single query to retrieve all responses for all questions in a survey.\n*   **Individual Question Queries:** Generates separate queries for each question in a survey, allowing focused analysis.\n*   **Dual Question ID Support:** Handles both index-based and UUID-based question IDs in the generated queries.\n*   **Open in Insight:** Provides a button to open the generated SQL query as a new insight in PostHog for data exploration and visualization.\n*   **Response Filter Integration:** Incorporates response filters set on the survey table into the generated SQL queries.\n*   **Disclaimer Display:** Shows a disclaimer about the limitations of the generated queries, specifically regarding additional property filters.\n"
    },
    {
        "path": "frontend/src/scenes/surveys/SurveyTemplates.tsx",
        "summary": "This code defines the `SurveyTemplates` component, which displays a list of pre-built survey templates that users can choose from to quickly create new surveys. The component fetches survey templates, including default templates and potentially an error tracking survey if certain feature flags are enabled. It renders each template with a preview and allows users to select a template, pre-populating the new survey form with the template's configuration, including questions, appearance settings, and conditions. The component also provides a button to create a blank survey from scratch.\n\nHere's a list of high-level product features:\n\n*   **Survey Template Selection:** Allows users to choose from a list of pre-designed survey templates.\n*   **Survey Template Preview:** Displays a preview of each survey template's appearance.\n*   **Template-Based Survey Creation:** Pre-populates a new survey with the selected template's questions, appearance, and conditions.\n*   **Blank Survey Creation:** Provides an option to create a survey from scratch.\n*   **Dynamic Template List:** Conditionally includes an error tracking survey template based on feature flags and data availability.\n*   **Customizable Appearance:** Merges default, template-specific, and team-level appearance settings for the survey.\n"
    },
    {
        "path": "frontend/src/scenes/surveys/QuestionBranchingInput.tsx",
        "summary": "This code defines the `QuestionBranchingInput` and `QuestionResponseBasedBranchingInput` components, which are used to configure branching logic within a survey. The `QuestionBranchingInput` component allows users to specify where the survey should navigate after a given question, offering options like the next question, the end of the survey, or a specific question. If response-based branching is selected, the `QuestionResponseBasedBranchingInput` component is rendered, enabling users to define different navigation paths based on the respondent's answer to the question. This component dynamically generates options based on the question type (rating or single choice) and scale (for rating questions), allowing for granular control over the survey flow. A warning dialog is displayed if the survey has question shuffling enabled, as branching logic disables shuffling.\n\nHere's a list of high-level product features:\n\n*   **Conditional Question Branching:** Allows survey creators to define the next question based on the answer to the current question.\n*   **Simple Branching:** Allows survey creators to define the next question to be either the next question in the survey, a specific question, or the end of the survey.\n*   **Response-Based Branching:** Enables branching based on specific responses to rating or single-choice questions.\n*   **NPS Category Branching:** For 10-point rating scales, provides branching options based on NPS categories (Detractors, Passives, Promoters).\n*   **Shuffle Question Compatibility Handling:** Warns users and disables question shuffling when branching logic is added.\n*   **Dynamic Branching Options:** Dynamically generates branching options based on question type and scale.\n"
    },
    {
        "path": "frontend/src/scenes/surveys/constants.tsx",
        "summary": "This code defines constants, default values, and templates for creating and managing surveys within the PostHog platform. It includes definitions for survey question types, match types, default appearance settings, and pre-built survey templates for various use cases like gathering open feedback, scheduling user interviews, measuring Net Promoter Score (NPS), Customer Satisfaction (CSAT), and more. It also defines a default \"New Survey\" object and an error tracking survey template.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Survey Creation:** Allows users to create custom surveys with various question types (open text, rating, link, single/multiple choice).\n*   **Survey Targeting:** Enables targeting surveys based on user behavior and properties, including event triggers and URL conditions.\n*   **Survey Appearance Customization:** Provides options to customize the look and feel of surveys, including fonts, colors, and widget placement.\n*   **Survey Scheduling:** Supports scheduling surveys to be displayed at specific times or intervals.\n*   **Survey Templates:** Offers pre-built survey templates for common use cases like NPS, CSAT, and user interviews.\n*   **Error Tracking Surveys:** Provides a specialized survey template to gather user feedback when exceptions occur in the application.\n*   **Response Handling:** Defines constants for tracking survey responses and managing response limits.\n*   **Partial Response Handling:** Enables the collection and storage of partial survey responses.\n"
    },
    {
        "path": "frontend/src/scenes/surveys/surveyLogic.tsx",
        "summary": "This code defines the `surveyLogic` Kea logic for managing individual surveys in a PostHog application. It handles loading, creating, updating, duplicating, launching, stopping, and resuming surveys. It also manages survey questions, branching logic, appearance settings, display conditions, scheduling, and completion conditions. The logic fetches and processes survey results, including user statistics, rating breakdowns, NPS scores, and open text responses. It uses HogQL queries to retrieve and analyze survey data, and it integrates with other parts of the application, such as feature flags, team settings, and event tracking.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Survey Creation and Editing:** Allows users to create new surveys and modify existing ones, including defining questions, branching logic, and appearance.\n*   **Survey Targeting and Display Conditions:** Enables users to target specific user segments with surveys based on properties and feature flags.\n*   **Survey Scheduling:** Allows users to schedule surveys to start and end at specific times.\n*   **Survey Launch and Management:** Provides functionality to launch, stop, and resume surveys.\n*   **Survey Duplication:** Enables users to duplicate existing surveys for reuse or modification.\n*   **Survey Results and Analytics:** Provides tools to analyze survey responses, including user statistics, rating breakdowns, NPS scores, and open text analysis.\n*   **Adaptive Sampling and Response Limits:** Allows users to configure adaptive sampling and response limits for surveys.\n*   **Integration with Feature Flags:** Enables surveys to be targeted based on feature flag status.\n*   **Customizable Survey Appearance:** Allows users to customize the appearance of surveys to match their brand.\n"
    },
    {
        "path": "frontend/src/scenes/surveys/SurveyEdit.tsx",
        "summary": "This code defines the `SurveyEdit` component, a feature-rich interface for creating and modifying surveys within the PostHog platform. It allows users to define survey questions, customize the survey's appearance, configure targeting options, and set response limits. The component leverages various Lemon UI components and integrates with PostHog's feature flag system to enable or disable certain functionalities. It also includes advanced features like adaptive response limits, recurring schedules, and branching logic.\n\nHere's a list of high-level product features implemented in the code:\n\n*   **Survey Creation and Editing:** Allows users to create new surveys or modify existing ones.\n*   **Question Management:** Enables users to add, edit, and reorder survey questions. Supports different question types (e.g., rating, link).\n*   **Appearance Customization:** Provides options to customize the survey's appearance, including the presentation type (e.g., popover) and widget customization.\n*   **Targeting Configuration:** Allows users to target specific users based on events, actions, feature flags, and properties.\n*   **Response Limiting:** Enables users to set limits on the number of survey responses collected, with options for fixed limits and adaptive limits.\n*   **Scheduling:** Supports scheduling surveys to run once or on a recurring basis.\n*   **Branching Logic:** Implements branching logic, allowing the survey flow to adapt based on user responses.\n*   **Partial Response Collection:** Collects and stores partial survey responses.\n*   **API Integration:** Provides an API editor for advanced survey configuration.\n*   **Preview Functionality:** Allows users to preview the survey's appearance."
    },
    {
        "path": "frontend/src/scenes/surveys/Survey.tsx",
        "summary": "This code defines a React component for creating, editing, and viewing surveys within a PostHog application. It leverages Kea logic for state management and form handling. The component handles loading surveys, displaying them in either edit or view mode, and managing display conditions based on URL, device type, feature flags, user properties, and event triggers. It also includes functionality for canceling or saving survey changes.\n\nHere's a list of high-level product features:\n\n*   **Survey Creation and Editing:** Allows users to create new surveys or modify existing ones.\n*   **Survey Viewing:** Displays surveys in a read-only format.\n*   **Display Condition Configuration:** Enables users to define conditions for when a survey should be displayed, including URL matching, device type targeting, feature flag targeting, user property targeting, and event-based triggering.\n*   **Feature Flag Integration:** Links surveys to feature flags, ensuring surveys are only shown to users who meet the flag's criteria.\n*   **URL Targeting:** Targets surveys based on the URL the user is visiting.\n*   **Device Type Targeting:** Targets surveys based on the device type the user is using.\n*   **User Property Targeting:** Targets surveys based on user properties.\n*   **Event-Based Triggering:** Triggers surveys based on specific events performed by the user.\n*   **Wait Period Configuration:** Allows setting a wait period before showing the survey again to a user who has already seen it.\n*   **Draft Saving:** Saves surveys as drafts for later editing.\n"
    },
    {
        "path": "frontend/src/scenes/surveys/SurveyEditQuestionRow.tsx",
        "summary": "This code defines the UI components for editing survey questions within a survey editor. It includes components for managing question order, deleting questions, and editing question properties such as type, label, description, and options. The code also handles branching logic, optional questions, and specific input types for different question types like links, ratings, and multiple-choice questions. The components use Lemon UI components and kea-forms for state management and UI elements.\n\nHere's a list of high-level product features based on the code:\n\n*   **Drag and Drop Question Ordering:** Allows users to reorder survey questions using drag and drop functionality.\n*   **Question Type Selection:** Enables users to choose from various question types, including open-ended, link/notification, rating, single-choice, and multiple-choice.\n*   **Question Label and Description Editing:** Provides input fields for editing the question label and description, with support for HTML descriptions.\n*   **Optional Question Setting:** Allows users to mark questions as optional.\n*   **Link Input for Link Questions:** Provides a specific input field for entering links for link-type questions.\n*   **Rating Question Configuration:** Enables users to configure rating questions with options for display type (number or emoji) and scale.\n*   **Choice Management for Multiple Choice Questions:** Allows users to add, edit, and remove choices for single and multiple-choice questions.\n*   **Branching Logic Management:** Handles branching logic, including warnings and deletion when deleting questions with active branching.\n*   **Question Deletion:** Allows users to delete questions from the survey."
    },
    {
        "path": "frontend/src/scenes/surveys/utils.ts",
        "summary": "This code provides a set of utility functions for handling surveys in a PostHog frontend application. It includes functions for sanitizing HTML and colors, generating keys for survey responses (handling both index-based and ID-based formats), constructing HogQL conditions for querying survey responses, calculating NPS scores and breakdowns, and creating HogQL expressions for filtering survey answers. The code ensures data integrity through sanitization and validation, and it facilitates flexible querying of survey responses by accommodating different key formats and operators.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **HTML Sanitization:** Prevents XSS vulnerabilities in survey content.\n*   **Color Sanitization and Validation:** Ensures consistent and valid styling of surveys.\n*   **Survey Response Key Generation:** Creates unique keys for storing and retrieving survey responses, supporting both index and ID based formats.\n*   **HogQL Condition Generation:** Constructs database queries to filter and analyze survey responses.\n*   **NPS Score Calculation:** Computes Net Promoter Score from survey results.\n*   **Survey Answer Filtering:** Allows filtering of survey responses based on various criteria (exact match, contains, regex, etc.).\n"
    },
    {
        "path": "frontend/src/scenes/surveys/SurveyResponseFilters.tsx",
        "summary": "This code defines a React component called `SurveyResponseFilters` that allows users to filter survey responses based on answers to survey questions and other event properties. It displays a UI for adding and configuring filters for each question in a survey, including selecting the filter operator (e.g., contains, exact match) and entering the value to filter by. The component also includes a button to generate the SQL query corresponding to the applied filters and a generic property filter component for filtering by event properties.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Filter Survey Responses by Question Answers:** Allows users to filter survey responses based on the answers provided to specific questions in the survey.\n*   **Multiple Filter Operators:** Supports various filter operators like \"contains\", \"exact match\", \"regex\", etc., depending on the question type.\n*   **Dynamic Filter Options:** Dynamically adjusts filter options based on the type of survey question (e.g., open text, rating, single choice).\n*   **SQL Query Generation:** Provides a feature to generate the SQL query equivalent to the applied filters for advanced analysis or debugging.\n*   **Filter by Event Properties:** Enables filtering survey responses based on event properties associated with the survey submission.\n*   **Visual Filter Configuration:** Offers a user-friendly interface to configure filters with dropdowns and input fields.\n*   **Logical AND operator between question filters:** Combines filters for multiple questions using a logical AND operator."
    },
    {
        "path": "frontend/src/scenes/surveys/SurveyOverview.tsx",
        "summary": "This code defines the `SurveyOverview` component, which provides a detailed summary and configuration options for a survey within the PostHog application. It displays key information such as the survey's display mode, questions, schedule, start and end dates, and completion conditions. Depending on the survey type (API or form-based), it either renders a preview of the survey form using `SurveyFormAppearance` or provides an API editor using `SurveyAPIEditor` along with a link to the documentation for API survey setup. The component utilizes various Lemon UI components and PostHog logic hooks to fetch and display survey data and manage user interactions.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Survey Summary Display:** Shows a summary of the survey's configuration, including questions, schedule, and dates.\n*   **Survey Type Handling:** Differentiates between API and form-based surveys, displaying appropriate configuration options.\n*   **Form-Based Survey Preview:** Renders a preview of the survey form, allowing users to see how it will appear to respondents.\n*   **API Survey Editor:** Provides an editor for configuring API-based surveys, including a link to relevant documentation.\n*   **Completion Condition Display:** Shows the conditions under which the survey will stop collecting responses (e.g., reaching a response limit).\n*   **Partial Response Setting:** Displays whether partial responses are enabled for the survey.\n*   **Adaptive Response Limiting:** Displays the adaptive sampling limit configuration for the survey.\n"
    },
    {
        "path": "frontend/src/scenes/surveys/surveyViewViz.tsx",
        "summary": "This code provides a React component for visualizing survey results within a PostHog application. It includes components for displaying overall survey statistics (number of users shown the survey, number of responses, and breakdown of responses into unanswered, dismissed, and submitted), as well as detailed visualizations for individual questions. The visualizations include stacked bar charts for representing response distributions (e.g., NPS scores) and bar/line charts for rating scale questions. The component leverages PostHog's feature flagging, Lemon UI library, and Kea for state management.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Survey Response Visualization:** Display aggregated survey response data.\n*   **User Statistics:** Show the number of users who have seen, dismissed, or submitted the survey.\n*   **Response Breakdown:** Visualize the distribution of responses (e.g., unanswered, dismissed, submitted) using a stacked bar chart.\n*   **NPS Score Visualization:** Display NPS score distribution using a stacked bar chart.\n*   **Rating Question Visualization:** Show the distribution of ratings for rating scale questions using a bar chart.\n*   **Recurring NPS Score Visualization:** Display NPS scores over time using a line chart.\n*   **Data Loading and Error Handling:** Display loading states and handle cases where survey results are not yet available.\n*   **Customizable Chart Appearance:** Allow customization of chart colors and labels.\n*   **Integration with PostHog Features:** Leverage PostHog feature flags and libraries for UI components and state management."
    },
    {
        "path": "frontend/src/scenes/surveys/Surveys.tsx",
        "summary": "The `Surveys.tsx` file defines the Surveys scene in PostHog, providing a user interface for managing and interacting with surveys. It includes features for creating new surveys (from templates or blank), searching and filtering surveys, viewing survey responses, and managing survey settings. The scene utilizes Lemon UI components for a consistent look and feel, and integrates with other PostHog features like Hog Functions for survey response notifications and the activity log for tracking survey changes. The scene also handles different tabs for active, archived, notifications, history, and settings related to surveys.\n\nHere's a list of high-level product features:\n\n*   **Survey Creation:** Allows users to create new surveys from templates or from scratch.\n*   **Survey Listing and Management:** Displays a list of surveys with details like name, responses, mode, question type, creator, creation date, and status.\n*   **Survey Search and Filtering:** Enables users to search for surveys by name and filter them by status (draft, running, complete) and creator.\n*   **Survey Response Tracking:** Shows the number of responses received for each survey.\n*   **Survey Status Management:** Allows users to archive and unarchive surveys.\n*   **Survey Settings:** Provides a dedicated settings tab to configure global survey appearance.\n*   **Survey Response Notifications:** Integrates with Hog Functions to enable notifications upon survey submission.\n*   **Activity Log:** Tracks changes made to surveys for auditing and historical purposes.\n*   **Survey Documentation:** Provides links to the PostHog surveys documentation.\n*   **Product Introduction:** Guides new users through the survey feature with a product introduction component."
    },
    {
        "path": "frontend/src/scenes/surveys/surveysLogic.tsx",
        "summary": "This code defines the logic for managing surveys in a PostHog application. It handles fetching, searching, filtering, creating, updating, and deleting surveys. It also manages UI state such as the active tab (Active, Yours, Archived, etc.) and search term. The logic connects to the PostHog API to persist changes and retrieve data, and it integrates with other parts of the application such as user and team management. It also checks for available features to enable or disable certain functionalities related to surveys.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Survey Listing and Management:** Displaying a list of surveys, with pagination and the ability to load more surveys.\n*   **Survey Creation, Editing, and Deletion:** Allowing users to create, modify, and remove surveys.\n*   **Survey Searching:** Enabling users to search for surveys by name or key.\n*   **Survey Filtering:** Providing options to filter surveys based on status (draft, running, complete), creator, and archived status.\n*   **Survey Archiving:** Allowing users to archive surveys.\n*   **Tabbed Interface:** Organizing surveys into different tabs (Active, Yours, Archived, etc.) for easy navigation.\n*   **Real-time Updates:** Updating the survey list and details in real-time after actions like creation, deletion, or updates.\n*   **Feature Flag Integration:** Enabling or disabling certain survey features based on available feature flags (e.g., styling, HTML support, multiple questions, recurring schedules).\n*   **Response Count Tracking:** Displaying the number of responses received for each survey.\n*   **Activation Task Completion:** Marking activation tasks as completed when surveys are launched or responses are collected.\n*   **Surveys Disabled Banner:** Displaying a banner if surveys are disabled for the current team."
    },
    {
        "path": "frontend/src/scenes/surveys/SurveyView.tsx",
        "summary": "This code defines the `SurveyView` component, which is responsible for displaying and managing a single survey. It fetches survey data using `surveyLogic` and `surveysLogic` and provides functionalities to view survey results, edit survey details, launch, stop, archive, resume, duplicate, and delete surveys. The component uses Lemon UI components for styling and interactions, and includes visualizations for different question types like multiple choice, NPS, rating, and open text. It also integrates with feature flags to conditionally display features like linked Hog Functions. The component uses tabs to switch between survey overview and results.\n\nHere's a list of high-level product features:\n\n*   **Survey Management:**\n    *   Create, Read, Update, and Delete (CRUD) surveys.\n    *   Launch, stop, archive, and resume surveys.\n    *   Duplicate existing surveys.\n*   **Survey Result Visualization:**\n    *   Display survey results in various chart formats (bar charts, pie charts, stacked bars) based on question type.\n    *   Support for multiple choice, NPS, rating, and open text questions.\n    *   Summary statistics for survey responses.\n*   **Survey Configuration:**\n    *   Edit survey details such as description.\n    *   Define display conditions for surveys.\n*   **User Interface:**\n    *   Tabbed interface for switching between survey overview and results.\n    *   Confirmation dialogs for important actions (launch, stop, delete, archive).\n    *   Integration with Lemon UI component library.\n*   **Activity Logging:**\n    *   Track survey-related activities in an activity log.\n*   **Hog Function Linking:**\n    *   Option to link Hog Functions to surveys (behind a feature flag).\n*   **Response Filtering:**\n    *   Filter survey responses based on various criteria.\n*   **Date Filtering:**\n    *   Filter survey responses by date range.\n"
    },
    {
        "path": "frontend/src/scenes/surveys/surveyActivityDescriber.tsx",
        "summary": "This code defines a `surveyActivityDescriber` function that generates human-readable descriptions of changes made to a survey, for use in an activity log. It handles various survey actions like creation, deletion, updates to name, description, questions, archiving status, start/end dates, appearance settings, conditions, response limits, iteration settings, and targeting flag configurations. The function leverages a mapping of survey fields to specific description generators, providing detailed information about each change, including before and after values where applicable. It constructs sentences and lists to present the changes in a clear and concise manner, incorporating links to the survey when appropriate.\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **Survey Creation and Deletion Logging:** Tracks when surveys are created and deleted, including the user who performed the action and a link to the survey.\n*   **Survey Name and Description Change Logging:** Records changes to the survey's name and description, showing the previous and new values.\n*   **Survey Question Change Logging:** Logs changes to the survey questions, including the number of questions and specific modifications to individual questions.\n*   **Survey Archiving/Unarchiving Logging:** Tracks when a survey is archived or unarchived.\n*   **Survey Scheduling Logging:** Records when a survey is launched (start date set) or stopped (end date set).\n*   **Survey Appearance Customization Logging:** Logs changes to the survey's appearance settings, such as background color, button colors, text, and positioning.\n*   **Survey Condition Change Logging:** Tracks modifications to survey conditions, including URL matching, selector conditions, and event-based conditions.\n*   **Survey Response Limit Logging:** Records changes to the maximum number of responses allowed for a survey.\n*   **Survey Iteration Logging:** Logs changes to the survey's iteration count and frequency.\n*   **Survey Targeting Flag Logging:** Tracks changes to the feature flag used for targeting the survey, including the flag key and targeting conditions.\n*   **Detailed Activity Log:** Provides a comprehensive activity log for surveys, showing who made the changes and what was changed.\n"
    },
    {
        "path": "frontend/src/scenes/surveys",
        "summary": "This collection of code files outlines a comprehensive survey management system within PostHog, enabling users to create, customize, target, and analyze surveys. The system provides a rich set of features for tailoring the survey experience, from visual appearance and question types to targeting rules and response analysis. Users can leverage pre-built templates, customize surveys with HTML and branching logic, and gain insights from detailed visualizations of survey results. The system also includes robust logging and versioning capabilities, ensuring a complete audit trail of survey changes.\n\nHere's a list of high-level product features:\n\n*   **Survey Creation and Editing:** Create new surveys from scratch or using templates, and modify existing surveys with a variety of question types and customization options.\n*   **Visual Customization:** Customize the survey's appearance with options for colors, fonts, positioning, and branding.\n*   **Targeting and Display Conditions:** Target specific user segments with surveys based on URL, device type, feature flags, user properties, and event triggers.\n*   **Scheduling and Iteration:** Schedule surveys to start and end at specific times, and configure recurring schedules for continuous feedback collection.\n*   **Branching Logic:** Implement branching logic to tailor the survey flow based on user responses.\n*   **Response Management:** Set response limits, enable partial response collection, and filter responses based on question answers and event properties.\n*   **Survey Results and Analytics:** Analyze survey responses with detailed visualizations, including user statistics, rating breakdowns, NPS scores, and open text analysis.\n*   **Activity Logging:** Track all changes made to surveys in a comprehensive activity log.\n*   **API Integration:** Configure surveys using an API editor and generate SQL queries for advanced analysis.\n*   **Template Library:** Choose from a library of pre-built survey templates for common use cases.\n*   **Feedback Widget:** Render surveys as feedback widgets for continuous user feedback.\n*   **HTML Content Editing:** Use HTML to customize survey content (potentially gated by subscription plan).\n*   **Drag and Drop Question Reordering:** Reorder survey questions using a drag-and-drop interface.\n*   **Survey Settings:** Configure global survey settings for the team, including default appearance.\n*   **SQL Query Generation:** Generate SQL queries to retrieve survey response data for custom analysis.\n*   **Partial Response Collection:** Capture and store survey responses even if the user doesn't finish the survey.\n*   **Survey Preview:** Preview how the survey will look to end-users.\n*   **Survey Duplication:** Duplicate existing surveys for reuse or modification.\n*   **Hog Function Integration:** Link Hog Functions to surveys for custom actions upon survey submission.\n"
    },
    {
        "path": "frontend/src/scenes/persons/PersonFeedCanvas.tsx",
        "summary": "The `PersonFeedCanvas` component displays a read-only \"canvas\" view of a person's data within a Notebook component. This canvas is pre-populated with a person feed, including a person info section, properties, and conditionally a map (if the application is running in cloud or development mode). The component utilizes the person's ID and distinct IDs to fetch and display relevant information.\n\nHere's a list of high-level product features:\n\n*   **Person Feed Display:** Shows a feed of information related to a specific person.\n*   **Read-Only Canvas View:** Presents the person's data in a non-editable canvas format.\n*   **Person Information Section:** Displays core information about the person.\n*   **Properties Display:** Shows the properties associated with the person.\n*   **Geographic Map (Conditional):** Displays a map related to the person, enabled in cloud or development environments.\n"
    },
    {
        "path": "frontend/src/scenes/persons/PersonDashboard.tsx",
        "summary": "The `PersonDashboard` component displays a dashboard specific to a person. If a dashboard is already associated with the person, it renders the existing dashboard, applying a filter to the dashboard to only show data relevant to that person (specifically filtering by email). If no dashboard is associated, it prompts the user to choose a dashboard to associate with the person. The component also provides a button to change the currently associated dashboard.\n\nHere's a list of high-level features:\n\n*   **Dashboard Association:** Allows associating a specific dashboard with a person.\n*   **Dashboard Creation Prompt:** Prompts the user to create or select a dashboard if none is associated with the person.\n*   **Person-Specific Filtering:** Automatically filters the dashboard data to be relevant to the specific person being viewed (by email).\n*   **Dashboard Switching:** Allows changing the associated dashboard for a person.\n*   **Dashboard Display:** Renders the associated dashboard with the applied person-specific filters.\n"
    },
    {
        "path": "frontend/src/scenes/persons/GroupActorDisplay.tsx",
        "summary": "This React component, `GroupActorDisplay`, is responsible for displaying information about a group actor. It takes a `GroupActorType` object as a prop and renders a link to the group's page, displaying the group's name (if available in the properties) or its group key. The component utilizes a helper function `groupDisplayId` to determine the display text.\n\nHere's a list of high-level features:\n\n*   **Group Actor Display:** Renders a display for a group actor, showing either the group's name or key.\n*   **Navigation to Group Page:** Provides a link to the specific group's page within the application.\n*   **Dynamic Display Text:** Chooses between displaying the group's name (if available) or the group key.\n"
    },
    {
        "path": "frontend/src/scenes/persons/personDashboardLogic.ts",
        "summary": "The `personDashboardLogic` Kea logic module manages the dashboard associated with a specific person in the application. It retrieves the user's personal dashboard ID for the \"Person\" scene from the `userLogic` and constructs the necessary props for a `DashboardLogic` instance. This allows the application to display a personalized dashboard tailored to the specific person being viewed.\n\n**Features:**\n\n*   **Personalized Person Dashboards:** Enables users to have customized dashboards for individual persons.\n*   **Dashboard ID Retrieval:** Fetches the correct dashboard ID for the \"Person\" scene from the user's settings.\n*   **Dashboard Logic Props Generation:** Creates the necessary props (ID and placement) to instantiate a `DashboardLogic` component for the person's dashboard.\n*   **Integration with User Settings:** Leverages user-specific settings to determine the appropriate dashboard to display.\n"
    },
    {
        "path": "frontend/src/scenes/persons/MergeSplitPerson.tsx",
        "summary": "This code implements a modal for splitting a person entity in PostHog into multiple person entities based on their distinct IDs. It allows the user to optionally select a distinct ID to which all the original person's properties will be assigned, while the remaining new person entities will start without any properties. The modal warns the user about the potential impact on historical data and provides cancel and execute actions with loading states.\n\nHere's a list of high-level product features:\n\n*   **Split Person Entity:** Allows splitting a single person entity into multiple entities based on distinct IDs.\n*   **Property Assignment on Split:** Option to assign all properties of the original person entity to one of the new entities based on a selected distinct ID.\n*   **Distinct ID Selection:** Provides a dropdown to select the distinct ID to which properties should be assigned.\n*   **Warning Banner:** Displays a warning message about the potential impact on historical data.\n*   **Loading State:** Shows a loading indicator during the splitting process.\n*   **Cancel Action:** Allows canceling the splitting operation.\n"
    },
    {
        "path": "frontend/src/scenes/persons/person-utils.ts",
        "summary": "This code provides utility functions for displaying and linking to person profiles within the PostHog application. It handles the logic for determining the best display name for a person based on configured properties, distinct IDs, and default settings. It also generates links to person profiles based on their distinct IDs.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Person Display Name Generation:** Dynamically generates a display name for a person based on configured properties, prioritizing custom properties, distinct IDs, and sorting distinct IDs by type (email, custom, anonymous).\n*   **Person Profile Linking:** Creates links to individual person profiles using their distinct IDs, allowing users to navigate to detailed information about a specific person.\n*   **Handling of Unknown Persons:** Provides a default display name (\"Unknown\") for cases where person data is missing or unavailable.\n*   **Distinct ID Prioritization:** Ranks distinct IDs based on their format (email, custom, anonymous) to select the most informative ID for display.\n*   **Customizable Display Properties:** Allows teams to configure which person properties should be used for display names, providing flexibility in how people are identified.\n"
    },
    {
        "path": "frontend/src/scenes/persons/personDeleteModalLogic.tsx",
        "summary": "This code defines a Kea logic module named `personDeleteModalLogic` responsible for handling the deletion of a person within the application. It manages the state and actions related to displaying a modal for confirming the deletion, triggering the deletion API call, and handling the success feedback. The logic allows for optionally deleting associated events along with the person and provides a callback function to be executed after the deletion is complete.\n\n**High-Level Product Features:**\n\n*   **Person Deletion:** Allows users to delete a person from the system.\n*   **Confirmation Modal:** Presents a confirmation modal before deleting a person.\n*   **Event Deletion Option:** Provides an option to delete events associated with the person.\n*   **Success Notification:** Displays a success notification after a person is deleted.\n*   **Callback Functionality:** Executes a callback function after the person is successfully deleted.\n"
    },
    {
        "path": "frontend/src/scenes/persons/PersonPreview.tsx",
        "summary": "The `PersonPreview` component in `PersonPreview.tsx` provides a preview of a person's profile within the PostHog application. It fetches and displays the person's properties in a scrollable table, along with their profile picture and name. The component also includes links to the full person profile page and allows users to create or open a notebook associated with the person. If no person profile is found for the given distinct ID, a message is displayed with a link to the documentation on how to create person profiles.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Person Profile Preview:** Displays a summary of a person's profile, including their name/identifier and profile picture.\n*   **Property Display:** Shows a table of properties associated with the person, sortable and scrollable.\n*   **Link to Full Profile:** Provides a link to view the complete person profile in a separate page.\n*   **Notebook Integration:** Allows users to create or open a notebook associated with the person.\n*   **\"No Profile\" Message:** Informs the user when a profile is not found for a given distinct ID and provides a link to relevant documentation.\n"
    },
    {
        "path": "frontend/src/scenes/persons/relatedFeatureFlagsLogic.ts",
        "summary": "This code defines a Kea logic module called `relatedFeatureFlagsLogic` that fetches and manages feature flags related to a specific user or group. It retrieves feature flag evaluation reasons from the API, maps them to existing feature flag data, and provides filtering and searching capabilities. The logic is keyed by the distinct ID of the user, ensuring that each user has their own instance of the logic.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Fetch Related Feature Flags:** Retrieves feature flags and their evaluation reasons for a given user or group from the API.\n*   **User/Group Targeting:** Filters feature flags based on user distinct ID or group properties.\n*   **Search Feature Flags:** Allows users to search for feature flags by key or name.\n*   **Filter Feature Flags:** Enables filtering of feature flags based on type (variants/non-variants), active status, and match reason.\n*   **Display Feature Flag Evaluation Reasons:** Shows the reasons why a feature flag was evaluated for a specific user or group.\n*   **Real-time Updates:** Automatically loads related feature flags after the component mounts.\n"
    },
    {
        "path": "frontend/src/scenes/persons/personLogic.tsx",
        "summary": "This code defines a Kea logic module called `personLogic` responsible for fetching and managing data for a single person. It uses a unique ID passed as a prop to identify the person. The logic module defines an action `loadPerson` which triggers an API call to retrieve person data based on the provided ID. The fetched person data is then stored in the `person` state variable. The `afterMount` lifecycle hook ensures that the `loadPerson` action is called when the logic module is initialized.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Person Data Loading:** Fetches person details from the backend based on a unique identifier.\n*   **State Management:** Manages the state of a single person's data within the application.\n*   **Data Persistence:** Caches the fetched person data for efficient access and rendering.\n*   **Automatic Data Fetching:** Automatically loads person data when the component mounts.\n"
    },
    {
        "path": "frontend/src/scenes/persons/PersonCohorts.tsx",
        "summary": "This React component, `PersonCohorts`, displays a table of cohorts that a specific person belongs to. It fetches cohort data using the `personsLogic` Kea logic hook and presents it in a `LemonTable`. The table shows the cohort's name (as a link to the cohort's page) and the number of users in the cohort. The table supports sorting by name and user count, and includes pagination and an empty state message when the person doesn't belong to any cohorts.\n\nHere's a list of high-level product features:\n\n*   **Display Cohort List:** Shows a list of cohorts associated with a person.\n*   **Cohort Name Links:** The cohort name is a clickable link that navigates to the cohort's details page.\n*   **User Count Display:** Shows the number of users belonging to each cohort.\n*   **Sortable Columns:** Allows sorting of cohorts by name and user count.\n*   **Loading State:** Indicates when cohort data is being fetched.\n*   **Pagination:** Implements pagination for long lists of cohorts.\n*   **Empty State Message:** Displays a message when the person is not in any cohorts.\n"
    },
    {
        "path": "frontend/src/scenes/persons/PersonDeleteModal.tsx",
        "summary": "This component implements a modal that prompts the user to confirm the deletion of a person. It warns about the consequences of re-using distinct IDs and informs the user that event deletion is scheduled. The modal provides options to delete the person with or without associated events, and requires the user to acknowledge the risks of re-using distinct IDs via a checkbox before proceeding with the deletion.\n\nHere's a list of high-level product features:\n\n*   **Person Deletion Confirmation:** Presents a modal to confirm the deletion of a person.\n*   **Warning about Re-using Distinct IDs:** Displays a warning about the negative consequences of re-using distinct IDs after deletion.\n*   **Event Deletion Information:** Informs the user that event deletion is scheduled and not immediate.\n*   **Delete with/without Events Options:** Provides options to delete the person with or without their associated events.\n*   **Confirmation Checkbox:** Requires user confirmation to proceed with deletion, acknowledging the risks of re-using distinct IDs.\n"
    },
    {
        "path": "frontend/src/scenes/persons/activityDescriptions.tsx",
        "summary": "This code defines a function `personActivityDescriber` that generates human-readable descriptions for activity log items related to persons. It handles specific activities like deleting a person, updating a person's properties, merging people, and splitting a person. For each activity, it constructs a descriptive sentence indicating who performed the action and what was affected, using components like `PersonDisplay` and `Link` to provide context and navigation. If the activity is not one of the specifically handled cases, it falls back to a default description.\n\nHere's a list of high-level product features derived from the code:\n\n*   **Activity Logging for Persons:** Tracks actions performed on person profiles.\n*   **Person Deletion Tracking:** Logs when a person profile is deleted, including the user who performed the deletion.\n*   **Person Property Update Tracking:** Logs when a person's properties are edited, including the user who made the changes.\n*   **Person Merge Tracking:** Logs when multiple person profiles are merged into one, showing the source profiles and the user who performed the merge.\n*   **Person Split Tracking:** Logs when a person profile is split into multiple profiles based on distinct IDs, showing the resulting distinct IDs and the user who performed the split.\n*   **User Attribution:** Identifies the user responsible for each activity log entry.\n*   **Contextual Links:** Provides links to related person profiles and distinct IDs within the activity log descriptions.\n"
    },
    {
        "path": "frontend/src/scenes/persons/PersonDisplay.tsx",
        "summary": "The `PersonDisplay` component in `PersonDisplay.tsx` provides a flexible way to display information about a person, such as their name or distinct ID, with options for linking to their profile, showing a profile picture, and displaying a popover with more details. It handles cases where the person's information might be incomplete or missing, and it offers customization options for appearance and behavior, including the ability to copy the displayed name to the clipboard. The component is designed to be reusable across different parts of the application where person information needs to be presented.\n\nHere's a list of high-level product features provided by the `PersonDisplay` component:\n\n*   **Person Information Display:** Displays a person's name or identifier.\n*   **Profile Picture Integration:** Shows a profile picture associated with the person.\n*   **Hyperlinking to Person Profile:** Creates a link to the person's detailed profile page.\n*   **Popover Preview:** Displays a popover with a preview of the person's information on hover or click.\n*   **Copy to Clipboard:** Allows copying the displayed person name or identifier to the clipboard.\n*   **Customizable Appearance:** Offers options to customize the appearance, such as icon size, text truncation, and alignment.\n*   **Notebook Node Integration:** Supports integration with notebook nodes, potentially modifying behavior within a notebook context.\n"
    },
    {
        "path": "frontend/src/scenes/persons/NewProperty.tsx",
        "summary": "This code defines a React component called `NewProperty` that allows users to create new properties with a key, type, and value. It uses a modal to collect the property details and provides options for string/number and boolean/null property types. The component includes input fields for the property key and value, and segmented buttons for selecting the property type and boolean values. The component takes an `onSave` prop, which is a callback function that is called when the user saves the new property.\n\nHere's a list of high-level product features:\n\n*   **Add New Property Button:** A button that opens a modal to create a new property.\n*   **Modal Interface:** A modal window for inputting the new property's details.\n*   **Property Key Input:** A text field to specify the key of the new property.\n*   **Property Type Selection:** A segmented button to choose between \"Text or Number\" and \"Boolean or Null\" property types.\n*   **Property Value Input:** An input field (text or segmented button) to specify the value of the new property, depending on the selected type.\n*   **Save Property Button:** A button within the modal to save the new property, triggering the `onSave` callback.\n*   **Input Validation:** Disables the save button if the key or value are not set.\n*   **Boolean Value Selection:** Segmented button for selecting true, false, or null values when the property type is boolean.\n"
    },
    {
        "path": "frontend/src/scenes/persons/mergeSplitPersonLogic.ts",
        "summary": "This code defines a Kea logic module named `mergeSplitPersonLogic` responsible for handling the splitting of a person entity in the application. It manages the state and actions related to selecting a person to assign the split to, executing the split operation via an API call, and handling the UI feedback and navigation after the split. The logic connects to `personsLogic` to access the list of persons and related actions.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Person Splitting:** Allows users to split a person entity into two, likely to correct data inaccuracies or merge errors.\n*   **Split Assignment:** Enables users to assign the split to an existing person, merging the split data into that person's profile.\n*   **API Integration:** Communicates with the backend API to execute the person split operation.\n*   **User Feedback:** Provides visual feedback to the user upon successful split, including a success message and a notification that the process may take some time.\n*   **Event Tracking:** Tracks the usage of the person split feature for analytics and reporting.\n*   **Navigation:** Redirects the user to the persons list after a successful split.\n*   **Modal Management:** Controls the visibility of the split/merge modal.\n"
    },
    {
        "path": "frontend/src/scenes/persons/personsLogic.tsx",
        "summary": "This code defines the `personsLogic` Kea logic for managing person data in a PostHog application. It handles fetching, updating, and filtering person data, as well as managing UI state related to person views, such as active tabs and modal visibility. The logic connects to other parts of the application, such as team and feature flag logic, and reports usage events. It also manages cohort associations for persons and provides functionality for exporting person data.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Person Data Management:** Fetching, displaying, and updating individual person details and lists of persons.\n*   **Filtering and Searching:** Filtering persons based on properties and other criteria.\n*   **Cohort Association:** Displaying and navigating to cohorts associated with a person.\n*   **UI State Management:** Managing the active tab (properties, feed, etc.) in the person view.\n*   **Property Editing:** Adding, updating, and deleting properties associated with a person.\n*   **Data Export:** Exporting lists of persons in various formats (e.g., CSV).\n*   **Distinct ID Management:** Displaying and managing distinct IDs associated with a person.\n*   **Feature Flag Integration:** Adapting the UI and functionality based on feature flags.\n*   **Person Feed:** Displaying a feed of events related to a person (if the feature flag is enabled).\n*   **Side Panel Context:** Providing context for the side panel based on the selected person.\n"
    },
    {
        "path": "frontend/src/scenes/persons/PersonScene.tsx",
        "summary": "The `PersonScene.tsx` file defines the user interface for viewing and managing individual person profiles within the PostHog application. It provides a comprehensive view of a person's data, including their distinct IDs, properties, events, session recordings, cohort memberships, and related groups. The scene allows users to perform actions such as deleting a person, splitting merged IDs, editing properties, and exploring related feature flags. It leverages various PostHog Lemon UI components and Kea logic hooks to manage state and interactions, offering a feature-rich experience for analyzing and manipulating person data.\n\nHere's a list of high-level product features implemented in this file:\n\n*   **Person Profile View:** Displays detailed information about a person, including distinct IDs, properties, and timestamps.\n*   **Identity Management:** Allows splitting merged distinct IDs associated with a person.\n*   **Data Exploration:** Provides tabs for viewing a person's event history, session recordings, and cohort memberships.\n*   **Property Management:** Enables editing and deleting custom properties associated with a person.\n*   **Related Groups:** Shows related groups based on shared events with the person.\n*   **Feature Flag Association:** Displays feature flags that target the person based on their properties.\n*   **Activity Feed:** Shows a feed of activity related to the person.\n*   **Session Recording Integration:** Allows viewing session recordings associated with the person.\n*   **Notebook Integration:** Allows creating and linking notebooks to the person profile.\n*   **Person Deletion:** Enables deleting a person profile.\n"
    },
    {
        "path": "frontend/src/scenes/persons/RelatedFeatureFlags.tsx",
        "summary": "This code defines a React component called `RelatedFeatureFlags` that displays a table of feature flags related to a specific user (identified by `distinctId`). It fetches and filters these flags based on a search term and various filter criteria like flag type (release toggle or variants), match evaluation status, and flag status (enabled or disabled). The table shows the flag key, type, value, match evaluation reason, and status, with links to the feature flag details page. The component uses Lemon UI components for the table, input, and select elements, and utilizes kea-logic for state management and actions.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Display of Related Feature Flags:** Shows a list of feature flags relevant to a specific user.\n*   **Feature Flag Details:** Displays key information about each feature flag, including key, type, value, and status.\n*   **Link to Feature Flag Management:** Provides a link to the detailed view of each feature flag.\n*   **Filtering by Search Term:** Allows users to filter the list of feature flags by searching for a specific key or name.\n*   **Filtering by Flag Type:** Enables filtering of feature flags based on their type (Release Toggle or Variants).\n*   **Filtering by Match Evaluation:** Filters feature flags based on whether they match the user's conditions.\n*   **Filtering by Flag Status:** Filters feature flags based on their status (enabled or disabled).\n*   **Simulated Feature Flag Evaluation:** Simulates feature flag evaluation for a given user, displaying the reason for the match or mismatch.\n"
    },
    {
        "path": "frontend/src/scenes/persons",
        "summary": "This code collectively provides a comprehensive suite of features for managing and analyzing individual person profiles within the PostHog application. It enables users to view detailed information about a person, including their properties, event history, session recordings, and cohort memberships. The system allows for editing person properties, merging or splitting person identities, and deleting person profiles with options for associated event deletion. Furthermore, it provides tools for associating dashboards with persons, displaying related feature flags, and tracking activity logs related to person profile changes. The UI components offer a user-friendly experience for navigating and interacting with person data, while the underlying logic modules ensure efficient data fetching, state management, and API integration.\n\nHere's a list of high-level product features:\n\n*   **Person Profile Management:** Creation, viewing, editing, merging, splitting, and deletion of person profiles.\n*   **Data Visualization:** Display of person properties, event history, session recordings, and cohort memberships.\n*   **Identity Resolution:** Tools for managing distinct IDs and merging/splitting person identities.\n*   **Feature Flag Integration:** Display of feature flags related to a person and their evaluation reasons.\n*   **Dashboard Association:** Linking and filtering dashboards to specific person profiles.\n*   **Activity Logging:** Tracking changes and actions performed on person profiles.\n*   **Property Management:** Adding, editing, and deleting custom properties associated with a person.\n*   **Cohort Management:** Displaying and navigating to cohorts associated with a person.\n*   **User Interface:** User-friendly components for navigating and interacting with person data.\n*   **API Integration:** Seamless communication with the backend API for data fetching and manipulation.\n*   **Search and Filtering:** Ability to search and filter persons based on various criteria.\n*   **Personalized Dashboards:** Custom dashboards tailored to individual persons.\n*   **Group Actor Display:** Displaying information about group actors associated with persons.\n*   **Data Export:** Exporting lists of persons in various formats.\n"
    },
    {
        "path": "frontend/src/scenes/saved-insights/ReloadInsight.tsx",
        "summary": "This React component, `ReloadInsight`, checks for a previously saved, but unsaved, insight query in the browser's local storage. If an unsaved insight is found, it displays a message to the user indicating the time the insight was last saved and provides a link to a new insight page, pre-populated with the unsaved query. If no unsaved insight is found, the component renders nothing.\n\nHere's a list of high-level product features:\n\n*   **Unsaved Insight Detection:** Detects if there's an unsaved insight query stored in local storage.\n*   **Timestamp Display:** Shows the date and time when the unsaved insight was last saved.\n*   **Link to New Insight with Query:** Provides a link that navigates the user to a new insight page, automatically loading the unsaved query.\n*   **Local Storage Management:** Clears invalid or outdated draft queries from local storage.\n"
    },
    {
        "path": "frontend/src/scenes/saved-insights/SavedInsightsFilters.tsx",
        "summary": "The `SavedInsightsFilters` component provides a set of filters for saved insights, allowing users to refine their search and view specific insights. It includes options to search by name, filter by dashboard, insight type, last modified date, and creator. The component dynamically adjusts the available filters based on the selected tab (e.g., hiding the \"Created by\" filter when the \"Yours\" tab is selected). It utilizes LemonInput and LemonSelect components for user input and selection, and the DateFilter component for date range selection.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Insight Name Search:** Allows users to search for insights by name using a text input field.\n*   **Dashboard Filtering:** Enables users to filter insights based on the dashboard they belong to.\n*   **Insight Type Filtering:** Provides options to filter insights by their type (e.g., trends, funnels).\n*   **Date Range Filtering:** Allows users to filter insights based on their last modified date range.\n*   **Creator Filtering:** Enables users to filter insights based on the user who created them (only available on certain tabs).\n"
    },
    {
        "path": "frontend/src/scenes/saved-insights/newInsightsMenu.tsx",
        "summary": "This code defines a function `overlayForNewInsightMenu` that generates a list of buttons for creating new insights, excluding the JSON insight type. Each button corresponds to a different insight type defined in `INSIGHT_TYPES_METADATA`. When a button is clicked, it navigates the user to the corresponding URL for that insight type and reports the click event for usage tracking. The buttons are styled with an icon, name, and description for each insight type.\n\nHere's a list of high-level product features based on the code:\n\n*   **New Insight Creation Menu:** Provides a menu to create new insights of various types.\n*   **Insight Type Selection:** Allows users to choose from a predefined set of insight types (e.g., Trends, Funnels, Retention).\n*   **Navigation to Insight Creation Page:** Redirects the user to the appropriate page for creating the selected insight type.\n*   **Usage Tracking:** Tracks the selection of insight types for usage analysis.\n*   **Insight Type Descriptions:** Displays a name and description for each insight type to help users understand their purpose.\n*   **Iconography:** Uses icons to visually represent different insight types.\n"
    },
    {
        "path": "frontend/src/scenes/saved-insights/addSavedInsightsModalLogic.ts",
        "summary": "This code defines the logic for a modal that allows users to add saved insights to dashboards. It handles loading insights based on various filters like search terms, insight type, creator, and date range. The logic also manages adding and removing insights from dashboards, updating the insight data, and providing loading indicators during these operations. It uses the Kea framework for state management and API calls to fetch and update insight data.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Insight Filtering:** Allows users to filter saved insights by search term, insight type, creator, and date range.\n*   **Insight Pagination:** Implements pagination for displaying insights in the modal.\n*   **Adding Insights to Dashboards:** Enables users to add selected insights to specific dashboards.\n*   **Removing Insights from Dashboards:** Enables users to remove insights from specific dashboards.\n*   **Loading Indicators:** Provides visual feedback during the process of adding or removing insights from dashboards.\n*   **Real-time Dashboard Updates:** Updates the dashboard view after adding or removing an insight.\n*   **Sorting:** Allows users to sort insights.\n"
    },
    {
        "path": "frontend/src/scenes/saved-insights/SavedInsights.tsx",
        "summary": "This code defines the SavedInsights scene in PostHog, providing a user interface for viewing, filtering, and managing saved insights. It includes components for displaying insights in various formats (cards, lists, tables), creating new insights, and filtering existing ones. The scene utilizes Lemon UI components for layout and interaction, and leverages Kea logic for state management. It also defines metadata for different insight types, including their names, descriptions, and icons, which are used in the UI to represent and differentiate them.\n\nHere's a list of high-level product features:\n\n*   **Insight Visualization:** Display saved insights in card, list, and table formats.\n*   **Insight Creation:** Allow users to create new insights through a menu with various insight types.\n*   **Insight Filtering:** Enable users to filter insights based on various criteria.\n*   **Insight Management:** Support actions like deleting insights.\n*   **Insight Type Metadata:** Provide descriptive information and icons for different insight types.\n*   **SQL Insights:** Allow users to create insights using SQL queries.\n*   **Custom Insights:** Allow users to create insights using a JSON query language.\n*   **Activity Log:** Track user activity related to insights.\n*   **Alerts:** Display alerts related to insights.\n*   **Object Tagging:** Allow users to tag insights for better organization.\n*   **Pagination:** Paginate through large lists of insights.\n"
    },
    {
        "path": "frontend/src/scenes/saved-insights/AddSavedInsightsToDashboard.tsx",
        "summary": "This component, `AddSavedInsightsToDashboard`, provides a modal interface for users to browse and select saved insights to add to a dashboard. It fetches insights based on filters and pagination, displays them in a table with details like name, tags, creator, and last modified date, and allows users to add or remove insights from the current dashboard. The component also handles loading states and empty state scenarios, providing a user-friendly experience for managing dashboard content.\n\nHere's a list of high-level product features:\n\n*   **Browse Saved Insights:** Allows users to view a list of available saved insights.\n*   **Filter and Sort Insights:** Enables users to filter insights based on criteria like name, tags, or creator and sort them by various attributes.\n*   **Paginate Insights:** Implements pagination for handling large numbers of insights.\n*   **Add/Remove Insights to Dashboard:** Provides functionality to add or remove selected insights from the current dashboard.\n*   **Loading State Management:** Displays a loading indicator while fetching insights.\n*   **Empty State Handling:** Shows a relevant message when no insights are available.\n*   **Insight Summarization:** Provides a summary of the insight query when the insight name is not available.\n*   **Real-time Updates:** Reflects changes to the dashboard in real-time, indicating when an insight is being added or removed."
    },
    {
        "path": "frontend/src/scenes/saved-insights/savedInsightsLogic.ts",
        "summary": "This code defines the logic for the saved insights page in PostHog. It manages the loading, filtering, and display of saved insights. It handles user interactions such as favoriting, renaming, and duplicating insights, as well as updating insights when they are modified via dashboards. The logic also integrates with the router to maintain URL synchronization with the current filter state.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Displaying Saved Insights:** Fetches and displays a paginated list of saved insights, including their metadata.\n*   **Filtering Saved Insights:** Allows users to filter insights by various criteria such as layout view, order, tab (All, Yours, Favorites), search term, insight type, creator, date range, and dashboard association.\n*   **Favoriting Insights:** Enables users to mark insights as favorites.\n*   **Renaming Insights:** Allows users to rename their saved insights.\n*   **Duplicating Insights:** Enables users to create copies of existing insights.\n*   **URL Synchronization:** Keeps the URL in sync with the current filter settings, enabling shareable links.\n*   **Real-time Updates:** Updates the insight list when insights are renamed, added, or modified via dashboards.\n*   **Tabbed Views:** Provides different views of insights based on tabs (All, Yours, Favorites).\n*   **Layout Options:** Supports different layout views for displaying insights (e.g., list, grid).\n*   **Alert Modal:** Opens a modal to display alerts related to insights."
    },
    {
        "path": "frontend/src/scenes/saved-insights/activityDescriptions.tsx",
        "summary": "This code defines functions to generate human-readable descriptions of activity log items related to insights within the PostHog application. It maps different insight properties and activities (creation, deletion, updates, etc.) to specific descriptions, including details about changes to filters, queries, names, descriptions, tags, and dashboard associations. The code also handles displaying summaries of changes to the insight's query definition, including series, properties, and breakdown information.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Insight Activity Logging:** Tracks changes made to insights, such as renaming, updating filters, adding/removing tags, and changes to associated dashboards.\n*   **Humanized Activity Descriptions:** Converts raw activity log data into user-friendly descriptions of what happened to an insight.\n*   **Insight Change Summarization:** Provides detailed summaries of changes to insight queries, including series, properties, and breakdowns.\n*   **Dashboard Association Tracking:** Logs when insights are added to or removed from dashboards.\n*   **Insight Sharing Activity:** Logs when insights are shared or unshared.\n*   **Insight Export Tracking:** Logs when insights are exported and in what format.\n*   **Notifications:** Supports generating descriptions suitable for notifications, indicating changes to insights.\n*   **Insight Favoriting Activity:** Logs when insights are favorited or unfavorited."
    },
    {
        "path": "frontend/src/scenes/saved-insights",
        "summary": "The provided code collectively implements a comprehensive saved insights management system within PostHog, offering users the ability to create, view, filter, organize, and utilize insights effectively.  The system provides a user-friendly interface for browsing and managing saved insights, including features for filtering, sorting, and paginating insights, as well as adding and removing them from dashboards.  It also includes activity logging, real-time updates, and the ability to recover unsaved insights, ensuring a seamless and efficient user experience.\n\nHere's a list of high-level product features:\n\n*   **Insight Creation:** Allows users to create new insights of various types (Trends, Funnels, Retention, SQL, Custom).\n*   **Insight Visualization:** Displays saved insights in various formats (cards, lists, tables).\n*   **Insight Filtering & Sorting:** Enables users to filter insights based on name, dashboard, insight type, date range, creator, and sort by various attributes.\n*   **Insight Management:** Supports actions like adding/removing insights to/from dashboards, favoriting, renaming, duplicating, and deleting insights.\n*   **Activity Logging:** Tracks changes made to insights and provides human-readable descriptions of these changes.\n*   **Dashboard Integration:** Allows users to add and remove insights from dashboards and reflects changes in real-time.\n*   **Unsaved Insight Recovery:** Detects and allows users to recover previously saved but unsaved insight queries.\n*   **Real-time Updates:** Reflects changes to insights and dashboards in real-time.\n*   **URL Synchronization:** Keeps the URL in sync with the current filter settings for shareable links.\n*   **Insight Type Metadata:** Provides descriptive information and icons for different insight types.\n"
    },
    {
        "path": "frontend/src/scenes/projectLogic.ts",
        "summary": "This code defines the `projectLogic` Kea logic which manages the current project and related operations. It handles loading, updating, creating, deleting, and moving projects between organizations. The logic interacts with the API to persist changes and uses toasts to provide user feedback. It also integrates with user and organization logic to keep data consistent across the application.\n\nHere's a list of high-level product features supported by this code:\n\n*   **Project Creation:** Allows users to create new projects.\n*   **Project Loading:** Loads the current project for the user.\n*   **Project Updating:** Enables users to modify project settings.\n*   **Project Deletion:** Allows users to delete projects.\n*   **Project Moving:** Enables moving projects between organizations.\n*   **Real-time Updates:** Updates the current organization and user data when a project is modified.\n*   **User Notifications:** Provides feedback to the user via toast notifications for successful operations.\n*   **Contextual Redirection:** Redirects the user to the products page after creating a project.\n"
    },
    {
        "path": "frontend/src/scenes/PreflightCheck/PreflightCheck.tsx",
        "summary": "The `PreflightCheck` component in `PreflightCheck.tsx` provides a user interface for validating a PostHog installation before proceeding. It allows users to select a launch mode (live or experimentation), runs a series of preflight checks based on the selected mode, and displays the status of each check. The component also provides options to revalidate the checks, expand/collapse the list of checks, and continue to the next step if all required checks pass or if the experimentation mode is selected. It guides users with links to documentation and support resources.\n\nHere's a list of high-level product features:\n\n*   **Launch Mode Selection:** Allows users to choose between \"Live implementation\" and \"Just experimenting\" modes, influencing the strictness of the preflight checks.\n*   **Automated Preflight Checks:** Performs a series of automated checks to validate the PostHog installation environment.\n*   **Real-time Status Display:** Shows the status of each preflight check (validated, warning, error, checking) with corresponding icons and text.\n*   **Revalidation:** Enables users to manually re-run the preflight checks.\n*   **Expandable Check List:** Allows users to expand or collapse the list of individual preflight checks for detailed information.\n*   **Summary Status:** Displays a summary of the overall validation status.\n*   **Conditional Navigation:** Prevents users from proceeding if required checks fail in \"Live implementation\" mode.\n*   **Documentation and Support Links:** Provides links to troubleshooting documentation and community support.\n"
    },
    {
        "path": "frontend/src/scenes/PreflightCheck/preflightLogic.tsx",
        "summary": "This code defines the logic for a preflight check feature within a larger application, likely PostHog. The preflight check assesses the status of various system components (database, cache, etc.) to ensure the application is properly configured and ready for use. It supports different modes, such as \"experimentation\" and \"live,\" which affect the severity of certain check failures. The logic fetches preflight status from an API, manages the preflight mode, and provides selectors to derive status summaries and configuration options. It also handles instrumentation and navigation based on the preflight results.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **System Readiness Assessment:** Checks the status of key system components like databases, queues, and servers.\n*   **Environment-Aware Checks:** Adapts checks based on the deployment mode (experimentation vs. live).\n*   **Status Summarization:** Provides a concise summary of the preflight check results, highlighting warnings and errors.\n*   **Configuration Guidance:** Displays relevant configuration options and their current values.\n*   **Automated Navigation:** Redirects users to appropriate setup steps based on preflight results.\n*   **Instrumentation:** Tracks preflight check results for analysis and improvement.\n*   **Manual Check Expansion:** Allows users to manually expand the checks to view the status of each component.\n*   **Revalidation:** Allows users to revalidate the preflight checks."
    },
    {
        "path": "frontend/src/scenes/PreflightCheck",
        "summary": "The preflight check feature provides a user interface and underlying logic to validate a PostHog installation before proceeding with its use. It assesses the status of various system components, adapts checks based on the selected launch mode (live or experimentation), and provides a concise summary of the results. The feature guides users with configuration options, documentation links, and automated navigation based on the preflight results, while also tracking check results for analysis.\n\nHere's a list of high-level product features:\n\n*   System Readiness Assessment: Checks the status of key system components.\n*   Environment-Aware Checks: Adapts checks based on the deployment mode.\n*   Status Summarization: Provides a concise summary of the preflight check results.\n*   Configuration Guidance: Displays relevant configuration options.\n*   Automated Navigation: Redirects users to appropriate setup steps.\n*   Instrumentation: Tracks preflight check results for analysis.\n*   Launch Mode Selection: Allows users to choose between \"Live implementation\" and \"Just experimenting\" modes.\n*   Real-time Status Display: Shows the status of each preflight check.\n*   Revalidation: Enables users to manually re-run the preflight checks.\n*   Expandable Check List: Allows users to expand or collapse the list of individual preflight checks.\n*   Documentation and Support Links: Provides links to troubleshooting documentation and community support.\n"
    },
    {
        "path": "frontend/src/scenes/data-model/TableFields.tsx",
        "summary": "This component displays the schema and joined tables for a given table. It shows the fixed fields (columns and their types) of the table in a schema section. It also displays a list of joined tables and provides a button to add a new join. The component uses LemonTable to display the data and leverages kea actions to manage the join table modal.\n\n**Features:**\n\n*   **Schema Display:** Shows the columns and data types of a table.\n*   **Joined Tables List:** Displays a list of tables joined to the current table.\n*   **Add Join Functionality:** Provides a button to open a modal for adding new joins to the table.\n*   **Table Highlighting:** Highlights joined tables in the UI.\n"
    },
    {
        "path": "frontend/src/scenes/data-model/Node.tsx",
        "summary": "The `Node.tsx` file defines a reusable `GenericNode` component in React. This component renders a styled `div` element that serves as a container for other React elements (children). It accepts props for setting a ref, width, height, class names, and rendering its children. The component provides a consistent visual style with a primary background color, black border, rounded corners, and flexbox layout for arranging its children.\n\nHere's a list of high-level features provided by the `GenericNode` component:\n\n*   **Styled Container:** Provides a pre-styled `div` element with a consistent look and feel (background color, border, rounded corners).\n*   **Flexible Layout:** Uses flexbox to easily arrange child elements within the node.\n*   **Customizable Styling:** Accepts `className` prop for adding custom CSS classes.\n*   **Ref Support:** Accepts a `pref` prop to attach a ref to the underlying `div` element.\n*   **Content Rendering:** Renders any React nodes passed as children.\n"
    },
    {
        "path": "frontend/src/scenes/data-model/types.ts",
        "summary": "This code defines the data structures used to represent a data model in a frontend application. It includes interfaces for `Position` (x, y coordinates), `Node` (representing a data node with an ID, name, optional saved query ID, and leaf nodes), `NodeWithDepth` (a node with its depth in the model), `NodePosition` (a node with depth and position), `Edge` (representing a connection between two positions), and `NodePositionWithBounds` (a node with position, depth, and left/right bounds). These interfaces are likely used to visualize and interact with a data model in a graphical user interface.\n\nHere's a list of high-level product features that could be built using these data structures:\n\n*   **Data Model Visualization:** Displaying a data model as a graph of interconnected nodes.\n*   **Node Management:** Creating, editing, and deleting data nodes within the model.\n*   **Relationship Management:** Defining and visualizing relationships (edges) between data nodes.\n*   **Hierarchical Data Representation:** Representing data with a hierarchical structure using node depth.\n*   **Data Query Integration:** Linking nodes to saved queries for data retrieval.\n*   **Layout and Positioning:** Automatically or manually positioning nodes within the visualization.\n*   **Visual Bounds Indication:** Displaying visual bounds for nodes.\n"
    },
    {
        "path": "frontend/src/scenes/data-model/NodeCanvas.tsx",
        "summary": "The `NodeCanvas.tsx` file defines a React component, `NodeCanvas`, responsible for rendering a directed graph of nodes and edges. It calculates the layout of the nodes based on their depth and dependencies, allowing for a clear visualization of hierarchical data. The component also supports panning the canvas using mouse drag, and dynamically renders edges as Bezier curves connecting the nodes. The grid background provides visual context, and the component is responsive to window resizing, ensuring the graph remains visible and interactive.\n\nHere's a list of high-level product features:\n\n*   **Automatic Graph Layout:** Automatically arranges nodes in a hierarchical structure based on their relationships.\n*   **Node Rendering:** Provides a flexible way to render custom node components within the graph.\n*   **Edge Rendering:** Draws smooth Bezier curve edges connecting related nodes.\n*   **Canvas Panning:** Allows users to pan the graph by dragging the canvas.\n*   **Responsive Design:** Adapts to different screen sizes, ensuring the graph is always visible.\n*   **Visual Grid:** Displays a subtle grid background for visual orientation.\n"
    },
    {
        "path": "frontend/src/scenes/data-model/dataModelSceneLogic.tsx",
        "summary": "This code defines the logic for a data model scene in a PostHog application. It manages the state and behavior related to visualizing and interacting with the data model, including traversing ancestors of data warehouse saved queries, managing nodes in a graph representation of the data model, and extracting information about person fields and joined fields. The logic connects to other parts of the application to access data about database tables, views, and data warehouse tables.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Data Model Visualization:** Displays a visual representation of the data model, likely as a graph or network.\n*   **Ancestor Traversal:** Allows users to explore the lineage or dependencies of data warehouse saved queries.\n*   **Node Management:** Creates and manages nodes in the data model graph, representing tables, views, or other data entities.\n*   **Person Field Extraction:** Extracts and categorizes fields from the \"persons\" table, distinguishing between simple fields and joined fields.\n*   **Joined Field Identification:** Identifies fields that are joined from other tables or views, providing insights into data relationships.\n*   **Data Warehouse Table Integration:** Integrates data warehouse tables and views into the data model visualization.\n"
    },
    {
        "path": "frontend/src/scenes/data-model",
        "summary": "The provided code snippets collectively define the features and functionality for visualizing and interacting with a data model within a PostHog application. The system allows users to explore data relationships, manage nodes representing tables and views, and visualize the data model as a directed graph with automatic layout and panning capabilities. The components provide a styled container for nodes, display table schemas and joined tables, and manage the state and behavior of the data model scene.\n\nHere's a list of high-level product features:\n\n*   **Data Model Visualization:** Displaying a data model as a graph of interconnected nodes with automatic hierarchical layout.\n*   **Interactive Canvas:** Panning and zooming the data model graph for easy exploration.\n*   **Node Management:** Creating, editing, and deleting data nodes within the model.\n*   **Relationship Management:** Defining and visualizing relationships (edges) between data nodes.\n*   **Schema Display:** Showing the columns and data types of a table.\n*   **Joined Tables List:** Displaying a list of tables joined to the current table and adding new joins.\n*   **Ancestor Traversal:** Exploring the lineage or dependencies of data warehouse saved queries.\n*   **Person Field Extraction:** Extracting and categorizing fields from the \"persons\" table.\n*   **Responsive Design:** Adapting to different screen sizes, ensuring the graph is always visible.\n"
    },
    {
        "path": "frontend/src/scenes/heatmaps/HeatmapsScene.tsx",
        "summary": "The `HeatmapsScene.tsx` file defines a scene in the application that renders a `HeatmapsBrowser` component. It also connects the scene to the `heatmapsSceneLogic`. This scene likely serves as the entry point for users to interact with heatmaps within the application.\n\nHere's a list of high-level product features based on the code:\n\n*   **Heatmap Visualization:** The primary feature is the ability to visualize data as heatmaps.\n*   **Heatmap Browsing:** Users can browse and navigate through different heatmaps.\n*   **Heatmap Management:** (Implied by `heatmapsSceneLogic`) Functionality to manage heatmaps, such as creation, deletion, or editing.\n"
    },
    {
        "path": "frontend/src/scenes/heatmaps/heatmapsSceneLogic.ts",
        "summary": "The `heatmapsSceneLogic.ts` file defines a Kea logic module for the heatmaps scene in the frontend application. This module is currently a placeholder, defining only the path for the logic within the Kea store. It serves as a starting point for managing the state and actions related to the heatmaps scene.\n\n**Features:**\n\n*   **Heatmaps Scene State Management:** Provides a dedicated Kea logic module for managing the state of the heatmaps scene.\n*   **Kea Integration:** Leverages the Kea framework for structured state management and side effect handling.\n*   **Modular Design:** Supports a modular design by isolating the heatmaps scene logic.\n"
    },
    {
        "path": "frontend/src/scenes/heatmaps/heatmapsBrowserLogic.ts",
        "summary": "This code defines the logic for the heatmaps browser feature in PostHog. It manages the state of the heatmap browser, including the URL being viewed, filters applied, color palette, and fixed position mode. It handles communication with an iframe that displays the heatmap, sending configuration and filter updates, and receiving loading status updates. The logic also includes functionality for searching and displaying top URLs, managing authorized URLs, and displaying banners for errors or loading status.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **URL-based Heatmap Visualization:** Allows users to view heatmaps for specific URLs within their product.\n*   **URL Search and Autocomplete:** Provides a search bar with autocomplete suggestions for URLs based on historical data.\n*   **Heatmap Configuration:** Enables users to customize the heatmap appearance through filters (date range, etc.), color palettes, and fixed position mode.\n*   **Authorized URL Management:** Ensures that heatmaps can only be viewed for authorized URLs, enhancing security.\n*   **Loading State Management:** Tracks the loading state of the heatmap within the iframe and displays appropriate indicators.\n*   **Error Handling:** Displays error banners when the heatmap fails to load.\n*   **Toolbar Communication:** Facilitates communication between the main application and the heatmap toolbar within the iframe.\n*   **Common Filters:** Allows the user to set common filters that are shared between heatmaps and clickmaps.\n"
    },
    {
        "path": "frontend/src/scenes/heatmaps/HeatmapsBrowser.tsx",
        "summary": "This code implements a Heatmaps Browser feature within a web application. It allows users to view heatmaps of their website pages directly within the application, using an embedded JavaScript SDK and the PostHog Toolbar. The browser includes a URL input for specifying the target page, displays a list of frequently viewed pages, and provides settings to filter and customize the heatmap display. It also handles scenarios such as unauthorized URLs, invalid URLs, and iframe loading errors, providing informative banners to the user.\n\nHere's a list of high-level product features:\n\n*   **URL-based Heatmap Viewing:** Allows users to enter a URL and view its heatmap, provided the page has the PostHog Toolbar installed and can be loaded in an iframe.\n*   **Top URLs Display:** Shows a list of the most viewed pages, allowing users to quickly select a page to view its heatmap.\n*   **URL Authorization:** Checks if a URL is authorized for heatmap viewing and prompts the user to authorize it if not.\n*   **Heatmap Settings Panel:** Provides a panel with settings to filter and customize the heatmap display, including date ranges, color palettes, and fixed position mode.\n*   **Viewport Selection:** Allows users to select different viewport sizes (mobile, tablet, desktop) to view the heatmap in different screen resolutions.\n*   **Error Handling:** Displays informative banners for invalid URLs, unauthorized URLs, and iframe loading errors.\n*   **Toolbar Integration:** Provides a button to open the selected URL in the PostHog Toolbar for further analysis.\n*   **Heatmaps Enablement Check:** Warns the user if heatmaps are not enabled in their project settings."
    },
    {
        "path": "frontend/src/scenes/heatmaps",
        "summary": "The provided code collectively implements a Heatmaps feature within a web application, enabling users to visualize user interaction data on their website pages. This is achieved through a dedicated Heatmaps Browser that allows users to input URLs, view heatmaps within an iframe, and customize the heatmap display through various settings. The system manages URL authorization, handles loading states and errors, and integrates with the PostHog Toolbar for further analysis. The underlying logic manages the state of the browser, communicates with the iframe, and provides features like URL search and autocomplete.\n\nHere's a list of high-level product features:\n\n*   URL-based Heatmap Visualization: Allows users to view heatmaps for specific URLs within their product.\n*   Heatmap Browsing: Users can browse and navigate through different heatmaps.\n*   Heatmap Configuration: Enables users to customize the heatmap appearance through filters (date range, etc.), color palettes, and fixed position mode.\n*   Top URLs Display: Shows a list of the most viewed pages, allowing users to quickly select a page to view its heatmap.\n*   URL Search and Autocomplete: Provides a search bar with autocomplete suggestions for URLs based on historical data.\n*   URL Authorization: Checks if a URL is authorized for heatmap viewing and prompts the user to authorize it if not.\n*   Error Handling: Displays informative banners for invalid URLs, unauthorized URLs, and iframe loading errors.\n*   Toolbar Integration: Provides a button to open the selected URL in the PostHog Toolbar for further analysis.\n*   Viewport Selection: Allows users to select different viewport sizes (mobile, tablet, desktop) to view the heatmap in different screen resolutions.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/FunnelCanvasLabel.tsx",
        "summary": "The `FunnelCanvasLabel` component displays key metrics and actions related to a funnel insight on the funnel canvas. It shows the total conversion rate, average time to convert, and allows users to switch between different funnel visualization types (Steps, Trends, TimeToConvert). Additionally, if the insight supports it, the component provides a button to create a draft experiment using the funnel's metric, facilitating A/B testing and optimization. The component uses tooltips to explain the metrics and provides links to navigate to different funnel visualizations or create experiments.\n\nHere's a list of high-level product features implemented by the code:\n\n*   **Display Total Conversion Rate:** Shows the overall conversion rate for the funnel.\n*   **Display Average Time to Convert:** Shows the average time users spend in the funnel.\n*   **Funnel Visualization Type Switching:** Allows users to switch between different funnel visualizations (Steps, Trends, TimeToConvert).\n*   **Experiment Creation:** Enables users to create a draft experiment based on the funnel's metric.\n*   **Metric Explanations:** Provides tooltips to explain the displayed metrics.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/Funnel.tsx",
        "summary": "This code defines the `Funnel` component, which is responsible for rendering different visualizations of funnel data based on the selected `funnelVizType` and `layout`. It uses `kea` for state management and imports various components for different funnel visualizations, including line graphs, histograms, and vertical/horizontal bar charts. The component dynamically selects the appropriate visualization based on the `funnelVizType` and `layout` properties, providing a flexible way to display funnel data.\n\nHere's a list of high-level product features:\n\n*   **Funnel Visualization:** Displays funnel data in various formats.\n*   **Trends Visualization:** Renders funnel data as a line graph to show trends over time.\n*   **Time to Convert Visualization:** Shows the distribution of time it takes for users to convert using a histogram.\n*   **Vertical Bar Chart Visualization:** Displays funnel steps as vertical bars.\n*   **Horizontal Bar Chart Visualization:** Displays funnel steps as horizontal bars.\n*   **Dynamic Layout Selection:** Automatically chooses the appropriate visualization based on user-defined settings.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/FunnelBarHorizontal/DuplicateStepIndicator.tsx",
        "summary": "This code defines a React component called `DuplicateStepIndicator` that displays an information icon with a tooltip. The tooltip explains that the funnel step involves a repeated event in a sequence, clarifying that repeated events are interpreted as a sequence of distinct occurrences of that event within the funnel. The component uses the `IconInfo` component from `@posthog/icons` and the `Tooltip` component from `lib/lemon-ui/Tooltip` to achieve this functionality.\n\nHere's a list of high-level product features:\n\n*   **Funnel Visualization:** Displays a horizontal bar representation of a funnel.\n*   **Duplicate Step Indication:** Indicates when a step in the funnel involves a repeated event.\n*   **Tooltip Explanation:** Provides a tooltip explaining how repeated events are handled in funnel analysis (interpreted as a sequence).\n*   **Visual Cue:** Uses an information icon to visually highlight duplicate steps.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/funnelUtils.ts",
        "summary": "This code provides utility functions for working with funnel data in a product analytics application. It includes functions for calculating conversion rates, identifying significant breakdowns, aggregating breakdown results, and formatting data for display. The code also handles edge cases such as empty breakdowns and incomplete conversion windows.\n\nHere's a list of high-level product features that utilize this code:\n\n*   **Funnel Analysis:** Define and analyze user funnels to understand conversion rates and drop-off points.\n*   **Breakdown Analysis:** Break down funnel results by different properties or cohorts to identify segments with higher or lower conversion rates.\n*   **Conversion Rate Calculation:** Calculate conversion rates between steps in a funnel, both relative to the previous step and relative to the first step.\n*   **Significance Testing:** Identify significant breakdowns in funnel conversion rates to highlight key areas for improvement.\n*   **Data Visualization:** Format funnel data for display in charts and tables, including handling of empty values and edge cases.\n*   **Funnel Exclusion:** Define a range of steps to exclude from a funnel.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/funnelCorrelationFeedbackLogic.ts",
        "summary": "This code defines a Kea logic module named `funnelCorrelationFeedbackLogic` that manages user feedback related to funnel correlation analysis. It handles actions for sending feedback, hiding the feedback form, setting the feedback rating, setting detailed feedback comments, and controlling the visibility of the detailed feedback input. The logic also connects to `funnelCorrelationLogic` and `funnelPropertyCorrelationLogic` to trigger loading of correlation data, and uses reducers to manage the state of the feedback form, including its visibility, rating, and detailed comments. Finally, it reports feedback events using `eventUsageLogic` and displays a success toast upon submission.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Collect User Feedback on Funnel Correlation Analysis:** Allows users to provide feedback on the results of funnel correlation analysis.\n*   **Rating-Based Feedback:** Enables users to rate the usefulness of the correlation analysis.\n*   **Detailed Feedback Comments:** Provides a text input for users to elaborate on their feedback.\n*   **Conditional Feedback Form Visibility:** Shows or hides the detailed feedback input based on the rating provided.\n*   **Usage Tracking:** Tracks user feedback events for analysis and product improvement.\n*   **User Notification:** Displays a success message upon submitting feedback.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/FunnelBarHorizontal/FunnelBarHorizontal.tsx",
        "summary": "This code defines the `FunnelBarHorizontal` component, which visually represents a funnel using horizontal bars. Each step in the funnel is displayed as a section with a bar representing the conversion rate. The component allows users to inspect the values and see the persons who converted or dropped off at each step, with support for breakdowns within each step. It also handles unordered funnels and duplicate steps, displaying relevant information and icons for each.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Horizontal Funnel Visualization:** Displays funnel steps as horizontal bars, representing conversion rates.\n*   **Conversion Rate Display:** Shows the conversion rate and number of users who completed each step.\n*   **Drop-off Rate Display:** Shows the drop-off rate and number of users who dropped off at each step.\n*   **Step Ordering:** Supports both ordered and unordered funnels.\n*   **Duplicate Step Handling:** Indicates duplicate steps in the funnel.\n*   **Breakdown Support:** Visualizes breakdowns within each funnel step.\n*   **User Inspection:** Allows users to inspect the list of users who converted or dropped off at each step.\n*   **Average Conversion Time:** Displays the average time to convert for each step.\n*   **Dynamic Resizing:** Adapts to different screen sizes.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/FunnelBarHorizontal/Bar.tsx",
        "summary": "This component, `Bar.tsx`, renders a horizontal bar representing a step in a funnel, visualizing conversion rates. It handles displaying the percentage of users who completed that step, with considerations for breakdowns (sub-segments) within the funnel. The component dynamically adjusts the label position (inside or outside the bar) based on available space and provides a tooltip with detailed information about the step and the users who reached it. The bar is interactive, allowing users to click to view the users who reached that step, unless disabled.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Visual Funnel Step Representation:** Displays a bar representing a step in a funnel.\n*   **Conversion Rate Visualization:** Shows the percentage of users who converted at each step.\n*   **Breakdown Support:** Handles breakdowns within the funnel, displaying sub-segments and their respective conversion rates.\n*   **Dynamic Label Placement:** Adjusts the position of the percentage label based on available space.\n*   **Interactive Tooltip:** Provides a tooltip with detailed information about the step, including the ability to view the users who reached that step.\n*   **Clickable Bar:** Allows users to click the bar to view the users who reached that step.\n*   **Color Coding:** Uses color to differentiate steps or breakdowns within the funnel.\n*   **Accessibility:** Implements accessibility features such as ARIA attributes for screen readers.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/funnelCorrelationUsageLogic.ts",
        "summary": "This code defines the `funnelCorrelationUsageLogic` Kea logic, which is responsible for tracking user interactions and views related to funnel correlation features within the PostHog application. It connects to various other logics, including `eventUsageLogic` for reporting events, `insightLogic` and `insightVizDataLogic` for accessing insight-related data, and funnel-specific logics like `funnelCorrelationLogic`, `funnelDataLogic`, `funnelPersonsModalLogic`, and `funnelPropertyCorrelationLogic`. The logic tracks when correlation results (both event and property correlations) are viewed, when users interact with correlation settings (like setting correlation types or excluding events/properties), and when users open the persons modal to investigate correlation results. It reports these interactions to `eventUsageLogic` for analysis.\n\nHere's a list of high-level product features this logic supports:\n\n*   **Event Correlation Tracking:** Tracks when users view event correlations in funnels.\n*   **Property Correlation Tracking:** Tracks when users view property correlations in funnels.\n*   **Interaction Tracking:** Records user interactions with correlation settings, such as setting correlation types and excluding events or properties from correlation analysis.\n*   **Persons Modal Tracking:** Tracks when users open the persons modal to investigate correlation results, capturing relevant context like the event name, properties, and conversion status.\n*   **Skew Warning Tracking:** Tracks when users hide the skew warning.\n*   **Event Property Correlation Tracking:** Tracks when users load event with property correlations and exclude event properties.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/funnelDataLogic.ts",
        "summary": "This code defines the `funnelDataLogic` Kea logic, responsible for managing and processing data for funnels insights in a PostHog application. It connects to other logic stores like `insightVizDataLogic`, `groupsModel`, and `featureFlagLogic` to access necessary data and actions. The logic handles various funnel visualizations (Steps, TimeToConvert, Trends), calculates conversion metrics, aggregates breakdown results, and prepares data for display in the UI. It also manages the visibility of legend breakdowns and handles customizations for funnel results.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Funnel Visualization:** Supports different funnel visualization types (Steps, Time to Convert, Trends).\n*   **Conversion Metrics Calculation:** Calculates and provides conversion rates (step rate, total rate) and average conversion time.\n*   **Breakdown Analysis:** Aggregates and flattens funnel data by breakdowns for detailed analysis.\n*   **Legend Customization:** Allows users to hide or show specific breakdowns in the legend.\n*   **Result Customization:** Supports customization of funnel result appearance (e.g., colors).\n*   **Time-to-Convert Funnels:** Specifically handles data and calculations for time-to-convert funnels, including histogram data.\n*   **Data Aggregation:** Aggregates data from various sources to provide a comprehensive view of funnel performance.\n*   **Data Transformation:** Transforms and prepares data for optimal display and analysis in the UI.\n*   **Empty State Handling:** Detects and handles scenarios where funnel results are empty.\n*   **Experiment Support:** Supports experiments by allowing the removal of baseline from funnel visualization."
    },
    {
        "path": "frontend/src/scenes/funnels/FunnelBarHorizontal",
        "summary": "The provided code implements a horizontal bar visualization for funnels, allowing users to understand conversion rates and drop-off points at each step. The visualization supports breakdowns, unordered funnels, and duplicate steps, providing detailed information through tooltips and interactive elements. Users can inspect the list of users who converted or dropped off at each step, gaining deeper insights into user behavior within the funnel.\n\nHere's a list of high-level product features:\n\n*   Horizontal Funnel Visualization\n*   Conversion Rate Visualization\n*   Drop-off Rate Visualization\n*   Breakdown Support\n*   Unordered Funnel Support\n*   Duplicate Step Handling\n*   User Inspection (View Users Who Converted/Dropped Off)\n*   Dynamic Label Placement\n*   Interactive Tooltips\n*   Clickable Bars\n*   Color Coding\n*   Accessibility\n*   Average Conversion Time Display\n*   Dynamic Resizing\n"
    },
    {
        "path": "frontend/src/scenes/funnels/FunnelBarVertical/StepBarLabels.tsx",
        "summary": "The `StepBarLabels` component generates a horizontal bar of labels representing percentage values. It creates six segments, each displaying a percentage label that increments by 20% from 0% to 100%. This component is likely used to visually represent the progress or conversion rate at different steps within a funnel.\n\n**Features:**\n\n*   Displays a horizontal bar of percentage labels.\n*   Generates six segments representing percentage values.\n*   Labels increment by 20% from 0% to 100%.\n*   Visually represents progress or conversion rate in a funnel.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/funnelTooltipLogic.ts",
        "summary": "This code defines a Kea logic module named `funnelTooltipLogic` responsible for managing the state and actions related to displaying a tooltip on a funnel chart. It handles showing and hiding the tooltip, storing the data to be displayed in the tooltip (step index and series data), and tracking the origin (position) of the tooltip. The logic is keyed to allow for multiple instances, though a default key is provided.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Displaying Tooltips on Funnel Charts:** Shows detailed information about a specific step in the funnel when hovered over.\n*   **Tooltip Positioning:** Positions the tooltip dynamically based on the origin point (likely the mouse position or step location).\n*   **Tooltip Content Management:** Stores and updates the data to be displayed in the tooltip, including step index and conversion metrics.\n*   **Tooltip Visibility Control:** Manages the visibility state of the tooltip (shown or hidden).\n"
    },
    {
        "path": "frontend/src/scenes/funnels/FunnelBarVertical/StepBars.tsx",
        "summary": "The `StepBars` component is responsible for rendering a set of bars representing a step in a funnel, broken down by nested breakdowns (series). It creates a grid background and then iterates through each series in the step's `nested_breakdown` to render a `StepBar` component for each series. The component receives step data, the step index, and a function to show a persons modal, passing these props down to the individual `StepBar` components.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Funnel Visualization:** Renders a vertical bar representation of funnel steps.\n*   **Nested Breakdown Support:** Displays breakdowns within each funnel step using multiple bars.\n*   **Grid Background:** Provides a visual grid to aid in comparing bar heights.\n*   **Step Index Awareness:** Styles the first step differently.\n*   **Person Modal Integration:** Allows triggering a modal to view the persons represented by a bar.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/funnelCorrelationDetailsLogic.ts",
        "summary": "This code defines a Kea logic module called `funnelCorrelationDetailsLogic` that manages the state and actions related to displaying detailed information about correlations within a funnel analysis. It handles opening and closing a modal to show these details, stores the selected correlation data, and calculates a correlation matrix and score to quantify the strength of the correlation. The logic connects to `funnelDataLogic` to access funnel step data.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Correlation Details Modal:** Ability to open a modal displaying detailed information about a specific correlation found in a funnel.\n*   **Correlation Data Storage:** Stores the data of the selected correlation for display in the modal.\n*   **Correlation Score Calculation:** Calculates a correlation score and its strength (weak, moderate, strong) based on the success and failure counts related to the correlation.\n*   **Correlation Matrix Display:** Provides data (true positive, false positive, true negative, false negative) for displaying a correlation matrix, visualizing the relationship between the correlated property and funnel conversion.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/FunnelBarVertical/StepLegend.tsx",
        "summary": "The `StepLegend` component provides a detailed breakdown of each step within a funnel visualization. It displays key metrics such as the number of users who converted at that step, the conversion rate relative to the first or previous step, the number of users who dropped off, and the drop-off rate. It also shows the median time of conversion from the previous step, if enabled. The component includes tooltips to explain the metrics, and buttons to open a modal displaying the list of users who converted or dropped off at that step.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Funnel Step Conversion Metrics:** Displays the number of users who converted at each step.\n*   **Conversion Rate Display:** Shows the conversion rate relative to the first or previous step.\n*   **Funnel Step Drop-off Metrics:** Displays the number of users who dropped off at each step.\n*   **Drop-off Rate Display:** Shows the drop-off rate relative to the previous step.\n*   **Median Conversion Time:** Displays the median time it takes users to convert from the previous step.\n*   **Metric Tooltips:** Provides tooltips to explain the meaning of each metric.\n*   **User List Modal:** Allows users to view a list of users who converted or dropped off at a specific step.\n*   **Step Customization:** Provides a \"More\" menu with additional options for each step (requires advanced paths feature).\n"
    },
    {
        "path": "frontend/src/scenes/funnels/FunnelBarVertical/StepBar.tsx",
        "summary": "The `StepBar` component visualizes a step within a funnel, displaying its conversion rate and allowing users to interact with it. It uses colors to represent the series the step belongs to and displays a tooltip on hover with step details. When `showPersonsModal` is enabled, clicking on the bar opens a modal showing the persons who converted or dropped off at that step.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Visual Funnel Step Representation:** Displays a step in a funnel with a visual representation of its conversion rate.\n*   **Series Coloring:** Colors the step bar based on the series it belongs to, improving visual distinction.\n*   **Tooltip on Hover:** Shows a tooltip with detailed information about the step when the user hovers over it.\n*   **Conversion Rate Display:** Visually represents the conversion rate of the step.\n*   **Persons Modal Integration:** Opens a modal to view users who converted or dropped off at the step (conditional on `showPersonsModal`).\n*   **Clickable Step Bar:** Makes the step bar clickable to trigger actions, such as opening the persons modal.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/FunnelBarVertical/FunnelBarVertical.tsx",
        "summary": "The `FunnelBarVertical` component visualizes funnel data in a vertical bar chart format. It dynamically adjusts the bar width based on the number of series, supports horizontal scrolling with shadows for overflow, and displays step labels and legends. The component also integrates with tooltips and conditionally enables a modal to show persons who reached a specific step. The height of the bars is dynamically calculated based on available space, legend height, and scrollbar presence.\n\nHere's a list of high-level product features:\n\n*   **Vertical Bar Chart Visualization:** Displays funnel data as a vertical bar chart.\n*   **Dynamic Bar Width Adjustment:** Automatically adjusts the width of the bars based on the number of series in the funnel.\n*   **Horizontal Scrolling:** Implements horizontal scrolling for funnels with many steps, ensuring all steps are viewable.\n*   **Scroll Shadows:** Provides visual cues (shadows) to indicate scrollable content.\n*   **Step Labels:** Displays labels for each step in the funnel.\n*   **Step Legend:** Shows key metrics for each step, including conversion rates and average conversion times.\n*   **Tooltip Integration:** Integrates with a tooltip system to provide additional information on hover.\n*   **Person Modal Integration:** Allows users to view a modal with a list of persons who reached a specific step.\n*   **Dynamic Height Calculation:** Calculates the height of the bars dynamically based on available space.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/FunnelBarVertical",
        "summary": "The funnel visualization provides a comprehensive view of user progression through a series of steps, offering insights into conversion and drop-off rates. The vertical bar chart format allows for easy comparison of step performance, with dynamic adjustments for multiple series and horizontal scrolling for extensive funnels. Users can interact with the visualization to explore detailed metrics, view user lists, and gain a deeper understanding of funnel performance.\n\n**Features:**\n\n*   **Vertical Bar Chart Visualization:** Displays funnel data as a vertical bar chart.\n*   **Dynamic Bar Width Adjustment:** Automatically adjusts the width of the bars based on the number of series in the funnel.\n*   **Horizontal Scrolling:** Implements horizontal scrolling for funnels with many steps, ensuring all steps are viewable.\n*   **Scroll Shadows:** Provides visual cues (shadows) to indicate scrollable content.\n*   **Step Labels:** Displays labels for each step in the funnel.\n*   **Step Legend:** Shows key metrics for each step, including conversion rates and average conversion times.\n*   **Tooltip Integration:** Integrates with a tooltip system to provide additional information on hover.\n*   **Person Modal Integration:** Allows users to view a modal with a list of persons who reached a specific step.\n*   **Dynamic Height Calculation:** Calculates the height of the bars dynamically based on available space.\n*   **Funnel Step Conversion Metrics:** Displays the number of users who converted at each step.\n*   **Conversion Rate Display:** Shows the conversion rate relative to the first or previous step.\n*   **Funnel Step Drop-off Metrics:** Displays the number of users who dropped off at each step.\n*   **Drop-off Rate Display:** Shows the drop-off rate relative to the previous step.\n*   **Median Conversion Time:** Displays the median time it takes users to convert from the previous step.\n*   **Metric Tooltips:** Provides tooltips to explain the meaning of each metric.\n*   **User List Modal:** Allows users to view a list of users who converted or dropped off at a specific step.\n*   **Step Customization:** Provides a \"More\" menu with additional options for each step (requires advanced paths feature).\n*   **Nested Breakdown Support:** Displays breakdowns within each funnel step using multiple bars.\n*   **Grid Background:** Provides a visual grid to aid in comparing bar heights.\n*   **Series Coloring:** Colors the step bar based on the series it belongs to, improving visual distinction.\n*   **Clickable Step Bar:** Makes the step bar clickable to trigger actions, such as opening the persons modal.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/funnelCorrelationLogic.ts",
        "summary": "This code defines the logic for funnel correlation analysis within a product analytics platform. It fetches and processes data to identify events and event properties that are correlated with success or failure in a funnel. The logic allows users to exclude specific events or event properties from the correlation analysis, providing more control over the insights generated. It also manages the state for displaying and filtering correlation results, including expanding nested tables for detailed information.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Funnel Correlation Analysis:** Identifies events and event properties that correlate with funnel conversion or drop-off.\n*   **Event Exclusion:** Allows users to exclude specific events from the correlation analysis.\n*   **Event Property Exclusion:** Allows users to exclude specific event properties from the correlation analysis.\n*   **Correlation Type Filtering:** Enables users to filter correlations based on success or failure types.\n*   **Detailed Correlation Results:** Provides detailed information about each correlation, including odds ratios.\n*   **Nested Table Expansion:** Allows users to expand nested tables to view more granular correlation data.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/FunnelHistogram.tsx",
        "summary": "The `FunnelHistogram` component visualizes the distribution of conversion times within a funnel using a histogram. It leverages the `Histogram` component from the insights module and dynamically adjusts its behavior based on whether it's rendered within a dashboard context. When in a dashboard, it forces a full re-render on data changes to avoid D3.js bugs. The component fetches histogram data from the `funnelDataLogic` and formats the x-axis tick labels to display human-friendly durations.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Funnel Conversion Time Visualization:** Displays a histogram showing the distribution of time taken for users to convert through the funnel steps.\n*   **Dynamic Resizing:** Adapts to the available width and height of its container.\n*   **Dashboard Compatibility:** Handles rendering within dashboards, including workarounds for D3.js rendering issues.\n*   **Human-Friendly Duration Formatting:** Presents time durations on the x-axis in a readable format (e.g., \"1m 30s\").\n"
    },
    {
        "path": "frontend/src/scenes/funnels/funnelPropertyCorrelationLogic.ts",
        "summary": "This code defines the logic for correlating properties with funnel conversions in PostHog. It fetches and displays correlations between user properties and funnel success/failure, allowing users to identify key factors influencing conversion rates. The logic handles filtering, sorting, and excluding properties from the analysis, providing insights into user behavior within funnels.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Property Correlation Analysis:** Identifies correlations between user properties and funnel conversion outcomes (success/failure).\n*   **Property Selection:** Allows users to select specific properties to analyze for correlation.\n*   **Property Exclusion:** Enables users to exclude properties from the correlation analysis.\n*   **Data Filtering:** Filters correlation results based on correlation type (success/failure).\n*   **Data Sorting:** Sorts correlation results by odds ratio to highlight the most significant correlations.\n*   **Visualization of Correlations:** Displays correlation results in a user-friendly format (likely a table).\n*   **Configuration of Excluded Properties:** Persists user-defined excluded properties for future analysis.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/FunnelLineGraph.tsx",
        "summary": "The `FunnelLineGraph` component visualizes funnel data as a line graph, displaying conversion rates over time. It leverages data from `funnelDataLogic` and `insightLogic` to render the graph using the `LineGraph` component. The component supports displaying the graph within a card or as a standalone insight, showing a tooltip with formatted dates and conversion percentages. It also allows users to click on data points to open a modal displaying the persons who converted at that point in time, provided the `showPersonsModal` prop is enabled and the user has permission to open the modal.\n\nHere's a list of high-level product features:\n\n*   **Funnel Visualization:** Displays funnel conversion rates as a line graph.\n*   **Time-Based Analysis:** Shows conversion trends over time intervals.\n*   **Interactive Tooltips:** Provides detailed information on data points, including formatted dates and conversion percentages.\n*   **Person Modal Integration:** Allows users to view a list of persons who converted at a specific point in the funnel.\n*   **Shared Mode Support:** Adapts the graph for use in shared dashboards or contexts.\n*   **Customizable Display:** Can be displayed within a card or as a standalone insight.\n*   **Data Incompleteness Indicator:** Indicates if the data is still being collected.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/FunnelStepMore.tsx",
        "summary": "This component, `FunnelStepMore`, renders a \"More\" button within a funnel visualization. When clicked, it displays a dropdown menu with options to view user paths related to a specific step in the funnel. These options include paths leading to the step, paths between the previous and current step, paths after the step, and paths before/after dropoff from the step. The component dynamically generates URLs to new insight pages pre-configured to show the relevant path analysis based on the selected option. The component will not render if the funnel is aggregating by groups, as paths are user-based.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Show User Paths Leading to Step:** Allows users to see the sequence of events users took before reaching a specific step in the funnel.\n*   **Show User Paths Between Steps:** Shows the paths users took between the previous step and the current step in the funnel.\n*   **Show User Paths After Step:** Displays the paths users took after completing a specific step in the funnel.\n*   **Show User Paths After Dropoff:** Shows the paths users took after dropping off from a specific step in the funnel.\n*   **Show User Paths Before Dropoff:** Shows the paths users took before dropping off from a specific step in the funnel.\n*   **Contextual Path Analysis:** Provides quick access to path analysis insights directly from the funnel visualization.\n*   **Dynamic URL Generation:** Generates pre-configured URLs for path analysis based on the selected funnel step and path type.\n*   **Group Aggregation Check:** Hides the path analysis options when the funnel is aggregating by groups, as paths are user-based.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/funnelPersonsModalLogic.ts",
        "summary": "This code defines a Kea logic module called `funnelPersonsModalLogic` that manages the opening of a modal displaying persons who have either converted or dropped off at a specific step in a funnel. It connects to other logic modules like `insightLogic` and `funnelDataLogic` to access funnel data and insight context. The logic provides actions to open the persons modal for a specific funnel step, a breakdown series within a step, or for a correlation analysis result. It constructs the appropriate query based on the context (step number, breakdown values, correlation results) and opens the `PersonsModal` with the query and a generated title.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **View Users at Funnel Step:** Allows users to see the list of people who reached a specific step in the funnel, differentiating between converters and non-converters.\n*   **View Users in Breakdown Series:** Enables viewing users within a specific breakdown series of a funnel step, providing insights into user behavior within different segments.\n*   **View Users from Correlation Analysis:** Supports viewing users based on the results of a funnel correlation analysis, showing users who converted or dropped off based on correlated events or properties.\n*   **Recordings Access:** Includes the ability to access matched recordings for users displayed in the modal, providing deeper insights into user behavior.\n*   **Dynamic Title Generation:** Generates a descriptive title for the modal based on the funnel step, breakdown value, and conversion status.\n"
    },
    {
        "path": "frontend/src/scenes/funnels/FunnelTooltip.tsx",
        "summary": "This code defines a React component, `FunnelTooltip`, which displays detailed information about a specific step in a funnel visualization. It leverages data from various PostHog models and logics to present metrics like conversion rates, drop-off numbers, and median/average conversion times. The tooltip content includes the step name, breakdown value, and key metrics associated with the step. A hook, `useFunnelTooltip`, manages the tooltip's visibility and positioning based on the funnel visualization's state, ensuring it appears near the relevant data point. It also allows for inspecting the actors (users) who reached a specific step.\n\nHere's a list of high-level product features related to this code:\n\n*   **Funnel Step Details:** Display detailed information about each step in a funnel, including conversion rates, drop-off numbers, and time-to-convert metrics.\n*   **Breakdown Support:** Show breakdown values for each funnel step, allowing users to segment the data and understand how different groups perform.\n*   **Conversion Time Metrics:** Display median and average conversion times for each step, providing insights into the time it takes users to move through the funnel.\n*   **Actor Inspection:** Enable users to inspect the actors (users) who reached a specific step in the funnel, facilitating deeper analysis and troubleshooting.\n*   **Tooltip Positioning:** Dynamically position the tooltip near the relevant data point in the funnel visualization, ensuring it's easily accessible and doesn't obscure the chart.\n*   **Dynamic Tooltip Visibility:** Control the visibility of the tooltip based on user interaction with the funnel visualization.\n"
    },
    {
        "path": "frontend/src/scenes/funnels",
        "summary": "The provided code collectively implements a comprehensive funnel analysis feature within a product analytics platform. This feature allows users to define and visualize user funnels, analyze conversion rates and drop-off points, and identify key factors influencing funnel performance. The platform supports various funnel visualizations, including steps, trends, and time-to-convert, and enables users to break down funnel results by different properties or cohorts. Users can also create experiments based on funnel metrics, track user interactions with correlation settings, and view detailed information about each step in the funnel through interactive tooltips and modals.\n\nHere's a list of high-level product features:\n\n*   Funnel Visualization (Steps, Trends, Time to Convert, Horizontal/Vertical Bar Charts)\n*   Conversion Rate Calculation and Display\n*   Drop-off Rate Analysis\n*   Breakdown Analysis and Segmentation\n*   Time-to-Convert Analysis\n*   Funnel Correlation Analysis (Event and Property Correlations)\n*   User Path Analysis\n*   Experiment Creation from Funnel Metrics\n*   User Inspection (View Users Who Converted/Dropped Off)\n*   Interactive Tooltips and Modals\n*   Data Filtering and Sorting\n*   Customizable Visualization Options\n*   User Feedback Collection\n*   Event and Property Exclusion from Analysis\n*   Dynamic Layout Selection\n*   Dashboard Compatibility\n"
    },
    {
        "path": "frontend/src/scenes/IntegrationsRedirect/IntegrationsRedirect.tsx",
        "summary": "The `IntegrationsRedirect` component is a simple loading screen displayed while the application handles redirection related to integrations. It utilizes a spinner to indicate that a process is ongoing. The component is connected to `integrationsLogic`, suggesting that the redirection is related to integration setup or management.\n\nHere's a list of high-level product features:\n\n*   **Integrations Management:** The application supports integrations with external services.\n*   **Integration Redirection:** Users are redirected to specific pages or services during the integration process.\n*   **Loading Indication:** A loading spinner is displayed to provide feedback during redirection.\n"
    },
    {
        "path": "frontend/src/scenes/IntegrationsRedirect",
        "summary": "The `IntegrationsRedirect` component provides a visual loading screen with a spinner to indicate ongoing redirection processes related to integrations. This component is part of the application's integration management system, ensuring users are aware that the system is working during redirection to external services or specific pages within the application related to integration setup or management.\n\nHere's a list of high-level product features:\n\n*   **Integrations Management:** Allows users to connect and manage integrations with external services.\n*   **Integration Redirection:** Handles redirection of users to external services or specific pages within the application during the integration process.\n*   **Loading Indication:** Provides visual feedback to the user during redirection processes using a loading spinner.\n"
    },
    {
        "path": "frontend/src/scenes/themes/CustomCssScene.tsx",
        "summary": "The `CustomCssScene` component allows users to customize the look and feel of their PostHog instance by adding custom CSS. It features a code editor where users can write or paste their CSS code, with the ability to preview the changes before saving. The component also provides example themes like \"Tron\" and \"Barbie\" to inspire users and provide a starting point for their customizations. The custom CSS is persisted and applied to the PostHog instance after saving.\n\nHere's a list of high-level product features:\n\n*   **Custom CSS Editor:** A code editor for writing and editing custom CSS.\n*   **CSS Preview:** Ability to preview the custom CSS changes before applying them.\n*   **Theme Templates:** Pre-defined CSS themes (e.g., Tron, Barbie) for inspiration and quick customization.\n*   **Persisted Customization:** Saving and persisting the custom CSS to apply it to the PostHog instance.\n*   **Apply Custom CSS:** Applying the saved custom CSS to the PostHog instance's UI.\n"
    },
    {
        "path": "frontend/src/scenes/themes/PreviewingCustomCssModal.tsx",
        "summary": "This React component, `PreviewingCustomCssModal`, renders a modal that allows users to preview and edit custom CSS. The modal displays a code editor (using Monaco) when the user chooses to edit inline, allowing them to modify the CSS. It provides options to minimize the editor and save the changes. The modal is positioned at the bottom of the screen and is only visible when the user is not already on the custom CSS page and when there is custom CSS being previewed.\n\nHere's a list of high-level product features:\n\n*   **Custom CSS Preview:** Allows users to preview custom CSS changes before applying them.\n*   **Inline Code Editor:** Provides a code editor within the modal for editing the custom CSS.\n*   **Save and Close:** Enables users to save the custom CSS changes and close the modal.\n*   **Toggle Editor Size:** Allows users to minimize or maximize the code editor within the modal.\n*   **Conditional Display:** The modal is only displayed when custom CSS is being previewed and the user is not already on the custom CSS settings page.\n"
    },
    {
        "path": "frontend/src/scenes/themes",
        "summary": "The provided code implements a custom CSS theming feature for PostHog, allowing users to personalize the look and feel of their instance. Users can write and edit CSS code in a dedicated editor, preview changes in real-time, and save their customizations. The system also offers pre-defined theme templates for inspiration and a quick start. A modal component facilitates previewing and editing CSS from different parts of the application, ensuring a consistent and accessible customization experience.\n\nHere's a list of high-level product features:\n\n*   Custom CSS Editor: A code editor for writing and editing custom CSS.\n*   CSS Preview: Ability to preview the custom CSS changes before applying them.\n*   Theme Templates: Pre-defined CSS themes (e.g., Tron, Barbie) for inspiration and quick customization.\n*   Persisted Customization: Saving and persisting the custom CSS to apply it to the PostHog instance.\n*   Apply Custom CSS: Applying the saved custom CSS to the PostHog instance's UI.\n*   Inline Code Editor: Provides a code editor within the modal for editing the custom CSS.\n*   Save and Close: Enables users to save the custom CSS changes.\n*   Toggle Editor Size: Allows users to minimize or maximize the code editor within the modal.\n*   Conditional Display: The modal is only displayed when custom CSS is being previewed and the user is not already on the custom CSS settings page.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/Login2FA.tsx",
        "summary": "The `Login2FA` component provides a user interface for two-factor authentication during the login process. It uses the `login2FALogic` and `preflightLogic` kea logics to manage the form submission and display relevant information such as error messages and branding. The component renders a form with a single input field for the authenticator token or backup code, along with a submit button. It also displays a welcome message and any general errors that occur during the authentication process.\n\nHere's a list of high-level product features:\n\n*   **Two-Factor Authentication (2FA):** Enables users to log in using a time-based one-time password (TOTP) generated by an authenticator app or a backup code.\n*   **Authenticator Token Input:** Provides a dedicated input field for users to enter their authenticator token or backup code.\n*   **Error Handling:** Displays error messages to the user if the authentication fails.\n*   **Loading State:** Indicates when the authentication process is in progress.\n*   **Branding:** Displays a welcome message with PostHog branding, including support for PostHog Cloud.\n*   **Form Management:** Uses kea-forms to handle form submission and validation.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/signup/verify-email/verifyEmailLogic.ts",
        "summary": "This code defines a Kea logic module for handling email verification. It manages the state of the verification process, including the current view (pending, verify, invalid, success), and the user's UUID. It provides actions for setting the view and UUID, validating the email token, and requesting a new verification link. The logic interacts with the backend API to validate the token and request new verification emails, displaying appropriate success or error messages using lemonToast. It also uses kea-router to handle different URL patterns related to email verification, triggering actions based on the URL.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Email Verification:** Allows users to verify their email address after signing up.\n*   **Token Validation:** Validates the email verification token received by the user.\n*   **Resend Verification Email:** Enables users to request a new verification email if they haven't received the original one.\n*   **Status Indication:** Provides visual feedback to the user on the status of the email verification process (pending, verifying, success, error).\n*   **URL-Based Verification:** Handles email verification through unique URLs containing a UUID and token.\n*   **Error Handling:** Displays user-friendly error messages for common issues like invalid tokens or request throttling.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/PasswordReset.tsx",
        "summary": "The `PasswordReset.tsx` component provides a user interface for requesting a password reset email. It handles different scenarios, including when the email service is unavailable, when the user has successfully requested a password reset, and when the user has been throttled due to too many requests. The component also includes a form for the user to enter their email address and a button to submit the request. It leverages various Lemon UI components for styling and interactivity, and uses kea-router for navigation.\n\nHere's a list of high-level product features:\n\n*   **Password Reset Request:** Allows users to initiate a password reset process by entering their email address.\n*   **Email Service Availability Check:** Determines if the email service is configured and available for sending password reset emails.\n*   **Success Message:** Displays a confirmation message upon successful password reset request, informing the user to check their email.\n*   **Throttling Mechanism:** Implements rate limiting to prevent abuse of the password reset functionality.\n*   **Email Unavailable Guidance:** Provides instructions for administrators to configure the email service or manually reset passwords if the service is unavailable.\n*   **Back to Login Button:** Provides a convenient way for users to navigate back to the login page after a successful request or if throttled.\n*   **Support Modal Button:** Provides a way for users to contact support.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/signup/verify-email/VerifyEmail.tsx",
        "summary": "The `VerifyEmail` component handles the email verification process for new users signing up to PostHog. It guides the user through different states of verification, including pending verification, verifying, success, and invalid link scenarios, displaying appropriate messages and illustrations. The component also provides a \"Get Help\" flow, which includes a checklist of common email issues and options to contact support or request a new verification link.\n\nHere's a list of high-level product features:\n\n*   **Email Verification Flow:** Guides users through the email verification process with different views for pending, verifying, success, and invalid states.\n*   **Visual Feedback:** Uses illustrations (MailHog, HeartHog, SurprisedHog) to provide visual feedback to the user during the verification process.\n*   **\"Get Help\" Modal:** Provides a modal with a checklist of common email issues and options for support.\n*   **Troubleshooting Checklist:** Offers a checklist to help users troubleshoot email delivery issues.\n*   **Contact Support Button:** Allows users to contact support if they encounter issues.\n*   **Request New Link Button:** Enables users to request a new verification link.\n*   **Dynamic Button Disabling:** Disables support buttons until the user confirms they have completed the troubleshooting checklist.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/twoFactorLogic.ts",
        "summary": "This code defines the logic for managing two-factor authentication (2FA) within the application. It handles enabling, disabling, and managing backup codes for 2FA. The logic includes fetching the 2FA status, initiating the setup process, validating tokens, generating backup codes, and disabling 2FA. It also manages the UI state for modals related to 2FA setup, disabling, and backup code display. The logic interacts with the backend API to perform these operations and uses toasts to display success or error messages to the user.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Enable 2FA:** Allows users to enable two-factor authentication for their accounts.\n*   **Disable 2FA:** Allows users to disable two-factor authentication for their accounts.\n*   **2FA Setup Modal:** Provides a guided setup process for enabling 2FA.\n*   **Token Validation:** Validates the token entered by the user during 2FA setup.\n*   **Backup Code Generation:** Generates backup codes that users can use if they lose access to their 2FA device.\n*   **Backup Code Display:** Allows users to view their generated backup codes.\n*   **2FA Status Display:** Displays the current 2FA status (enabled/disabled) to the user.\n*   **Enforced 2FA:** Enforces 2FA for all users in an organization.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/Login.tsx",
        "summary": "The `Login.tsx` file defines the login page for the PostHog application. It includes features for email/password login, SSO login (with enforcement and SAML options), social login, and password reset. The page dynamically adjusts based on pre-login checks, such as SSO enforcement and the availability of SAML. It also handles error messages and redirects for cloud instances.\n\nHere's a list of high-level product features implemented in the code:\n\n*   **Email/Password Login:** Standard login functionality with email and password fields.\n*   **SSO Login:** Supports login via Single Sign-On (SSO) providers, with options for enforced SSO and SAML.\n*   **Social Login:** Allows users to log in using social media accounts.\n*   **Password Reset:** Provides a link to the password reset page.\n*   **Region Selection:** Allows users to select their region.\n*   **Error Handling:** Displays error messages for various login issues, such as invalid credentials or SSO configuration problems.\n*   **Pre-login Checks:** Performs checks before login to determine SSO enforcement and SAML availability.\n*   **Cloud Instance Redirection:** Redirects users to the correct PostHog Cloud instance if they are already logged in elsewhere.\n*   **Account Creation Link:** Provides a link to the signup page for new users.\n*   **Support Modal Button:** Provides a button to access the support modal.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/signup/verify-email",
        "summary": "The provided code implements a comprehensive email verification flow for new users. It handles various states of the verification process, from pending to success or failure, providing visual feedback and helpful guidance to the user. The system validates email tokens, allows users to request new verification links, and offers a \"Get Help\" flow with a troubleshooting checklist and options to contact support.\n\nHere's a list of high-level product features:\n\n*   Email Verification Flow: Guides users through the email verification process with different views for pending, verifying, success, and invalid states.\n*   Token Validation: Validates the email verification token received by the user.\n*   Resend Verification Email: Enables users to request a new verification email if they haven't received the original one.\n*   Status Indication: Provides visual feedback to the user on the status of the email verification process (pending, verifying, success, error).\n*   URL-Based Verification: Handles email verification through unique URLs containing a UUID and token.\n*   Error Handling: Displays user-friendly error messages for common issues like invalid tokens or request throttling.\n*   \"Get Help\" Modal: Provides a modal with a checklist of common email issues and options for support.\n*   Troubleshooting Checklist: Offers a checklist to help users troubleshoot email delivery issues.\n*   Contact Support Button: Allows users to contact support if they encounter issues.\n*   Dynamic Button Disabling: Disables support buttons until the user confirms they have completed the troubleshooting checklist.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/signup/signupForm/panels/SignupPanel2.tsx",
        "summary": "This React component, `SignupPanel2`, represents the second panel in the signup form. It collects user's name, organization name, role, and referral source. It uses Lemon UI components for input fields and buttons, and integrates with `kea` for state management and form handling. The panel includes a submit button that triggers account creation or demo environment entry, depending on the preflight configuration. It also displays links to the Terms of Service and Privacy Policy.\n\nHere's a list of high-level product features implemented in this component:\n\n*   **Collects User Information:** Gathers the user's name, organization name, role, and referral source during signup.\n*   **Form Validation and Submission:** Handles form submission and validation using `kea-forms`.\n*   **Dynamic Button Text:** Adapts the submit button text based on whether the user is creating an account or entering a demo environment.\n*   **Terms of Service and Privacy Policy Links:** Provides links to the Terms of Service and Privacy Policy.\n*   **Loading State:** Displays a loading indicator while the form is submitting.\n*   **Referral Source Tracking:** Captures the user's referral source.\n*   **Role Selection:** Allows the user to select their role within the organization.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/signup/signupForm/panels/SignupPanel1.tsx",
        "summary": "This React component, `SignupPanel1`, is the first panel in the signup form. It allows users to sign up using either social login (if available and not in demo mode) or email and password. The panel includes a region selector, email and password input fields with password strength validation, and a \"Continue\" button to submit the form. It also provides a link to the login page for users who already have an account. The component leverages Lemon UI components and Kea logic for form management and state.\n\nHere's a list of the high-level product features implemented in this component:\n\n*   **Region Selection:** Allows users to select their region during signup.\n*   **Social Login:** Enables users to sign up using social authentication providers (e.g., Google, GitHub).\n*   **Email and Password Signup:** Provides a traditional signup method using email and password.\n*   **Password Strength Validation:** Offers real-time feedback on password strength.\n*   **Form Submission:** Handles the submission of the signup form.\n*   **Loading State:** Indicates when the form is submitting.\n*   **Link to Login:** Provides a link to the login page for existing users.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/signup/SignupContainer.tsx",
        "summary": "The `SignupContainer.tsx` file defines the signup page for PostHog, offering both cloud and self-hosted options. It uses a `BridgePage` component to structure the layout, featuring a signup form on the right and a container with product benefits and a call to action on the left. The page dynamically adjusts its footer content based on whether the user is signing up for the cloud or self-hosted version, highlighting the respective advantages of each. It also provides links to switch between US and EU cloud regions.\n\nHere's a list of high-level product features implemented in this file:\n\n*   **Signup Form:** Allows new users to create an account.\n*   **Cloud vs. Self-Hosted Options:** Presents users with a choice between PostHog Cloud and self-hosting.\n*   **Product Benefits Display:** Showcases the advantages of using PostHog, such as free monthly usage, easy data collection, and industry adoption.\n*   **Region Selection (EU/US):** Enables users to choose a cloud region (EU or US) for their data residency.\n*   **Dynamic Footer:** Displays relevant information based on the selected hosting option (cloud or self-hosted).\n"
    },
    {
        "path": "frontend/src/scenes/authentication/signup/signupForm/panels",
        "summary": "The signup process is divided into multiple panels to collect user information in a structured manner. The first panel handles region selection, social login options, and email/password registration with password strength validation. The second panel gathers user details like name, organization, role, and referral source, and presents links to the Terms of Service and Privacy Policy. Both panels feature form validation, submission handling, and loading states during submission, ensuring a smooth user experience.\n\n*   Region Selection\n*   Social Login\n*   Email and Password Signup\n*   Password Strength Validation\n*   Collects User Information (Name, Organization, Role)\n*   Referral Source Tracking\n*   Terms of Service and Privacy Policy Links\n*   Form Validation and Submission\n*   Loading State\n*   Link to Login\n*   Role Selection\n*   Dynamic Button Text (Account Creation vs. Demo)\n"
    },
    {
        "path": "frontend/src/scenes/authentication/signup/signupForm/SignupForm.tsx",
        "summary": "The `SignupForm` component provides a two-panel signup process for new users. It leverages various logic hooks to manage form state, handle submissions, and display errors. The form adapts its messaging based on preflight checks, offering a tailored experience for demo environments. A spinner overlay provides visual feedback during panel transitions, and users can navigate back to the first panel from the second.\n\nHere's a list of high-level product features:\n\n*   **Two-Panel Signup Process:** Guides users through a multi-step signup.\n*   **Dynamic Messaging:** Adapts signup messages based on environment (e.g., demo vs. production).\n*   **Error Handling:** Displays error banners for signup failures.\n*   **Visual Feedback:** Uses a spinner overlay during panel transitions.\n*   **Navigation:** Allows users to go back to the previous signup panel.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/signup/signupForm/signupLogic.ts",
        "summary": "The `signupLogic.ts` file defines the logic for the signup form using Kea. It manages a two-panel signup process, handling form state, validation, and submission. The first panel captures email and password, while the second gathers name, organization, role, and referral information. It integrates with the PostHog API to create accounts and handles redirects based on preflight checks and feature flags, including maintenance scenarios. The logic also includes password validation and error handling, providing a structured and robust signup experience.\n\nHere's a list of high-level product features implemented in the code:\n\n*   **Two-Panel Signup Form:** Guides users through a multi-step signup process.\n*   **Email and Password Validation:** Validates user inputs for email format and password strength.\n*   **Account Creation:** Creates new user accounts via the PostHog API.\n*   **Organization Information Capture:** Collects details about the user's organization.\n*   **Referral Source Tracking:** Records how users discovered the product.\n*   **Maintenance Redirection:** Redirects users to different regions during maintenance.\n*   **Demo Mode Support:** Simplifies signup for demo environments.\n*   **Error Handling:** Displays error messages to guide users through the signup process.\n*   **Feature Flag Integration:** Adapts signup flow based on feature flags.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/signup/signupForm",
        "summary": "The signup functionality provides a multi-step, guided experience for new users to create accounts. It includes features for region selection, social login, email/password registration with validation, and collection of user details like name, organization, role, and referral source. The system integrates with the PostHog API for account creation, handles redirects based on preflight checks and feature flags, and provides error handling and visual feedback throughout the process. The signup flow adapts dynamically based on the environment (e.g., demo vs. production) and supports maintenance redirection.\n\n*   Multi-Step Signup Process\n*   Region Selection\n*   Social Login Integration\n*   Email/Password Registration with Validation\n*   User Information Collection (Name, Organization, Role)\n*   Referral Source Tracking\n*   Terms of Service and Privacy Policy Links\n*   Account Creation via API\n*   Dynamic Messaging based on Environment\n*   Error Handling and Visual Feedback\n*   Maintenance Redirection\n*   Demo Mode Support\n*   Feature Flag Integration\n"
    },
    {
        "path": "frontend/src/scenes/authentication/signup",
        "summary": "The signup and email verification process for PostHog is designed to be a user-friendly and comprehensive experience. It guides new users through account creation, offering options for cloud or self-hosted deployments, region selection, and social login. The system validates email addresses, allows users to request new verification links, and provides a \"Get Help\" flow with troubleshooting steps and support contact options. The signup form collects necessary user information and integrates with the PostHog API for account creation, while dynamically adapting to the environment and feature flags.\n\n*   Email Verification Flow with Token Validation and Resend Functionality\n*   Cloud vs. Self-Hosted Signup Options\n*   Region Selection (EU/US)\n*   Social Login Integration\n*   Multi-Step Signup Process with User Information Collection\n*   Dynamic Messaging and Error Handling\n*   \"Get Help\" Modal with Troubleshooting Checklist and Support Contact\n"
    },
    {
        "path": "frontend/src/scenes/authentication/PasswordResetComplete.tsx",
        "summary": "This code implements the password reset completion page for a web application. It allows users who have received a password reset link to enter and confirm a new password. The page validates the reset token, displays an error message if the link is invalid or expired, and provides a form for entering the new password. It also includes password strength validation and handles submission errors.\n\nHere's a list of high-level product features:\n\n*   **Password Reset Completion:** Allows users to set a new password after receiving a password reset link.\n*   **Reset Token Validation:** Validates the reset token from the URL to ensure it's valid and hasn't expired.\n*   **Password Strength Indicator:** Provides visual feedback on the strength of the entered password.\n*   **Password Confirmation:** Requires users to confirm their new password to prevent typos.\n*   **Error Handling:** Displays error messages for invalid or expired reset links and submission errors.\n*   **New Reset Link Request:** Provides a button to request a new password reset link if the current one is invalid.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/WelcomeLogo.tsx",
        "summary": "The `WelcomeLogo` component displays the PostHog logo, dynamically choosing between the default, cloud, or demo logo based on the preflight check results. It links to the PostHog website, appending UTM tags for tracking the origin of the click. The component uses `kea` to access preflight data and Lemon UI's `Link` component for navigation.\n\nHere's a list of high-level product features:\n\n*   **Dynamic Logo Display:** Chooses the appropriate logo (default, cloud, or demo) based on the application's environment.\n*   **Website Link:** Provides a link to the PostHog website.\n*   **UTM Tracking:** Appends UTM parameters to the website link for tracking purposes.\n*   **Preflight Check Integration:** Uses preflight data to determine the correct logo to display.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/TwoFactorSetup.tsx",
        "summary": "This React component, `TwoFactorSetup`, facilitates the setup of two-factor authentication (2FA) for a user account. It fetches a QR code for the user to scan with their authenticator app and provides a form for the user to input the token generated by the app. Upon submission of the token, the component verifies it and, if successful, redirects the user. Error messages are displayed using a LemonBanner component.\n\nHere's a list of high-level product features:\n\n*   **QR Code Display:** Shows a QR code that users can scan with their authenticator app (e.g., Google Authenticator, Authy).\n*   **Token Input:** Provides a field for users to enter the 6-digit token generated by their authenticator app.\n*   **Token Validation:** Validates the entered token against the server.\n*   **Error Handling:** Displays error messages if the token is invalid or if there are other issues during setup.\n*   **Success Redirection:** Redirects the user to a specified page upon successful 2FA setup.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/passwordResetLogic.ts",
        "summary": "This code defines the logic for handling password reset functionality in a web application. It uses the Kea framework for state management and data flow. The logic includes validating reset tokens, requesting password resets via email, and submitting new passwords. It also incorporates password strength validation and error handling, providing feedback to the user through lemonToast notifications.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Request Password Reset:** Allows users to initiate a password reset process by providing their email address.\n*   **Validate Reset Token:** Verifies the validity of a password reset token received via email.\n*   **Password Reset Form:** Provides a form for users to enter and confirm their new password.\n*   **Password Strength Validation:** Validates the strength of the entered password and provides feedback to the user.\n*   **Error Handling:** Handles errors during the password reset process and displays appropriate error messages.\n*   **Success Notification:** Notifies the user upon successful password reset and redirects them to the application's homepage.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/RegionSelect.tsx",
        "summary": "The `RegionSelect` component in `frontend/src/scenes/authentication/RegionSelect.tsx` allows users to select their preferred data region (US or EU) for PostHog Cloud hosting. It displays a LemonSelect component with options for \"United States\" and \"European Union\". Upon selection, the application redirects the user to the appropriate PostHog Cloud instance based on the chosen region. A modal, `WhyCloudModal`, provides detailed information about the benefits of each region, such as data residency and compliance with regulations. The component only renders if the `preflight` check indicates a cloud environment and a region is available.\n\nHere's a list of high-level product features:\n\n*   **Data Region Selection:** Allows users to choose where their data is hosted (US or EU).\n*   **Automatic Redirection:** Redirects users to the appropriate PostHog Cloud instance based on their region selection.\n*   **Informational Modal:** Provides detailed information about the benefits of each data region (US and EU), including data residency and compliance.\n*   **Conditional Rendering:** Only displays the region selection component in cloud environments where a region is applicable.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/SupportModalButton.tsx",
        "summary": "This code defines a `SupportModalButton` component that renders a button to report an issue. The button is only displayed for cloud-hosted instances, determined by the `preflight?.cloud` check. When clicked, the button opens a support form pre-filled with the user's name and email (if provided), sets the issue type to \"bug\", and the target area to \"login\". The button uses the `supportLogic` to open the support form and the `preflightLogic` to determine if the instance is cloud-hosted.\n\n**Features:**\n\n*   **Conditional Rendering:** Only displays the support button for cloud-hosted instances.\n*   **Issue Reporting:** Allows users to report bugs or issues.\n*   **Pre-filled Form:** Pre-populates the support form with the user's name and email (if available).\n*   **Bug Report Type:** Sets the default issue type to \"bug\".\n*   **Login Target Area:** Sets the target area for the issue to \"login\".\n*   **Support Form Integration:** Integrates with a support form component (likely a modal).\n"
    },
    {
        "path": "frontend/src/scenes/authentication/TwoFactorSetupModal.tsx",
        "summary": "This code defines a modal component, `TwoFactorSetupModal`, that guides users through setting up two-factor authentication (2FA). The modal is controlled by the `twoFactorLogic` and can be opened either by user choice or forced open by the organization. When forced, a warning banner is displayed. The modal contains instructions for using an authenticator app and includes the `TwoFactorSetup` component, which handles the actual 2FA setup process. Upon successful setup, the modal closes, and user and member data are reloaded.\n\nHere's a list of high-level product features:\n\n*   **Two-Factor Authentication (2FA) Setup Modal:** A modal interface for guiding users through the 2FA setup process.\n*   **Forced 2FA Setup:** The ability for organizations to require users to set up 2FA.\n*   **Authenticator App Integration:** Instructions and integration with authenticator apps like Google Authenticator and 1Password.\n*   **Success Handling:** Reloading user and member data upon successful 2FA setup.\n*   **Warning Banner:** A warning banner displayed when 2FA setup is mandatory.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/login2FALogic.ts",
        "summary": "This code defines the logic for handling two-factor authentication (2FA) during the login process. It manages the state of the 2FA form, including input validation and submission. It interacts with the API to authenticate the token and handles errors. Upon successful authentication, it redirects the user and reloads the page.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Two-Factor Authentication (2FA):** Enables users to secure their accounts with a second layer of authentication using a token.\n*   **2FA Token Input:** Provides a form for users to enter their 2FA token.\n*   **2FA Token Validation:** Validates the entered token to ensure it's not empty.\n*   **API Authentication:** Sends the 2FA token to the backend API for verification.\n*   **Error Handling:** Displays general errors to the user if the 2FA token is invalid or if there are other issues during authentication.\n*   **Login Redirection:** Redirects the user to the appropriate page after successful 2FA authentication.\n*   **Page Reload:** Reloads the page after login to ensure the application context is set correctly.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/loginLogic.ts",
        "summary": "This code defines the logic for the login page in a PostHog application. It manages the login form, handles pre-login checks (like SSO enforcement), interacts with the backend API for authentication, and manages error states. It also handles redirects after successful login, including those specified in the URL. The logic uses kea for state management, forms, loaders, and routing.\n\nHere's a list of high-level product features:\n\n*   **User Login:** Allows users to log in with their email and password.\n*   **Pre-Login Checks:** Performs checks before login, such as SSO enforcement and SAML availability.\n*   **Error Handling:** Displays general error messages to the user, including specific messages for invalid credentials and two-factor authentication requirements.\n*   **Two-Factor Authentication (2FA) Support:** Redirects users to a 2FA page if required.\n*   **Login Redirection:** Redirects users to a specified URL after successful login.\n*   **URL-Based Login Parameters:** Handles login parameters passed through the URL, such as pre-filling the email field.\n*   **Data Region Selection Support:** Provides specific error messaging related to data region selection for cloud instances.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/redirectToLoggedInInstance.ts",
        "summary": "This code addresses the scenario where a user is logged into a PostHog instance on a different subdomain (e.g., EU vs. US) than the one they are currently trying to access. It reads a cookie (`ph_current_instance`) to determine the subdomain of the user's logged-in instance. If the current subdomain doesn't match the logged-in instance's subdomain, the code redirects the user to the correct subdomain. A toast notification informs the user about the redirection, providing a \"Cancel\" button to prevent the redirect. Error handling is included to prevent issues with the redirection logic from breaking the login page.\n\nHere's a list of high-level product features:\n\n*   **Cross-Subdomain Redirection:** Automatically redirects users to the correct PostHog instance subdomain (e.g., EU or US) based on their login status.\n*   **Cookie-Based Instance Detection:** Uses a cookie (`ph_current_instance`) to identify the user's logged-in instance.\n*   **User Notification:** Displays a toast notification informing the user about the redirection and the reason for it.\n*   **Redirection Cancellation:** Provides a \"Cancel\" button in the toast notification, allowing users to prevent the automatic redirection.\n*   **Error Handling:** Includes error handling to prevent redirection issues from disrupting the login process.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/inviteSignupLogic.ts",
        "summary": "This code defines the logic for handling user signup via invite links in a PostHog application. It manages the state and actions related to validating the invite, handling form input for new users, and submitting the signup form. It also handles potential errors during the signup process, such as invalid invites or recipient issues, and redirects the user upon successful signup.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Invite Link Validation:** Verifies the validity of an invite link, checking for issues like invalid invites or incorrect recipients.\n*   **User Signup Form:** Provides a form for new users to enter their first name, password, and role at the organization.\n*   **Password Strength Validation:** Validates the strength of the user's chosen password.\n*   **Error Handling:** Displays appropriate error messages to the user if the invite is invalid or if there are issues during signup.\n*   **Automatic First Name Prefill:** Prefills the first name field if the invite contains the user's first name.\n*   **Signup Submission:** Submits the signup form data to the backend to create a new user account.\n*   **Redirection on Success:** Redirects the user to a specified URL (either a provided redirect URL or the application's homepage) upon successful signup.\n"
    },
    {
        "path": "frontend/src/scenes/authentication/InviteSignup.tsx",
        "summary": "The `InviteSignup.tsx` component handles the user signup flow when a user is invited to join an organization on PostHog. It checks for invite validity, handles different error scenarios, and presents different UI elements based on whether the user is already authenticated. If the user is authenticated, they can accept the invite to join the organization. If not, they are presented with a signup form (or SSO options) to create an account and accept the invite. The component also integrates with preflight checks and login logic to determine if SSO is enforced and adjusts the signup form accordingly.\n\nHere's a list of high-level product features:\n\n*   **Invite Validation:** Verifies the validity and expiration of invite links.\n*   **Error Handling:** Displays informative error messages for invalid invites, recipient mismatches, and unknown errors.\n*   **Authenticated User Flow:** Allows existing users to accept invites to new organizations.\n*   **Unauthenticated User Flow:** Guides new users through the signup process with email, password, and name fields.\n*   **SSO Integration:** Supports Single Sign-On (SSO) for signup and login, including SAML.\n*   **Social Login:** Offers social login options for new users.\n*   **Role Selection:** Allows users to select their role during signup.\n*   **Password Strength Validation:** Provides feedback on password strength during signup.\n*   **Terms of Service and Privacy Policy Links:** Includes links to the Terms of Service and Privacy Policy during signup.\n*   **Preflight Checks:** Integrates with preflight checks to determine if SSO is enforced.\n*   **Support Modal:** Provides access to a support modal for assistance."
    },
    {
        "path": "frontend/src/scenes/authentication",
        "summary": "The provided code implements a comprehensive authentication system with features ranging from basic email/password login to advanced security measures like two-factor authentication and SSO. It includes user-friendly signup flows, password reset mechanisms, and region selection for cloud deployments. The system also prioritizes security with features like password strength validation, reset token validation, and rate limiting. Furthermore, it provides helpful user guidance through error messages, success notifications, and support modal integration, ensuring a smooth and secure user experience.\n\nHere's a list of high-level product features:\n\n*   Email/Password Login\n*   SSO Login (with SAML support)\n*   Social Login\n*   Two-Factor Authentication (2FA) - Enable, Disable, Setup, Validation, Backup Codes\n*   Password Reset - Request, Validation, Completion\n*   Signup Flow - Cloud/Self-Hosted Options, Region Selection, Social Login, Invite-Based Signup\n*   Region Selection (US/EU)\n*   Error Handling and User Notifications\n*   Pre-Login Checks (SSO Enforcement, SAML Availability)\n*   Support Modal Integration\n*   Password Strength Validation\n*   Invite Validation\n*   Cross-Subdomain Redirection\n*   Dynamic Logo Display\n*   Issue Reporting\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/AddToNotebook/DraggableToNotebook.tsx",
        "summary": "This code provides a React component, `DraggableToNotebook`, and a hook, `useNotebookDrag`, that enables elements to be dragged and dropped into a notebook interface. The component wraps around other elements, making them draggable. When dragged, the component can transfer a URL, a notebook node object, and/or a set of properties to the receiving notebook. The `useNotebookDrag` hook manages the drag state and sets the data to be transferred during the drag operation. The dragging can be configured to only activate when a modifier key (Alt) is held down.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Drag and Drop to Notebook:** Allows users to drag elements (e.g., links, nodes, properties) directly into a notebook interface.\n*   **URL Transfer on Drag:** Transfers a URL to the notebook when dragging a link.\n*   **Node Transfer on Drag:** Transfers a notebook node object to the notebook.\n*   **Properties Transfer on Drag:** Transfers a set of properties to the notebook.\n*   **Conditional Drag Activation:** Enables dragging only when a modifier key (e.g., Alt) is held down.\n*   **Visual Drag State:** Provides visual feedback (e.g., a CSS class) to indicate when an element is being dragged.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/AddToNotebook",
        "summary": "This code provides the functionality to drag and drop various elements into a notebook interface. The `DraggableToNotebook` component makes elements draggable, allowing users to transfer URLs, notebook node objects, and custom properties into a target notebook. The `useNotebookDrag` hook manages the drag state and data transfer, with the option to require a modifier key for drag activation and provide visual feedback during the drag operation.\n\nHere's a list of high-level product features:\n\n*   Drag and Drop to Notebook\n*   URL Transfer on Drag\n*   Node Transfer on Drag\n*   Properties Transfer on Drag\n*   Conditional Drag Activation (Modifier Key)\n*   Visual Drag State Feedback\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Marks/NotebookMarkComment.tsx",
        "summary": "This code defines a Tiptap mark called \"comment\" for use in a notebook editor. This mark allows users to highlight and annotate specific sections of text within the notebook. The mark is represented by a `<span>` element with a `data-id` attribute that stores a unique identifier for the comment. When the selection updates within the editor, the code checks if the \"comment\" mark is active and, if so, triggers an action to select the corresponding comment using the `notebookLogic`.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Text Highlighting:** Allows users to highlight specific sections of text within a notebook.\n*   **Comment Annotation:** Enables users to associate comments with highlighted text.\n*   **Comment Identification:** Provides a unique identifier for each comment, allowing for easy referencing and management.\n*   **Comment Selection:** Automatically selects the corresponding comment when the highlighted text is selected in the editor.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Marks/NotebookMarkLink.tsx",
        "summary": "This code defines a Tiptap mark extension called `NotebookMarkLink` that enhances text with hyperlink functionality within a notebook editor. It handles link creation, rendering, and interaction, including special handling for PostHog links (links within the same origin). The extension also provides paste rules for automatically converting pasted URLs into links and adds a ProseMirror plugin to manage link clicks, opening external links in new tabs when the meta key is pressed and selecting the link text otherwise.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Hyperlink Creation:** Allows users to create hyperlinks within the notebook editor.\n*   **Link Rendering:** Renders hyperlinks with appropriate HTML attributes, including `href` and `target`.\n*   **Automatic Link Conversion on Paste:** Automatically converts pasted URLs into clickable links.\n*   **Meta-Key Click Handling:** Opens external links in a new tab when clicked with the meta key (Cmd/Ctrl).\n*   **Link Text Selection on Click:** Selects the entire link text when clicked without the meta key.\n*   **Internal Link Handling:** Prevents external links from opening in a new tab if the link is internal to the application.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/NotebookCanvasScene.tsx",
        "summary": "The `NotebookCanvasScene.tsx` file defines a canvas-based notebook interface within a PostHog application. It provides a shareable, collaborative space where users can create and manipulate content, with changes persisted to the URL. The canvas supports exporting and importing content as JSON, clearing the canvas, and saving the canvas content as a standard notebook. The scene utilizes Lemon UI components for its interface, including buttons, menus, and banners, and leverages kea logic for state management.\n\nHere's a list of high-level product features:\n\n*   **Canvas-based Notebook Interface:** Provides a free-form canvas for creating and manipulating notebook content.\n*   **Real-time URL Persistence:** Saves canvas changes to the URL, enabling easy sharing and collaboration.\n*   **JSON Export/Import:** Allows users to export the canvas content as JSON for backup or sharing, and import JSON files to load content.\n*   **Clear Canvas:** Provides a function to quickly clear all content from the canvas.\n*   **Save as Notebook:** Enables users to save the current canvas content as a standard, named notebook within the application.\n*   **Shareable Canvas URL:** Generates a URL that can be shared with others to view and collaborate on the canvas.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Marks",
        "summary": "This code introduces two key features to a notebook editor: enhanced hyperlink functionality and comment annotation. The hyperlink functionality allows users to create, render, and interact with links, including automatic conversion of pasted URLs and special handling for internal links and meta-key clicks. The comment annotation feature enables users to highlight text and associate comments with it, providing a unique identifier for each comment and automatically selecting the corresponding comment when the highlighted text is selected.\n\nHere's a list of high-level product features:\n\n*   Hyperlink Creation\n*   Link Rendering\n*   Automatic Link Conversion on Paste\n*   Meta-Key Click Handling for Links\n*   Internal Link Handling\n*   Link Text Selection on Click\n*   Text Highlighting for Comments\n*   Comment Annotation\n*   Comment Identification\n*   Comment Selection\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/components/NotebookNodeEmptyState.tsx",
        "summary": "The `NotebookNodeEmptyState` component is a simple React component that displays a message within a container. It's used to indicate an empty state within a notebook node, providing a user-friendly message when there's no content to display. The component centers the provided message both horizontally and vertically within the container, using a secondary text color and some padding for visual appeal.\n\nHere's a list of high-level product features:\n\n*   **Empty State Display:** Shows a message when a notebook node is empty.\n*   **Customizable Message:** Allows passing a custom message to display in the empty state.\n*   **Centered Content:** Centers the message within the container for better presentation.\n*   **Themed Styling:** Uses a secondary text color and padding for visual consistency.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/notebookSceneLogic.ts",
        "summary": "This code defines the logic for the Notebook scene in the PostHog application. It manages the loading and display of a specific notebook, handles breadcrumbs for navigation, and provides context for the side panel, including activity scope and access control information. The logic connects to the `notebookLogic` and `notebooksModel` to fetch notebook data and manage the overall state of notebooks. It also handles the creation of new notebooks and loading existing ones based on the provided `shortId`.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Notebook Loading and Display:** Loads and displays a specific notebook based on its `shortId`.\n*   **Breadcrumb Navigation:** Provides breadcrumbs for easy navigation back to the notebooks list and within the notebook itself.\n*   **Side Panel Context:** Sets the context for the side panel, enabling activity tracking and access control for notebooks.\n*   **New Notebook Creation:** Supports the creation of new notebooks.\n*   **Loading State Management:** Manages and indicates the loading state of notebooks and the overall notebooks list.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodeContext.ts",
        "summary": "This code defines a React context, `NotebookNodeContext`, for sharing the logic associated with a notebook node throughout the component tree. It uses Kea for state management and logic definition. The `useNotebookNode` hook provides a way to access this logic within components, potentially returning `undefined` if the logic is not provided via the context provider. This allows components to interact with and modify the state of a specific notebook node.\n\n**Features:**\n\n*   **Context-based Logic Sharing:** Provides a mechanism to share the logic and state of a notebook node across multiple components.\n*   **Kea Integration:** Leverages Kea for state management and logic definition within the notebook node.\n*   **Optional Logic Access:** Allows components to optionally access the notebook node logic, handling cases where the logic might not be available.\n*   **Centralized State Management:** Enables centralized management of the notebook node's state, promoting consistency and maintainability.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodeEmbed.tsx",
        "summary": "This code defines a PostHog Notebook node for embedding content via iframes. It allows users to embed content from external URLs directly within their notebooks. The node provides a settings panel for configuring the iframe source, and it validates the URL before rendering the iframe. It also includes a loading spinner to indicate when the iframe content is loading. The node supports pasting iframe code directly, parsing the `src`, `width`, and `height` attributes.\n\nHere's a list of high-level product features:\n\n*   **Iframe Embedding:** Allows users to embed content from external URLs into PostHog notebooks.\n*   **URL Validation:** Validates the provided URL to ensure it's a valid and secure (HTTPS) source.\n*   **Iframe Code Parsing:** Parses iframe code pasted by the user to extract the `src` attribute.\n*   **Loading Indicator:** Displays a loading spinner while the iframe content is loading.\n*   **Configuration Panel:** Provides a settings panel for users to configure the iframe source URL.\n*   **Dynamic Title Placeholder:** Sets the title placeholder of the node to the hostname of the embedded URL.\n*   **Paste Support:** Supports pasting iframe code directly into the node.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodeReplayTimestamp.tsx",
        "summary": "This code defines a Tiptap node extension for a replay timestamp within a notebook. It allows users to embed a specific timestamp from a session recording directly into a notebook. When clicked, the timestamp can either navigate the user to the replay at that time or, if the recording is already present in the notebook, trigger playback at the specified time within the existing recording node. The component displays the timestamp in a formatted `HH:mm:ss` format and provides a button for interaction.\n\n**Features:**\n\n*   **Embeddable Replay Timestamps:** Allows users to insert specific timestamps from session recordings into notebook entries.\n*   **Direct Playback Integration:** When clicked, timestamps can trigger playback within an existing recording node in the notebook.\n*   **Navigation to Replay:** If the recording isn't already in the notebook, clicking the timestamp navigates the user to the replay at the specified time.\n*   **Formatted Timestamp Display:** Displays timestamps in a user-friendly `HH:mm:ss` format.\n*   **Session Recording Association:**  Links the timestamp to a specific session recording ID.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodeCohort.tsx",
        "summary": "This code defines a Notebook Node component in PostHog for displaying and interacting with Cohorts. It fetches cohort data based on an ID, displays the cohort's name, size, and type (static or dynamic). When expanded, it shows a query related to the cohort and provides actions to view the people in the cohort or create a cohort trends insight. The component integrates with the PostHog notebook feature, allowing users to embed and interact with cohort data directly within their notebooks.\n\nHere's a list of high-level product features:\n\n*   **Cohort Display:** Display cohort name, size, and type (static/dynamic) within a notebook.\n*   **Cohort Data Fetching:** Fetch cohort details based on ID for display.\n*   **Expandable View:** Show a query related to the cohort when the node is expanded.\n*   **\"People in Cohort\" Action:** Create a query to view the list of people belonging to the cohort.\n*   **\"Cohort Trends\" Action:** Create a trends insight based on the cohort.\n*   **Notebook Integration:** Seamlessly embed and interact with cohort data within PostHog notebooks.\n*   **Dynamic Title:** Display the cohort name in the node title.\n*   **Cohort Query Customization:** Customize the query displayed when the node is expanded (e.g., remove unnecessary controls).\n*   **URL Paste Support:** Automatically create a cohort node by pasting a cohort URL.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodeExperiment.tsx",
        "summary": "This code defines a Notebook Node component in PostHog for displaying and interacting with experiments. It fetches experiment data using the `experimentLogic`, displays experiment details like name, status, description, and results (if running). The component also provides actions to view the associated feature flag and insert it into the notebook. The node dynamically renders different information based on whether the node is expanded, the experiment's status, and the availability of experiment data.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Experiment Display:** Renders key experiment information within a notebook, including name, status, and description.\n*   **Experiment Status:** Shows the current status of the experiment (e.g., running, completed).\n*   **Experiment Results:** Displays experiment results in a table format, including trends and funnels queries.\n*   **Feature Flag Integration:** Provides a direct link to view the feature flag associated with the experiment and insert it into the notebook.\n*   **Dynamic Content Rendering:** Adapts the displayed information based on the experiment's state and the notebook node's expanded state.\n*   **Notebook Node Integration:** Implements a PostHog Notebook Node for experiments, allowing users to embed and interact with experiments directly within notebooks.\n*   **Experiment Linking:** Provides a link to the full experiment view.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodeSurvey.tsx",
        "summary": "This code defines a Notebook Node component for displaying and interacting with surveys within a PostHog notebook. It fetches survey data using the `surveyLogic`, displays survey details like name, description, and status, and provides options to view linked feature flags or survey results. When expanded, the node shows a summary of the survey, a preview of its appearance, or the survey results if the survey is running. The component also handles cases where the survey is missing and provides a \"Not Found\" message.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Survey Display:** Renders a survey within a PostHog notebook.\n*   **Survey Details:** Shows survey name, description, and status.\n*   **Linked Feature Flag Integration:** Provides a link to view the feature flag associated with the survey.\n*   **Survey Summary:** Displays a summary of the survey's targeting and appearance.\n*   **Survey Results:** Shows survey results when the survey is active.\n*   **\"Not Found\" Handling:** Displays a \"Not Found\" message if the survey doesn't exist.\n*   **Notebook Node Integration:** Implements the component as a node within the PostHog notebook system.\n*   **URL-based Survey Linking:** Allows pasting a survey URL to automatically create a survey node in the notebook.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodePlaylist.tsx",
        "summary": "This code defines a Notebook Node component for displaying a session recording playlist within a PostHog notebook. It allows users to filter recordings, pin specific recordings, and interact with the playlist directly from the notebook. The component integrates with the session recording player, enabling users to view replays and add comments at specific timestamps. It also provides settings to adjust the filters applied to the playlist.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Session Recording Playlist Integration:** Embed and display session recording playlists directly within PostHog notebooks.\n*   **Filtering:** Apply filters to the session recording playlist to narrow down the recordings displayed.\n*   **Pinning:** Pin specific recordings within the playlist for easy access and reference.\n*   **Replay Viewing:** Seamlessly view session replays from the playlist within the notebook.\n*   **Commenting:** Add comments to specific timestamps within a session replay directly from the playlist.\n*   **Navigation from Notebook:** Ability to navigate to a specific replay and time within the replay from outside the playlist (e.g. from another node in the notebook).\n*   **URL Paste Support:** Paste a URL from the replay page and automatically extract the filters to populate the playlist.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodeImage.tsx",
        "summary": "This code defines a React component, `NotebookNodeImage`, designed for embedding images within a notebook interface. It handles image uploads, displays images from either a file or a URL, and manages potential errors during the upload process. The component also dynamically adjusts the image height to fit within a maximum default height and provides a loading spinner during uploads. It leverages PostHog widget node functionality to integrate seamlessly into the notebook environment.\n\nHere's a list of high-level product features:\n\n*   **Image Upload:** Allows users to upload image files directly into the notebook.\n*   **Image Display (File or URL):** Supports displaying images from either uploaded files or provided URLs.\n*   **Dynamic Height Adjustment:** Automatically adjusts the image height to fit within a defined maximum height.\n*   **Error Handling:** Displays error messages for failed image uploads or missing image sources.\n*   **Loading Indicator:** Provides a visual loading spinner during the image upload process.\n*   **PostHog Integration:** Integrates with PostHog for widget node functionality within the notebook environment.\n*   **Image Resizing:** Allows users to resize the image within the notebook.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodeFlagCodeExample.tsx",
        "summary": "This code defines a PostHog Notebook Node that displays a code example for a given feature flag. It fetches the feature flag data based on an ID passed as an attribute and renders the `FeatureFlagCodeExample` component, which shows the code snippet. The node is configured to be initially expanded and not resizable, and it links to the feature flag's settings page. If the feature flag is missing, a \"Not Found\" component is displayed.\n\nHere's a list of high-level product features:\n\n*   **Display Feature Flag Code Example:** Renders a code snippet demonstrating how to use a specific feature flag in code.\n*   **Feature Flag Integration:** Fetches feature flag data from the PostHog backend.\n*   **Notebook Node:** Integrates with the PostHog Notebooks feature, allowing users to embed feature flag code examples within their notebooks.\n*   **Dynamic Title:** Sets the title of the node based on the feature flag's key.\n*   **Error Handling:** Displays a \"Not Found\" message if the specified feature flag does not exist.\n*   **Link to Feature Flag Settings:** Provides a link to the feature flag's settings page.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodeEarlyAccessFeature.tsx",
        "summary": "This code defines a React component, `NotebookNodeEarlyAccessFeature`, designed to display information about an early access feature within a PostHog notebook. It fetches and presents details such as the feature's name, stage (e.g., Beta, General Availability), description, documentation URL, and associated users (for Beta features). The component integrates with PostHog's early access feature management system and allows users to view the corresponding feature flag. It also handles cases where the early access feature is missing.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Display Early Access Feature Details:** Shows the name, stage (Beta, GA, etc.), description, and documentation URL of an early access feature.\n*   **Show Beta User List:** For Beta features, displays a list of users who have access.\n*   **Link to Feature Flag:** Provides a button to navigate to the associated feature flag.\n*   **Handle Missing Features:** Gracefully handles cases where the specified early access feature doesn't exist.\n*   **Integration with Notebooks:** Allows embedding early access feature information directly within PostHog notebooks.\n*   **Dynamic Title Placeholder:** Sets the title placeholder based on the early access feature name.\n*   **Paste Support:** Allows pasting a URL to an early access feature to create a node."
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodeQuery.tsx",
        "summary": "This code defines a React component, `NotebookNodeQuery`, designed for embedding and configuring queries within a PostHog notebook environment. It leverages PostHog's query engine to display data tables, visualizations, and saved insights. The component allows users to view and interact with query results, and provides settings to modify the query, including detaching from saved insights to enable independent editing. The component dynamically adjusts its display and functionality based on the type of query being rendered, offering a tailored experience for data exploration and insight analysis within the notebook.\n\nHere's a list of high-level product features:\n\n*   **Query Embedding:** Allows embedding different types of PostHog queries (data tables, visualizations, saved insights) within a notebook.\n*   **Query Configuration:** Provides settings to modify embedded queries, including filters, date ranges, and column configurations.\n*   **Insight Detachment:** Enables detaching a saved insight from its original source, allowing independent modifications within the notebook.\n*   **Dynamic Display:** Adapts the display and functionality based on the query type, optimizing the user experience for different data exploration scenarios.\n*   **Read-Only Mode:** Renders queries in a read-only mode for viewing results.\n*   **HogQL Editor Integration:** Provides an editor for HogQL queries within the notebook.\n*   **Insight Summarization:** Automatically generates a title for insight visualizations.\n*   **Serialization:** Extracts HogQL queries for serialization and text representation."
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodeFlag.tsx",
        "summary": "This code defines a React component, `NotebookNodeFlag`, designed to be integrated into a PostHog notebook environment. It allows users to view and interact with feature flags directly within the notebook. The component fetches feature flag details, displays its key and status (enabled/disabled), and provides actions to navigate to related resources like surveys, code examples, and recording playlists. It also supports the creation and viewing of early access features associated with the flag. The component leverages PostHog's feature flag logic and integrates with the notebook's node structure, enabling seamless insertion of related content.\n\nHere's a list of high-level product features:\n\n*   **Feature Flag Display:** Renders a feature flag's key and status (enabled/disabled) within a notebook node.\n*   **Navigation Actions:** Provides quick actions to navigate to related surveys, code examples, and recording playlists associated with the feature flag.\n*   **Early Access Feature Integration:** Supports the creation and viewing of early access features linked to the feature flag.\n*   **Dynamic Content Insertion:** Allows inserting related content (code examples, playlists, surveys, early access features) after the current node in the notebook.\n*   **Feature Flag Details:** Displays feature flag release conditions when the node is expanded.\n*   **Paste Support:** Allows pasting a feature flag URL into the notebook to create a feature flag node.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/notebookNodeLogic.ts",
        "summary": "This code defines the `notebookNodeLogic` using Kea, a state management library. It manages the state and behavior of individual nodes within a notebook editor. Each node has properties like its type, attributes, expansion state, and associated actions. The logic handles actions such as inserting, deleting, selecting, and updating nodes, as well as managing the node's editing state and communication with the parent notebook. It also provides functionality for copying node configurations to the clipboard and converting nodes to backlinks.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Node Management:** Create, delete, update, and reorder nodes within a notebook.\n*   **Node Expansion/Collapse:** Expand and collapse nodes to show/hide their content.\n*   **Node Resizing:** Dynamically resize nodes based on their content or user preferences.\n*   **Node Editing:** Toggle editing mode for individual nodes.\n*   **Inter-Node Communication:** Send messages between nodes.\n*   **Contextual Actions:** Display a list of available actions for each node.\n*   **Clipboard Integration:** Copy node configurations to the clipboard for easy duplication or sharing.\n*   **Backlink Conversion:** Convert nodes into backlinks to other resources.\n*   **Comment Integration:** Display comments associated with specific nodes.\n*   **Dynamic Node Attributes:** Support for custom attributes on each node type.\n*   **Session Recording Integration:** Insert comments linked to specific timestamps in session recordings.\n*   **Node Selection and Navigation:** Select nodes and navigate between adjacent nodes.\n*   **Placeholder Titles:** Display placeholder titles for nodes.\n*   **Scroll to Node:** Scroll the editor to bring a specific node into view."
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodePerson.tsx",
        "summary": "This code defines a React component, `NotebookNodePerson`, designed to display information about a specific person within a PostHog notebook. It fetches person data based on an ID passed as an attribute, and renders a summary of the person, including their name, key properties (like country, browser, device), and first seen timestamp. When expanded, the component shows a table of all the person's properties. It also provides an action to quickly create a new query node to display the person's events.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Person Data Display:** Shows key information about a person, including name, properties, and first seen time.\n*   **Property Table:** Displays a table of all properties associated with a person.\n*   **Quick Event Query:** Allows users to quickly create a query node to view events associated with the person.\n*   **Notebook Integration:** Integrates person data into the PostHog notebook interface.\n*   **Dynamic Title:** Sets the title of the node to the person's name.\n*   **Loading State:** Displays a loading state while person data is being fetched.\n*   **Not Found Handling:** Displays a \"Not Found\" message if the person is not found.\n*   **Copy/Paste Support:** Allows pasting a person URL to create a node.\n*   **Expandable View:** Provides an expandable view to show more details (properties table).\n*   **Icon Display:** Displays icons for key properties like country, browser, and device."
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/components/NotebookNodeTitle.tsx",
        "summary": "This component, `NotebookNodeTitle`, renders the title of a notebook node within a larger notebook interface. It allows users to view and edit the title of a node, with editability controlled by the `notebookLogic` and editing state managed within `notebookNodeLogic`. When not in edit mode, the title is displayed as a simple span, optionally with a tooltip. When in edit mode, a LemonInput field is rendered, allowing the user to modify the title, commit changes with Enter, or cancel with Escape. Updates to the title trigger a PostHog event.\n\nHere's a list of high-level features:\n\n*   **Title Display:** Displays the title of a notebook node.\n*   **Editable Title:** Allows users to edit the title of a notebook node when the notebook is in editable mode.\n*   **Double-Click Editing:** Enables editing the title by double-clicking on it.\n*   **In-Place Editing:** Provides an in-place editing experience using a LemonInput component.\n*   **Keyboard Shortcuts:** Supports keyboard shortcuts (Enter to commit, Escape to cancel) during title editing.\n*   **Title Placeholder:** Shows a placeholder text in the input field when the title is empty.\n*   **Tooltip on Hover:** Displays a tooltip indicating that the title is editable.\n*   **Analytics Tracking:** Tracks title updates using PostHog.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/components",
        "summary": "The code snippets describe two React components related to displaying and editing content within a notebook interface. `NotebookNodeEmptyState` provides a user-friendly message when a notebook node is empty, centering the message with themed styling. `NotebookNodeTitle` displays the title of a notebook node and allows users to edit it in-place with keyboard shortcuts, analytics tracking, and a tooltip for discoverability.\n\nHere's a list of high-level product features:\n\n*   **Empty State Display:** Show a message when a notebook node is empty.\n*   **Title Display:** Display the title of a notebook node.\n*   **Editable Title:** Allow users to edit the title of a notebook node.\n*   **In-Place Editing:** Provide an in-place editing experience for the title.\n*   **Keyboard Shortcuts:** Support keyboard shortcuts during title editing (Enter to commit, Escape to cancel).\n*   **Analytics Tracking:** Track title updates.\n*   **Tooltip on Hover:** Display a tooltip indicating that the title is editable.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodePersonFeed/EventIcon.tsx",
        "summary": "This code defines a React component called `EventIcon` that displays an icon representing a specific event type. The component takes an `event` object as a prop, determines the appropriate icon based on the event's name (e.g., pageview, pageleave, autocapture, rageclick), and renders the icon within a tooltip that displays the event's label. If the event is not a standard event, it defaults to a code icon and labels the event as \"Custom\".\n\n**Features:**\n\n*   **Event Type Iconography:** Displays different icons based on the event type (pageview, pageleave, autocapture, rageclick, custom).\n*   **Tooltip Labels:** Provides a tooltip on hover that displays the label of the event.\n*   **Custom Event Handling:** Defaults to a code icon and \"Custom\" label for unrecognized event types.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodePersonFeed/notebookNodePersonFeedLogic.ts",
        "summary": "This code defines a Kea logic hook called `notebookNodePersonFeedLogic` that fetches and stores session data for a specific person. It uses `kea-loaders` to manage the loading state and data fetching. The logic is keyed by the `personId` prop, ensuring that each person has their own instance of the logic. Upon mounting, the logic triggers the `loadSessionsTimeline` action, which performs a query to retrieve the person's session timeline data and stores it in the `sessions` state.\n\n**Features:**\n\n*   **Data Fetching:** Fetches session timeline data for a specific person.\n*   **State Management:** Manages the loading state and stores the fetched session data.\n*   **Person-Specific Instances:** Creates a separate instance of the logic for each person based on their `personId`.\n*   **Automatic Data Loading:** Automatically loads session data when the logic is mounted.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodePersonFeed/SessionEvent.tsx",
        "summary": "This React component, `SessionEvent`, is designed to display a single event within a session feed, likely in a notebook or similar interface. It takes an event object as a prop and renders a visually appealing representation of the event, including an icon, a description generated from the event data, and the event's timestamp formatted for easy readability. The component uses styling to ensure a consistent and informative display of each event.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Event Visualization:** Displays events with an associated icon for quick identification.\n*   **Event Description:** Generates a human-readable description of the event based on its data.\n*   **Timestamp Display:** Shows the event's timestamp in a user-friendly format (h:mm:ss A).\n*   **Styled Presentation:** Presents the event information within a styled container for visual consistency.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodePersonFeed/Session.tsx",
        "summary": "This code defines a `Session` component in a React application, likely part of a larger notebook or timeline feature. The component displays information about a user session, including its start time, duration, and the number of events within it. It allows users to expand or collapse the session details to view individual events and provides a button to open a replay of the session if a recording is available. The component utilizes PostHog's Lemon UI library for styling and icons, and Kea for state management.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Session Summarization:** Displays key information about a user session (start time, duration, event count).\n*   **Session Expansion/Collapse:** Allows users to toggle the visibility of individual events within a session.\n*   **Event Listing:** Shows a list of events that occurred during the session.\n*   **Session Replay Integration:** Provides a button to open a replay of the session if a recording exists.\n*   **Timeline Visualization:** Integrates with a timeline or notebook interface to display sessions in chronological order.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodeMap.tsx",
        "summary": "This code defines a PostHog Notebook Node that displays a map with a marker indicating the location of a person, based on their `$geoip_longitude` and `$geoip_latitude` properties. It fetches person data using `personLogic` and displays a loading state, a \"person not found\" message, or a \"no map available\" message if data is missing. The map is only rendered when the node is expanded.\n\nHere's a list of high-level product features:\n\n*   **Map Visualization:** Displays a map based on geographic coordinates.\n*   **Person Location Marker:**  Places a marker on the map to indicate a person's location.\n*   **Data Fetching:** Fetches person data, including geographic coordinates.\n*   **Loading State:** Shows a loading indicator while fetching data.\n*   **Error Handling:** Displays appropriate messages when person data is not found or geographic coordinates are missing.\n*   **Expandable Node:** The map is only displayed when the notebook node is expanded.\n*   **Notebook Node Integration:** Integrates as a node within the PostHog Notebook feature.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodeFlagLogic.tsx",
        "summary": "This code defines a Kea logic module `notebookNodeFlagLogic` that manages the insertion of Early Access Feature and Survey nodes into a notebook based on feature flag status. It connects to the `featureFlagLogic` to track the state of a specific feature flag and provides selectors to determine whether inserting an Early Access Feature or Survey node should be disabled based on existing nodes and feature flag configuration. The logic also listens for successful creation of Early Access Features and Surveys, inserting corresponding nodes into the notebook after the current node.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Conditional Notebook Node Insertion:** Allows inserting Early Access Feature and Survey nodes into a notebook based on the status of a feature flag.\n*   **Early Access Feature Integration:** Enables the insertion of Early Access Feature nodes into the notebook, linking them to specific feature flags.\n*   **Survey Integration:** Enables the insertion of Survey nodes into the notebook, linking them to specific feature flags.\n*   **Node Insertion Management:** Provides logic to prevent duplicate Early Access Feature or Survey nodes from being inserted based on feature flag configuration and existing nodes.\n*   **Dynamic Notebook Content:** Allows the notebook content to be dynamically updated based on the creation of new Early Access Features and Surveys.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodePersonFeed/NotebookNodePersonFeed.tsx",
        "summary": "This code defines a React component, `NotebookNodePersonFeed`, which is a PostHog widget node designed to display a feed of sessions for a specific person within a notebook. It fetches person data and their associated sessions, displaying a loading skeleton while data is being retrieved, a \"not found\" message if the person doesn't exist, and the session feed using the `Session` component once the data is available. The component utilizes Kea logic for state management and data fetching.\n\nHere's a list of high-level product features:\n\n*   **Person Session Feed Display:** Shows a chronological feed of user sessions within a PostHog notebook.\n*   **Data Loading State:** Displays a skeleton UI while person data and sessions are being fetched.\n*   **\"Person Not Found\" Handling:** Shows a \"not found\" message if the specified person doesn't exist.\n*   **Integration with Notebooks:** Functions as a node within the PostHog notebook system.\n*   **Person ID Configuration:** Allows specifying a person ID to display the feed for that specific user.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodeGroup.tsx",
        "summary": "This code defines a PostHog Notebook Node component for displaying and interacting with Group data. It fetches group information based on `id` and `groupTypeIndex`, displays the group's key and properties, and provides an action to insert a query node to view events associated with the group. The component handles loading states and displays a \"Not Found\" message if the group data cannot be retrieved. It also integrates with the notebook node logic to manage the node's title and available actions.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Group Data Display:** Fetches and displays key information about a specific group, including its key and properties.\n*   **Loading State Handling:** Shows a skeleton UI while group data is being fetched.\n*   **\"Not Found\" Handling:** Displays a user-friendly message when the specified group cannot be found.\n*   **Event Query Insertion:** Provides an action to quickly create a query node that filters events specifically for the displayed group.\n*   **Dynamic Title Placeholder:** Sets the title placeholder of the notebook node based on the group's information.\n*   **URL-based Group Linking:** Allows pasting a group URL to automatically populate the node with the corresponding group data.\n*   **Serialized Text Representation:** Provides a text representation of the node's data for search and other purposes."
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NodeWrapper.tsx",
        "summary": "The `NodeWrapper.tsx` file provides a wrapper component for nodes within a notebook editor. It handles node selection, editing, resizing, expansion/collapse, and deletion. It also manages the display of node-specific settings and metadata, including a title, drag handle, and action buttons. The component uses various hooks and logic to manage node state, including whether it's selected, expanded, or being edited. It also handles lazy loading of node content using `react-intersection-observer` to improve performance. The component renders a skeleton loader while the node is out of view.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Node Editing:** Enables editing of individual nodes within the notebook.\n*   **Node Resizing:** Allows users to dynamically adjust the height of resizable nodes.\n*   **Node Expansion/Collapse:** Provides the ability to expand or collapse nodes to show or hide content.\n*   **Node Deletion:** Enables the removal of nodes from the notebook.\n*   **Node Drag and Drop:** Supports dragging and dropping nodes to reorder them within the notebook.\n*   **Node Settings:** Displays node-specific settings for customization.\n*   **Node Title Editing:** Allows users to edit the title of a node.\n*   **Lazy Loading:** Improves performance by only rendering nodes when they are in view.\n*   **Context Menu:** Provides a context menu with actions like copy, reset height, convert to link, comment, and remove.\n*   **Slash Commands:** Integrates with a slash command interface for adding new content below the node.\n*   **Commenting:** Supports adding and viewing comments on nodes.\n*   **Copy to Clipboard:** Allows copying the node content to the clipboard.\n*   **Convert to Backlink:** Converts a node to an inline link."
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodePersonFeed",
        "summary": "The code collectively implements a person session feed within a PostHog notebook, providing a detailed view of user activity. It fetches and displays a chronological list of user sessions, summarizing each session with key information like start time, duration, and event count. Users can expand sessions to view individual events, each represented with an icon, description, and timestamp. The feed also integrates with session replays, allowing users to quickly access recordings when available. The system handles loading states and \"person not found\" scenarios gracefully, ensuring a smooth user experience.\n\n**Features:**\n\n*   Person Session Feed Display: Shows a chronological feed of user sessions within a PostHog notebook.\n*   Session Summarization: Displays key information about a user session (start time, duration, event count).\n*   Session Expansion/Collapse: Allows users to toggle the visibility of individual events within a session.\n*   Event Listing: Shows a list of events that occurred during the session, including an icon, description, and timestamp.\n*   Session Replay Integration: Provides a button to open a replay of the session if a recording exists.\n*   Data Loading State: Displays a skeleton UI while person data and sessions are being fetched.\n*   \"Person Not Found\" Handling: Shows a \"not found\" message if the specified person doesn't exist.\n*   Event Type Iconography: Displays different icons based on the event type.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/messaging/notebook-node-messages.ts",
        "summary": "This code defines a messaging system for nodes within a notebook application. It establishes a type-safe structure for sending and receiving messages between nodes, allowing for communication and interaction. The system defines the possible message types (`NotebookNodeMessages`), their associated data structures, and the listener functions that can be registered to handle specific message types. This enables features like replaying session recordings at a specific time and potentially highlighting or interacting with specific nodes based on messages.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Session Recording Replay:** Allows a node to trigger the replay of a session recording, starting at a specific timestamp.\n*   **Node Highlighting/Interaction (Future):** Provides a mechanism for one node to \"ping\" another, potentially triggering a visual highlight or other interactive behavior.\n*   **Inter-Node Communication:** Enables different nodes within the notebook to communicate and coordinate actions.\n*   **Extensible Messaging System:** Provides a foundation for adding new message types and functionalities in the future.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodeProperties.tsx",
        "summary": "This code defines a React component, `NotebookNodeProperties`, designed to display the properties of a person within a PostHog notebook. It fetches person data based on an ID passed as an attribute, handles loading and not-found states, and renders the person's properties in a structured format using `LemonLabel` and `PropertiesTable` components. The component is wrapped with `createPostHogWidgetNode` to integrate it as a node within the PostHog notebook system, making it resizable, expandable, and configurable with an ID attribute.\n\nHere's a list of high-level product features:\n\n*   **Person Property Display:** Renders a list of properties associated with a specific person.\n*   **Data Loading State:** Displays a loading indicator while fetching person data.\n*   **\"Not Found\" Handling:** Shows a \"Not Found\" message if the person data cannot be retrieved.\n*   **Expandable Node:** Allows users to expand or collapse the node to show or hide the properties.\n*   **Property Key Information:** Displays information about each property key.\n*   **Integration with Notebook System:** Integrates as a node within the PostHog notebook system.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodeRecording.tsx",
        "summary": "This code defines a React component, `NotebookNodeRecording`, which is a PostHog widget node designed to embed and display session recordings within a notebook interface. It leverages the `SessionRecordingPlayer` component from the session recordings feature and provides controls for interacting with the recording, such as playing, seeking, and adding comments. The component also supports toggling the visibility of the session recording inspector panel. The node can be collapsed to show a preview of the recording, and expanded to show the full player.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Session Recording Embedding:** Allows users to embed session recordings directly into notebooks.\n*   **Session Recording Playback:** Provides controls for playing, pausing, and seeking within the embedded session recording.\n*   **Commenting on Recordings:** Enables users to add comments at specific timestamps within the recording.\n*   **Person Identification:** Displays information about the person associated with the recording and allows navigation to their profile.\n*   **Inspector Panel Toggle:** Allows users to hide or show the session recording inspector panel.\n*   **Session Recording Preview:** Displays a preview of the session recording when the node is collapsed.\n*   **Notebook Integration:** Seamlessly integrates with the notebook interface, including actions, expansion/collapse functionality, and scrolling.\n*   **URL Pasting:** Allows users to paste a session recording URL into the notebook, which will automatically create a recording node.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/messaging",
        "summary": "The code establishes a robust and type-safe messaging system for nodes within a notebook application, enabling seamless communication and interaction between different nodes. This system defines message types, data structures, and listener functions, facilitating features such as replaying session recordings at specific timestamps and laying the groundwork for future functionalities like node highlighting and interactive behaviors. The extensible design allows for the addition of new message types and functionalities, ensuring the system can adapt to evolving needs.\n\nHere's a list of high-level product features enabled by this code:\n\n*   Session Recording Replay: Allows a node to trigger the replay of a session recording, starting at a specific timestamp.\n*   Node Highlighting/Interaction (Future): Provides a mechanism for one node to \"ping\" another, potentially triggering a visual highlight or other interactive behavior.\n*   Inter-Node Communication: Enables different nodes within the notebook to communicate and coordinate actions.\n*   Extensible Messaging System: Provides a foundation for adding new message types and functionalities in the future.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodeMention.tsx",
        "summary": "This code defines a Tiptap node extension called `NotebookNodeMention` for rendering user mentions within a notebook editor. It allows users to tag other members of their organization within the notebook. The mention is displayed as a button with the member's name, and hovering over it reveals a tooltip containing the member's profile picture, full name, and email address. The node stores the mentioned user's ID as an attribute.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **User Mentioning:** Allows users to tag other members within a notebook.\n*   **Rich Display of Mentions:** Displays mentions as buttons with the member's name.\n*   **User Information on Hover:** Shows a tooltip with the member's profile picture, full name, and email address when hovering over a mention.\n*   **Serialization and Deserialization:** Stores and retrieves mention data (user ID) when saving and loading the notebook content.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/NotebookNodeBacklink.tsx",
        "summary": "This code defines a Tiptap node extension called `NotebookNodeBacklink` that allows embedding links to various PostHog resources (dashboards, insights, feature flags, etc.) within a notebook. It fetches the title of the linked resource and displays it along with an icon. The component handles displaying the link, fetching the title, and styling the link based on whether it's the currently viewed page. It also handles pasting URLs to automatically create backlinks.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Backlink Embedding:** Allows users to embed links to other PostHog resources within a notebook.\n*   **Automatic Title Fetching:** Automatically fetches the title of the linked resource and displays it.\n*   **Icon Display:** Displays an icon associated with the type of resource being linked.\n*   **Link Styling:** Styles the link to indicate whether it's the currently viewed page.\n*   **Paste to Backlink Conversion:** Automatically converts pasted URLs into backlinks.\n*   **Support for Various Resource Types:** Supports linking to dashboards, insights, feature flags, experiments, surveys, events, persons, cohorts, playlists, replays, and other notebooks.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes/utils.tsx",
        "summary": "This code provides utility functions and React hooks for managing nodes within a Tiptap-based notebook editor. It includes functions for creating regular expressions for URL matching, reporting node creation events to PostHog, defining paste rules for inserting content based on pasted URLs, and a hook for synchronizing and parsing node attributes, ensuring efficient updates and data consistency. The `useSyncedAttributes` hook handles JSON parsing of attributes and optimizes updates to prevent unnecessary re-renders.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **URL Handling:** Automatically convert pasted URLs into links within the notebook.\n*   **Customizable Paste Rules:** Define rules for handling pasted content, allowing for the insertion of specific node types with attributes derived from the pasted text.\n*   **Node Creation Tracking:** Track the creation of different node types within the notebook using PostHog analytics.\n*   **Attribute Synchronization:** Synchronize and efficiently update node attributes, including parsing JSON data, to maintain data consistency and optimize performance.\n*   **Unique Node Identifiers:** Automatically generate and manage unique IDs for notebook nodes.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Nodes",
        "summary": "The provided code implements a comprehensive set of features for PostHog Notebooks, enabling users to create dynamic and interactive documents that integrate directly with PostHog's analytics platform. These features range from embedding various data visualizations and insights to linking to specific resources like feature flags, experiments, and session recordings, fostering a collaborative environment for data exploration and analysis. The notebook nodes are designed to be modular and extensible, allowing for the addition of new content types and functionalities in the future.\n\nHere's a list of high-level product features:\n\n*   **Data Visualization Embedding:** Embed various PostHog data visualizations, including charts, tables, and maps, directly within notebooks.\n*   **Resource Linking:** Create links to other PostHog resources, such as feature flags, experiments, surveys, cohorts, persons, groups, and session recordings.\n*   **Session Recording Integration:** Embed and interact with session recordings, including playback, commenting, and timestamp linking.\n*   **User Mentioning:** Tag other team members within notebooks for collaboration.\n*   **Code Example Display:** Display code examples for feature flags and other resources.\n*   **Early Access Feature Management:** Display and manage early access features within notebooks.\n*   **Survey Integration:** Embed and interact with surveys, including displaying results.\n*   **Iframe Embedding:** Embed content from external URLs using iframes.\n*   **Image Embedding:** Upload and display images within notebooks.\n*   **Node Management:** Create, delete, update, reorder, expand/collapse, and resize nodes within a notebook.\n*   **Inter-Node Communication:** Enable communication and interaction between different nodes within a notebook.\n*   **Dynamic Content Insertion:** Conditionally insert nodes based on feature flag status or other criteria.\n*   **URL Handling:** Automatically convert pasted URLs into links or specific node types.\n*   **Contextual Actions:** Provide a list of available actions for each node.\n*   **Clipboard Integration:** Copy node configurations to the clipboard.\n*   **Backlink Conversion:** Convert nodes into backlinks to other resources.\n*   **Commenting:** Add and view comments on nodes.\n*   **Empty State Handling:** Display a user-friendly message when a node is empty.\n*   **Title Editing:** Allow users to edit the title of a node.\n*   **Loading State Handling:** Display loading indicators while fetching data.\n*   **\"Not Found\" Handling:** Display appropriate messages when data is not found.\n*   **Session Recording Playlist Integration:** Embed and display session recording playlists directly within PostHog notebooks.\n*   **Group Data Display:** Display key information about a specific group, including its key and properties.\n*   **Person Session Feed Display:** Shows a chronological feed of user sessions within a PostHog notebook.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/NotebookPanel/NotebookPanel.tsx",
        "summary": "The `NotebookPanel` component provides a user interface for interacting with notebooks within a side panel. It displays a mini notebook list for navigation, sync information, a menu for notebook actions, and the selected notebook itself. The panel also includes a dropzone for handling dropped resources and an option to open the notebook in the main view. The component adapts to different screen sizes, offering an expand button on medium-sized screens.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Notebook Navigation:** Allows users to switch between notebooks using a mini notebook list.\n*   **Notebook Display:** Renders the content of the selected notebook within the panel.\n*   **Notebook Editing:** Enables editing of non-template notebooks.\n*   **Notebook Synchronization Information:** Displays sync status and related information for the current notebook.\n*   **Notebook Actions:** Provides a menu for performing actions on the notebook (e.g., rename, delete).\n*   **External View:** Opens the notebook in a dedicated full-screen view.\n*   **Drag and Drop Support:** Accepts dropped resources via a dropzone.\n*   **Responsive Layout:** Adapts to different screen sizes.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/NotebookPanel/notebookPanelLogic.ts",
        "summary": "This code defines the logic for the Notebook Panel in the PostHog application. It manages the panel's visibility, selected notebook, drag-and-drop functionality for resources, and interaction with the side panel. The logic uses Kea for state management, connecting to the side panel and feature flag logic. It handles actions like selecting a notebook, toggling visibility, and managing drag-and-drop operations, updating the state accordingly. The logic also includes selectors to determine the panel's visibility and properties related to drag-and-drop.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Notebook Selection:** Allows users to select a specific notebook to view and edit.\n*   **Panel Visibility Control:** Enables users to toggle the visibility of the notebook panel.\n*   **Drag-and-Drop Support:** Facilitates dragging and dropping resources (like charts or dashboards) into the notebook panel.\n*   **Side Panel Integration:** Integrates with the side panel to display the notebook panel when selected.\n*   **Automatic Panel Opening During Drag:** Automatically opens the notebook panel when a user drags a resource towards it.\n*   **Persistence of Selected Notebook:** Remembers the last selected notebook for the user.\n*   **Initial Focus Control:** Allows specifying where the editor should focus when a notebook is selected.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/NotebookPanel/NotebookPanelDropzone.tsx",
        "summary": "The `NotebookPanelDropzone` component provides a drag-and-drop target within the PostHog application, specifically designed for notebooks. It allows users to drag resources (either text or structured node data) from other parts of the application and drop them into a designated area. Upon dropping, the component displays a UI that prompts the user to select a notebook to which the dropped resource should be added. The component manages drag state (active or inactive) and displays different messages based on whether a resource has been dropped or not. It leverages kea-logic for state management and actions to handle the dropped resource and update the UI accordingly.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Drag-and-Drop Support:** Enables users to drag text or structured data (nodes) into the panel.\n*   **Drop Target Indication:** Visually indicates when the panel is an active drop target.\n*   **Notebook Selection:** Presents a list of available notebooks for the user to choose from after a resource is dropped.\n*   **Resource Insertion:** Allows the dropped resource to be inserted into the selected notebook.\n*   **Cancellation:** Provides a \"Cancel\" button to clear the dropped resource and return to the initial state.\n*   **Dynamic Message Display:** Shows different messages based on the drag state and whether a resource has been dropped.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/NotebookPanel",
        "summary": "The Notebook Panel provides a dedicated space within the PostHog application for users to interact with and manage their notebooks. It offers features for notebook navigation, display, and editing, along with drag-and-drop functionality for seamlessly integrating resources from other parts of the application. The panel integrates with the side panel, adapts to different screen sizes, and provides visual cues and prompts to guide users through the process of adding resources to their notebooks.\n\nHere's a list of high-level product features:\n\n*   Notebook Selection and Navigation\n*   Notebook Display and Editing\n*   Drag-and-Drop Support for Resources\n*   Side Panel Integration and Visibility Control\n*   Notebook Synchronization Information\n*   Notebook Actions (e.g., rename, delete)\n*   External View (Open in Full Screen)\n*   Responsive Layout\n*   Drop Target Indication\n*   Resource Insertion into Notebooks\n*   Dynamic Message Display\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/NotebooksScene.tsx",
        "summary": "The `NotebooksScene` component renders a page for managing notebooks. It includes a page header with buttons for creating a new notebook, creating a new canvas (a shareable exploration space), and loading a notebook from a JSON file. The scene also includes a table (`NotebooksTable`) for displaying and managing existing notebooks. The JSON loading feature allows users to import notebook data from a JSON file, validating its structure before navigating the user to a new canvas with the loaded data.\n\nHere's a list of high-level product features:\n\n*   **Create New Notebook:** Allows users to create a new, standard notebook.\n*   **Create New Canvas:** Allows users to create a new canvas, a shareable exploration space where all exploration is persisted to the URL.\n*   **Import Notebook from JSON:** Allows users to load notebook data from a JSON file.\n*   **Notebook Listing and Management:** Displays a table of existing notebooks, presumably with actions to manage them (handled by the `NotebooksTable` component).\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/NotebookSelectButton/notebookSelectButtonLogic.ts",
        "summary": "This code defines a Kea logic module named `notebookSelectButtonLogic` that manages the state and behavior of a notebook selection button component. It handles searching for notebooks, loading all notebooks, and loading notebooks that contain a specific resource. The logic also manages the visibility of a popover associated with the button and filters notebooks to distinguish between those containing a specified resource and those that do not.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Notebook Search:** Allows users to search for notebooks by name.\n*   **Resource Association:** Enables associating a specific resource (e.g., a query or dashboard) with a notebook.\n*   **Notebook Listing:** Displays a list of available notebooks.\n*   **Filtered Notebook Listing:** Differentiates and displays notebooks that already contain a specific resource separately from those that do not.\n*   **Popover Control:** Manages the visibility of a popover for selecting notebooks.\n*   **Loading State Management:** Indicates when notebooks are being loaded.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/NotebookSelectButton/NotebookSelectButton.tsx",
        "summary": "This code provides React components for selecting and managing notebooks within the PostHog application. It includes a button, a popover, and a list for displaying notebooks. Users can create new notebooks, add content to existing ones, search for notebooks, and quickly access their scratchpad. The components handle loading notebooks, displaying them in a structured manner, and integrating with the PostHog notebooks model.\n\nHere's a list of high-level product features:\n\n*   **Notebook Selection:** Allows users to select an existing notebook to add content to.\n*   **Notebook Creation:** Enables users to create new notebooks with a default title based on the current date or a custom title.\n*   **Scratchpad Access:** Provides quick access to a personal scratchpad notebook.\n*   **Notebook Search:** Allows users to search for notebooks by title.\n*   **Resource Integration:** Supports adding specific resources (e.g., insights, experiments) to notebooks.\n*   **Notebook List Display:** Displays a list of notebooks, differentiating between those already containing a resource and those that don't.\n*   **Notebook Association Indication:** Displays a count on the button indicating how many notebooks the current resource is already in.\n*   **Notebook Opening:** Opens the selected notebook, optionally inserting the resource at the start or end.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/NotebookSelectButton",
        "summary": "The provided code implements a notebook selection and management feature within the PostHog application. It allows users to easily select existing notebooks, create new ones, and manage the association of resources with these notebooks. The system provides search functionality, filtered lists to differentiate notebooks containing specific resources, and a popover interface for streamlined interaction.\n\nHere's a list of high-level product features:\n\n*   Notebook Selection\n*   Notebook Creation\n*   Scratchpad Access\n*   Notebook Search\n*   Resource Association\n*   Filtered Notebook Listing\n*   Popover Control\n*   Loading State Management\n*   Notebook Association Indication\n*   Notebook Opening\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/NotebookTemplates/notebookTemplates.ts",
        "summary": "This code defines a notebook template for PostHog, specifically an introductory notebook. It showcases the capabilities of PostHog notebooks, including text editing features (headings, bold, italic, lists), embedding images and iframes (like YouTube videos), and integrating PostHog data. The template highlights use cases such as investigating bug reports with session replays, researching new ideas with insights and survey results, and planning launches with feature flags and events. It emphasizes the collaborative nature of notebooks within an organization, while noting the absence of multiplayer editing.\n\nHere's a list of high-level product features based on the code:\n\n*   **Notebook Creation and Management:** Users can create and manage multiple notebooks.\n*   **Rich Text Editing:** Support for headings, bold, italic, numbered and un-numbered lists, and other standard text formatting options.\n*   **Media Embedding:** Ability to embed images and iframes (e.g., YouTube videos) within notebooks.\n*   **PostHog Data Integration:** Seamless integration of PostHog resources (session replays, feature flags, events, cohorts, surveys, etc.) into notebooks.\n*   **Collaboration and Sharing:** Notebooks can be shared within an organization.\n*   **Use Case Support:** Facilitates various workflows like bug investigation, research, and launch planning.\n*   **Single-User Editing:** Concurrent editing by multiple users is not supported.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/NotebookTemplates",
        "summary": "The PostHog notebook template demonstrates a powerful tool for internal collaboration and documentation, showcasing PostHog's capabilities through a rich, interactive medium. Users can create and share notebooks within their organization to investigate bug reports, research new ideas, and plan product launches, all while leveraging PostHog's data and features. The template emphasizes rich text editing, media embedding, and seamless integration with PostHog resources, although it currently lacks support for real-time multiplayer editing.\n\nHere's a list of high-level product features:\n\n*   Notebook Creation and Management\n*   Rich Text Editing (headings, bold, italic, lists)\n*   Media Embedding (images, iframes)\n*   PostHog Data Integration (session replays, feature flags, events, cohorts, surveys)\n*   Collaboration and Sharing\n*   Use Case Support (bug investigation, research, launch planning)\n*   Single-User Editing\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Suggestions/SlashCommands.tsx",
        "summary": "This code defines a React component that provides a slash command interface for a notebook editor. It uses a button with a plus icon to trigger a popover containing available slash commands. When the button is clicked, the popover becomes visible, allowing the user to select and insert commands into the editor at the current cursor position. The component is implemented as an insertion suggestion, making it readily available within the notebook interface.\n\nHere's a list of high-level product features:\n\n*   **Slash Command Interface:** Provides a way to insert commands into the notebook editor using a slash (/) followed by a command name.\n*   **Insertion Suggestion:** Integrates the slash command interface as a suggestion within the notebook, making it easily discoverable.\n*   **Popover Display:** Displays available slash commands in a popover when the trigger button is clicked.\n*   **Visual Trigger:** Uses a button with a plus icon as a visual cue to open the slash command popover.\n*   **Editor Integration:** Seamlessly integrates with the notebook editor, allowing commands to be inserted at the current cursor position.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Suggestions/ReplayTimestamp.tsx",
        "summary": "This code defines a suggestion component for inserting a timestamp into a notebook, specifically related to session recordings. It leverages the PostHog Lemon UI library and Kea for state management. The component displays a button with the current timestamp from a session recording player. When clicked, it inserts a timestamp comment into the notebook editor, referencing the current playback time of the associated session recording. The suggestion intelligently appears only after a recording node or another timestamp node, and it can be triggered via tab key.\n\nHere's a list of high-level product features:\n\n*   **Timestamp Insertion:** Allows users to insert timestamps into a notebook, linked to specific points in a session recording.\n*   **Session Recording Integration:** Integrates with session recording player to fetch and display the current playback time.\n*   **Contextual Suggestion:** Suggests timestamp insertion only when relevant (after a recording node or another timestamp).\n*   **Keyboard Shortcut:** Supports timestamp insertion via the Tab key.\n*   **Visual Indication:** Displays the current timestamp on a button for easy insertion.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Suggestions/InsertionSuggestion.tsx",
        "summary": "This code defines a class `InsertionSuggestion` that represents a suggestion for inserting content into a notebook editor. It encapsulates the logic for determining when the suggestion should be displayed, the React component to render for the suggestion, and an optional handler for when the user presses the Tab key while the suggestion is active. The `InsertionSuggestion` class is configured using an `InsertionSuggestionConfig` object, which specifies the `shouldShow` condition (either a boolean or a function that determines visibility based on the previous node), the `Component` to render, and an optional `onTab` handler.\n\nHere's a list of high-level product features related to this code:\n\n*   **Content Insertion Suggestions:** Provides suggestions to users on what content to insert next in a notebook.\n*   **Context-Aware Suggestions:** Suggestions can be dynamically shown or hidden based on the preceding content (previous node) in the notebook.\n*   **Customizable Suggestion Components:** Allows developers to define custom React components for rendering the suggestions.\n*   **Tab Key Handling:** Supports custom actions when the user presses the Tab key while a suggestion is active, enabling quick insertion or other actions.\n*   **Suggestion Dismissal:** Provides a mechanism to dismiss suggestions, preventing them from reappearing.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Suggestions/insertionSuggestionsLogic.ts",
        "summary": "This code defines the logic for handling insertion suggestions within a notebook editor. It manages a list of suggestions, determines which suggestion is currently active based on its visibility criteria and dismissal status, and handles user interactions like pressing Tab to accept a suggestion or Escape to dismiss it. The logic also listens for keydown events (Tab and Escape) at the window level to trigger the corresponding actions.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Intelligent Insertion Suggestions:** Provides context-aware suggestions to the user while editing a notebook.\n*   **Replay Timestamp Suggestion:** Suggests relevant replay timestamps for insertion into the notebook.\n*   **Slash Commands:** Enables the use of slash commands for quick actions within the notebook.\n*   **Suggestion Acceptance (Tab):** Allows users to quickly accept the active suggestion by pressing the Tab key.\n*   **Suggestion Dismissal (Escape):** Allows users to dismiss the active suggestion by pressing the Escape key.\n*   **Dynamic Suggestion Visibility:** Determines whether a suggestion should be displayed based on the current context (e.g., the previous node in the notebook).\n*   **Persistent Dismissal:** Remembers which suggestions have been dismissed by the user.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Suggestions/FloatingSuggestions.tsx",
        "summary": "This component, `FloatingSuggestions`, provides a dynamic suggestion interface within a Tiptap editor in a notebook application. It displays a floating button with contextually relevant suggestions based on the current editor state, such as whether the editor has focus, is editable, the current node is a paragraph, and if that paragraph is empty. The position of the button is dynamically updated based on the current selection within the editor. The suggestions are provided via the `insertionSuggestionsLogic` and rendered using a component defined in the `activeSuggestion` state.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Contextual Suggestions:** Provides intelligent, context-aware suggestions to the user as they type in the notebook editor.\n*   **Dynamic Positioning:** The suggestion button floats and repositions itself based on the user's current selection within the editor.\n*   **Real-time Updates:** The suggestions update in real-time as the user types and interacts with the editor.\n*   **Focus and Edit State Awareness:** The suggestions only appear when the editor has focus, is editable, and meets specific node criteria (e.g., an empty paragraph).\n*   **Extensible Suggestion Components:** The system allows for different suggestion components to be plugged in and rendered based on the current context.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Suggestions",
        "summary": "The notebook application features an intelligent and context-aware suggestion system to enhance the user's writing experience. This system provides dynamic, real-time suggestions for content insertion, including timestamps linked to session recordings and slash commands for quick actions. The suggestions are displayed via a floating button or popover, dynamically positioned based on the user's cursor and editor state, and can be accepted with the Tab key or dismissed with the Escape key. The system is designed to be extensible, allowing for custom suggestion components and context-dependent visibility rules.\n\nHere's a list of high-level product features:\n\n*   Contextual Suggestions: Provides intelligent, context-aware suggestions to the user as they type in the notebook editor.\n*   Dynamic Positioning: The suggestion button floats and repositions itself based on the user's current selection within the editor.\n*   Real-time Updates: The suggestions update in real-time as the user types and interacts with the editor.\n*   Slash Command Interface: Provides a way to insert commands into the notebook editor using a slash (/) followed by a command name.\n*   Timestamp Insertion: Allows users to insert timestamps into a notebook, linked to specific points in a session recording.\n*   Keyboard Shortcuts: Supports timestamp insertion via the Tab key and suggestion dismissal via the Escape key.\n*   Customizable Suggestion Components: Allows developers to define custom React components for rendering the suggestions.\n*   Suggestion Acceptance (Tab): Allows users to quickly accept the active suggestion by pressing the Tab key.\n*   Suggestion Dismissal (Escape): Allows users to dismiss the active suggestion by pressing the Escape key.\n*   Dynamic Suggestion Visibility: Determines whether a suggestion should be displayed based on the current context.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/NotebookMenu.tsx",
        "summary": "This code defines a `NotebookMenu` component in a React application, providing a dropdown menu of actions for a specific notebook. The menu includes options to export the notebook as JSON, view its history, share the notebook with others, and delete the notebook (if the user has sufficient permissions and the notebook is not a template or local-only). The menu is triggered by clicking an ellipsis icon button.\n\nHere's a list of the high-level product features implemented by this component:\n\n*   **Export to JSON:** Allows users to download the notebook's content as a JSON file.\n*   **View History:** Toggles the visibility of the notebook's history/version control.\n*   **Share Notebook:** Opens a modal to share the notebook with other users.\n*   **Delete Notebook:** Enables users with editor permissions to delete the notebook (disabled for templates and local-only notebooks).\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/migrations/migrate.ts",
        "summary": "This code defines a migration function for PostHog notebooks, responsible for updating the notebook's content structure and data formats to newer versions. It iterates through the content of a notebook, transforming various types of nodes and their associated data, such as converting legacy insight nodes to query nodes, parsing query strings into objects, and migrating legacy filter formats for insights, funnels, retention, paths, stickiness, and lifecycle queries to a new schema. The migration also handles converting legacy playlist filters to universal filters. The `NOTEBOOKS_VERSION` constant is used for cache busting when migrations are added.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Notebook Content Migration:** Automatically updates the structure and format of notebook content to maintain compatibility with newer versions of the PostHog platform.\n*   **Insight Conversion:** Converts legacy insight representations within notebooks to a new query node format.\n*   **Query Parsing:** Parses query strings stored in notebook nodes into structured query objects.\n*   **Filter Migration:** Migrates legacy filter formats used in various insight types (Trends, Funnels, Retention, Paths, Stickiness, Lifecycle) to a unified and updated schema.\n*   **Playlist Filter Conversion:** Converts legacy filters used in recording playlists within notebooks to a universal filter format.\n*   **Cache Busting:** Provides a mechanism to invalidate cached notebook content when migrations are applied, ensuring users always see the latest version.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/migrations",
        "summary": "The provided code enables seamless evolution of PostHog notebooks by automatically migrating their content to newer formats. This migration process ensures compatibility and leverages updated features within the PostHog platform. The migration function handles various transformations, including converting legacy insights to query nodes, parsing query strings, and updating filter formats for different insight types and recording playlists. A cache-busting mechanism ensures users always access the latest notebook version after migrations.\n\nHere's a list of high-level product features enabled by this code:\n\n*   Notebook Content Migration\n*   Insight Conversion\n*   Query Parsing\n*   Filter Migration\n*   Playlist Filter Conversion\n*   Cache Busting\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/NotebookLoadingState.tsx",
        "summary": "The `NotebookLoadingState` component in `NotebookLoadingState.tsx` provides a visual placeholder while a notebook is loading. It uses LemonSkeleton components to display a series of animated gray blocks, simulating the eventual content of the notebook. This gives the user feedback that the application is working and content is on its way.\n\nHere's a list of high-level product features represented by this code:\n\n*   **Loading State Indication:** Displays a loading state to the user while the notebook data is being fetched.\n*   **Skeleton UI:** Uses skeleton elements to provide a visual representation of the notebook's layout during loading.\n*   **Improved User Experience:** Enhances the user experience by providing feedback and reducing perceived loading times.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/notebookSettingsLogic.ts",
        "summary": "The `notebookSettingsLogic` Kea logic manages settings that persist across all notebooks within the application. It provides functionality to control the expanded/collapsed state of a UI element, persisting this state using the `kea` framework's built-in persistence mechanism.\n\n**Features:**\n\n*   **Persistent Expanded State:** Maintains whether a UI element (likely a settings panel or similar) is expanded or collapsed across different notebooks and sessions.\n*   **`setIsExpanded` Action:** Provides an action to programmatically set the expanded state.\n*   **`isExpanded` Reducer:** Manages the `isExpanded` state, updating it based on the `setIsExpanded` action.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/NotebookConflictWarning.tsx",
        "summary": "The `NotebookConflictWarning` component is a React component that displays a warning message to the user when the notebook they are currently viewing has been edited by someone else. It informs the user that they need to reload the notebook to see the latest version and provides a button to trigger the reload action. The component utilizes the `notebookLogic` to reload the notebook data.\n\nHere's a list of high-level product features:\n\n*   **Conflict Detection:** Detects when a notebook has been modified by another user.\n*   **Real-time Warning:** Displays a warning message to the user when a conflict is detected.\n*   **Notebook Reload:** Provides a button to reload the notebook and display the latest version.\n*   **User Notification:** Informs the user about the need to reload the notebook to avoid overwriting changes.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/NotebookListMini.tsx",
        "summary": "This React component, `NotebookListMini`, displays a button that, when clicked, opens a popover containing a list of notebooks. It uses the `notebooksModel` to fetch the available notebooks and templates. The button's text reflects the title of the currently selected notebook (or \"My scratchpad\" if the scratchpad is selected), defaulting to \"Notebooks\" if none is selected. The component takes a `selectedNotebookId` prop to determine the currently selected notebook and an `onSelectNotebook` prop to handle notebook selection.\n\n**Features:**\n\n*   **Notebook Selection:** Allows users to select a notebook from a list of available notebooks and templates.\n*   **Scratchpad Support:** Provides a \"My scratchpad\" option for quick note-taking.\n*   **Dynamic Button Text:** The button displays the title of the currently selected notebook.\n*   **Popover Interface:** Uses a popover to display the list of notebooks when the button is clicked.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/InlineMenu.tsx",
        "summary": "This code defines an inline menu component for a notebook editor, providing formatting options that appear when text is selected. The menu allows users to format text as headings (H1, H2, H3), apply bold and italic styles, insert and manage hyperlinks, and add comments to selected text (if the \"DISCUSSIONS\" feature flag is enabled). The menu dynamically adjusts its content based on whether a link is currently active, providing options to edit, open, or remove the link.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Text Formatting:**\n    *   Apply Heading styles (H1, H2, H3)\n    *   Apply Bold style\n    *   Apply Italic style\n*   **Hyperlink Management:**\n    *   Insert a hyperlink\n    *   Edit an existing hyperlink\n    *   Open a hyperlink in a new tab\n    *   Remove a hyperlink\n*   **Commenting (Conditional):**\n    *   Add comments to selected text (controlled by feature flag)\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/NotebookColumnRight.tsx",
        "summary": "This React component, `NotebookColumnRight`, renders a right-hand column in a notebook interface. It dynamically displays widgets based on the `nodeLogicsWithChildren` state from the `notebookLogic`. The column's visibility is controlled by the presence of child nodes and the state of the left column. The `Widgets` component iterates through the children of each node logic and renders them using the `NotebookNodeChildRenderer`. It also ensures that each child node has a unique ID (`nodeId`) to prevent re-rendering issues.\n\n**Features:**\n\n*   **Dynamic Widget Display:** Shows widgets in a right-hand column based on notebook node data.\n*   **Conditional Visibility:** The right column is only visible when there are child nodes and the left column is hidden.\n*   **Unique Node Identification:** Assigns unique IDs to child nodes to optimize rendering performance.\n*   **Node Rendering:** Renders individual notebook nodes and their content using `NotebookNodeChildRenderer`.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/NotebookIconHeading.tsx",
        "summary": "The `NotebookIconHeading` component is a simple React component that displays a heading icon resembling a stylized \"H\" followed by a number representing the heading level. The component takes a `level` prop, which is a number, and renders an \"H\" with the level displayed as a smaller, bolded superscript. This component is likely used to visually represent different heading levels within a notebook or document interface.\n\nHere's a list of high-level product features that could utilize this component:\n\n*   **Notebook/Document Editor:** Used to visually represent heading levels (H1, H2, H3, etc.) in a document or notebook editor.\n*   **Table of Contents Generation:** Display heading levels in a table of contents.\n*   **Document Outline View:** Show a hierarchical view of a document based on heading levels.\n*   **Content Formatting Toolbar:** Provide a visual indicator of the currently selected heading level.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/notebookActivityDescriber.tsx",
        "summary": "This code defines a function `notebookActivityDescriber` that generates human-readable descriptions of activity logs related to notebooks. It focuses on describing changes made to notebooks, specifically changes to the content. It uses a mapping of notebook fields to functions that generate descriptions for those changes. The function constructs sentences describing who made the change and what was changed, including a link to the notebook if available. If the activity is not a change or update, it falls back to a default description.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Activity Logging for Notebooks:** Tracks changes and updates made to notebooks.\n*   **Human-Readable Activity Descriptions:** Converts raw activity log data into easy-to-understand sentences.\n*   **Content Change Tracking:** Specifically identifies and describes changes made to the content of notebooks.\n*   **User Attribution:** Identifies the user who performed the activity.\n*   **Notebook Linking:** Provides links to the specific notebook where the activity occurred.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/Notebook.tsx",
        "summary": "This code defines the main component for displaying and interacting with a notebook. It handles loading, displaying, and editing notebooks, including conflict resolution, template handling, and scratchpad functionality. The component uses a layout with left and right columns surrounding an editor. It also manages the notebook's editable state and responsiveness to different screen sizes.\n\n**High-level product features:**\n\n*   **Notebook Display and Editing:** Core functionality for viewing and modifying notebook content using a rich text editor.\n*   **Conflict Resolution:** Detects and warns users about conflicting changes to the notebook.\n*   **Template Support:** Allows users to create and duplicate notebooks from templates.\n*   **Scratchpad:** Provides a personal, temporary notebook for quick note-taking.\n*   **Responsive Layout:** Adapts the notebook layout to different screen sizes.\n*   **Notebook History:** Displays warnings related to notebook history.\n*   **Editable State Management:** Controls whether the notebook is editable or read-only.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/NotebookShareModal.tsx",
        "summary": "This React component, `NotebookShareModal`, provides a modal interface for sharing notebooks within PostHog. It offers options for copying an internal link to the notebook (if it's not local-only), copying a \"template link\" that opens the notebook's content in a Canvas, and expresses interest in future external sharing capabilities. The modal also integrates with role-based access control (if enabled) and tracks user interest in external sharing.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Internal Notebook Sharing:** Allows users to copy a direct link to a notebook for sharing with other PostHog users within the same project.\n*   **Template Creation via Canvas:** Enables users to share a notebook's content as a template by generating a link that opens the content in a Canvas.\n*   **Role-Based Access Control Integration:** Provides a link to manage access control settings for the notebook (if RBAC is enabled).\n*   **External Sharing Interest Tracking:** Allows users to express interest in future external sharing capabilities for notebooks.\n*   **Local-Only Notebook Handling:** Informs users when a notebook is only visible to them and cannot be shared directly.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/MentionsExtension.tsx",
        "summary": "This code implements a mention feature for a rich text editor in a notebook application. It allows users to type \"@\" followed by a query to search and select organization members to mention within the editor. The component displays a popover with a list of filtered members, highlighting the active selection, and allows navigation and selection via keyboard or mouse. The selected member is then inserted into the editor as a mention node.\n\nHere's a list of high-level product features:\n\n*   **Member Mentioning:** Allows users to mention other organization members within the notebook editor.\n*   **Real-time Search:** Filters the list of members as the user types after the \"@\" symbol.\n*   **Keyboard Navigation:** Enables users to navigate and select members from the list using the keyboard (arrow keys and enter).\n*   **Visual Highlighting:** Highlights the currently selected member in the list.\n*   **Profile Picture Display:** Shows the profile picture of each member in the suggestion list.\n*   **Popover UI:** Presents the mention suggestions in a popover for a clean user experience.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/NotebookColumnLeft.tsx",
        "summary": "This code defines the left column of a notebook interface, responsible for displaying settings and history related to the currently selected notebook node. It dynamically renders either the settings widget for the selected node or the notebook history, based on the application state. The settings widget allows users to edit attributes of the selected node, while the history component displays the notebook's history. The column's visibility is also controlled by the application state.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Dynamic Left Column Display:** Shows either node settings or notebook history based on user interaction.\n*   **Node Settings Editor:** Provides a widget to edit the attributes of a selected notebook node.\n*   **Notebook History Viewer:** Displays the history of changes made to the notebook.\n*   **Real-time Settings Offset:** Keeps the settings widget aligned with the selected node.\n*   **Node Selection:** Allows users to select a node for editing.\n*   **\"Done\" Button:** A button to exit the node settings editor.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/NotebookMeta.tsx",
        "summary": "This code defines React components for displaying the synchronization status of a notebook and a button to toggle the notebook's expanded view. The `NotebookSyncInfo` component shows the current sync status (synced, saving, unsaved, or local) with a corresponding tooltip. The component uses a debounce to update the displayed status, and it automatically hides the status after a delay if the notebook is synced. The `NotebookExpandButton` component allows users to toggle between a fixed content width and a full-width display for the notebook, using an icon to indicate the current state.\n\nHere's a list of high-level product features:\n\n*   **Notebook Sync Status Display:** Shows the current synchronization status of the notebook (e.g., \"Saved\", \"Saving\", \"Edited\", \"Local\").\n*   **Real-time Sync Indication:** Provides visual feedback during the saving process with a spinner.\n*   **Tooltip Explanations:** Offers detailed explanations of each sync status via tooltips.\n*   **Debounced Status Updates:** Prevents rapid status changes from being displayed immediately, improving user experience.\n*   **Automatic Status Hiding:** Automatically hides the sync status when the notebook is synced, reducing visual clutter.\n*   **Toggleable Expanded View:** Allows users to switch between a fixed-width and full-width display for the notebook content.\n*   **Intuitive Expand/Collapse Icon:** Uses an icon to clearly indicate the current expanded state of the notebook.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/utils.ts",
        "summary": "This file defines utilities and types for creating and managing a rich text editor for notebooks, leveraging the Tiptap editor framework. It provides a way to define custom node types with specific attributes, components, and paste handling. The code also includes helper functions for interacting with the editor, such as getting the current node, setting content, and managing text serialization for different node types. The goal is to provide a flexible and extensible system for building interactive notebooks with custom PostHog widgets.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Customizable Notebook Nodes:** Allows defining custom node types with specific attributes, components, and behaviors.\n*   **Rich Text Editing:** Provides a rich text editor interface for creating and editing notebook content.\n*   **Paste Handling:** Supports custom paste handling for different node types, allowing for seamless integration of external content.\n*   **Text Serialization:** Enables custom text serialization for different node types, ensuring accurate representation of content.\n*   **Editor Interaction Helpers:** Offers helper functions for interacting with the editor, such as getting the current node, setting content, and managing selections.\n*   **Extensible Widget System:** Provides a framework for building interactive notebooks with custom PostHog widgets.\n*   **Default Notebook Content:** Provides a function to create default notebook content with a title and initial content.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/NotebookHistory.tsx",
        "summary": "The `NotebookHistory.tsx` file provides a component for viewing and interacting with the history of a notebook. It fetches the activity log for a specific notebook and displays a list of revisions, allowing users to preview older versions of the notebook content. Users can then revert the notebook to a previous version or create a copy of a previous version. The component also includes pagination for navigating through the history and displays user information and timestamps for each revision. A warning banner is displayed when a user is viewing an older revision, prompting them to revert or create a copy.\n\nHere's a list of high-level product features:\n\n*   **View Notebook History:** Allows users to see a chronological list of changes made to a notebook, including who made the changes and when.\n*   **Preview Previous Versions:** Enables users to view the content of a notebook at a specific point in its history.\n*   **Revert to Previous Version:** Provides the ability to restore a notebook to a selected older version.\n*   **Create a Copy of a Previous Version:** Allows users to duplicate a notebook based on a selected older version, creating a new notebook with the content of the older version.\n*   **Pagination:** Supports navigating through a large number of revisions using pagination controls.\n*   **User Attribution:** Displays the user who made each change in the notebook's history.\n*   **Timestamp Display:** Shows the date and time when each change was made, including timezone information.\n*   **Informative Banner:** Displays a banner when viewing a previous version, prompting the user to revert or create a copy."
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/notebookLogic.ts",
        "summary": "This code defines the logic for a notebook editor feature within a larger application. It manages the state of a notebook, including its content, title, and editing status. The logic handles loading, saving, renaming, and duplicating notebooks, as well as managing local changes and resolving conflicts. It also supports different modes (notebook, canvas), templates, and scratchpads. The code interacts with an API to persist notebooks and integrates with other parts of the application, such as comments and side panels.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Notebook Creation and Editing:** Allows users to create new notebooks and edit existing ones with rich text and other content types.\n*   **Real-time Collaboration:** Manages local changes and conflicts to support collaborative editing.\n*   **Notebook Persistence:** Saves notebooks to a backend API for persistence and retrieval.\n*   **Templates and Scratchpads:** Supports notebook templates and scratchpad functionality for quick note-taking.\n*   **Version Control:** Detects and handles conflicts between different versions of a notebook.\n*   **Comments Integration:** Enables users to add and manage comments within notebooks.\n*   **Content Preview:** Allows previewing notebook content before saving.\n*   **Export Functionality:** Enables exporting notebooks in JSON format.\n*   **Access Control:** Manages user access permissions to notebooks.\n*   **Duplicate Notebooks:** Allows users to duplicate existing notebooks.\n*   **Replay Comments:** Allows users to insert comments related to session replays by timestamp.\n*   **Share Notebooks:** Allows users to share notebooks with others."
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/SlashCommands.tsx",
        "summary": "This code defines a React component called `SlashCommands` that provides a popover interface for inserting various content elements into a Tiptap editor within a PostHog notebook. It allows users to quickly add headings, format text (bold, italic), and insert pre-configured insight visualizations (trends, funnels, retention, paths, stickiness, lifecycle), SQL queries, data tables (events, people), session recording playlists, images, and embedded iframes. The component uses Fuse.js for fuzzy searching commands and provides keyboard navigation for selecting and executing commands. It distinguishes between adding content via a slash command and adding content via a button, and adjusts keyboard listeners accordingly.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Slash Command Interface:** Provides a quick way to insert content using \"/\" trigger.\n*   **Text Formatting:** Allows users to quickly add headings (H1, H2, H3), bold, and italic text.\n*   **Insight Visualization Insertion:** Enables users to insert pre-configured insight visualizations like Trends, Funnels, Retention, Paths, Stickiness, and Lifecycle charts.\n*   **SQL Query Insertion:** Allows users to insert pre-configured SQL queries into the notebook.\n*   **Data Table Insertion:** Enables users to insert data tables displaying Events and People data.\n*   **Session Recording Playlist Insertion:** Allows users to insert a session recording playlist.\n*   **Image Upload and Insertion:** Enables users to upload and insert images into the notebook.\n*   **Embedded Iframe Insertion:** Allows users to insert embedded iframes.\n*   **Fuzzy Search:** Provides fuzzy search functionality to quickly find commands.\n*   **Keyboard Navigation:** Supports keyboard navigation for selecting and executing commands.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook/Editor.tsx",
        "summary": "This code defines the `Editor` component for a notebook application, built using the Tiptap rich text editor. It configures the editor with various extensions for enhanced functionality, including support for headings, text formatting, task lists, mentions, links, comments, and embedded content like queries, recordings, playlists, people, cohorts, flags, experiments, surveys, images, and properties. The editor also handles drag-and-drop and paste events for files and links, providing a seamless user experience. It integrates with PostHog for analytics and provides slash commands and floating menus for easy content insertion and formatting. The component manages editor state and provides methods for interacting with the editor content.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Rich Text Editing:** Core text editing capabilities with formatting options.\n*   **Headings and Structure:** Support for headings to organize content.\n*   **Task Lists:** Creation and management of task lists.\n*   **Mentions:** Ability to mention users or other entities within the notebook.\n*   **Links:** Insertion and management of hyperlinks.\n*   **Comments:** Adding and resolving comments on specific text sections.\n*   **Embedded Content:** Integration of various content types like queries, recordings, playlists, people, cohorts, flags, experiments, surveys, images, and properties.\n*   **Drag and Drop:** Support for dragging and dropping files (images) and links into the editor.\n*   **Paste Support:** Handling of pasted content, including images and links.\n*   **Slash Commands:** Quick access to commands via slash (/) menu.\n*   **Floating Menus:** Contextual menus for formatting and actions.\n*   **Image Support:** Ability to insert and display images.\n*   **Analytics Integration:** Tracking of user actions with PostHog.\n*   **Customizable Placeholders:** Displaying helpful placeholders for different content types.\n*   **Backlinks:** Support for linking to other notebooks or sections within the application.\n*   **Code Examples:** Ability to embed code examples, specifically for flags.\n*   **Maps:** Ability to embed maps.\n*   **Person Feed:** Ability to embed a feed of activity related to a specific person."
    },
    {
        "path": "frontend/src/scenes/notebooks/Notebook",
        "summary": "The provided code collectively powers a comprehensive notebook feature within PostHog, enabling users to create, edit, share, and collaborate on rich text documents enhanced with interactive elements and visualizations. The notebook functionality includes features such as real-time collaboration with conflict resolution, version history, customizable content blocks, and integration with other PostHog features like insights, recordings, and user data. Users can easily format text, embed various content types, and share notebooks internally or as templates. The system also provides a scratchpad for quick note-taking and a robust framework for managing notebook settings and user activity.\n\nHere's a list of high-level product features:\n\n*   **Rich Text Editing:** Core text editing capabilities with formatting options, headings, and task lists.\n*   **Collaborative Editing:** Real-time collaboration with conflict resolution and version history.\n*   **Content Embedding:** Integration of various content types like insights, recordings, user data, and custom widgets.\n*   **Sharing and Templates:** Internal notebook sharing, template creation, and external sharing interest tracking.\n*   **Customizable Content Blocks:** Ability to define custom node types with specific attributes and behaviors.\n*   **Activity Logging:** Tracks changes and updates made to notebooks, providing human-readable descriptions.\n*   **User Mentions:** Ability to mention other organization members within the notebook editor.\n*   **Slash Commands:** Quick access to commands via slash (/) menu for inserting content.\n*   **Notebook History:** Allows users to view and revert to previous versions of a notebook.\n*   **Scratchpad:** Provides a personal, temporary notebook for quick note-taking.\n*   **Settings Management:** Persistent settings for UI elements like expanded/collapsed states.\n*   **Loading State Indication:** Displays a loading state to the user while the notebook data is being fetched.\n*   **Accessibility and Responsiveness:** Adapts the notebook layout to different screen sizes and provides keyboard navigation.\n*   **Notebook Content Migration:** Seamless evolution of PostHog notebooks by automatically migrating their content to newer formats.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/NotebooksTable/NotebooksTable.tsx",
        "summary": "The `NotebooksTable` component provides a user interface for viewing, searching, and managing notebooks within PostHog. It displays a table of notebooks with key information such as title, creator, creation date, and last modified date. Users can search for notebooks, filter by type and creator, sort the table by different columns, and delete notebooks (excluding templates). The component also includes a banner introducing the Notebooks feature with a link to get started with a template.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Display Notebook List:** Shows a table of available notebooks with key details.\n*   **Search Notebooks:** Allows users to search for notebooks by title.\n*   **Filter Notebooks:** Enables filtering notebooks by type (e.g., template) and creator.\n*   **Sort Notebooks:** Supports sorting the notebook list by title, creation date, or last modified date.\n*   **Delete Notebooks:** Provides functionality to delete notebooks (excluding templates).\n*   **Notebook Templates:** Highlights template notebooks and provides a quick start option.\n*   **User Attribution:** Displays the creator of each notebook.\n*   **Pagination:** Implements pagination for handling large lists of notebooks.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/NotebooksTable/ContainsTypeFilter.tsx",
        "summary": "This code defines a React component called `ContainsTypeFilters` that allows users to filter a list of notebooks based on the types of content they contain. It uses a `LemonInputSelect` component to provide a multi-select dropdown with options derived from the `fromNodeTypeToLabel` object, which maps notebook node types to human-readable labels. When the user selects content types, the component updates the `contains` filter in the parent component's state and triggers a PostHog event for analytics.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Filtering Notebooks by Content Type:** Users can narrow down the list of notebooks displayed based on the types of content they contain (e.g., feature flags, experiments, recordings).\n*   **Multi-Select Content Type Filtering:** Users can select multiple content types to filter for notebooks containing any combination of the selected types.\n*   **User-Friendly Content Type Labels:** The filter options are presented with clear and understandable labels, improving the user experience.\n*   **Analytics Tracking:** User interactions with the content type filter are tracked using PostHog, providing insights into how users are using the feature.\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/NotebooksTable/notebooksTableLogic.ts",
        "summary": "This code defines the logic for a Notebooks Table component in a PostHog application. It manages the state and data fetching for displaying a list of notebooks, including filtering, sorting, and pagination. The logic fetches notebooks from the API based on user-defined filters (search term, creator, content type), sorting preferences, and pagination settings. It also handles displaying notebook templates when no filters are applied and updates the table when a notebook is deleted.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Display a list of notebooks:** Fetches and renders a paginated list of notebooks.\n*   **Filtering:** Allows users to filter notebooks by search term, creator, and content type.\n*   **Sorting:** Enables users to sort notebooks based on different criteria (e.g., last modified date).\n*   **Pagination:** Provides pagination controls for navigating through large lists of notebooks.\n*   **Display notebook templates:** Shows notebook templates when no filters are applied, allowing users to quickly create new notebooks from templates.\n*   **Real-time updates:** Refreshes the notebook list automatically after a notebook is deleted."
    },
    {
        "path": "frontend/src/scenes/notebooks/NotebookScene.tsx",
        "summary": "The `NotebookScene.tsx` file defines the main view for displaying and interacting with a notebook within the PostHog application. It handles loading notebooks, displaying them in full screen or in a side panel, and provides various actions such as creating new notebooks, sharing notebooks, and opening a guide. The scene also manages access control, displaying appropriate messages for not found or access denied scenarios. The component utilizes several other components like `Notebook`, `NotebookMenu`, `NotebookShareModal`, and `NotebookSyncInfo` to provide a rich user experience.\n\nHere's a list of high-level product features implemented in this code:\n\n*   **Notebook Display:** Renders a notebook in full screen mode.\n*   **Side Panel Integration:** Allows opening a notebook in a side panel for easy access while navigating the application.\n*   **Notebook Creation:** Supports creating new notebooks.\n*   **Access Control:** Handles scenarios where a user doesn't have access to a notebook or the notebook is not found.\n*   **Template Support:** Indicates if a notebook is a template.\n*   **User Activity Tracking:** Displays the last modified date and user who modified the notebook.\n*   **Notebook Menu:** Provides a menu for notebook-related actions (defined in `NotebookMenu.tsx`).\n*   **Notebook Sharing:** Allows sharing notebooks via a modal (defined in `NotebookShareModal.tsx`).\n*   **Guide Integration:** Provides a button to open a guide notebook.\n*   **Realtime Sync Information:** Displays sync status and information about the notebook (defined in `NotebookSyncInfo.tsx`).\n"
    },
    {
        "path": "frontend/src/scenes/notebooks/NotebooksTable",
        "summary": "The Notebooks feature in PostHog provides a comprehensive interface for users to manage and interact with their notebooks. Users can view a list of notebooks, search and filter them based on various criteria like content type and creator, and sort them according to their preferences. The system also supports pagination for efficient navigation through large datasets, allows for the deletion of notebooks, and highlights notebook templates for quick starts. User interactions with the content type filter are tracked using PostHog, providing insights into how users are using the feature.\n\n*   Display Notebook List\n*   Search Notebooks\n*   Filter Notebooks by Content Type and Creator\n*   Sort Notebooks\n*   Delete Notebooks\n*   Display Notebook Templates\n*   User Attribution\n*   Pagination\n*   Analytics Tracking of Filter Usage\n"
    },
    {
        "path": "frontend/src/scenes/notebooks",
        "summary": "The PostHog Notebooks feature provides a collaborative and dynamic space for users to create, share, and manage rich text documents integrated with PostHog's analytics platform. Users can embed data visualizations, link to resources, and annotate content, fostering data exploration and analysis. The notebooks support real-time collaboration, version history, and customizable content blocks, allowing teams to investigate bug reports, research ideas, and plan product launches effectively.\n\nHere's a list of high-level product features:\n\n*   **Notebook Creation and Management:** Create, organize, and manage notebooks within the PostHog application.\n*   **Rich Text Editing:** Format text, create headings, lists, and embed media.\n*   **Collaborative Editing:** Real-time collaboration with conflict resolution and version history.\n*   **Data Visualization Embedding:** Embed charts, tables, and maps directly within notebooks.\n*   **Resource Linking:** Link to PostHog resources like feature flags, experiments, and session recordings.\n*   **Comment Annotation:** Highlight text and associate comments for collaborative feedback.\n*   **Contextual Suggestions:** Intelligent suggestions for content insertion, including timestamps and slash commands.\n*   **Drag and Drop Integration:** Seamlessly integrate resources from other parts of the application into notebooks.\n*   **Canvas-based Notebooks:** Create free-form canvases for exploration, with changes persisted to the URL.\n*   **Notebook Templates:** Utilize pre-built templates for common use cases.\n*   **Access Control and Sharing:** Manage access permissions and share notebooks with team members.\n*   **Search and Filtering:** Find notebooks based on content, creator, and other criteria.\n*   **Export and Import:** Export notebooks as JSON for backup or sharing, and import JSON files to load content.\n*   **User Mentions:** Tag other team members within notebooks for collaboration.\n*   **Activity Logging:** Track changes and updates made to notebooks.\n*   **Scratchpad:** A personal, temporary notebook for quick note-taking.\n*   **Hyperlink Creation and Management:** Create, render, and interact with hyperlinks.\n"
    },
    {
        "path": "frontend/src/scenes/paths-v2/types.ts",
        "summary": "This code defines the data structures used to represent paths in the frontend application. It introduces three types: `PathsNode`, `PathsLink`, and `Paths`. `PathsNode` represents a node in the path, containing its name. `PathsLink` is imported from another module and likely represents a connection between two nodes. `Paths` combines these, containing an array of `PathsNode` and an array of `PathsLink` to define a complete path structure.\n\nHere's a list of high-level product features that could utilize these data structures:\n\n*   **Path Visualization:** Displaying a visual representation of paths, showing nodes and the connections between them.\n*   **Path Exploration:** Allowing users to explore different paths and their constituent nodes and links.\n*   **Path Analysis:** Providing tools to analyze paths, such as identifying the most common paths or bottlenecks.\n*   **Path Filtering/Search:** Enabling users to filter or search for specific paths or nodes within paths.\n*   **Path Editing/Creation:** Allowing users to create new paths or modify existing ones.\n"
    },
    {
        "path": "frontend/src/scenes/paths-v2/pathUtils.ts",
        "summary": "This code defines utility functions and interfaces for visualizing and interacting with path analysis data in a funnel or path report. It includes interfaces for representing path nodes and links, a function for generating rounded rectangles in SVG, a function for formatting and shortening URLs for display, and a function to determine if a path node represents a selected start or end point based on the applied filters.\n\nHere's a list of high-level product features that can be derived from this code:\n\n*   **Path Visualization:** Displaying user paths as a visual graph with nodes and links.\n*   **Funnel Path Analysis:** Filtering and highlighting paths based on funnel steps.\n*   **URL Formatting:** Displaying shortened and user-friendly URLs in the path visualization.\n*   **Path Selection:** Highlighting paths based on start and end points defined by user filters.\n*   **Conversion Time Display:** Showing the average conversion time between steps in a path.\n"
    },
    {
        "path": "frontend/src/scenes/paths-v2/pathsDataLogic.ts",
        "summary": "This code defines the `pathsDataLogic` using Kea, a state management library. This logic is responsible for fetching, processing, and providing data for displaying user paths in a visual format. It connects to other logic modules like `insightVizDataLogic` and `featureFlagLogic` to access relevant data and functionalities. The logic handles opening a persons modal to view users matching a specific path, and viewing a path as a funnel.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Path Visualization:** Displays user navigation paths as a graph, showing how users move between different pages or events.\n*   **Data Fetching and Processing:** Fetches path data from the backend and transforms it into a format suitable for visualization.\n*   **Filtering:** Allows filtering paths based on event types (page views, screen views, custom events).\n*   **User Identification:** Enables opening a modal to view the specific users who followed a particular path.\n*   **Path to Funnel Conversion:** Allows converting a selected path into a funnel insight for further analysis.\n"
    },
    {
        "path": "frontend/src/scenes/paths-v2/renderPaths.ts",
        "summary": "This code renders a Sankey diagram representing user paths on a web application. It uses the d3.js and d3-sankey libraries to create and manipulate the SVG elements. The diagram visualizes the flow of users between different events or pages, with nodes representing these events and links representing the transitions between them. The code handles node and link styling, including highlighting on hover, and integrates with a modal for displaying user details related to specific nodes. It also dynamically adjusts the canvas size based on the number of layers in the path.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Sankey Diagram Visualization:** Renders a Sankey diagram to visualize user paths.\n*   **Dynamic Canvas Resizing:** Adjusts the canvas size based on the number of layers in the path.\n*   **Node Highlighting:** Highlights nodes on hover to emphasize specific events.\n*   **Link Highlighting:** Highlights links on hover to emphasize transitions between events.\n*   **Node Styling:** Styles nodes based on whether they are start or end points in the path.\n*   **User Details Modal Integration:** Opens a modal to display user details related to specific nodes.\n*   **Interactive Elements:** Makes nodes and links interactive, responding to mouse events.\n*   **Customizable Appearance:** Allows customization of node and link appearance through CSS variables.\n"
    },
    {
        "path": "frontend/src/scenes/paths-v2/PathNodeLabel.tsx",
        "summary": "This component, `PathNodeLabel`, is responsible for rendering the label associated with each node in a Paths visualization. It displays the page URL of the node, the node's value (likely a count or metric), and provides a menu with actions such as setting the node as the path start or end point, excluding the node from the path, viewing a funnel based on the path, copying the node name, and opening a modal to view associated persons. The available actions in the menu depend on whether the user has the \"Advanced Paths\" feature enabled. The component also uses tooltips to display the full page URL and handles truncated paths.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Node Label Display:** Shows the page URL and value (count) for each node in the Paths visualization.\n*   **Path Start/End Point Setting:** Allows users to set a node as the starting or ending point of the path.\n*   **Path Exclusion:** Enables users to exclude specific nodes from the path analysis.\n*   **Funnel View:** Provides a way to view a funnel based on the selected path.\n*   **Copy Node Name:** Allows users to copy the page URL of a node to the clipboard.\n*   **Person Modal:** Opens a modal displaying persons associated with the node.\n*   **Advanced Paths Feature Check:** Conditionally displays advanced path options based on user feature availability.\n*   **Tooltip Display:** Shows the full page URL on hover for truncated labels.\n"
    },
    {
        "path": "frontend/src/scenes/paths-v2/PathsV2.tsx",
        "summary": "The `PathsV2` component visualizes user paths within a product, rendering a dynamic SVG canvas that represents user flows. It fetches path data, handles resizing, and renders nodes and connections based on the data. The component also manages loading and error states, displaying appropriate messages when data is unavailable or an error occurs. It leverages custom hooks for managing state and side effects, and utilizes a separate module (`renderPaths`) for the actual rendering logic. The component also allows users to click on nodes to open a modal with more information about the users who followed that path.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Path Visualization:** Renders a visual representation of user paths, showing how users navigate through the product.\n*   **Dynamic Canvas:** Adapts the visualization to different screen sizes using a resizable canvas.\n*   **Data Loading and Error Handling:** Displays loading states and error messages when fetching or processing path data.\n*   **Empty State Handling:** Shows a specific message when no path data is available.\n*   **Node Interaction:** Allows users to interact with nodes in the path visualization, potentially opening modals with more information.\n*   **Theming:** Supports custom themes for the path visualization, allowing for customization of colors and styles.\n*   **Funnel Paths Filter**: Supports filtering paths based on funnel criteria.\n"
    },
    {
        "path": "frontend/src/scenes/paths-v2",
        "summary": "The provided code collectively implements a comprehensive user path analysis and visualization tool. It fetches and processes path data, renders interactive Sankey diagrams representing user flows, and provides features for exploring, filtering, and analyzing these paths. Users can identify key navigation patterns, understand user behavior, and convert paths into funnels for deeper analysis. The system handles data loading, error states, and dynamic canvas resizing, ensuring a smooth user experience across different devices and screen sizes.\n\n**Features:**\n\n*   **Path Visualization:** Displays user navigation paths as an interactive Sankey diagram.\n*   **Path Exploration:** Allows users to explore different paths, nodes, and connections.\n*   **Path Filtering:** Enables filtering paths based on event types, funnel criteria, and start/end points.\n*   **Path Analysis:** Provides tools to analyze paths, identify common patterns, and understand user behavior.\n*   **Funnel Conversion:** Allows converting selected paths into funnels for further analysis.\n*   **User Identification:** Enables viewing the specific users who followed a particular path.\n*   **Interactive Elements:** Provides interactive nodes and links with highlighting and user details modals.\n*   **Customization:** Supports theming and customization of node and link appearance.\n*   **Data Handling:** Manages data fetching, processing, loading states, and error handling.\n"
    },
    {
        "path": "frontend/src/scenes/billing/InitialBillingLimitNotice.tsx",
        "summary": "The `InitialBillingLimitNotice` component displays a banner to users who are using the default initial billing limit for a specific product. The banner informs them about the limit, its purpose (preventing unexpected charges), and the potential consequences of exceeding it (feature limitations and data loss). It also provides a link to the billing settings page where they can change the limit. The component checks if a custom limit has been set and if the current limit matches the initial default limit before displaying the banner.\n\nHere's a list of high-level product features:\n\n*   **Billing Limit Notification:** Informs users when they are using the default initial billing limit.\n*   **Usage Protection:** Protects users from unexpected charges by setting a default billing limit.\n*   **Billing Settings Link:** Provides a direct link to the billing settings page to modify the limit.\n*   **Contextual Information:** Displays the current billing limit and explains the consequences of exceeding it.\n"
    },
    {
        "path": "frontend/src/scenes/billing/AuthorizationStatus.tsx",
        "summary": "The `AuthorizationStatus` component is a simple page displayed after a user enters payment information in the payment entry modal and is redirected back to the application. It uses a spinner overlay to indicate that a process is running in the background. The component calls the `pollAuthorizationStatus` action from the `paymentEntryLogic` to check the status of the payment authorization.\n\nHere's a list of high-level product features:\n\n*   **Payment Entry Modal:** Allows users to enter their payment information.\n*   **Payment Authorization Redirection:** Handles redirection to external URLs for payment authorization.\n*   **Authorization Status Polling:** Checks the status of the payment authorization in the background.\n*   **Loading Indicator:** Displays a spinner overlay to indicate that the authorization process is in progress.\n"
    },
    {
        "path": "frontend/src/scenes/billing/ExportsUnsubscribeTable/index.ts",
        "summary": "This code exports the `ExportsUnsubscribeTable` component and its associated logic from the `frontend/src/scenes/billing/ExportsUnsubscribeTable` directory. This suggests the existence of a table component related to unsubscribing from exports, likely within a billing context.\n\nHere's a list of high-level product features based on this code:\n\n*   **Exports Management:** The system allows users to manage data exports.\n*   **Unsubscribe Functionality:** Users can unsubscribe from specific data exports.\n*   **Billing Integration:** The unsubscribe functionality is likely tied to billing, potentially affecting subscription tiers or data usage limits.\n*   **Table View:** The unsubscribe options are presented in a tabular format for easy management.\n"
    },
    {
        "path": "frontend/src/scenes/billing/ProductPricingModal.tsx",
        "summary": "This component, `ProductPricingModal.tsx`, renders a modal that displays the pricing details for a specific product or addon. It fetches pricing tiers based on the selected plan and presents them in a user-friendly format, including volume discounts. The modal shows the starting price, free tier information (if applicable), and a breakdown of costs for each tier, ensuring transparency in pricing.\n\nHere's a list of high-level product features:\n\n*   **Modal Display:** Opens a modal to show product pricing details.\n*   **Pricing Tier Visualization:** Displays pricing tiers for a selected product plan.\n*   **Volume Discount Information:** Shows volume discounts available for the product.\n*   **Free Tier Indication:** Highlights if a free tier is available and describes its benefits.\n*   **Dynamic Pricing Display:** Dynamically calculates and displays prices based on the selected plan and tiers.\n*   **Currency Formatting:** Formats prices in USD with appropriate significant figures.\n"
    },
    {
        "path": "frontend/src/scenes/billing/UnsubscribeCard.tsx",
        "summary": "The `UnsubscribeCard` component in the billing section provides users with options to downgrade their current plan to the free plan. It informs users about the implications of downgrading, such as losing access to platform features and the immediate application of usage limits. The component also provides links to resources that help users control their costs, including documentation on reducing PostHog costs and the pricing page. Users can also directly contact support for billing-related inquiries. A button is provided to initiate the downgrade process, which also triggers a survey to understand the reason for downgrading.\n\nHere's a list of high-level features:\n\n*   **Plan Downgrade:** Allows users to downgrade their current plan to the free plan.\n*   **Usage Limit Warning:** Informs users about the immediate application of usage limits upon downgrading.\n*   **Cost Reduction Resources:** Provides links to documentation and support for reducing PostHog costs.\n*   **Support Access:** Enables users to contact support for billing-related inquiries.\n*   **Downgrade Survey:** Triggers a survey to collect feedback when a user downgrades their plan.\n"
    },
    {
        "path": "frontend/src/scenes/billing/BillingSummary.tsx",
        "summary": "The `BillingSummary` component provides a summary of the user's current billing information. It displays the current bill total, projected total, available credits, and applied discounts, along with the billing period. The component also includes a button to manage billing information via the Stripe portal. The displayed amounts are formatted in a human-friendly currency.\n\nHere's a list of high-level product features:\n\n*   **Display Current Bill Total:** Shows the user the amount they have been billed for the current billing period.\n*   **Display Projected Total:** Estimates the total bill for the current billing period based on current usage.\n*   **Display Available Credits:** Shows the user any credits available on their account and their expiration date, if applicable.\n*   **Display Applied Discount:** Shows the user any discounts applied to their current bill.\n*   **Display Billing Period:** Shows the start and end dates of the current billing period.\n*   **Stripe Portal Integration:** Provides a button that redirects the user to the Stripe portal to manage their billing information.\n"
    },
    {
        "path": "frontend/src/scenes/billing/StripePortalButton.tsx",
        "summary": "This component provides a button that links users to the Stripe Customer Portal, allowing them to manage their billing information. The button's text changes depending on whether the user has an active subscription. The button is only rendered if the user's billing information includes a Stripe customer ID and a Stripe portal URL.\n\nHere's a list of high-level product features:\n\n*   **Stripe Customer Portal Integration:** Allows users to manage their billing information (card details, invoices) through Stripe's customer portal.\n*   **Conditional Button Text:** The button text dynamically adapts based on the user's subscription status, providing contextually relevant actions.\n*   **Billing Information Check:** Ensures the button is only displayed when the necessary billing information (customer ID and portal URL) is available.\n"
    },
    {
        "path": "frontend/src/scenes/billing/billingProductAddonLogic.ts",
        "summary": "This code defines a Kea logic module called `billingProductAddonLogic` that is responsible for managing and displaying information about a specific billing product addon. It takes an `addon` object as a prop, which contains details about the addon such as its type, tiers, and current usage. The logic module then calculates and provides a list of \"gauge items\" that represent the free tier limit and current usage of the addon. These gauge items are used to display the addon's usage information in a user-friendly way.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Display Free Tier Limit:** Shows the maximum usage allowed within the free tier for a specific addon.\n*   **Display Current Usage:** Shows the current usage of a specific addon.\n*   **Abstraction of Addon Details:** Encapsulates the logic for retrieving and formatting addon-related information.\n*   **Gauge Item Representation:** Provides a structured format for representing addon usage data, suitable for visualization.\n"
    },
    {
        "path": "frontend/src/scenes/billing/BillingGauge.tsx",
        "summary": "The `BillingGauge` component visualizes billing usage by displaying a horizontal bar with segments representing different usage categories. Each segment's width corresponds to its proportion of the total usage, and tooltips provide detailed information about each category. The component dynamically adjusts the maximum value of the gauge and indicates whether the usage is within the defined limit. The `BillingGaugeItem` component renders individual bars within the gauge, displaying the usage amount and category name.\n\nHere's a list of high-level product features:\n\n*   **Usage Visualization:** Displays a horizontal bar representing total billing usage.\n*   **Categorized Usage Breakdown:** Segments the bar to show usage across different categories.\n*   **Dynamic Scaling:** Automatically adjusts the gauge's maximum value based on usage data.\n*   **Usage Limit Indication:** Visually indicates if usage is within the defined limit.\n*   **Detailed Tooltips:** Provides detailed usage information for each category on hover.\n*   **Addon Support:** Differentiates between base product usage and addon usage.\n"
    },
    {
        "path": "frontend/src/scenes/billing/types.ts",
        "summary": "The code defines types and enums related to billing information displayed in the frontend. It introduces an enum `BillingGaugeItemKind` to categorize different types of billing gauge items, such as free tier, current usage, projected usage, and billing limit. It also defines a `BillingGaugeItemType` which represents the structure of a single billing gauge item, including its type, text description, optional prefix, and numerical value. Lastly, it defines a `BillingSectionId` type which is a union of string literals representing the different sections of the billing page.\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **Billing Overview:** Displaying a summary of billing information.\n*   **Usage Tracking:** Monitoring and displaying current resource usage.\n*   **Projected Usage Forecasting:** Predicting future resource consumption and associated costs.\n*   **Billing Limit Management:** Setting and displaying billing limits to control spending.\n*   **Free Tier Monitoring:** Tracking usage within the free tier allowance.\n"
    },
    {
        "path": "frontend/src/scenes/billing/paymentEntryLogic.ts",
        "summary": "This code defines the `paymentEntryLogic` using Kea, a state management library. It handles the process of initiating and authorizing payments, including setting up the client secret, managing loading and error states, polling for payment status, and handling redirects upon success or failure. It also manages the visibility of a payment entry modal and integrates with user, organization, and billing data.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Payment Initiation:** Allows users to initiate the payment process.\n*   **Payment Authorization:** Handles the authorization of payments through a third-party payment provider.\n*   **Payment Status Polling:** Continuously checks the status of a payment until it succeeds, fails, or times out.\n*   **Error Handling:** Displays error messages to the user if the payment process fails.\n*   **Loading State Management:** Shows a loading indicator while the payment process is in progress.\n*   **Redirection Handling:** Redirects the user to a specified path upon successful payment.\n*   **Payment Entry Modal:** Provides a modal for entering payment information.\n*   **Integration with User, Organization, and Billing Data:** Updates user, organization, and billing information upon successful payment.\n"
    },
    {
        "path": "frontend/src/scenes/billing/ExportsUnsubscribeTable/ExportsUnsubscribeTable.tsx",
        "summary": "The `ExportsUnsubscribeTable` component displays a table of items (plugins, batch exports, or Hog functions) that can be disabled within a PostHog organization. It fetches data using `exportsUnsubscribeTableLogic` and `organizationLogic` to display the item's icon, name (as a link), associated project, and a button to disable the item. The button's state (enabled/disabled) and text reflect the current status of the item.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Display of Disablable Items:** Shows a list of plugins, batch exports, and Hog functions that can be disabled.\n*   **Item Details:** Displays the name, description, and associated project for each item.\n*   **Disable Functionality:** Provides a button to disable each item (plugin, batch export, or Hog function).\n*   **Status Indication:** Indicates whether an item is currently enabled or disabled.\n*   **Loading State:** Shows a loading indicator while fetching data.\n*   **Organization Context:** Uses the current organization to display project names.\n"
    },
    {
        "path": "frontend/src/scenes/billing/BillingLimit.tsx",
        "summary": "This React component, `BillingLimit`, allows users to manage their billing limits for a specific product within a monthly billing cycle. It displays the current billing limit, if set, and provides options to edit, set, or remove the limit. When editing, a numeric input field is presented, allowing the user to specify a new limit, which can then be saved or canceled. Tooltips provide context about the purpose and implications of setting a billing limit.\n\nHere's a list of high-level product features:\n\n*   **Display Current Billing Limit:** Shows the user their currently set billing limit for a given product.\n*   **Set Billing Limit:** Allows users to define a custom spending limit for a product on a monthly basis.\n*   **Edit Billing Limit:** Enables users to modify an existing billing limit.\n*   **Remove Billing Limit:** Gives users the option to remove a previously set billing limit.\n*   **Real-time Input Validation:** Provides immediate feedback on the entered billing limit value.\n*   **Loading State:** Indicates when the billing limit update is in progress.\n*   **Informative Tooltips:** Explains the purpose and implications of setting or modifying billing limits.\n*   **Default Initial Billing Limit:** Informs the user of the default initial billing limit.\n"
    },
    {
        "path": "frontend/src/scenes/billing/BillingProductAddonActions.tsx",
        "summary": "This code defines the `BillingProductAddonActions` component, which renders the appropriate actions a user can take for a specific billing product add-on. The actions rendered depend on the user's current subscription status, trial eligibility, and the add-on's configuration. It handles scenarios such as subscribing to an add-on, starting or canceling a trial, viewing pricing, or contacting support. The component also displays relevant pricing information, including prorated amounts when applicable.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Add-on Subscription Management:** Allows users to subscribe to and unsubscribe from add-ons.\n*   **Free Trial Management:** Enables users to start and cancel free trials for add-ons.\n*   **Pricing Information Display:** Shows pricing details for add-ons, including flat rates and prorated amounts.\n*   **Trial Status Indication:** Displays the status of a user's free trial for a specific add-on.\n*   **Contact Support Option:** Provides a button to contact support for add-ons that require it.\n*   **Plan Inclusion Indication:** Shows when an add-on is already included in the user's current plan.\n*   **Upgrade Path Initiation:** Guides users through the process of upgrading their plan to include specific add-ons.\n"
    },
    {
        "path": "frontend/src/scenes/billing/PurchaseCreditsModal.tsx",
        "summary": "This code defines a modal component, `PurchaseCreditsModal`, that allows users to prepay for usage credits and receive a discount. The modal displays information about estimated monthly credit usage, allows users to input the desired amount of credits to purchase, shows a gauge indicating discount tiers based on the purchase amount, and provides a summary of the purchase, including discounts and the total amount due. Users can choose their payment method and submit the form to purchase the credits.\n\nHere's a list of high-level product features:\n\n*   **Credit Purchase:** Allows users to purchase credits in advance.\n*   **Discount Tiers:** Offers discounts on credit purchases based on the amount purchased.\n*   **Usage Estimation:** Provides an estimate of monthly credit usage based on historical data.\n*   **Payment Method Selection:** Allows users to choose their preferred payment method (credit card or invoice).\n*   **Purchase Summary:** Displays a summary of the purchase, including discounts and the total amount due.\n*   **Support Link:** Provides a link to open a support form for billing-related inquiries.\n*   **Credit Input:** Allows users to specify the amount of credits they want to purchase.\n*   **Credit Gauge:** Visual representation of discount tiers based on credit input."
    },
    {
        "path": "frontend/src/scenes/billing/PaymentEntryModal.tsx",
        "summary": "The `PaymentEntryModal.tsx` file defines a modal that allows users to enter their payment information using Stripe. It dynamically loads Stripe.js when the modal is opened and initiates an authorization process. The modal includes a form for entering payment details, displays a temporary $0.50 hold message, handles payment submission, and displays any errors. It also includes a loading state while contacting the \"Hedgehogs\" for approval.\n\nHere's a list of high-level product features:\n\n*   **Payment Information Entry:** Allows users to securely enter their credit card or other payment details.\n*   **Stripe Integration:** Uses Stripe.js and Stripe Elements for secure payment processing.\n*   **Dynamic Stripe Loading:** Loads Stripe.js only when the payment modal is opened to improve initial page load time.\n*   **Payment Authorization:** Initiates a payment authorization process to verify the payment method.\n*   **Temporary Hold Verification:** Informs users about a temporary $0.50 hold for card verification.\n*   **Error Handling:** Displays error messages to the user if there are issues with the payment submission.\n*   **Loading State:** Shows a loading animation while waiting for payment authorization.\n*   **Modal Presentation:** Presents the payment form within a modal for a clean user experience.\n*   **Cancellation:** Allows users to cancel the payment entry process.\n"
    },
    {
        "path": "frontend/src/scenes/billing/CreditCTAHero.tsx",
        "summary": "The `CreditCTAHero` component is a call-to-action banner displayed to users to encourage them to purchase credits for their PostHog usage and save money. It dynamically adjusts its content based on the user's credit status, displaying information about pending credit applications or highlighting potential savings from prepaying for credits. The component also provides options to view invoices, learn more about purchasing credits, or contact sales for enterprise tier benefits. The banner can be dismissed by the user, with an option to restore it later.\n\nHere's a list of high-level product features implemented by the component:\n\n*   **Credit Purchase Incentive:** Displays a banner to encourage users to purchase credits and save money.\n*   **Dynamic Content Based on Credit Status:** Adjusts the displayed message based on whether the user has pending credits or no credits.\n*   **Estimated Savings Calculation:** Calculates and displays the estimated monthly and yearly savings from purchasing credits.\n*   **Invoice Viewing:** Provides a button to view the invoice for pending credit applications.\n*   **Purchase Credits Modal:** Opens a modal to allow users to purchase credits.\n*   **Dismissible Banner:** Allows users to dismiss the banner, with an option to restore it.\n*   **Enterprise Tier Promotion:** Promotes the Enterprise tier and provides a link to contact sales.\n"
    },
    {
        "path": "frontend/src/scenes/billing/BillingProductPricingTable.tsx",
        "summary": "This component, `BillingProductPricingTable`, displays a detailed breakdown of billing information for a specific product or addon. It uses a tiered table structure to show pricing per unit, current usage, total cost, and projected total, potentially including addon costs. The table dynamically adjusts based on the product type and whether addons are included, displaying a total row and handling potential discounts. It also includes expandable rows to show a breakdown of the base price and addon costs for each tier.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Tiered Pricing Display:** Shows pricing tiers based on usage volume.\n*   **Addon Cost Breakdown:** Displays costs associated with subscribed addons.\n*   **Usage Tracking:** Shows current usage for each tier.\n*   **Cost Calculation:** Calculates and displays total and projected costs.\n*   **Discount Application:** Applies and displays discounts on total costs.\n*   **Dynamic Table Structure:** Adapts the table structure based on product type and addon availability.\n*   **Expandable Rows:** Provides detailed breakdown of costs within each tier.\n*   **Total Cost Summary:** Displays a summary row with total and projected costs.\n*   **Data Visualization:** Presents billing data in a clear and organized table format.\n"
    },
    {
        "path": "frontend/src/scenes/billing/BillingHero.tsx",
        "summary": "The `BillingHero` component displays a hero section on the billing page, providing information and calls to action based on the user's current billing plan and startup program status. It dynamically renders content based on the user's plan (Free, Paid, Teams, Enterprise, Startup, YC), offering upgrade options, plan comparisons, and relevant information. The component uses feature flags to determine which upgrade flow to use (in-app payment entry or redirect to product link).\n\nHere's a list of high-level product features implemented in the code:\n\n*   **Dynamic Content based on Billing Plan:** Display different messages, badges, and upgrade options based on the user's current billing plan (Free, Paid, Teams, Enterprise).\n*   **Startup Program Support:** Display specific messages and badges for users on Startup or YC plans.\n*   **Upgrade Call to Action:** Provide a prominent \"Upgrade now\" button that either triggers an in-app payment entry modal or redirects the user to a product upgrade link.\n*   **Plan Comparison Modal:** Allow users to compare different billing plans and their features.\n*   **Feature Flag Controlled Upgrade Flow:** Use feature flags to switch between different upgrade flows (in-app payment entry vs. redirect to product link).\n*   **Managed Account Handling:** Disable upgrade options for managed accounts.\n*   **Contextual Information:** Display relevant information and links based on the user's plan and startup program status, such as links to the Founders Club for YC users.\n"
    },
    {
        "path": "frontend/src/scenes/billing/BillingProductAddon.tsx",
        "summary": "This code defines a React component, `BillingProductAddon`, which displays information and actions related to a specific product addon within a billing context. It fetches data and actions using Kea logic hooks, including details about the addon, current plan, upgrade plans, and trial status. The component renders the addon's name, description, features, and subscription status, along with actions like upgrading the plan or managing the subscription. It also includes modals for viewing pricing details, completing an unsubscribe survey, and starting a trial. For mobile replay addons, it displays a usage gauge and pricing table.\n\nHere's a list of high-level product features implemented by the code:\n\n*   **Addon Information Display:** Shows the addon's name, description, icon, and subscription status.\n*   **Feature List:** Displays a list of features included in the addon.\n*   **Subscription Management:** Allows users to subscribe to or unsubscribe from the addon.\n*   **Pricing Information:** Provides access to a modal displaying detailed pricing information for the addon.\n*   **Trial Management:** Supports starting and managing trials for the addon, including a modal with trial details.\n*   **Usage Gauge (Mobile Replay):** Visualizes the usage of mobile replay addons with a gauge.\n*   **Pricing Table (Mobile Replay):** Displays a pricing table for mobile replay addons, showing tier breakdowns.\n*   **Unsubscribe Survey:** Presents a survey to users who are unsubscribing from the addon.\n*   **Contextual Actions:** Provides actions specific to the addon, such as upgrading the plan or contacting support.\n"
    },
    {
        "path": "frontend/src/scenes/billing/BillingProduct.tsx",
        "summary": "The `BillingProduct` component displays billing information for a specific product, including usage, limits, and pricing. It fetches data using Kea logic and displays it using Lemon UI components. The component handles scenarios such as exceeding limits, temporary free products, and custom plans. It also provides options for upgrading, unsubscribing, and contacting support. The component conditionally renders elements based on feature flags and subscription status.\n\nHere's a list of high-level product features:\n\n*   **Usage Display:** Shows current usage of the product with a gauge.\n*   **Limit Alerts:** Displays a banner if the usage exceeds the limit.\n*   **Tier Breakdown:** Allows users to view a detailed breakdown of pricing tiers.\n*   **Subscription Management:** Provides options to upgrade, unsubscribe, or contact support.\n*   **Documentation Links:** Links to the product's documentation.\n*   **Pricing Information:** Displays pricing information and allows users to open a pricing modal.\n*   **Free Product Handling:** Handles products offered for free to beta users.\n*   **Custom Plan Support:** Provides specific options for custom plans.\n*   **Enterprise Feature Promotion:** Promotes enterprise features and encourages users to contact sales.\n*   **Discount Display:** Shows the discounted amount billed.\n*   **Unsubscribe Survey:** Allows users to complete a survey when unsubscribing.\n"
    },
    {
        "path": "frontend/src/scenes/billing/UnsubscribeSurveyModal.tsx",
        "summary": "The `UnsubscribeSurveyModal` component is a modal that appears when a user attempts to unsubscribe from a PostHog product or addon. It presents a survey to gather feedback on the reason for unsubscribing, offers options to reduce costs or contact support, and handles the deactivation of the product or addon. It also includes a fun \"Hedgehog Step\" if the user selects \"Not enough hedgehogs\" as a reason, offering more hedgehogs or a direct unsubscribe option. The modal adapts its text and actions based on whether the user is unsubscribing from an addon or a full product, and whether they are on a paid subscription.\n\nHere's a list of high-level product features:\n\n*   **Unsubscribe Survey:** Presents a survey with predefined reasons and a text area for additional feedback when a user attempts to unsubscribe.\n*   **Dynamic Actions:** Adapts the unsubscribe action (e.g., \"Unsubscribe,\" \"Remove addon,\" \"Downgrade\") and messaging based on the product type and subscription level.\n*   **Cost Reduction and Support Options:** Offers links to documentation on reducing costs and provides a direct link to contact support.\n*   **Hedgehog Step:** A playful step triggered by a specific survey response, offering more hedgehogs or a direct unsubscribe option.\n*   **Data Pipeline Handling:**  For users with data pipelines, prompts them to disable export apps before unsubscribing to avoid data loss.\n*   **Error Handling:** Displays error messages if the unsubscribe process fails.\n*   **Modal Management:** Controls the visibility and steps of the unsubscribe modal.\n*   **Hogfetti Integration:** Triggers a confetti animation upon successful unsubscription (handled by the `useHogfetti` hook).\n"
    },
    {
        "path": "frontend/src/scenes/billing/ExportsUnsubscribeTable/exportsUnsubscribeTableLogic.tsx",
        "summary": "This code defines a Kea logic module named `exportsUnsubscribeTableLogic` that manages the state and actions related to disabling or pausing various data export mechanisms within PostHog. It fetches and displays a list of plugin configurations, batch exports, and Hog Functions that can be disabled, along with their status and relevant information. The logic provides actions to disable plugins, pause batch exports, and disable Hog Functions, updating the UI accordingly. It also determines a reason why the user might not be able to unsubscribe.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Display of Export Mechanisms:** Shows a table or list of active data export mechanisms, including plugins, batch exports, and Hog Functions.\n*   **Status Indication:** Indicates whether each export mechanism is currently enabled or disabled/paused.\n*   **Disabling Plugins:** Allows users to disable individual plugin configurations.\n*   **Pausing Batch Exports:** Allows users to pause individual batch export configurations.\n*   **Disabling Hog Functions:** Allows users to disable individual Hog Functions.\n*   **Dependency Management:** Prevents users from unsubscribing from exports if there are active plugins or batch exports.\n*   **Loading State:** Provides a loading indicator while fetching data.\n*   **Permissions Check:** Checks user permissions before allowing disabling of plugins.\n"
    },
    {
        "path": "frontend/src/scenes/billing/billingLogic.tsx",
        "summary": "This code defines the `billingLogic` Kea logic which manages the billing information and interactions for a PostHog instance. It handles fetching billing details, updating billing limits, deactivating products, and managing billing-related alerts and errors. The logic also integrates with other parts of the application, such as feature flags, preflight checks, user and organization data, and event usage tracking. It provides functionality for displaying alerts related to usage limits, managing credit purchases, and handling unsubscribe errors.\n\nHere's a list of high-level product features managed by this logic:\n\n*   **Billing Information Display:** Fetches and displays current billing information, including billing period, free trial status, and discounts.\n*   **Billing Limit Management:** Allows users to view and update their billing limits.\n*   **Product Deactivation:** Enables users to unsubscribe from specific PostHog products.\n*   **Billing Alerts:** Displays alerts related to billing issues, such as open invoices or approaching usage limits.\n*   **Credit Purchase:** Supports the purchase of additional credits.\n*   **Error Handling:** Manages and displays errors related to billing operations, such as failed invoice payments or missing payment methods.\n*   **Usage Limit Monitoring:** Monitors event usage and displays warnings when approaching or exceeding limits.\n*   **Discount Management:** Computes and displays applicable discounts.\n*   **Instrumentation:** Tracks user interactions with billing-related features.\n*   **Onboarding Redirection:** Handles redirection during the onboarding process."
    },
    {
        "path": "frontend/src/scenes/billing/ExportsUnsubscribeTable",
        "summary": "The `ExportsUnsubscribeTable` component and its associated logic provide a user interface for managing and disabling various data export mechanisms within PostHog, including plugins, batch exports, and Hog functions. The component displays a table of these items, indicating their status (enabled/disabled), associated project, and provides actions to disable or pause them. The system also manages dependencies, preventing users from unsubscribing if there are active plugins or batch exports that rely on them, and checks user permissions before allowing disabling of plugins.\n\nHere's a list of high-level product features:\n\n*   Display of Disablable Items (plugins, batch exports, Hog functions)\n*   Item Details (name, description, associated project)\n*   Disable Functionality (for plugins, batch exports, Hog functions)\n*   Status Indication (enabled/disabled)\n*   Loading State\n*   Organization Context\n*   Dependency Management (prevents unsubscribing from exports with active dependencies)\n*   Permissions Check (before disabling plugins)\n*   Exports Management\n*   Unsubscribe Functionality\n*   Billing Integration (potentially affecting subscription tiers or data usage limits)\n*   Table View\n"
    },
    {
        "path": "frontend/src/scenes/billing/BillingOverview.tsx",
        "summary": "The `BillingOverview` component in the PostHog frontend displays a basic billing overview page. Currently, it includes a heading \"Billing Overview\" and an informational banner indicating that the section is under construction. This suggests that the page is a placeholder for a more comprehensive billing management interface.\n\n**Features:**\n\n*   **Billing Overview Page:** A dedicated page to display billing-related information.\n*   **Under Construction Indicator:** A banner to inform users that the page is not yet fully functional.\n"
    },
    {
        "path": "frontend/src/scenes/billing/BillingUsage.tsx",
        "summary": "The `BillingUsage` component in the PostHog frontend displays a placeholder page for usage details related to billing. Currently, it shows a heading \"Usage Details\" and an informational banner indicating that the section is under construction.\n\n**Features:**\n\n*   **Display Usage Details:** The component aims to provide users with a view of their product usage relevant to billing.\n*   **Under Construction Banner:** Informs users that the usage details section is not yet fully implemented.\n"
    },
    {
        "path": "frontend/src/scenes/billing/BillingSection.tsx",
        "summary": "The `BillingSection` component provides a user interface for managing billing information within an organization. It features a navigation sidebar with links to \"Overview\" and \"Usage\" sections. The component dynamically renders either the `BillingOverview` or `BillingUsage` component based on the currently selected section, determined by the URL path. It also redirects the user to the overview page if they navigate to the base billing URL.\n\nHere's a list of high-level product features:\n\n*   **Billing Overview:** Displays general billing information and settings.\n*   **Usage Tracking:** Provides insights into resource consumption and usage patterns.\n*   **Section Navigation:** Allows users to switch between different billing sections (Overview, Usage) via a sidebar menu.\n*   **URL-Based Routing:** Uses URL paths to determine the active billing section.\n*   **Automatic Redirection:** Redirects users to the overview page if they access the base billing URL."
    },
    {
        "path": "frontend/src/scenes/billing/BillingPopup.tsx",
        "summary": "The `BillingPopup.tsx` file defines a function `openBillingPopupModal` that opens a modal dialog using the `LemonDialog` component. This modal displays the `Billing` component, allowing users to interact with billing-related functionalities. The modal's title and description are customizable, and it includes a \"Maybe later...\" button to dismiss the dialog. The modal has a fixed width of 800 pixels.\n\nHere's a list of high-level product features:\n\n*   **Billing Information Display:** Shows billing details to the user.\n*   **Modal Dialog:** Presents billing information in a modal popup.\n*   **Customizable Title and Description:** Allows setting a custom title and description for the billing popup.\n*   **Dismissible Dialog:** Provides a \"Maybe later...\" button to close the billing popup.\n"
    },
    {
        "path": "frontend/src/scenes/billing/billing-utils.ts",
        "summary": "This code provides utility functions for handling billing calculations and displaying billing information. It includes functions for summarizing usage, projecting usage based on the billing period, converting usage to an amount based on tiered pricing, converting an amount to usage, generating a link to upgrade a product, converting large numbers to words for display, and calculating proration amounts. These utilities are essential for displaying accurate and understandable billing information to users.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Usage Summarization:** Displaying usage in a human-readable format (e.g., \"1.5 thousand\" instead of \"1500\").\n*   **Usage Projection:** Estimating future usage based on current trends within the billing period.\n*   **Tiered Pricing Calculation:** Calculating the cost based on tiered pricing models, including add-ons and discounts.\n*   **Usage Calculation from Amount:** Determining the amount of usage a user can get for a given amount of money.\n*   **Product Upgrade Links:** Generating links to upgrade to different billing products.\n*   **Large Number Conversion:** Converting large numbers to words for better readability in billing displays.\n*   **Proration Calculation:** Calculating prorated amounts for billing periods that are not complete.\n*   **Proration Messaging:** Displaying messages to users about prorated amounts and future billing cycles."
    },
    {
        "path": "frontend/src/scenes/billing/PlanComparison.tsx",
        "summary": "This code defines a React component called `PlanComparison` that displays a table comparing different billing plans for a given product. The table shows the monthly price, tiered pricing (if applicable), available add-ons, and a comparison of features across the plans. It fetches billing information, product details, and feature flags to dynamically render the table content, including proration details, add-on availability, and feature limitations. The component uses tooltips to provide additional information about features and add-ons, and it adjusts the layout based on screen size.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Plan Comparison Table:** Displays a comparison of different billing plans.\n*   **Monthly Pricing:** Shows the monthly base price for each plan.\n*   **Tiered Pricing:** Displays pricing tiers for usage-based products and add-ons.\n*   **Add-on Support:** Lists available add-ons and their pricing for each plan.\n*   **Feature Comparison:** Compares features across different plans using icons and descriptions.\n*   **Proration Display:** Calculates and displays proration amounts for plan upgrades or changes.\n*   **Responsive Layout:** Adapts the layout based on screen size.\n*   **Tooltips:** Provides additional information about features and add-ons.\n*   **Addon Inclusions:** Displays whether an addon is an inclusion or an add-on.\n*   **Free Allocation:** Displays the amount of free allocation for a product."
    },
    {
        "path": "frontend/src/scenes/billing/Billing.tsx",
        "summary": "The Billing page in PostHog allows organization admins to manage their subscription and billing details. It displays billing summaries, product details, and options to manage payment methods. Users can activate license keys, view trial information, and access a Stripe portal for payment management. The page also handles error scenarios, access restrictions, and provides links to support or sales.\n\nHere's a list of high-level product features implemented in the Billing page:\n\n*   **Billing Summary Display:** Shows a summary of the current billing status and subscription details.\n*   **Product Details:** Displays a list of PostHog products and their associated billing plans.\n*   **Stripe Portal Integration:** Provides a button to redirect users to the Stripe portal for managing payment methods and billing information.\n*   **License Key Activation:** Allows users to activate PostHog licenses directly via a license key input form.\n*   **Trial Information:** Displays information about active trials, including expiration dates and plan details.\n*   **Error Handling:** Shows error banners for billing-related issues and provides links to support or sales.\n*   **Access Control:** Restricts access to the billing page to organization admins.\n*   **Unsubscribe Functionality:** Allows users on paid plans to unsubscribe from their current plan.\n*   **Credit CTA Hero:** Displays a call to action related to credits.\n*   **Billing Hero:** Displays a hero section with information about the billing plan."
    },
    {
        "path": "frontend/src/scenes/billing/billingProductLogic.ts",
        "summary": "This code defines the `billingProductLogic` Kea logic, which manages the state and actions related to individual billing products within the PostHog application. It handles functionalities such as editing billing limits, displaying tier breakdowns, managing pricing and plan comparison modals, collecting survey responses for churn reasons, initiating product upgrades, managing trial periods, and handling product deactivation. The logic also calculates and displays billing gauge items, determines if a product is an addon, and manages the unsubscribe modal flow.\n\nHere's a list of high-level product features managed by this logic:\n\n*   **Billing Limit Management:** Allows users to view, edit, and set custom billing limits for individual products.\n*   **Tier Breakdown Display:** Enables users to view a detailed breakdown of billing tiers for a product.\n*   **Pricing and Plan Comparison:** Provides modals for comparing different pricing plans and features.\n*   **Churn Survey:** Collects user feedback and reasons for unsubscribing from a product.\n*   **Product Upgrades:** Initiates and manages the process of upgrading to a higher billing plan.\n*   **Trial Management:** Allows users to activate or cancel trial periods for products.\n*   **Product Deactivation:** Handles the deactivation process for a product, including survey submission.\n*   **Billing Gauges:** Displays visual representations of billing limits, free tier usage, projected usage, and current usage.\n*   **Addon Product Handling:** Identifies and manages billing logic specific to addon products.\n*   **Unsubscribe Modal Flow:** Manages the steps and state of the unsubscribe modal."
    },
    {
        "path": "frontend/src/scenes/billing",
        "summary": "The provided code snippets detail a comprehensive billing system within a product, focusing on transparency, user control, and ease of management. The system provides users with clear insights into their current and projected usage, costs, and available credits. It empowers them to manage their subscriptions, set billing limits, purchase credits, and understand the implications of downgrading or unsubscribing. The system also offers proactive notifications, such as alerts for approaching usage limits and incentives for purchasing credits, and integrates with third-party services like Stripe for secure payment processing.\n\nHere's a list of high-level product features:\n\n*   **Billing Information Display:** Provides a clear and concise summary of current billing status, including totals, credits, discounts, and billing period.\n*   **Usage Tracking & Projection:** Monitors and displays current resource usage, projects future consumption, and alerts users to potential overages.\n*   **Billing Limit Management:** Allows users to set, edit, and remove custom spending limits for individual products to control costs.\n*   **Subscription Management:** Enables users to subscribe to, unsubscribe from, and manage add-ons and plans.\n*   **Payment Management:** Integrates with Stripe to securely manage payment methods and billing information.\n*   **Credit Purchase:** Offers the option to purchase credits in advance and receive discounts.\n*   **Plan Comparison:** Provides a detailed comparison of different billing plans and their features.\n*   **Unsubscribe Flow:** Guides users through the unsubscription process, including surveys and cost reduction options.\n*   **Alerts & Notifications:** Proactively informs users about billing issues, approaching limits, and potential savings.\n*   **Reporting & Analytics:** Provides detailed billing reports and analytics to help users understand their spending.\n*   **Stripe Portal Integration:** Allows users to manage their billing information (card details, invoices) through Stripe's customer portal.\n*   **Free Trial Management:** Enables users to start and cancel free trials for add-ons.\n*   **Add-on Management:** Allows users to subscribe to and unsubscribe from add-ons.\n*   **Dynamic Content based on Billing Plan:** Display different messages, badges, and upgrade options based on the user's current billing plan.\n*   **Data Export Management:** Allows users to manage and disable various data export mechanisms.\n*   **License Key Activation:** Allows users to activate PostHog licenses directly via a license key input form.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/data-warehouse/OnboardingDataWarehouseSourcesStep.tsx",
        "summary": "This React component, `OnboardingDataWarehouseSourcesStep`, is a step within a larger onboarding flow, specifically focused on guiding users to connect data sources to their data warehouse. It leverages the `NewSourcesWizard` component to facilitate the connection process, allowing users to link data from various sources like CRMs, payment processors, and databases. The step provides context and instructions, and upon successful completion of the data source connection, it advances the user to the next step in the onboarding process.\n\nHere's a list of high-level product features:\n\n*   **Data Source Connection Onboarding:** Guides users through connecting external data sources to their data warehouse during the onboarding process.\n*   **New Sources Wizard Integration:** Uses a dedicated wizard component to simplify the data source connection process.\n*   **Support for Multiple Data Sources:** Enables users to connect data from various sources, including CRMs, payment processors, and databases.\n*   **Step-by-Step Guidance:** Provides clear instructions and context for each step of the data source connection process.\n*   **Onboarding Flow Integration:** Seamlessly integrates with the overall onboarding flow, automatically advancing users to the next step upon completion.\n*   **Skip Option:** Allows users to skip the data source connection step during the initial stage of the wizard.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/data-warehouse",
        "summary": "The `OnboardingDataWarehouseSourcesStep` component streamlines the process of connecting data sources to a user's data warehouse as part of the initial onboarding experience. By integrating the `NewSourcesWizard`, it offers a user-friendly interface for linking various data sources such as CRMs, payment processors, and databases, providing step-by-step guidance and the option to skip the connection process during the initial wizard stage. Upon successful connection, the component automatically advances the user to the next onboarding step, ensuring a smooth and efficient setup.\n\nHere's a list of high-level product features:\n\n*   Data Source Connection Onboarding\n*   New Sources Wizard Integration\n*   Support for Multiple Data Sources\n*   Step-by-Step Guidance\n*   Onboarding Flow Integration\n*   Skip Option\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/SDKSnippet.tsx",
        "summary": "The `SDKSnippet` component displays instructions for integrating PostHog with a specific SDK. It shows the SDK's name as a heading, provides a link to the SDK's documentation, and renders the SDK-specific integration instructions provided as a prop.\n\nHere's a list of high-level features:\n\n*   **SDK Integration Instructions:** Displays instructions tailored to integrate PostHog with a specific SDK.\n*   **SDK Name Display:** Shows the name of the SDK being integrated.\n*   **Documentation Link:** Provides a direct link to the official documentation for the SDK.\n*   **Customizable Instructions:** Accepts a function (`sdkInstructions`) as a prop to render SDK-specific instructions.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/OnboardingInstallStep.tsx",
        "summary": "This code defines a React component called `OnboardingInstallStep` that conditionally renders either the `AlternativeSDKs` or `SDKs` component based on the `ONBOARDING_NEW_INSTALLATION_STEP` feature flag. It serves as a step in the onboarding process, likely guiding users through the installation of an SDK. The component receives props that are passed down to the rendered SDK component.\n\nHere's a list of high-level product features:\n\n*   **Conditional SDK Installation Steps:** Dynamically display different SDK installation steps based on feature flags.\n*   **Alternative SDK Options:** Provides users with alternative SDK installation methods or options.\n*   **Standard SDK Installation:** Guides users through the standard SDK installation process.\n*   **Feature Flag Controlled Onboarding:** Uses feature flags to control and experiment with different onboarding flows.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/python.tsx",
        "summary": "This code defines a React component called `SDKInstallPythonInstructions` that provides instructions for installing and configuring the PostHog Python SDK. It displays two code snippets: one for installing the SDK using `pip install posthog`, and another for configuring the SDK with the project API key and PostHog host. The API key is dynamically retrieved from the current team's settings.\n\nHere's a list of high-level product features:\n\n*   **SDK Installation Instructions:** Provides code snippets for installing the PostHog Python SDK.\n*   **SDK Configuration Instructions:** Provides code snippets for configuring the PostHog Python SDK with the project API key and host.\n*   **Dynamic API Key Injection:** Dynamically injects the current team's API key into the configuration code snippet.\n*   **Copy-Paste Ready Code Snippets:** Presents code snippets in a format that is easy to copy and paste into a Python project.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/OnboardingLiveEvents.tsx",
        "summary": "The `OnboardingLiveEvents` component displays a table of live events to the user, specifically designed for onboarding. It uses the `liveEventsTableLogic` to fetch the latest events and renders them in a `LemonTable` with columns for \"Event\" and \"Time\". The \"Event\" column shows a visual indicator of a live event and links to event details, while the \"Time\" column displays the event timestamp with timezone information. Only the first event is displayed in the table, and the table headers are hidden.\n\nHere's a list of high-level product features:\n\n*   **Live Event Display:** Shows a table of live events.\n*   **Event Details:** Displays the event name with a link to more information.\n*   **Timestamp Display:** Shows the event timestamp with timezone information.\n*   **Real-time Indicator:** Indicates that the events are live with a visual cue.\n*   **Onboarding Focus:** Designed specifically for the onboarding experience, showing only the most recent event."
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/framer.tsx",
        "summary": "This code provides instructions for installing the PostHog web snippet into a Framer project. It guides the user through the process of accessing the Framer project settings, locating the custom code section, and pasting the PostHog snippet into the designated area within the `<head>` tag. The instructions also highlight the need for a minimum \"Mini\" site plan to enable custom code injection.\n\n**Features:**\n\n*   Displays instructions for installing the PostHog web snippet in a Framer project.\n*   Provides a code snippet component (`JSSnippet`) to display the user's PostHog snippet.\n*   Guides the user to the correct location within Framer's settings to inject the code.\n*   Informs the user about the minimum Framer site plan required for custom code injection.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/android.tsx",
        "summary": "This code provides React components for displaying Android SDK installation instructions for PostHog. It includes code snippets for installing the PostHog Android library using Gradle, configuring the SDK with the API key and host, and optionally enabling session replay with configuration options for masking images and text. Additionally, it shows how to manually track screen views using the `screen` function.\n\nHere's a list of high-level product features:\n\n*   **Android SDK Installation Instructions:** Provides code snippets for installing the PostHog Android SDK.\n*   **SDK Configuration:** Shows how to configure the SDK with the API key and host URL.\n*   **Session Replay Configuration:** Demonstrates how to enable and configure session replay, including options for masking sensitive data.\n*   **Manual Screen Tracking:** Provides code for manually tracking screen views using the `screen` function.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/bubble.tsx",
        "summary": "This code provides instructions for installing the PostHog web snippet on a Bubble website. It guides the user through copying the snippet, navigating to the Bubble site settings, specifically the SEO/metatags tab, and pasting the snippet into the header section. It also emphasizes the need for a Starter site plan or higher to enable custom code injection and deploying the site to live for the changes to take effect.\n\nHere's a list of high-level product features:\n\n*   **Installation Instructions:** Provides step-by-step instructions for installing the PostHog web snippet on a Bubble website.\n*   **Snippet Display:** Displays the user's PostHog web snippet for easy copying.\n*   **Bubble Specific Guidance:** Offers guidance tailored to the Bubble platform, including navigation and plan requirements.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/webflow.tsx",
        "summary": "This code provides instructions for installing the PostHog web snippet into a Webflow website. It guides the user to copy the JavaScript snippet from PostHog and then paste it into the \"Head code\" section of the Webflow site's custom code settings. The instructions also highlight the need for a Basic Webflow plan (or higher) to enable custom code injection and instruct the user to publish the site after saving the snippet.\n\n**Features:**\n\n*   Displays instructions for installing the PostHog web snippet in Webflow.\n*   Provides a code snippet component (`JSSnippet`) to display the user's PostHog snippet.\n*   Guides the user through Webflow's site settings to the custom code section.\n*   Specifies the \"Head code\" section as the location for the snippet.\n*   Reminds the user to publish their site after installation.\n*   Informs the user of the Webflow plan requirements for custom code.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/html-snippet.tsx",
        "summary": "This code defines a React component called `SDKHtmlSnippetInstructions` that displays instructions for installing PostHog on a website. It includes a heading \"Install\", a paragraph explaining where to place the provided JavaScript snippet, and the `JSSnippet` component itself, which presumably renders the actual JavaScript code. The instructions advise users to add the snippet within the `<head>` tag of their website or use it in services like Google Tag Manager.\n\nHere's a list of high-level product features:\n\n*   **Installation Instructions:** Provides clear instructions for installing PostHog on a website.\n*   **JavaScript Snippet:** Displays a JavaScript snippet that needs to be added to the website.\n*   **Placement Guidance:** Specifies that the snippet should be placed within the `<head>` tag.\n*   **Integration Support:** Mentions compatibility with services like Google Tag Manager.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/astro.tsx",
        "summary": "This code provides instructions and code snippets for installing the PostHog web snippet in an Astro project. It guides the user to create a `posthog.astro` file within the `src/components` directory and then add the PostHog JavaScript snippet to that file. The code includes components to display the necessary commands and code snippets for this process.\n\n**Features:**\n\n*   **Instructions for creating `posthog.astro` file:** Provides a command to create the necessary component file.\n*   **Code snippet for `posthog.astro`:** Displays the JavaScript snippet that needs to be added to the component.\n*   **Uses `CodeSnippet` component:** Renders code snippets with syntax highlighting.\n*   **Uses `useJsSnippet` hook:** Fetches the PostHog JavaScript snippet.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/nextJsInstructionsLogic.ts",
        "summary": "This code defines a Kea logic module named `nextJsInstructionsLogic` for managing the Next.js router type ('app' or 'pages') within an onboarding flow. It allows setting and storing the selected router type using Kea's actions and reducers. The logic is initialized with a default router type of 'app' and provides an action `setNextJsRouter` to update the router type in the state.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Next.js Router Type Selection:** Allows users to specify whether their Next.js project uses the 'app' or 'pages' router.\n*   **State Management for Onboarding:** Manages the selected Next.js router type as part of the onboarding process.\n*   **Customizable Default Router:** Provides a way to initialize the router type with a default value.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/ruby.tsx",
        "summary": "This React component provides instructions for installing and configuring the PostHog Ruby SDK. It displays code snippets for installing the `posthog-ruby` gem using `gem install` and for initializing the PostHog client with the API key and host URL. The API key is dynamically retrieved from the current team's settings, and the host URL is determined using `apiHostOrigin()`. The configuration snippet also includes an error handling block.\n\n**Features:**\n\n*   **Ruby SDK Installation Instructions:** Provides code snippet for installing the PostHog Ruby SDK.\n*   **Ruby SDK Configuration Instructions:** Provides code snippet for configuring the PostHog Ruby SDK with the API key and host.\n*   **Dynamic API Key Injection:** Injects the current team's API key into the configuration snippet.\n*   **Dynamic Host URL Generation:** Generates the host URL using `apiHostOrigin()`.\n*   **Error Handling Example:** Includes an example of how to handle errors in the configuration snippet.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/nodejs.tsx",
        "summary": "The code defines a React component `SDKInstallNodeInstructions` that renders instructions for installing and configuring the PostHog Node.js SDK. It includes code snippets for installing the `posthog-node` package using npm, yarn, or pnpm, and for initializing the PostHog client with the project's API token and host URL. The component utilizes the `CodeSnippet` component to display the code in a user-friendly format.\n\nHere's a list of the high-level product features:\n\n*   **Installation Instructions:** Provides code snippets for installing the PostHog Node.js SDK using various package managers (npm, yarn, pnpm).\n*   **Configuration Instructions:** Offers a code snippet for initializing the PostHog client with the API token and host URL.\n*   **Dynamic API Token:** Uses the current team's API token to pre-populate the configuration snippet.\n*   **Dynamic Host URL:** Uses the `apiHostOrigin()` function to dynamically set the host URL in the configuration snippet.\n*   **Code Snippet Display:** Uses a `CodeSnippet` component to display code in a readable and syntax-highlighted format.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/ios.tsx",
        "summary": "This code provides React components to display instructions for installing and configuring the PostHog iOS SDK. It offers installation snippets for both CocoaPods and Swift Package Manager (SPM), along with a configuration snippet that includes options for session replay. The configuration snippet dynamically includes session replay configuration based on the `includeReplay` prop. Additionally, it provides instructions and a code snippet for manually tracking screen views.\n\nHere's a list of high-level product features based on the code:\n\n*   **CocoaPods Installation Instructions:** Displays code snippet for installing the PostHog iOS SDK using CocoaPods.\n*   **Swift Package Manager (SPM) Installation Instructions:** Displays code snippet for installing the PostHog iOS SDK using SPM.\n*   **Configuration Snippet:** Provides a code snippet for configuring the PostHog iOS SDK with the API key and host.\n*   **Session Replay Configuration:** Includes optional configuration for enabling and customizing session replay, including masking images and text, and enabling screenshots.\n*   **Manual Screen Tracking Instructions:** Provides instructions and a code snippet for manually tracking screen views using the `screen` function.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/go.tsx",
        "summary": "This code provides instructions for installing and configuring the PostHog Go SDK. It includes code snippets for installing the SDK using `go get` and for initializing the PostHog client with the team's API token and PostHog endpoint. The component renders these snippets within a user interface to guide users through the setup process.\n\nHere's a list of high-level product features:\n\n*   **Go SDK Installation Instructions:** Displays a command to install the PostHog Go SDK using `go get`.\n*   **Go SDK Configuration Snippet:** Provides a code snippet for initializing the PostHog client in Go, pre-filled with the user's API token and PostHog endpoint.\n*   **Dynamic API Token Insertion:**  The configuration snippet dynamically includes the user's API token.\n*   **Dynamic Endpoint Configuration:** The configuration snippet dynamically includes the PostHog endpoint.\n*   **Code Snippet Display:** Uses a `CodeSnippet` component to display the code in a readable and copyable format.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/svelte.tsx",
        "summary": "This code provides instructions and a code snippet for integrating PostHog's JavaScript library (`posthog-js`) into a Svelte application. It guides the user through installing the library using a package manager and initializing it within a Svelte layout file. The code snippet includes the necessary import statements, initialization logic, and configuration options, such as the API host and person profiles setting. It also dynamically adjusts the configuration based on feature flags, such as disabling person profiles if they are not supported.\n\nHere's a list of high-level product features:\n\n*   **Svelte Integration Instructions:** Provides specific instructions for integrating PostHog into Svelte applications.\n*   **Package Manager Installation:** Guides users on how to install `posthog-js` using a package manager.\n*   **Initialization Code Snippet:** Offers a pre-built code snippet for initializing PostHog within a Svelte layout file.\n*   **Dynamic Configuration:** Adjusts the PostHog configuration based on feature flags, such as disabling person profiles.\n*   **API Host Configuration:** Sets the `api_host` option during initialization.\n*   **Person Profiles Configuration:** Allows configuring the `person_profiles` option to control profile creation.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/django.tsx",
        "summary": "This code provides React components to display instructions for installing and configuring the PostHog SDK in a Django project. It includes code snippets for installing the `posthog` package via pip, configuring the PostHog API key and host within a Django AppConfig, and adding the AppConfig to the Django project's `settings.py`. The instructions guide users through the necessary steps to integrate PostHog into their Django application.\n\nHere's a list of the high-level features provided by the code:\n\n*   **Installation Instructions:** Displays a command to install the PostHog Python package using pip.\n*   **App Configuration Snippet:** Shows how to configure the PostHog API key and host within a Django AppConfig.\n*   **Settings Configuration Snippet:** Demonstrates how to add the AppConfig to the Django project's `settings.py`.\n*   **Dynamic API Key Insertion:** Injects the current team's API token into the AppConfig snippet.\n*   **Dynamic Host Insertion:** Injects the PostHog host origin into the AppConfig snippet.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/react.tsx",
        "summary": "This React component, `SDKInstallReactInstructions`, provides instructions for integrating PostHog into a React application. It displays code snippets for installing the PostHog JavaScript package, setting up environment variables with the PostHog API key and host, and initializing PostHog at the root of the React application using the `PostHogProvider`. The component leverages other components like `JSInstallSnippet`, `ReactEnvVarsSnippet`, and `ReactSetupSnippet` to present the installation steps in a clear and concise manner.\n\nHere's a list of high-level product features:\n\n*   **Installation Instructions:** Provides step-by-step instructions for installing the PostHog SDK in a React application.\n*   **Package Installation Snippet:** Displays the code required to install the PostHog JavaScript package.\n*   **Environment Variable Setup:** Shows how to configure environment variables for the PostHog API key and host.\n*   **Initialization Snippet:** Provides a code snippet for initializing PostHog at the root of the React application using the `PostHogProvider`.\n*   **Dynamic API Key and Host:** Dynamically inserts the PostHog API key and host into the environment variable snippet.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/SDKs.tsx",
        "summary": "This React component, `SDKs`, is a crucial part of the onboarding process, guiding users through the installation of PostHog's SDKs. It presents a user interface for selecting an SDK, displaying code snippets for installation, and verifying the installation by listening for incoming events. The component adapts to different screen sizes, offering a side-by-side view on larger screens and a panel-based layout on smaller screens. It also provides options to invite team members for help and skip the installation process if needed.\n\nHere's a list of high-level product features implemented in the code:\n\n*   **SDK Selection:** Allows users to choose an SDK from a list of available options.\n*   **Code Snippet Display:** Shows relevant code snippets for the selected SDK to guide the installation process.\n*   **Installation Verification:** Automatically checks if the SDK has been successfully installed by listening for incoming events.\n*   **Responsive Layout:** Adapts the layout to different screen sizes for optimal user experience.\n*   **Team Collaboration:** Provides an option to invite team members for assistance.\n*   **Skip Installation:** Allows users to skip the installation process and proceed to the next step.\n*   **Dynamic Source Filtering:** Filters SDK options based on the selected source type.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/angular.tsx",
        "summary": "This code provides instructions and code snippets for installing and initializing PostHog in an Angular application. It includes steps for installing the `posthog-js` library, setting up environment variables for the API key and host, and initializing PostHog within the `src/main.ts` file of an Angular project. The initialization snippet also conditionally includes the `person_profiles` configuration option based on a feature flag.\n\n**Features:**\n\n*   **Installation Instructions:** Provides instructions for installing the `posthog-js` library using a package manager.\n*   **Environment Variable Setup:** Guides users on setting up environment variables for the PostHog API key and host.\n*   **Initialization Code Snippet:** Offers a code snippet for initializing PostHog within the Angular application's `src/main.ts` file.\n*   **Conditional Configuration:** Conditionally includes the `person_profiles` configuration option based on a feature flag, allowing control over profile creation.\n*   **Code Snippets with Syntax Highlighting:** Uses the CodeSnippet component to display code with appropriate syntax highlighting for different languages (Bash, JavaScript).\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/laravel.tsx",
        "summary": "This React component, `SDKInstallLaravelInstructions`, provides instructions for installing and configuring the PostHog PHP library in a Laravel application. It displays code snippets for installing the `posthog/posthog-php` package using Composer and for initializing the PostHog client with the project's API token and PostHog host within the `AppServiceProvider`. The component leverages `kea` for state management to access the current team's API token.\n\nHere's a list of the high-level product features:\n\n*   **Dependency Installation Instructions:** Provides a Composer command to install the PostHog PHP library.\n*   **Configuration Instructions:** Guides users on how to initialize the PostHog client within their Laravel application's `AppServiceProvider`.\n*   **Dynamic API Token Injection:** Injects the current team's API token into the configuration snippet.\n*   **Dynamic Host Configuration:** Sets the PostHog host during initialization.\n*   **Code Snippets:** Displays formatted code snippets for easy copy-pasting.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/remix.tsx",
        "summary": "This code provides instructions and a code snippet for integrating PostHog into a Remix.js application. It focuses on initializing the `posthog-js` library within the `app/entry.client.tsx` file. The snippet includes setting the API host and conditionally enabling or disabling person profiles based on a feature flag. It also uses `hydrateRoot` to render the Remix browser and the `PosthogInit` component within a `StrictMode`.\n\nHere's a list of high-level product features:\n\n*   **Remix.js Integration Instructions:** Provides specific guidance for installing and initializing PostHog within a Remix.js application.\n*   **Code Snippet Generation:** Generates a ready-to-use code snippet for initializing `posthog-js` in the `app/entry.client.tsx` file.\n*   **Dynamic Configuration:** Configures the `posthog-js` initialization based on feature flags, specifically controlling the creation of person profiles.\n*   **API Host Configuration:** Sets the `api_host` option for `posthog-js` to ensure proper communication with the PostHog API.\n*   **Package Manager Installation Instructions:** Guides the user on how to install the `posthog-js` library using a package manager.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/react-native.tsx",
        "summary": "This code provides React Native installation and configuration instructions for the PostHog analytics platform. It includes code snippets for installing the `posthog-react-native` library using Expo, Yarn, or npm, along with instructions for iOS. It also demonstrates how to configure PostHog using the `PostHogProvider` component, including options for session replay with configurable masking and telemetry settings. The component dynamically adjusts the installation and configuration instructions based on whether session replay is included.\n\nHere's a list of high-level product features:\n\n*   **React Native SDK Installation Instructions:** Provides code snippets for installing the PostHog React Native SDK using various package managers (Expo, Yarn, npm).\n*   **iOS Setup Instructions:** Includes instructions for setting up the iOS environment (running `pod install`).\n*   **PostHogProvider Configuration:** Demonstrates how to configure PostHog using the `PostHogProvider` component.\n*   **Session Replay Integration:** Offers instructions and configuration options for enabling session replay in React Native apps.\n*   **Session Replay Configuration:** Allows customization of session replay behavior, including masking text inputs and images, capturing logs (Android), and capturing network telemetry (iOS).\n*   **Dynamic Code Snippets:** Adapts the code snippets based on whether session replay is included.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/next-js.tsx",
        "summary": "This code provides instructions for integrating PostHog into a Next.js application, supporting both the \"app\" and \"pages\" routers. It offers an automated installation option via an AI setup wizard, alongside detailed manual installation steps. The manual steps include installing the `posthog-js` library, setting up environment variables, and initializing PostHog within the Next.js application, with specific code snippets tailored to either the \"app\" or \"pages\" router architecture. The code also handles disabling person profiles based on feature flags.\n\nHere's a list of high-level product features:\n\n*   **Automated Installation via AI Setup Wizard:** Simplifies PostHog integration with an automated setup process.\n*   **Environment Variable Configuration:** Provides guidance on setting up necessary environment variables for PostHog.\n*   **\"App Router\" Integration:** Offers specific code snippets and instructions for integrating PostHog with Next.js applications using the \"app router\".\n*   **\"Pages Router\" Integration:** Offers specific code snippets and instructions for integrating PostHog with Next.js applications using the \"pages router\".\n*   **Manual Pageview Capture:** Provides code for manually capturing `$pageview` events in Next.js single-page applications.\n*   **Person Profile Control:** Allows disabling person profiles based on feature flags.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/nuxt.tsx",
        "summary": "This code provides instructions and code snippets for integrating PostHog into a Nuxt.js application (version 3.0 and above). It guides the user through installing the `posthog-js` library, configuring environment variables in `nuxt.config.js`, and creating a plugin to initialize PostHog and capture pageviews on route changes. The code also conditionally includes `person_profiles` configuration based on a feature flag.\n\nHere's a list of high-level product features:\n\n*   **Nuxt.js Integration Guide:** Provides step-by-step instructions for integrating PostHog into Nuxt.js applications.\n*   **Environment Variable Configuration Snippet:** Generates a code snippet for configuring PostHog API key and host in `nuxt.config.js`.\n*   **Plugin Creation Snippet:** Generates a code snippet for creating a Nuxt.js plugin to initialize PostHog and capture pageviews.\n*   **Conditional Person Profile Configuration:** Includes or excludes `person_profiles` configuration based on a feature flag.\n*   **Version Handling:** Provides a link to documentation for older Nuxt.js versions (v2.16 and below).\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/flutter.tsx",
        "summary": "This code provides Flutter SDK installation instructions for PostHog, covering Android, iOS/macOS, and Web platforms. It includes code snippets for installing the `posthog_flutter` package, configuring the SDK with the API key and host, and setting up session replay. The instructions also detail how to configure AndroidManifest.xml and Info.plist files for native mobile platforms, and how to integrate the JavaScript snippet for web applications. Additionally, it explains how to automatically track screen changes using `PosthogObserver` or manually using the `screen` function.\n\nHere's a list of high-level product features:\n\n*   **Flutter SDK Installation Instructions:** Provides step-by-step instructions for installing the PostHog Flutter SDK.\n*   **Android Configuration:** Guides users on configuring the AndroidManifest.xml file with the necessary PostHog settings.\n*   **iOS/macOS Configuration:** Guides users on configuring the Info.plist file with the necessary PostHog settings.\n*   **Web Integration:** Provides instructions for integrating the PostHog JavaScript snippet into web applications.\n*   **Session Replay Setup:** Includes instructions and code snippets for enabling and configuring session replay in Flutter applications.\n*   **Automatic Screen Tracking:** Explains how to automatically track screen changes using the `PosthogObserver`.\n*   **Manual Screen Tracking:** Demonstrates how to manually send screen capture events using the `screen` function.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/vue.tsx",
        "summary": "This code provides instructions and code snippets for integrating PostHog into a Vue.js application using the `posthog-js` library. It focuses on Vue 3+ versions and utilizes the plugin approach. The instructions guide the user through installing the library, creating a plugin file, adding the necessary code to initialize PostHog within the plugin, and activating the plugin within the main application file. The code snippets include commands for creating the plugin file, the plugin code itself (including API token and host configuration), and the code for activating the plugin in `main.js`.\n\nHere's a list of high-level product features:\n\n*   **Vue.js Integration Instructions:** Provides step-by-step instructions for integrating PostHog into Vue.js applications.\n*   **Plugin-Based Integration:** Focuses on the plugin approach for Vue 3+ versions.\n*   **Code Snippets:** Offers pre-built code snippets for installing the library, creating the plugin, initializing PostHog, and activating the plugin.\n*   **API Token and Host Configuration:** Includes placeholders for the PostHog API token and host configuration within the code snippets.\n*   **Link to Documentation:** Provides a link to the full Vue.js documentation for alternative integration methods and older versions.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdksLogic.tsx",
        "summary": "This code defines the `sdksLogic` Kea logic component, which manages the selection and filtering of SDKs (Software Development Kits) during the onboarding process. It handles filtering SDKs based on source, search terms, and tags, and manages the display of SDK instructions. The logic also fetches data about snippet events to improve the onboarding experience. It connects to other logic components like `onboardingLogic`, `liveEventsTableLogic`, `featureFlagLogic`, and `userLogic` to access relevant data and actions.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **SDK Selection and Filtering:** Allows users to select an SDK from a list, filtering by source, search term, and tags.\n*   **SDK Instructions Display:** Shows instructions for the selected SDK, potentially in a side-by-side view.\n*   **Source Filtering:** Filters SDKs based on their source (e.g., web, mobile).\n*   **Search Functionality:** Enables users to search for SDKs by name.\n*   **Tag-based Filtering:** Allows users to filter SDKs by predefined tags.\n*   **Snippet Event Detection:** Detects snippet events to provide a more tailored onboarding experience.\n*   **URL-based SDK Selection:** Allows selecting an SDK directly via a URL parameter.\n*   **SDK Usage Reporting:** Reports the selected SDK for usage tracking.\n*   **Multi-Install Product Handling:** Supports products that can be installed in multiple places (e.g., web and mobile).\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/allSDKs.tsx",
        "summary": "The code defines a comprehensive list of SDKs (Software Development Kits) that PostHog supports for various platforms and frameworks. These SDKs are categorized by platform (Web, Mobile, Server, LLM) and include integrations with other services. Each SDK entry contains metadata such as its name, a unique key, relevant tags, a recommended status, an associated logo, and a link to its documentation.\n\nHere's a list of high-level product features derived from the code:\n\n*   **SDK Support:** Provides SDKs for a wide range of platforms and frameworks, including web (Next.js, React, Angular, Vue.js, etc.), mobile (Android, iOS, React Native, Flutter), server-side (Node.js, Python, Django, Go, etc.), and LLM (Helicone, Langfuse, Traceloop).\n*   **Integration Support:** Offers integrations with popular tools and platforms like Google Tag Manager, Segment, RudderStack, Docusaurus, Shopify, Wordpress, Sentry, and Retool.\n*   **Platform Categorization:** Organizes SDKs by platform tags (Web, Mobile, Server, LLM, Integration) for easy filtering and discovery.\n*   **Recommended SDKs:** Highlights recommended SDKs for common use cases, guiding users towards the most suitable options.\n*   **Documentation Links:** Provides direct links to the documentation for each SDK, facilitating easy setup and usage.\n*   **Visual Identification:** Includes logos for each SDK, making it easier for users to visually identify and select the correct SDK."
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/index.tsx",
        "summary": "This file serves as an index that exports a collection of modules, each likely containing SDK installation instructions for a specific platform or framework. The purpose is to provide a centralized location to access installation guides for various technologies, simplifying the onboarding process for users integrating the product with their existing projects.\n\nHere's a list of high-level product features based on the code:\n\n*   **Android SDK Installation Instructions:** Guides users on how to install and configure the SDK for Android applications.\n*   **Angular SDK Installation Instructions:** Provides instructions for integrating the SDK into Angular projects.\n*   **Astro SDK Installation Instructions:** Offers guidance on installing the SDK within Astro projects.\n*   **Bubble SDK Installation Instructions:** Details the installation process for Bubble applications.\n*   **Django SDK Installation Instructions:** Explains how to install and set up the SDK for Django-based projects.\n*   **Elixir SDK Installation Instructions:** Provides instructions for integrating the SDK into Elixir projects.\n*   **Flutter SDK Installation Instructions:** Guides users on how to install and configure the SDK for Flutter applications.\n*   **Framer SDK Installation Instructions:** Provides instructions for integrating the SDK into Framer projects.\n*   **Go SDK Installation Instructions:** Explains how to install and set up the SDK for Go-based projects.\n*   **iOS SDK Installation Instructions:** Guides users on how to install and configure the SDK for iOS applications.\n*   **JavaScript (Web) SDK Installation Instructions:** Provides instructions for integrating the SDK into standard JavaScript web applications.\n*   **Laravel SDK Installation Instructions:** Explains how to install and set up the SDK for Laravel-based projects.\n*   **Node.js SDK Installation Instructions:** Provides instructions for integrating the SDK into Node.js applications.\n*   **Nuxt.js SDK Installation Instructions:** Offers guidance on installing the SDK within Nuxt.js projects.\n*   **PHP SDK Installation Instructions:** Explains how to install and set up the SDK for PHP-based projects.\n*   **Python SDK Installation Instructions:** Provides instructions for integrating the SDK into Python projects.\n*   **React Native SDK Installation Instructions:** Guides users on how to install and configure the SDK for React Native applications.\n*   **Remix SDK Installation Instructions:** Offers guidance on installing the SDK within Remix projects.\n*   **Ruby SDK Installation Instructions:** Explains how to install and set up the SDK for Ruby-based projects.\n*   **Svelte SDK Installation Instructions:** Offers guidance on installing the SDK within Svelte projects.\n*   **Vue.js SDK Installation Instructions:** Provides instructions for integrating the SDK into Vue.js projects.\n*   **Webflow SDK Installation Instructions:** Details the installation process for Webflow applications.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/php.tsx",
        "summary": "This code provides instructions for installing and configuring the PostHog PHP SDK. It includes code snippets for dependency setup using Composer, installation via the command line, and initialization with the PostHog API token and host. The component renders these snippets within a structured format, guiding users through the necessary steps to integrate the PostHog PHP SDK into their projects.\n\n**Features:**\n\n*   **Dependency Setup Snippet:** Displays a JSON snippet for configuring Composer to include the PostHog PHP SDK as a dependency.\n*   **Installation Snippet:** Provides a Bash command to install the dependencies using Composer.\n*   **Configuration Snippet:** Shows a PHP code snippet for initializing the PostHog SDK with the project's API token and PostHog host.\n*   **Dynamic API Token:** The configuration snippet dynamically includes the current team's API token.\n*   **Dynamic Host:** The configuration snippet dynamically includes the PostHog host origin.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions/js-web.tsx",
        "summary": "This code provides React components for displaying JavaScript web SDK installation and initialization instructions. It includes code snippets for installing the `posthog-js` library using npm, yarn, or pnpm, and a snippet for initializing the library with the project's API token and API host. The initialization snippet also conditionally includes the `person_profiles` configuration option based on a feature flag, allowing control over whether profiles are created for anonymous users.\n\nHere's a list of high-level product features:\n\n*   **Installation Instructions:** Displays instructions for installing the PostHog JavaScript library using various package managers.\n*   **Initialization Snippet:** Generates a code snippet for initializing the PostHog library with the project's API token and API host.\n*   **Conditional Configuration:** Conditionally includes the `person_profiles` configuration option in the initialization snippet based on a feature flag.\n*   **Code Snippet Display:** Uses a `CodeSnippet` component to display code in a formatted and readable way.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/sdk-install-instructions",
        "summary": "This collection of code files provides comprehensive SDK installation instructions for a wide range of platforms and frameworks, aiming to simplify the onboarding process for new users. The instructions typically include code snippets for installing the relevant SDK package, configuring it with the project's API key and host URL, and initializing the SDK within the application. Many implementations dynamically inject the API key and host URL, and some offer conditional configuration options based on feature flags, such as enabling or disabling session replay or person profiles. The instructions are tailored to each platform, providing specific guidance for integrating PostHog into various environments like web applications, mobile apps, and backend services.\n\nHere's a list of high-level product features:\n\n*   SDK Installation Instructions for various platforms (Android, Angular, Astro, Bubble, Django, Elixir, Flutter, Framer, Go, iOS, JavaScript (Web), Laravel, Node.js, Nuxt.js, PHP, Python, React Native, Remix, Ruby, Svelte, Vue.js, Webflow).\n*   Automated Installation via AI Setup Wizard (Next.js).\n*   Dynamic API Key Injection into code snippets.\n*   Dynamic Host URL Generation.\n*   Code Snippets for installation and configuration.\n*   Conditional Configuration based on feature flags (e.g., session replay, person profiles).\n*   Environment Variable Setup Guides.\n*   Platform-Specific Configuration Instructions (e.g., AndroidManifest.xml, Info.plist).\n*   Session Replay Setup Instructions and configuration options.\n*   Automatic and Manual Screen Tracking Instructions.\n*   Support for different router types (Next.js).\n*   Integration with package managers (npm, yarn, pnpm, CocoaPods, Swift Package Manager, Composer, pip).\n*   Links to relevant documentation.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/bubble.tsx",
        "summary": "The `ExperimentsBubbleInstructions` component renders instructions for installing the PostHog SDK, followed by a divider, and then an implementation snippet specifically for experiments using the JavaScript Web SDK. This component aims to guide users through setting up and using PostHog experiments in their web applications.\n\n**Features:**\n\n*   Displays SDK installation instructions.\n*   Provides a visual divider to separate sections.\n*   Shows a code snippet for implementing experiments using the JavaScript Web SDK.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/webflow.tsx",
        "summary": "The `ExperimentsWebflowInstructions` component provides instructions for integrating PostHog experiments into a Webflow project. It leverages two sub-components: `SDKInstallWebflowInstructions` which likely contains the steps to install the PostHog SDK within Webflow, and `ExperimentsImplementationSnippet` which displays code snippets for implementing experiments using the JavaScript Web SDK.\n\n**Features:**\n\n*   **Webflow SDK Installation Instructions:** Provides step-by-step guidance on installing the PostHog JavaScript SDK within a Webflow project.\n*   **Experiment Implementation Snippets:** Offers code examples demonstrating how to implement and run experiments using the PostHog JavaScript Web SDK.\n*   **SDK Key Configuration:** Specifies the use of the JavaScript Web SDK (SDKKey.JS_WEB) for experiment implementation.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/flutter.tsx",
        "summary": "This React component, `ExperimentsFlutterInstructions`, provides instructions for integrating PostHog's experiment feature into a Flutter application. It renders two sub-components: `SDKInstallFlutterInstructions`, which guides the user through the process of installing the PostHog Flutter SDK, and `ExperimentsImplementationSnippet`, which displays code snippets demonstrating how to implement experiment tracking using the Flutter SDK. The component essentially combines the necessary steps for setting up the SDK and implementing experiment tracking in a Flutter project.\n\n**Features:**\n\n*   **Flutter SDK Installation Instructions:** Provides step-by-step guidance on installing the PostHog Flutter SDK.\n*   **Experiment Implementation Snippets:** Displays code examples demonstrating how to use the Flutter SDK to implement experiment tracking.\n*   **SDK Key Parameterization:** Passes the Flutter SDK key to the implementation snippet component.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/angular.tsx",
        "summary": "The `ExperimentsAngularInstructions` component provides instructions and code snippets for integrating PostHog's experiment feature into an Angular application. It renders the installation instructions using the `SDKInstallAngularInstructions` component, followed by a visual divider, and then displays an implementation snippet using the `ExperimentsImplementationSnippet` component, configured for the JavaScript Web SDK.\n\nHere's a list of high-level product features:\n\n*   **Angular SDK Installation Instructions:** Guides users on how to install the PostHog SDK in an Angular project.\n*   **Experiment Implementation Snippet:** Provides a code snippet demonstrating how to implement experiment tracking within an Angular application using the JavaScript Web SDK.\n*   **Visual Separation:** Uses a divider to clearly separate the installation instructions from the implementation snippet.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/go.tsx",
        "summary": "The `ExperimentsGoInstructions` component provides instructions and code snippets for integrating PostHog's experiment feature into a Go application. It renders the installation instructions using the `SDKInstallGoInstructions` component, followed by a divider, and then displays a code snippet demonstrating how to implement experiment functionality using the `ExperimentsImplementationSnippet` component, specifically tailored for the Go SDK.\n\nHere's a list of high-level product features:\n\n*   **Go SDK Installation Instructions:** Guides users on how to install the PostHog Go SDK.\n*   **Experiment Implementation Snippet (Go):** Provides a code example demonstrating how to use the Go SDK to implement experiment feature flags.\n*   **SDK Key Handling:** Passes the appropriate SDK key for Go to the implementation snippet component.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/js-web.tsx",
        "summary": "The `ExperimentsJSWebInstructions` component provides instructions and code snippets for integrating PostHog experiments into a JavaScript web application. It renders the standard SDK installation instructions followed by a divider and then displays a code snippet demonstrating how to implement experiments using the JavaScript web SDK, using the appropriate SDK key.\n\n**Features:**\n\n*   **SDK Installation Instructions:** Displays instructions for installing the PostHog JavaScript web SDK.\n*   **Experiment Implementation Snippet:** Shows a code snippet for implementing experiments using the JavaScript web SDK.\n*   **SDK Key Handling:** Uses the correct SDK key for the JavaScript web SDK.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/react-native.tsx",
        "summary": "This React Native component provides instructions for integrating PostHog experiments into a React Native application. It displays SDK installation instructions using the `SDKInstallRNInstructions` component, followed by a visual divider. Subsequently, it presents a code snippet demonstrating how to implement experiments using the `ExperimentsImplementationSnippet` component, specifically tailored for the React Native SDK.\n\n**Features:**\n\n*   **SDK Installation Instructions:** Displays instructions for installing the PostHog React Native SDK.\n*   **Code Snippet Generation:** Generates and displays a code snippet demonstrating how to implement experiments with the React Native SDK.\n*   **SDK Key Handling:** Passes the React Native SDK key to the code snippet component.\n*   **Visual Separation:** Uses a divider to visually separate the installation instructions from the code snippet.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/vue.tsx",
        "summary": "The `ExperimentsVueInstructions` component provides instructions and code snippets for integrating DevCycle's experiment functionality into a Vue.js application. It leverages the `SDKInstallVueInstructions` component to guide users through the SDK installation process and displays a code snippet using the `ExperimentsImplementationSnippet` component, pre-configured for the JavaScript Web SDK, to demonstrate how to implement experiments.\n\nHere's a list of high-level product features:\n\n*   **Vue.js SDK Installation Instructions:** Provides step-by-step guidance on installing the DevCycle SDK in a Vue.js project.\n*   **Experiment Implementation Snippet:** Displays a pre-configured code snippet demonstrating how to use the DevCycle SDK to implement experiments in Vue.js.\n*   **JavaScript Web SDK Configuration:** The implementation snippet is pre-configured to use the JavaScript Web SDK.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/nuxt.tsx",
        "summary": "The `ExperimentsNuxtInstructions` component provides instructions for integrating PostHog experiments into a Nuxt.js application. It covers both client-side and server-side rendering scenarios. The component includes installation and setup steps, along with code snippets demonstrating how to implement experiment tracking using the React SDK.\n\nHere's a list of high-level features:\n\n*   **Nuxt.js Integration Instructions:** Provides specific instructions for integrating PostHog experiments into Nuxt.js projects.\n*   **Client-Side Rendering Instructions:** Guides users on implementing experiment tracking in client-side rendered Nuxt.js applications.\n*   **Server-Side Rendering Instructions:** Guides users on implementing experiment tracking in server-side rendered Nuxt.js applications.\n*   **Installation Snippets:** Offers code snippets for installing necessary dependencies.\n*   **Configuration Snippets:** Provides code snippets for configuring PostHog within the Nuxt.js environment.\n*   **Experiment Implementation Snippets:** Demonstrates how to implement experiment tracking using the React SDK in both client-side and server-side contexts.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/ios.tsx",
        "summary": "The `ExperimentsIOSInstructions` component provides instructions and code snippets for integrating PostHog experiments into an iOS application. It leverages the `SDKInstallIOSInstructions` component to guide users through the SDK installation process and then presents an `ExperimentsImplementationSnippet` component, pre-configured for the iOS SDK, to demonstrate how to implement experiment tracking in their code. A divider separates the installation instructions from the code snippet.\n\nHere's a list of high-level product features:\n\n*   **iOS SDK Installation Instructions:** Provides step-by-step guidance for installing the PostHog iOS SDK.\n*   **Experiment Implementation Snippet (iOS):** Offers a pre-built code snippet demonstrating how to implement experiment tracking using the iOS SDK.\n*   **Visual Separation:** Uses a divider to clearly separate the installation instructions from the code implementation example.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/framer.tsx",
        "summary": "This code defines a React component, `ExperimentsFramerInstructions`, which renders instructions for installing the PostHog SDK in a Framer project and provides a code snippet demonstrating how to implement experiments using the JavaScript Web SDK. The component combines the `SDKInstallFramerInstructions` component, which likely contains the installation steps, and the `ExperimentsImplementationSnippet` component, which displays the code snippet, using the `JS_WEB` SDK key.\n\nHere's a list of high-level product features:\n\n*   **Framer SDK Installation Instructions:** Provides step-by-step guidance for integrating the PostHog SDK into Framer projects.\n*   **Experiment Implementation Snippet:** Offers a pre-built code example demonstrating how to use PostHog to run experiments within a Framer environment using the JavaScript Web SDK.\n*   **SDK Key Configuration:** Specifies the appropriate SDK key (`JS_WEB`) for the provided code snippet.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/android.tsx",
        "summary": "The `ExperimentsAndroidInstructions` component provides instructions and code snippets for integrating PostHog experiments into an Android application. It renders the `SDKInstallAndroidInstructions` component, which likely contains instructions on how to install the PostHog Android SDK. It then displays an `ExperimentsImplementationSnippet` component, which shows example code for implementing experiments using the Android SDK, using the Android SDK key. A divider separates the installation instructions from the implementation snippet.\n\nHere's a list of high-level product features:\n\n*   **Android SDK Installation Instructions:** Provides step-by-step instructions for installing the PostHog Android SDK.\n*   **Experiments Implementation Snippet:** Displays code snippets demonstrating how to implement experiments using the PostHog Android SDK.\n*   **SDK Key Handling:** Passes the appropriate Android SDK key to the implementation snippet component.\n*   **UI Separation:** Uses a divider to visually separate the installation instructions from the implementation examples.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/astro.tsx",
        "summary": "The `ExperimentsAstroInstructions` component provides instructions for integrating PostHog experiments into an Astro project. It renders the `SDKInstallAstroInstructions` component, which likely contains the necessary steps to install the PostHog SDK within an Astro environment. Following the installation instructions, a divider separates the content from the `ExperimentsImplementationSnippet` component. The `ExperimentsImplementationSnippet` component displays code snippets demonstrating how to implement experiment tracking using the PostHog JavaScript Web SDK.\n\nHere's a list of high-level product features:\n\n*   **Astro SDK Installation Instructions:** Provides step-by-step guidance for installing the PostHog SDK in an Astro project.\n*   **Experiment Implementation Snippets:** Offers code examples for implementing experiment tracking using the PostHog JavaScript Web SDK within an Astro application.\n*   **SDK Selection:** Specifies the use of the JavaScript Web SDK for experiment implementation.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/php.tsx",
        "summary": "The `ExperimentsPHPInstructions` component provides instructions and code snippets for integrating PostHog's experiment feature using the PHP SDK. It renders the `SDKInstallPHPInstructions` component, which likely contains instructions on how to install the PHP SDK. It then displays a divider followed by the `ExperimentsImplementationSnippet` component, which shows example code for implementing experiments using the PHP SDK.\n\n**Features:**\n\n*   **PHP SDK Installation Instructions:** Provides guidance on installing the PostHog PHP SDK.\n*   **Experiment Implementation Snippets (PHP):** Displays code examples demonstrating how to use the PHP SDK to implement and run experiments.\n*   **Clear Visual Separation:** Uses a divider to separate installation instructions from implementation examples.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/python.tsx",
        "summary": "The `ExperimentsPythonInstructions` component provides instructions for integrating PostHog's experiment feature using the Python SDK. It renders the `SDKInstallPythonInstructions` component, which likely contains the necessary steps to install the Python SDK. Following the installation instructions, a divider separates the content from the `ExperimentsImplementationSnippet` component, which displays code snippets demonstrating how to implement experiment functionality using the Python SDK.\n\nHere's a list of high-level product features:\n\n*   **Python SDK Installation Instructions:** Guides users through installing the PostHog Python SDK.\n*   **Experiment Implementation Snippets (Python):** Provides code examples for implementing experiment features using the Python SDK.\n*   **Clear Separation of Concerns:** Uses a divider to visually separate installation instructions from implementation examples.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/ruby.tsx",
        "summary": "The `ExperimentsRubyInstructions` component provides instructions and code snippets for integrating PostHog's experiment feature into a Ruby application. It renders the `SDKInstallRubyInstructions` component, which likely contains instructions on how to install the PostHog Ruby SDK. It then displays an `ExperimentsImplementationSnippet` component, which shows example code for using the SDK to run experiments, configured specifically for the Ruby SDK. A divider separates the installation instructions from the code snippet.\n\nHere's a list of the high-level features provided by this component:\n\n*   **Ruby SDK Installation Instructions:** Guides users on how to install the PostHog Ruby SDK.\n*   **Experiment Implementation Snippet (Ruby):** Provides a code example demonstrating how to use the Ruby SDK to implement and run experiments.\n*   **Visual Separation:** Uses a divider to clearly separate the installation instructions from the code snippet.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/nodejs.tsx",
        "summary": "The `ExperimentsNodeJSInstructions` component provides instructions and code snippets for integrating PostHog experiments into a Node.js application. It renders the `SDKInstallNodeInstructions` component, which likely contains instructions on how to install the PostHog Node.js SDK. It then displays a divider followed by the `ExperimentsImplementationSnippet` component, which shows a code snippet demonstrating how to implement experiments using the Node.js SDK.\n\nHere's a list of high-level product features:\n\n*   **Node.js SDK Installation Instructions:** Provides instructions for installing the PostHog Node.js SDK.\n*   **Experiments Implementation Snippet:** Displays a code snippet demonstrating how to implement experiments using the Node.js SDK.\n*   **SDK Selection:** Specifies the Node.js SDK for the code snippet.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/react.tsx",
        "summary": "This React component, `ExperimentsReactInstructions`, provides instructions and code snippets for integrating PostHog experiments into a React application. It renders the installation instructions using the `SDKInstallReactInstructions` component, followed by a visual separator (`LemonDivider`), and then displays a code snippet demonstrating how to implement experiments using the `ExperimentsImplementationSnippet` component, specifically tailored for the React SDK.\n\nHere's a list of the high-level product features:\n\n*   **React SDK Installation Instructions:** Provides step-by-step guidance on installing the PostHog React SDK.\n*   **Experiment Implementation Snippets:** Offers ready-to-use code examples for implementing experiments within a React application.\n*   **SDK Key Handling:** Specifies the React SDK key for the code snippets.\n*   **Visual Separation:** Uses a divider to visually separate the installation instructions from the implementation snippets.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/next-js.tsx",
        "summary": "This code defines a React component, `ExperimentsNextJSInstructions`, which provides instructions for integrating PostHog experiments into a Next.js application. It covers both client-side and server-side rendering scenarios. The component displays installation and setup instructions, along with code snippets demonstrating how to implement experiment tracking using the PostHog React and Node.js SDKs.\n\nHere's a list of high-level product features this code supports:\n\n*   **Next.js Integration Instructions:** Provides specific guidance for integrating PostHog experiments into Next.js projects.\n*   **Client-Side Experiment Implementation:** Offers code snippets and instructions for implementing experiments in client-side rendered Next.js components using the React SDK.\n*   **Server-Side Experiment Implementation:** Offers code snippets and instructions for implementing experiments in server-side rendered Next.js components using the Node.js SDK.\n*   **SDK Installation Instructions:** Guides users through installing the necessary PostHog SDKs (React and Node.js) for experiment tracking.\n*   **Configuration Instructions:** Provides instructions on how to configure the PostHog SDKs within a Next.js environment.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/django.tsx",
        "summary": "The `ExperimentsDjangoInstructions` component provides instructions and code snippets for integrating PostHog's experiments feature into a Django (Python) project. It renders the installation instructions using `SDKInstallDjangoInstructions` and displays a code snippet demonstrating how to implement experiments using the `ExperimentsImplementationSnippet` component, specifically tailored for the Python SDK. A divider separates the installation instructions from the code snippet.\n\nHere's a list of high-level product features:\n\n*   **Django SDK Installation Instructions:** Provides step-by-step guidance on installing the PostHog Python SDK in a Django project.\n*   **Experiments Implementation Snippet (Python):** Displays a code example demonstrating how to use the PostHog Python SDK to implement feature flag/experiment logic in a Django application.\n*   **Visual Separation:** Uses a divider to clearly separate the installation instructions from the code implementation example.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/laravel.tsx",
        "summary": "This React component, `ExperimentsLaravelInstructions`, provides instructions and code snippets for integrating PostHog experiments into a Laravel (PHP) application. It renders the standard SDK installation instructions for Laravel, followed by a divider, and then displays a code snippet demonstrating how to implement experiments using the PostHog PHP SDK. The component utilizes shared components for the installation instructions and code snippet display.\n\n**Features:**\n\n*   **Laravel SDK Installation Instructions:** Displays instructions for installing the PostHog PHP SDK in a Laravel project.\n*   **Experiment Implementation Snippet:** Shows a code example of how to use the PostHog PHP SDK to implement feature flags/experiments in Laravel.\n*   **PHP SDK Key:** Specifies the use of the PHP SDK.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/ExperimentsImplementationSnippet.tsx",
        "summary": "The `ExperimentsImplementationSnippet` component displays code snippets demonstrating how to implement experiments using feature flags within the PostHog platform. It retrieves the appropriate code snippet based on the provided SDK key and renders it along with explanatory text. The component highlights the basic implementation of feature flags and explains how to run experiments by enabling the flag for a target audience through the PostHog dashboard.\n\nHere's a list of high-level product features:\n\n*   **Code Snippet Generation:** Dynamically generates code snippets for experiment implementation based on the selected SDK.\n*   **Feature Flag Integration:** Demonstrates how experiments are built on top of feature flags.\n*   **Experiment Configuration Guidance:** Provides instructions on configuring experiments within the PostHog dashboard.\n*   **SDK Support:** Supports multiple SDKs for experiment implementation (determined by `OPTIONS` and `SDKKey`).\n*   **Targeted Audience Experimentation:** Explains how to enable feature flags for specific target audiences to run experiments.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/remix.tsx",
        "summary": "The `ExperimentsRemixInstructions` component provides instructions for integrating PostHog experiments into a Remix.js application. It covers both client-side and server-side rendering scenarios. For client-side rendering, it uses the JavaScript Web SDK, and for server-side rendering, it uses the Node.js SDK. The component includes installation and configuration steps, along with code snippets demonstrating how to implement experiments in each environment.\n\nHere's a list of the high-level features provided by this component:\n\n*   **Client-Side Experiment Implementation Instructions:** Provides code snippets and instructions for implementing PostHog experiments in a Remix.js application using client-side rendering with the JavaScript Web SDK.\n*   **Server-Side Experiment Implementation Instructions:** Provides code snippets and instructions for implementing PostHog experiments in a Remix.js application using server-side rendering with the Node.js SDK.\n*   **Node.js SDK Installation Instructions:** Guides the user through installing the Node.js SDK for server-side experiment evaluation.\n*   **Node.js SDK Configuration Instructions:** Guides the user through configuring the Node.js SDK for server-side experiment evaluation.\n*   **Remix.js SDK Installation Instructions:** Provides instructions for installing the PostHog SDK within a Remix.js project.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/ExperimentsSDKInstructions.tsx",
        "summary": "This code defines a mapping between SDK keys and their corresponding instruction components for integrating PostHog Experiments into various platforms. It exports a constant `ExperimentsSDKInstructions` which is an object that maps SDK keys (like JavaScript Web, Android, iOS, etc.) to the specific UI components that display the integration instructions for that SDK. This allows the application to dynamically render the correct instructions based on the user's selected SDK.\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **SDK Integration Guides:** Provides instructions and guides for integrating PostHog Experiments with various SDKs and platforms.\n*   **Multi-Platform Support:** Supports a wide range of platforms and frameworks, including web (JavaScript, React, Angular, Vue, Svelte, Next.js, Nuxt.js, Remix, Astro, Webflow), mobile (Android, iOS, React Native, Flutter), and backend (Node.js, Python, Django, Go, PHP, Ruby, Laravel).\n*   **Platform-Specific Instructions:** Offers tailored instructions for each supported platform, ensuring a smooth integration process.\n*   **Onboarding Assistance:** Helps users onboard and set up PostHog Experiments in their projects.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments/svelte.tsx",
        "summary": "This Svelte component provides instructions for integrating PostHog experiments into Svelte applications, covering both client-side and server-side rendering scenarios. It includes installation instructions, configuration steps, and code snippets demonstrating how to implement experiment checks using the JavaScript Web and Node.js SDKs.\n\nHere's a list of the high-level features:\n\n*   **Client-Side Rendering Instructions:** Provides specific instructions for installing and using PostHog experiments in a client-side Svelte application.\n*   **Server-Side Rendering Instructions:** Offers guidance on integrating PostHog experiments into a server-side rendered Svelte application using Node.js.\n*   **Installation Snippets:** Includes code snippets for installing the necessary PostHog SDKs using package managers like npm or yarn.\n*   **Configuration Snippets:** Provides code snippets for setting up and initializing the PostHog client in both client-side and server-side environments.\n*   **Experiment Implementation Snippets:** Demonstrates how to use the PostHog SDK to check if a user is in a specific experiment variant and adjust the application behavior accordingly.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/experiments",
        "summary": "The provided code implements a comprehensive suite of components designed to guide users through integrating PostHog's experiment feature into a wide array of platforms and frameworks. These components offer platform-specific installation instructions, code snippets demonstrating experiment implementation, and clear visual separation between setup and usage examples. The system supports various SDKs, including JavaScript Web, React, Node.js, Python, Django, Go, PHP, Ruby, Laravel, Android, iOS, React Native, Flutter, Angular, Vue, Svelte, Next.js, Nuxt.js, Remix, Astro, Webflow, Framer, and Bubble, catering to diverse development environments and ensuring a smooth onboarding experience for users regardless of their chosen technology stack.\n\nHere's a list of high-level product features:\n\n*   **SDK Installation Instructions:** Provides step-by-step guides for installing PostHog SDKs across various platforms.\n*   **Experiment Implementation Snippets:** Offers code examples demonstrating how to implement experiment tracking and feature flags using different SDKs.\n*   **Multi-Platform Support:** Supports a wide range of platforms and frameworks, including web, mobile, and backend technologies.\n*   **Client-Side and Server-Side Rendering Support:** Provides specific instructions and code snippets for both client-side and server-side rendering scenarios where applicable.\n*   **Visual Separation of Concerns:** Uses dividers to clearly separate installation instructions from implementation examples.\n*   **SDK Key Handling:** Manages and passes the appropriate SDK keys to the implementation snippets.\n*   **Configuration Instructions:** Guides users on how to configure the PostHog SDKs within their specific environments.\n*   **Feature Flag Integration:** Demonstrates how experiments are built on top of feature flags.\n*   **Targeted Audience Experimentation Guidance:** Explains how to enable feature flags for specific target audiences to run experiments.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/ruby.tsx",
        "summary": "The `FeatureFlagsRubyInstructions` component provides instructions for installing the PostHog Ruby SDK and demonstrates how to implement a feature flag using the SDK. It leverages the `SDKInstallRubyInstructions` component to guide users through the installation process and the `FlagImplementationSnippet` component to display a code snippet illustrating feature flag implementation in Ruby.\n\n**Features:**\n\n*   **Ruby SDK Installation Instructions:** Provides step-by-step instructions for installing the PostHog Ruby SDK.\n*   **Feature Flag Implementation Snippet (Ruby):** Displays a code snippet demonstrating how to implement a feature flag using the Ruby SDK.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/django.tsx",
        "summary": "The `FeatureFlagsDjangoInstructions` component renders instructions for installing the Django SDK and provides a code snippet demonstrating how to implement feature flags using the Python SDK. This component is part of an onboarding process, guiding users on how to integrate PostHog's feature flag capabilities into their Django projects.\n\n**Features:**\n\n*   **SDK Installation Instructions:** Provides instructions for installing the Django SDK.\n*   **Feature Flag Implementation Snippet:** Displays a code snippet demonstrating how to implement feature flags using the Python SDK.\n*   **SDK Key Handling:** Uses the `SDKKey.PYTHON` to specify the relevant SDK for the code snippet.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/bubble.tsx",
        "summary": "This React component, `FeatureFlagsBubbleInstructions`, is designed to guide users through the process of implementing feature flags within their application. It combines two sub-components: `SDKInstallBubbleInstructions`, which likely provides instructions on installing the necessary SDK, and `FlagImplementationSnippet`, which displays a code snippet demonstrating how to implement a feature flag using the JavaScript web SDK. This allows users to quickly understand and integrate feature flags into their projects.\n\n**Features:**\n\n*   **SDK Installation Instructions:** Provides guidance on installing the appropriate SDK for feature flag management.\n*   **Feature Flag Implementation Snippet:** Displays a code example demonstrating how to implement a feature flag using the JavaScript web SDK.\n*   **JavaScript Web SDK Support:** Specifically targets users implementing feature flags in JavaScript web applications.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/android.tsx",
        "summary": "This React component provides instructions and code snippets for integrating PostHog feature flags into an Android application. It guides the user through installing the Android SDK, demonstrates how to implement a feature flag using a code snippet, and promotes the mobile replay functionality.\n\n**Features:**\n\n*   **Android SDK Installation Instructions:** Provides guidance on installing the PostHog Android SDK.\n*   **Feature Flag Implementation Snippet:** Displays a code snippet demonstrating how to implement a feature flag in Android using the PostHog SDK.\n*   **Mobile Replay Advertisement:** Promotes the mobile replay feature with context specific to feature flag onboarding and the Android SDK.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/react-native.tsx",
        "summary": "This React Native component provides instructions and code snippets to help users integrate PostHog feature flags into their React Native applications. It guides users through the SDK installation process, demonstrates how to implement feature flags using a code snippet, and promotes the use of PostHog's mobile session replay feature.\n\nHere's a list of high-level product features:\n\n*   **SDK Installation Instructions:** Provides step-by-step guidance for installing the PostHog React Native SDK.\n*   **Feature Flag Implementation Snippet:** Offers a code example demonstrating how to use feature flags within a React Native application.\n*   **Mobile Session Replay Advertisement:** Promotes PostHog's mobile session replay functionality, encouraging users to leverage session replay for enhanced insights.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/flutter.tsx",
        "summary": "This Flutter feature flags onboarding component guides users through setting up feature flags in their Flutter application. It provides instructions for installing the Flutter SDK, demonstrates how to implement a feature flag using a code snippet, and promotes the mobile replay functionality, linking it to the current onboarding context.\n\n**Features:**\n\n*   **SDK Installation Instructions:** Provides step-by-step guidance on installing the Flutter SDK.\n*   **Feature Flag Implementation Snippet:** Offers a code snippet demonstrating how to implement a feature flag in Flutter.\n*   **Mobile Replay Advertisement:** Promotes the mobile replay feature, encouraging users to integrate session replay capabilities.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/flagImplementationSnippet.tsx",
        "summary": "The `FlagImplementationSnippet` component displays code snippets for basic feature flag implementation and provides information on running experiments using PostHog's feature flags. It utilizes the `CodeInstructions` component to show code examples in different languages based on the selected SDK key. The component also explains that experiments are built on top of feature flags and can be configured through the PostHog dashboard.\n\nHere's a list of high-level product features:\n\n*   **Code Snippet Generation:** Generates code snippets for implementing feature flags in various SDKs.\n*   **Multi-Language Support:** Supports multiple programming languages/SDKs for code snippet generation.\n*   **Experimentation Guidance:** Provides instructions and context on how to run experiments using feature flags.\n*   **Integration with PostHog Dashboard:** Highlights the connection between code implementation and experiment configuration within the PostHog dashboard.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/webflow.tsx",
        "summary": "The `FeatureFlagsWebflowInstructions` component provides instructions for installing the PostHog SDK in a Webflow project and demonstrates how to implement a feature flag using the JavaScript Web SDK. It leverages the `SDKInstallWebflowInstructions` component for installation guidance and the `FlagImplementationSnippet` component to display the code snippet for feature flag implementation using the `JS_WEB` SDK key.\n\nHere's a list of the high-level product features:\n\n*   **Webflow SDK Installation Instructions:** Provides step-by-step instructions for integrating the PostHog SDK into a Webflow project.\n*   **Feature Flag Implementation Snippet:** Displays a code snippet demonstrating how to use feature flags within a Webflow project using the JavaScript Web SDK.\n*   **SDK Selection:** Specifies the JavaScript Web SDK (`JS_WEB`) for feature flag implementation.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/astro.tsx",
        "summary": "The `FeatureFlagsAstroInstructions` component renders instructions for installing the PostHog SDK in an Astro project, followed by a code snippet demonstrating how to implement a feature flag using the JavaScript Web SDK. This component combines installation guidance with a practical example to help users quickly integrate feature flags into their Astro applications.\n\n**Features:**\n\n*   **Astro SDK Installation Instructions:** Provides step-by-step instructions for installing the PostHog SDK within an Astro project.\n*   **Feature Flag Implementation Snippet:** Displays a code snippet demonstrating how to use the JavaScript Web SDK to implement a feature flag.\n*   **SDK Key Parameter:** Uses the `SDKKey.JS_WEB` to specify the relevant SDK for the feature flag implementation.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/vue.tsx",
        "summary": "The `FeatureFlagsVueInstructions` component provides instructions for integrating feature flags into a Vue.js application. It leverages two sub-components: `SDKInstallVueInstructions`, which likely details the steps for installing the PostHog JavaScript SDK in a Vue project, and `FlagImplementationSnippet`, which displays code snippets demonstrating how to implement feature flags using the installed SDK and a provided SDK key.\n\n**Features:**\n\n*   **Vue.js SDK Installation Instructions:** Provides guidance on installing the PostHog JavaScript SDK within a Vue.js project.\n*   **Feature Flag Implementation Snippets:** Offers code examples illustrating how to use the installed SDK to implement feature flags in a Vue.js application.\n*   **SDK Key Integration:** Uses the JavaScript Web SDK key to configure the feature flag implementation snippets.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/php.tsx",
        "summary": "This React component provides instructions for integrating PostHog feature flags into a PHP application. It renders two sub-components: `SDKInstallPHPInstructions`, which likely displays instructions on how to install the PostHog PHP SDK, and `FlagImplementationSnippet`, which shows a code snippet demonstrating how to implement a feature flag using the PHP SDK. The component essentially guides the user through the process of setting up and using feature flags in their PHP project.\n\n**Features:**\n\n*   Displays instructions for installing the PostHog PHP SDK.\n*   Provides a code snippet demonstrating feature flag implementation using the PHP SDK.\n*   Specifically tailored for PHP-based feature flag integration.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/framer.tsx",
        "summary": "The `FeatureFlagsFramerInstructions` component displays instructions for installing the PostHog SDK in a Framer project and provides a code snippet demonstrating how to implement a feature flag using the JavaScript Web SDK. It leverages the `SDKInstallFramerInstructions` component for installation steps and the `FlagImplementationSnippet` component to showcase the feature flag implementation.\n\nHere's a list of high-level product features:\n\n*   **Framer SDK Installation Instructions:** Provides specific instructions for installing the PostHog SDK within a Framer project.\n*   **Feature Flag Implementation Snippet:** Displays a code snippet demonstrating how to use feature flags with the JavaScript Web SDK.\n*   **SDK Selection:** Implicitly supports the JavaScript Web SDK (`SDKKey.JS_WEB`) for feature flag implementation.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/go.tsx",
        "summary": "The `FeatureFlagsGoInstructions` component provides instructions for integrating PostHog feature flags into a Go application. It renders two sub-components: `SDKInstallGoInstructions`, which likely contains instructions on how to install the PostHog Go SDK, and `FlagImplementationSnippet`, which displays a code snippet demonstrating how to implement feature flags using the Go SDK and a provided SDK key.\n\n**Features:**\n\n*   Displays instructions for installing the PostHog Go SDK.\n*   Provides a code snippet demonstrating feature flag implementation using the Go SDK.\n*   Uses the `SDKKey.GO` constant to specify the Go SDK.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/angular.tsx",
        "summary": "This code defines a React component, `FeatureFlagsAngularInstructions`, which renders instructions for installing the PostHog SDK in an Angular project and provides a code snippet demonstrating how to implement a feature flag using the JavaScript Web SDK. The component combines the `SDKInstallAngularInstructions` component, which likely contains the installation steps, with the `FlagImplementationSnippet` component, which displays the feature flag implementation code.\n\nHere's a list of high-level product features:\n\n*   **Angular SDK Installation Instructions:** Provides step-by-step guidance for installing the PostHog SDK in an Angular project.\n*   **Feature Flag Implementation Snippet:** Displays a code snippet demonstrating how to use feature flags within an Angular application using the JavaScript Web SDK.\n*   **SDK Key Configuration:** Allows specifying the appropriate SDK key (in this case, `JS_WEB`) for the feature flag implementation snippet.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/api.tsx",
        "summary": "The code defines a React component `FeatureFlagsAPIInstructions` that renders a `FlagImplementationSnippet` component. The `FlagImplementationSnippet` component receives the `SDKKey.API` as a prop, which likely configures the snippet to display instructions or code related to using feature flags with the PostHog API. Essentially, this component provides instructions on how to implement feature flags using the PostHog API.\n\n**Features:**\n\n*   **Feature Flag Implementation Snippets:** Displays code snippets and instructions for implementing feature flags.\n*   **API SDK Support:** Specifically provides instructions tailored for the PostHog API SDK.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/python.tsx",
        "summary": "This React component, `FeatureFlagsPythonInstructions`, renders instructions for installing the PostHog Python SDK and provides a code snippet demonstrating how to implement feature flags using the SDK. It leverages two sub-components: `SDKInstallPythonInstructions` to display the installation steps and `FlagImplementationSnippet` to show the code snippet, configured specifically for the Python SDK.\n\nHere's a list of high-level product features:\n\n*   **SDK Installation Instructions:** Provides instructions for installing the PostHog Python SDK.\n*   **Feature Flag Implementation Snippet:** Displays a code snippet demonstrating how to use feature flags with the Python SDK.\n*   **Python SDK Support:** Specifically targets and supports the Python SDK for feature flag implementation.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/js-web.tsx",
        "summary": "This React component, `FeatureFlagsJSWebInstructions`, provides instructions and code snippets for integrating PostHog feature flags into a JavaScript web application. It renders the installation instructions using the `SDKInstallJSWebInstructions` component, followed by a visual divider. Then, it displays a code snippet demonstrating how to implement feature flags using the `FlagImplementationSnippet` component, specifically tailored for the JavaScript web SDK.\n\n**Features:**\n\n*   **Installation Instructions:** Displays instructions for installing the PostHog JavaScript web SDK.\n*   **Code Snippet Generation:** Generates and displays a code snippet demonstrating how to implement feature flags using the JavaScript web SDK.\n*   **SDK Key Specification:** Uses the `SDKKey.JS_WEB` constant to configure the code snippet for the JavaScript web SDK.\n*   **Visual Separation:** Uses a divider to visually separate the installation instructions from the code snippet.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/ios.tsx",
        "summary": "The `FeatureFlagsIOSInstructions` component provides a set of instructions and code snippets to guide users in implementing feature flags in their iOS applications using PostHog. It includes steps for installing the iOS SDK, a code snippet demonstrating how to implement a feature flag, and an advertisement for PostHog's mobile replay feature.\n\nHere's a list of the high-level product features this component supports:\n\n*   **iOS SDK Installation Instructions:** Guides users through the process of installing the PostHog iOS SDK.\n*   **Feature Flag Implementation Snippet:** Provides a code example for implementing feature flags in an iOS application.\n*   **Mobile Replay Advertisement:** Promotes PostHog's mobile replay functionality for iOS applications.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/laravel.tsx",
        "summary": "This React component, `FeatureFlagsLaravelInstructions`, provides instructions for integrating feature flags into a Laravel (PHP) application. It leverages two sub-components: `SDKInstallLaravelInstructions` which likely details the steps to install the PostHog PHP SDK within a Laravel project, and `FlagImplementationSnippet` which displays code snippets demonstrating how to implement feature flags using the PHP SDK. The component is designed to guide developers through the process of setting up and using feature flags in their Laravel applications.\n\nHere's a list of high-level product features:\n\n*   **SDK Installation Instructions:** Provides step-by-step instructions for installing the PostHog PHP SDK in a Laravel project.\n*   **Feature Flag Implementation Snippets:** Displays code examples demonstrating how to use the PHP SDK to implement feature flags in Laravel code.\n*   **SDK Key Handling:** Uses the `SDKKey.PHP` constant, likely to configure the code snippets and instructions specifically for the PHP SDK.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/react.tsx",
        "summary": "The `FeatureFlagsReactInstructions` component provides instructions for integrating feature flags into a React application. It leverages two sub-components: `SDKInstallReactInstructions` which likely guides the user through installing the necessary React SDK, and `FlagImplementationSnippet` which displays a code snippet demonstrating how to implement a feature flag using the React SDK. The component aims to streamline the process of setting up and using feature flags in a React project.\n\n**Features:**\n\n*   **React SDK Installation Instructions:** Provides step-by-step guidance on installing the PostHog React SDK.\n*   **Feature Flag Implementation Snippet:** Displays a code example demonstrating how to use feature flags within a React component.\n*   **SDK Key Configuration:** Uses the `SDKKey.REACT` to configure the code snippet for the React SDK.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/nodejs.tsx",
        "summary": "The `FeatureFlagsNodeInstructions` component renders instructions for installing the PostHog Node.js SDK and provides a code snippet demonstrating how to implement a feature flag using the SDK. This component is part of the onboarding process, guiding users on how to integrate PostHog feature flags into their Node.js applications.\n\nHere's a list of high-level product features:\n\n*   **SDK Installation Instructions:** Provides step-by-step guidance on installing the PostHog Node.js SDK.\n*   **Feature Flag Implementation Snippet:** Displays a code example demonstrating how to use the SDK to implement a feature flag.\n*   **SDK Key Integration:** Uses the Node.js SDK key to provide a tailored code snippet.\n*   **Onboarding Support:** Assists new users in integrating PostHog feature flags into their Node.js projects.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/next-js.tsx",
        "summary": "This React component, `FeatureFlagsNextJSInstructions`, provides instructions for integrating PostHog feature flags into a Next.js application. It covers both client-side and server-side rendering scenarios. The component displays installation and configuration steps, along with code snippets demonstrating how to implement feature flags using the React SDK for client-side rendering and the Node.js SDK for server-side rendering. It leverages other components like `SDKInstallNextJSInstructions`, `NodeInstallSnippet`, `NodeSetupSnippet`, and `FlagImplementationSnippet` to present the necessary information.\n\n**Features:**\n\n*   **Next.js Installation Instructions:** Guides users through installing the PostHog SDK in a Next.js project.\n*   **Client-Side Rendering Example:** Provides a code snippet demonstrating feature flag implementation for client-side rendering using the React SDK.\n*   **Server-Side Rendering Instructions:** Details the steps for setting up PostHog for server-side rendering in Next.js.\n*   **Server-Side Rendering Example:** Offers a code snippet showcasing feature flag implementation for server-side rendering using the Node.js SDK.\n*   **Code Snippets:** Displays relevant code snippets for installation, configuration, and feature flag usage.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/FeatureFlagsSDKInstructions.tsx",
        "summary": "This code defines a mapping between SDK keys and their corresponding instruction components for integrating feature flags into various platforms. It essentially provides a lookup table to determine which set of instructions to display based on the selected SDK. The `FeatureFlagsSDKInstructions` object acts as a central registry for all supported SDKs and their associated instruction components.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **SDK-Specific Instructions:** Provides tailored instructions for integrating feature flags into different SDKs and platforms.\n*   **Multi-Platform Support:** Supports a wide range of platforms including web (JavaScript, Angular, React, Vue, Svelte, Next.js, Nuxt.js, Remix.js, Astro, Webflow, Framer), mobile (Android, iOS, React Native, Flutter), backend (Node.js, Go, Python, PHP, Ruby, Django, Laravel), and no-code (Bubble).\n*   **Centralized Instruction Management:** Manages and organizes instructions for all supported SDKs in a single location.\n*   **Onboarding Assistance:** Facilitates the onboarding process for new users by providing clear and concise instructions for their chosen SDK.\n*   **API Integration Instructions:** Includes instructions for integrating feature flags via a generic API.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/svelte.tsx",
        "summary": "This Svelte component provides instructions for integrating feature flags into a Svelte application. It covers both client-side and server-side rendering scenarios. For client-side rendering, it includes instructions for installing the Svelte/JS SDK and a code snippet demonstrating how to implement a feature flag. For server-side rendering, it provides instructions for installing and configuring the Node.js SDK, along with a code snippet for implementing a feature flag in a Node.js environment.\n\nHere's a list of high-level features:\n\n*   **Svelte/JS SDK Installation Instructions:** Guides users on how to install the necessary SDK for client-side feature flag evaluation.\n*   **Client-Side Feature Flag Implementation Snippet:** Provides a code example demonstrating how to use feature flags within a Svelte component rendered on the client.\n*   **Node.js SDK Installation Instructions:** Guides users on how to install the necessary SDK for server-side feature flag evaluation.\n*   **Node.js SDK Configuration Instructions:** Provides instructions on how to configure the Node.js SDK for feature flag evaluation.\n*   **Server-Side Feature Flag Implementation Snippet:** Provides a code example demonstrating how to use feature flags within a Svelte component rendered on the server using Node.js.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/remix.tsx",
        "summary": "The `FeatureFlagsRemixJSInstructions` component provides instructions for integrating PostHog feature flags into a Remix.js application. It covers both client-side and server-side rendering scenarios. The component includes installation and setup instructions, along with code snippets demonstrating how to implement feature flags using the JavaScript Web SDK for client-side rendering and the Node.js SDK for server-side rendering.\n\nHere's a list of high-level features provided by this component:\n\n*   **Client-Side Feature Flag Implementation Instructions:** Provides code snippets and guidance for using PostHog feature flags in client-side Remix.js components.\n*   **Server-Side Feature Flag Implementation Instructions:** Offers code snippets, installation, and configuration steps for utilizing PostHog feature flags in server-side rendered Remix.js applications.\n*   **Remix.js SDK Installation Instructions:** Guides users through the process of installing the necessary PostHog SDKs for Remix.js.\n*   **Node.js SDK Configuration Instructions:** Provides instructions on how to configure the Node.js SDK for use in a Remix.js environment.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/nuxt.tsx",
        "summary": "This code defines a React component, `FeatureFlagsNuxtJSInstructions`, which provides instructions for integrating feature flags into a Nuxt.js application. It includes installation and setup steps for both client-side and server-side rendering. The component leverages other components like `SDKInstallNuxtJSInstructions`, `NodeInstallSnippet`, `NodeSetupSnippet`, and `FlagImplementationSnippet` to display the necessary code snippets and instructions. It targets both React (client-side) and Node.js (server-side) SDKs for feature flag implementation.\n\nHere's a list of high-level product features:\n\n*   **Nuxt.js SDK Installation Instructions:** Provides step-by-step guidance on installing the PostHog SDK in a Nuxt.js project.\n*   **Client-Side Feature Flag Implementation:** Offers code snippets and instructions for implementing feature flags in the client-side rendering of a Nuxt.js application, utilizing the React SDK.\n*   **Server-Side Feature Flag Implementation:** Provides code snippets and instructions for implementing feature flags in the server-side rendering of a Nuxt.js application, utilizing the Node.js SDK.\n*   **Code Snippet Generation:** Automatically generates code snippets for installation, setup, and feature flag usage based on the selected SDK.\n*   **SDK Selection:** Supports different SDKs (React and Node.js) for client-side and server-side implementations.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags/index.tsx",
        "summary": "This code file serves as an index, exporting components related to feature flag implementations for various SDKs and platforms. It aggregates and makes available feature flag onboarding guides and SDK integrations for a wide range of technologies.\n\nHere's a list of high-level product features based on the code:\n\n*   **Android Feature Flag SDK Integration:** Guides and components for integrating feature flags into Android applications.\n*   **Angular Feature Flag SDK Integration:** Guides and components for integrating feature flags into Angular applications.\n*   **API Feature Flag Integration:** Guides and components for using feature flags via a direct API.\n*   **Astro Feature Flag SDK Integration:** Guides and components for integrating feature flags into Astro applications.\n*   **Bubble Feature Flag SDK Integration:** Guides and components for integrating feature flags into Bubble applications.\n*   **Django Feature Flag SDK Integration:** Guides and components for integrating feature flags into Django applications.\n*   **Flutter Feature Flag SDK Integration:** Guides and components for integrating feature flags into Flutter applications.\n*   **Framer Feature Flag SDK Integration:** Guides and components for integrating feature flags into Framer applications.\n*   **Go Feature Flag SDK Integration:** Guides and components for integrating feature flags into Go applications.\n*   **iOS Feature Flag SDK Integration:** Guides and components for integrating feature flags into iOS applications.\n*   **JavaScript (Web) Feature Flag SDK Integration:** Guides and components for integrating feature flags into JavaScript web applications.\n*   **Laravel Feature Flag SDK Integration:** Guides and components for integrating feature flags into Laravel applications.\n*   **Next.js Feature Flag SDK Integration:** Guides and components for integrating feature flags into Next.js applications.\n*   **Node.js Feature Flag SDK Integration:** Guides and components for integrating feature flags into Node.js applications.\n*   **Nuxt Feature Flag SDK Integration:** Guides and components for integrating feature flags into Nuxt applications.\n*   **PHP Feature Flag SDK Integration:** Guides and components for integrating feature flags into PHP applications.\n*   **Python Feature Flag SDK Integration:** Guides and components for integrating feature flags into Python applications.\n*   **React Feature Flag SDK Integration:** Guides and components for integrating feature flags into React applications.\n*   **React Native Feature Flag SDK Integration:** Guides and components for integrating feature flags into React Native applications.\n*   **Remix Feature Flag SDK Integration:** Guides and components for integrating feature flags into Remix applications.\n*   **Ruby Feature Flag SDK Integration:** Guides and components for integrating feature flags into Ruby applications.\n*   **Svelte Feature Flag SDK Integration:** Guides and components for integrating feature flags into Svelte applications.\n*   **Vue Feature Flag SDK Integration:** Guides and components for integrating feature flags into Vue applications.\n*   **Webflow Feature Flag SDK Integration:** Guides and components for integrating feature flags into Webflow applications.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/feature-flags",
        "summary": "This collection of components provides comprehensive onboarding and integration guides for implementing feature flags across a wide variety of platforms and SDKs. The system offers tailored instructions, code snippets, and SDK-specific configurations to streamline the process of integrating PostHog's feature flag capabilities into diverse development environments, ranging from web and mobile applications to backend services and no-code platforms. The components also promote related features like mobile replay and experimentation, enhancing the overall user experience.\n\n*   **SDK Installation Instructions:** Provides step-by-step guidance for installing PostHog SDKs across various platforms (Web, Mobile, Backend, No-Code).\n*   **Feature Flag Implementation Snippets:** Generates and displays code examples demonstrating how to use feature flags within different SDKs and environments.\n*   **Multi-Platform Support:** Supports a wide range of platforms including Android, Angular, API, Astro, Bubble, Django, Flutter, Framer, Go, iOS, JavaScript (Web), Laravel, Next.js, Node.js, Nuxt.js, PHP, Python, React, React Native, Remix, Ruby, Svelte, Vue, and Webflow.\n*   **Client-Side and Server-Side Rendering Support:** Offers specific instructions and code snippets for implementing feature flags in both client-side and server-side rendering scenarios for frameworks like Next.js, Nuxt.js, Svelte, and Remix.js.\n*   **Mobile Replay Advertisement:** Promotes the mobile replay feature, encouraging users to integrate session replay capabilities into their mobile applications.\n*   **Experimentation Guidance:** Provides instructions and context on how to run experiments using feature flags.\n*   **SDK Key Configuration:** Uses SDK keys to configure code snippets and instructions specifically for each supported SDK.\n*   **Centralized Instruction Management:** Manages and organizes instructions for all supported SDKs in a single location.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/python.tsx",
        "summary": "The `ProductAnalyticsPythonInstructions` component provides instructions for integrating PostHog's product analytics features into a Python application. It includes steps for installing the PostHog Python SDK, sending a basic event using `posthog.capture()`, and instructions for setting event properties in person mode.\n\nHere's a list of the high-level features demonstrated:\n\n*   **SDK Installation Instructions:** Guides the user on how to install the PostHog Python SDK.\n*   **Event Tracking:** Shows how to capture events using the `posthog.capture()` method.\n*   **Person Mode Event Properties:** Provides instructions on how to set event properties when using person mode.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/elixir.tsx",
        "summary": "The code defines a React component `ProductAnalyticsElixirInstructions` that renders the `SDKInstallElixirInstructions` component. This component likely provides instructions for installing and configuring the PostHog Elixir SDK for product analytics.\n\n**Features:**\n\n*   **Elixir SDK Installation Instructions:** Provides step-by-step guidance for integrating the PostHog Elixir SDK into Elixir applications.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/shared-snippets.tsx",
        "summary": "This code provides React components for displaying instructions and code snippets related to PostHog onboarding, specifically for session replay and event processing. It includes a component for final session replay steps and another for explaining and providing a code snippet to disable person profile processing for specific events, which is conditionally rendered based on a feature flag.\n\nHere's a list of high-level product features:\n\n*   **Session Replay Onboarding Instructions:** Guides users on how to generate initial session recordings.\n*   **Person Profile Processing Control:** Allows users to disable person profile creation for specific events.\n*   **Code Snippet Display:** Shows code snippets for disabling person profile processing.\n*   **Feature Flag Integration:** Conditionally renders content based on feature flag status.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/flutter.tsx",
        "summary": "This code provides instructions and code snippets for integrating PostHog's product analytics features into a Flutter application. It guides the user through installation, event tracking, and setting user properties. It also promotes the mobile session replay feature.\n\nHere's a list of high-level features:\n\n*   **Installation Instructions:** Guides users on how to install the PostHog Flutter SDK.\n*   **Event Tracking:** Provides a code snippet demonstrating how to capture screen events in Flutter.\n*   **User Properties:** Includes instructions on how to set user properties, likely for user identification and segmentation.\n*   **Session Replay Advertisement:** Promotes PostHog's mobile session replay feature.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/next-js.tsx",
        "summary": "The `ProductAnalyticsNextJSInstructions` component renders instructions for integrating PostHog's product analytics into a Next.js application. It combines Next.js specific installation steps with general JavaScript final setup instructions. This allows users to easily configure PostHog for tracking user behavior and product usage within their Next.js projects.\n\n**Features:**\n\n*   **Next.js Installation Instructions:** Provides specific instructions for installing the PostHog SDK in a Next.js project.\n*   **General JavaScript Setup:** Guides users through the final steps required to complete the integration of PostHog, applicable to all JavaScript projects.\n*   **Step-by-step guidance:** Divides the integration process into manageable steps.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/bubble.tsx",
        "summary": "The `ProductAnalyticsBubbleInstructions` component combines two sub-components to guide users through the product analytics SDK onboarding process. It first displays general SDK installation instructions using `SDKInstallBubbleInstructions`, and then presents product analytics specific final steps using `ProductAnalyticsAllJSFinalSteps`. This provides a step-by-step guide for users to integrate the product analytics SDK into their projects.\n\nHere's a list of high-level product features:\n\n*   **SDK Installation Instructions:** Provides instructions for installing the SDK.\n*   **Product Analytics Specific Final Steps:** Guides users through the final steps required for product analytics setup.\n*   **Step-by-Step Onboarding:** Offers a structured, step-by-step guide for SDK integration.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/django.tsx",
        "summary": "The `ProductAnalyticsDjangoInstructions` component provides instructions for integrating PostHog product analytics into a Django application. It includes steps for installing the PostHog Python library, sending a basic event using `posthog.capture`, and instructions for setting user identity and properties.\n\n**Features:**\n\n*   **Installation Instructions:** Guides users through installing the PostHog Python library for Django.\n*   **Event Tracking:** Demonstrates how to capture events using the `posthog.capture` method.\n*   **User Identification:** Provides instructions for setting user identity and properties.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/RealtimeCheckIndicator.tsx",
        "summary": "The `RealtimeCheckIndicator` component provides real-time feedback on the status of a PostHog SDK installation. It uses the `useInstallationComplete` hook to determine if a specified team property has been received, indicating successful installation. Based on the installation status, it displays either a \"Installation Complete\" message with a checkmark and a live events feed, or a \"Verify Installation\" message with a waiting indicator that listens for a specified event.\n\nHere's a list of high-level product features:\n\n*   **Real-time Installation Verification:** Provides immediate feedback on whether the PostHog SDK has been successfully installed.\n*   **Dynamic Status Updates:** Changes the displayed message and indicator based on the installation status.\n*   **Event Listening:** Monitors incoming events to determine installation completion.\n*   **Visual Indicators:** Uses checkmarks and waiting animations to clearly communicate the installation status.\n*   **Live Event Feed:** Displays a live feed of events after successful installation.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/AllJSFinalSteps.tsx",
        "summary": "The `ProductAnalyticsAllJSFinalSteps` component provides instructions for users who have integrated PostHog's JavaScript library for product analytics. It guides users to generate automatic events by navigating the application and suggests sending manual events using the `posthog.capture` function with an example code snippet.\n\n**Features:**\n\n*   **Instructions for Automatic Event Capture:** Guides users to generate events by interacting with the application.\n*   **Manual Event Sending Guidance:** Provides instructions and an example code snippet for manually sending events using `posthog.capture`.\n*   **Code Snippet Display:** Shows a JavaScript code snippet demonstrating how to capture a custom event with properties.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/angular.tsx",
        "summary": "The `ProductAnalyticsAngularInstructions` component provides instructions for integrating PostHog's product analytics into an Angular application. It leverages two sub-components: `SDKInstallAngularInstructions`, which likely contains the Angular-specific installation steps, and `ProductAnalyticsAllJSFinalSteps`, which probably includes the final steps common to all JavaScript-based integrations. A LemonDivider visually separates these two sets of instructions.\n\n**Features:**\n\n*   **Angular SDK Installation Instructions:** Provides step-by-step guidance for installing the PostHog SDK in an Angular project.\n*   **Common JavaScript Integration Steps:** Includes final integration steps applicable to all JavaScript-based product analytics setups.\n*   **Visual Separation of Steps:** Uses a divider to clearly distinguish between Angular-specific installation and general integration steps.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/svelte.tsx",
        "summary": "The `ProductAnalyticsSvelteJSInstructions` component renders instructions for integrating PostHog's product analytics with a Svelte.js application. It leverages two sub-components: `SDKInstallSvelteJSInstructions` to guide the user through the initial SDK installation steps specific to Svelte, and `ProductAnalyticsAllJSFinalSteps` to provide generic JavaScript-based final configuration and verification steps applicable across different JavaScript frameworks.\n\nHere's a list of high-level product features:\n\n*   **Svelte.js SDK Installation Instructions:** Provides step-by-step guidance for installing the PostHog SDK in a Svelte.js project.\n*   **Generic JavaScript Configuration Steps:** Offers framework-agnostic instructions for completing the product analytics setup.\n*   **Verification Steps:** Guides the user through verifying that the integration is working correctly.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/android.tsx",
        "summary": "The `ProductAnalyticsAndroidInstructions` component provides instructions and code snippets for integrating PostHog's product analytics features into an Android application. It guides users through the installation process, demonstrates how to capture events, and highlights the use of person mode and event properties. It also advertises the mobile replay feature.\n\nHere's a list of high-level features covered in the component:\n\n*   **SDK Installation Instructions:** Guides users on how to install the PostHog Android SDK.\n*   **Event Capture:** Shows how to capture events using the `PostHog.capture()` method.\n*   **Person Mode and Event Properties:** Demonstrates how to use person mode and event properties to enrich captured data.\n*   **Mobile Replay Advertisement:** Promotes the mobile replay feature for session recording and analysis.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/astro.tsx",
        "summary": "The `ProductAnalyticsAstroInstructions` component provides instructions for integrating PostHog's product analytics with an Astro project. It leverages two sub-components: `SDKInstallAstroInstructions`, which likely contains the Astro-specific installation steps, and `ProductAnalyticsAllJSFinalSteps`, which probably includes the final steps common to all JavaScript-based integrations.\n\nHere's a list of high-level features provided by this component:\n\n*   **Astro-Specific Installation Guide:** Provides instructions tailored for integrating PostHog into Astro projects.\n*   **SDK Installation Instructions:** Guides users through the process of installing the PostHog SDK.\n*   **Final Integration Steps:** Outlines the concluding steps required to complete the PostHog integration, applicable across JavaScript projects.\n*   **Product Analytics Integration:** Enables product analytics tracking within an Astro application using PostHog.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/laravel.tsx",
        "summary": "This code defines a React component, `ProductAnalyticsLaravelInstructions`, which renders instructions for integrating PostHog product analytics into a Laravel application. It includes instructions for installing the Laravel SDK, a code snippet demonstrating how to capture an event using the SDK, and instructions related to identifying users and setting event properties.\n\nHere's a list of high-level features provided by this component:\n\n*   **SDK Installation Instructions:** Guides users through the process of installing the PostHog Laravel SDK.\n*   **Event Capture Example:** Provides a code snippet demonstrating how to capture events with user identification in Laravel.\n*   **User Identification and Event Properties Instructions:** Guides users on how to set user properties and event properties.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/webflow.tsx",
        "summary": "This code defines a React component, `ProductAnalyticsWebflowInstructions`, which renders instructions for integrating a product analytics SDK into a Webflow website. It combines two sets of instructions: Webflow-specific installation steps (`SDKInstallWebflowInstructions`) and final steps common to all JavaScript-based integrations (`ProductAnalyticsAllJSFinalSteps`).\n\nHere's a list of high-level product features this component supports:\n\n*   **Webflow Integration Instructions:** Provides specific guidance for installing a product analytics SDK within a Webflow environment.\n*   **JavaScript SDK Support:** Handles the final configuration steps common to JavaScript-based product analytics SDK integrations.\n*   **Step-by-Step Guidance:** Offers a structured, step-by-step approach to integrating product analytics.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/vue.tsx",
        "summary": "The `ProductAnalyticsVueInstructions` component renders instructions for integrating PostHog's product analytics with a Vue.js application. It leverages two sub-components: `SDKInstallVueInstructions`, which likely provides the initial steps for installing the PostHog SDK within a Vue project, and `ProductAnalyticsAllJSFinalSteps`, which probably outlines the concluding steps applicable to all JavaScript-based integrations, including Vue.\n\n**Features:**\n\n*   **Vue.js SDK Installation Guide:** Provides step-by-step instructions for installing the PostHog SDK in a Vue.js project.\n*   **Generic JavaScript Finalization Steps:** Guides the user through the final configuration and verification steps common to all JavaScript-based PostHog integrations.\n*   **Unified Onboarding Experience:** Combines Vue-specific installation with general JavaScript finalization for a seamless onboarding process.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/traceloop.tsx",
        "summary": "This component provides instructions for integrating Traceloop, an LLM observability platform, with PostHog for product analytics. It guides users through the process of connecting their Traceloop account to PostHog by providing steps to locate the PostHog project API key and host URL, and then enabling the integration within the Traceloop dashboard. This allows Traceloop events to be exported into PostHog for analysis.\n\nHere's a list of high-level product features:\n\n*   **Integration Instructions:** Provides step-by-step instructions for integrating Traceloop with PostHog.\n*   **API Key Display:** Displays the user's PostHog project API key for easy copying and pasting into Traceloop.\n*   **Host URL Display:** Displays the PostHog host URL for easy copying and pasting into Traceloop.\n*   **Links to External Resources:** Provides links to the Traceloop website and integrations page for easy access.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/index.tsx",
        "summary": "This code file serves as an index, exporting a collection of modules related to integrating PostHog product analytics with various SDKs and platforms. It essentially bundles together different onboarding guides or setup instructions tailored for specific technologies.\n\nHere's a list of the supported SDKs and platforms:\n\n*   Android\n*   Angular\n*   API\n*   Astro\n*   Bubble\n*   Django\n*   Elixir\n*   Flutter\n*   Framer\n*   Go\n*   Helicone\n*   HTML Snippet\n*   iOS\n*   JS Web\n*   Langfuse\n*   Laravel\n*   Next.js\n*   Node.js\n*   Nuxt\n*   PHP\n*   Python\n*   React\n*   React Native\n*   Remix\n*   Ruby\n*   Svelte\n*   Traceloop\n*   Vue\n*   Webflow\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/remix.tsx",
        "summary": "The `ProductAnalyticsRemixJSInstructions` component renders instructions for installing the PostHog SDK in a Remix.js project. It combines the generic Remix.js installation instructions with final steps common to all JavaScript-based product analytics integrations. This provides a complete guide for users setting up PostHog in their Remix.js application.\n\nHere's a list of high-level features provided by this component:\n\n*   **Remix.js SDK Installation Instructions:** Provides specific instructions for installing the PostHog SDK within a Remix.js project.\n*   **Generic JavaScript Product Analytics Final Steps:** Includes final configuration steps applicable to all JavaScript-based product analytics integrations, ensuring a complete setup process.\n*   **Combined Installation Guide:** Integrates Remix.js-specific instructions with general JavaScript product analytics steps for a streamlined user experience.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/framer.tsx",
        "summary": "The `ProductAnalyticsFramerInstructions` component combines two sub-components to guide users through integrating product analytics into a Framer project. It first displays the standard SDK installation instructions tailored for Framer, and then presents the final steps applicable to all JavaScript-based product analytics integrations. This provides a comprehensive onboarding experience for Framer users looking to implement product analytics.\n\nHere's a list of the high-level features:\n\n*   **Framer-Specific SDK Installation Instructions:** Provides tailored guidance for installing the product analytics SDK within a Framer environment.\n*   **Generic JavaScript Final Steps:** Outlines the concluding steps necessary for completing the product analytics integration, applicable across all JavaScript projects.\n*   **Combined Onboarding Flow:** Integrates both Framer-specific and general JavaScript instructions into a single, cohesive onboarding experience.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/go.tsx",
        "summary": "The `ProductAnalyticsGoInstructions` component provides instructions for integrating PostHog's product analytics features into a Go application. It includes steps for installing the Go SDK, sending a basic event using `client.Enqueue`, and instructions related to identifying users and setting user properties. The component leverages shared snippets for installation instructions and user property guidance.\n\n**Features:**\n\n*   **Go SDK Installation Instructions:** Guides users through installing the PostHog Go SDK.\n*   **Basic Event Capture:** Demonstrates how to send a simple event to PostHog using the `client.Enqueue` method with a distinct user ID and event name.\n*   **User Identification and Properties:** Provides instructions on how to identify users and set user properties for more detailed analytics (likely through a shared component).\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/ios.tsx",
        "summary": "This code defines a React component, `ProductAnalyticsIOSInstructions`, which provides instructions for integrating PostHog's product analytics features into an iOS application. It includes steps for installing the iOS SDK, sending a basic event, setting user properties, and advertising the mobile replay feature. The component leverages other components like `SDKInstallIOSInstructions`, `CodeSnippet`, `PersonModeEventPropertyInstructions`, and `AdvertiseMobileReplay` to present these instructions in a clear and concise manner.\n\nHere's a list of high-level product features that the code helps implement:\n\n*   **iOS SDK Installation Instructions:** Guides users through the process of installing the PostHog iOS SDK.\n*   **Event Tracking:** Demonstrates how to capture and send custom events from an iOS application to PostHog.\n*   **User Identification:** Provides instructions on how to identify users and set user properties.\n*   **Mobile Session Replay:** Promotes the use of PostHog's mobile session replay feature for iOS applications.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/nuxt.tsx",
        "summary": "The `ProductAnalyticsNuxtJSInstructions` component renders instructions for installing and configuring PostHog's product analytics SDK within a Nuxt.js application. It leverages two sub-components: `SDKInstallNuxtJSInstructions` to provide Nuxt.js specific installation steps, and `ProductAnalyticsAllJSFinalSteps` to handle the final configuration steps common to all JavaScript-based SDK installations.\n\nHere's a list of high-level product features:\n\n*   **Nuxt.js SDK Installation Instructions:** Provides step-by-step guidance for installing the PostHog SDK in a Nuxt.js project.\n*   **JavaScript SDK Configuration:** Guides the user through the final configuration steps required for the JavaScript SDK, applicable across different JavaScript frameworks.\n*   **Product Analytics Integration:** Enables the collection of product analytics data from a Nuxt.js application using PostHog.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/ruby.tsx",
        "summary": "The `ProductAnalyticsRubyInstructions` component provides instructions for integrating PostHog's product analytics features into a Ruby application. It includes steps for installing the Ruby SDK, sending a basic event with a distinct ID, and instructions for using person mode and event properties. The component leverages other components like `SDKInstallRubyInstructions`, `RubyCaptureSnippet`, and `PersonModeEventPropertyInstructions` to display code snippets and explanations.\n\nHere's a list of high-level features:\n\n*   **Ruby SDK Installation Instructions:** Guides users through installing the PostHog Ruby SDK.\n*   **Basic Event Capture:** Demonstrates how to capture a simple event with a distinct user ID using the Ruby SDK.\n*   **Person Mode and Event Properties Instructions:** Provides guidance on leveraging person mode and event properties for richer user data and analysis.\n*   **Code Snippets:** Displays code examples for easy copy-pasting and implementation.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/react.tsx",
        "summary": "The `ProductAnalyticsReactInstructions` component provides instructions for integrating PostHog's product analytics SDK into a React application. It combines React-specific installation instructions with general JavaScript final steps to guide the user through the complete setup process. The component leverages `SDKInstallReactInstructions` for the React-specific part and `ProductAnalyticsAllJSFinalSteps` for the concluding steps applicable to all JavaScript projects.\n\nHere's a list of high-level product features:\n\n*   **React-Specific Installation Instructions:** Provides tailored guidance for installing the PostHog SDK in a React environment.\n*   **General JavaScript Final Steps:** Includes universal instructions applicable to all JavaScript projects to complete the SDK integration.\n*   **Step-by-Step Guidance:** Offers a structured approach to guide users through the entire SDK setup process.\n*   **UI Dividers:** Uses visual separators to clearly distinguish between different sets of instructions.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/html-snippet.tsx",
        "summary": "This React component, `HTMLSnippetInstructions`, is designed for onboarding users to PostHog's product analytics features. It combines two sub-components: `SDKHtmlSnippetInstructions`, which likely provides instructions on how to install PostHog's JavaScript snippet into an HTML page, and `ProductAnalyticsAllJSFinalSteps`, which probably outlines the final steps needed to complete the integration and start using product analytics. A LemonDivider visually separates these two sets of instructions.\n\nHere's a list of the high-level product features this component supports:\n\n*   **HTML Snippet Installation Instructions:** Guides users on how to embed the PostHog JavaScript snippet into their website's HTML.\n*   **Final Integration Steps:** Provides a checklist or instructions for completing the product analytics setup after the snippet is installed.\n*   **Visual Separation of Steps:** Uses a divider to clearly distinguish between the initial installation and the final configuration steps.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/langfuse.tsx",
        "summary": "This component provides instructions for integrating Langfuse, an LLM tracing tool, with PostHog for product analytics. It guides users through the process of configuring the PostHog integration within the Langfuse dashboard, including retrieving the PostHog API key and host URL and enabling the integration. The component emphasizes that Langfuse data is batch exported to PostHog daily, so there may be a delay before the data appears in PostHog.\n\nHere's a list of high-level product features:\n\n*   **Integration Instructions:** Provides step-by-step instructions for integrating Langfuse with PostHog.\n*   **API Key Display:** Displays the user's PostHog API key for easy copying and pasting into Langfuse.\n*   **Host URL Display:** Displays the PostHog host URL for configuration in Langfuse.\n*   **Links to External Resources:** Provides links to Langfuse documentation and dashboard for further information and configuration.\n*   **Data Export Information:** Informs users about the daily batch export of Langfuse data to PostHog and potential delays.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/react-native.tsx",
        "summary": "The code defines a React component `ProductAnalyticsRNInstructions` that provides instructions for integrating PostHog's product analytics into a React Native application. It includes instructions for installing the SDK, a code snippet demonstrating how to manually capture events using the `usePostHog` hook, and a component advertising mobile session replay functionality. The component aims to guide users through the initial setup and usage of PostHog's product analytics features in a React Native environment.\n\nHere's a list of high-level product features highlighted in the code:\n\n*   **SDK Installation Instructions:** Provides guidance on installing the PostHog React Native SDK.\n*   **Automatic Event Capture:** Implies that the SDK automatically captures certain events without manual configuration.\n*   **Manual Event Capture:** Enables users to define and capture custom events using the `posthog.capture` method.\n*   **React Hooks Integration:** Demonstrates how to use the `usePostHog` hook for easy access to PostHog functionality within React components.\n*   **Mobile Session Replay Advertisement:** Promotes the availability of mobile session replay functionality as an additional feature.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/nodejs.tsx",
        "summary": "This code defines a React component, `ProductAnalyticsNodeInstructions`, which renders instructions for integrating PostHog's product analytics SDK into a Node.js application. It includes installation instructions (via the `SDKInstallNodeInstructions` component) and a code snippet (`NodeCaptureSnippet`) demonstrating how to capture an event with a distinct ID using the PostHog client. The snippet also shows how to immediately send queued events and shut down the client, which is useful in serverless environments.\n\nHere's a list of high-level product features demonstrated by this code:\n\n*   **Node.js SDK Installation Instructions:** Provides guidance on installing the PostHog SDK in a Node.js environment.\n*   **Event Capture:** Enables tracking of user actions or events within a Node.js application.\n*   **Distinct ID Assignment:** Allows associating events with specific users or entities using a distinct ID.\n*   **Event Queue Management:** Offers control over how events are queued and sent to PostHog.\n*   **Serverless Environment Support:** Provides specific instructions for using the SDK in serverless environments, including immediate event flushing and client shutdown.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/ProductAnalyticsSDKInstructions.tsx",
        "summary": "This code defines a mapping between SDK keys and their corresponding instruction components for product analytics integration. It essentially provides a centralized registry of instructions for various platforms and frameworks, allowing users to easily find the specific instructions needed to integrate product analytics into their projects. The `ProductAnalyticsSDKInstructions` object acts as a lookup table, associating each supported SDK (e.g., JavaScript, Android, React) with the appropriate UI component that renders the integration instructions.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **SDK Integration Instructions:** Provides platform-specific instructions for integrating the product analytics SDK into various environments.\n*   **Web Integration:** Supports integration with JavaScript web applications, including frameworks like React, Angular, Vue.js, Svelte, Next.js, Nuxt.js, Remix, Astro, and Webflow.\n*   **Mobile Integration:** Supports integration with mobile applications built using Android, iOS, React Native, and Flutter.\n*   **Backend Integration:** Supports integration with backend frameworks and languages like Node.js, Python, Django, PHP, Ruby, Go, Elixir, and Laravel.\n*   **API Integration:** Offers instructions for integrating via a generic API.\n*   **Low-Code Integration:** Supports integration with low-code platforms like Bubble and Framer.\n*   **Observability Integration:** Supports integration with observability tools like Helicone and Traceloop and Langfuse.\n*   **HTML Snippet Integration:** Provides instructions for simple HTML snippet integration.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/js-web.tsx",
        "summary": "The `JSWebInstructions` component renders instructions for integrating PostHog's product analytics SDK into a JavaScript web application. It displays the initial installation instructions using the `SDKInstallJSWebInstructions` component, followed by a visual divider, and then presents the final steps common to all JavaScript integrations using the `ProductAnalyticsAllJSFinalSteps` component.\n\nHere's a list of high-level product features:\n\n*   **SDK Installation Instructions:** Provides instructions for installing the PostHog JavaScript web SDK.\n*   **Final Steps for JS Integrations:** Guides the user through the final steps required for all JavaScript-based product analytics integrations.\n*   **Visual Separation of Steps:** Uses a divider to clearly separate the initial installation steps from the final configuration steps.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/helicone.tsx",
        "summary": "This component provides instructions for integrating Helicone, an LLM observability platform, with PostHog for product analytics. It guides users through the process of setting up Helicone and configuring it to send data to PostHog by adding specific headers (Helicone-Posthog-Key and Helicone-Posthog-Host) to their LLM requests. The instructions include a code snippet demonstrating how to add these headers when using OpenAI in Python.\n\nHere's a list of high-level product features:\n\n*   **Integration Instructions:** Provides step-by-step instructions for integrating Helicone with PostHog.\n*   **Helicone Setup Guidance:** Guides users on setting up Helicone for LLM observability.\n*   **Header Configuration:** Explains how to configure Helicone to send data to PostHog using specific headers.\n*   **Code Snippet Example:** Offers a Python code example demonstrating how to add the necessary headers.\n*   **Links to External Resources:** Provides links to Helicone's website and documentation for further information.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics/php.tsx",
        "summary": "This code defines a React component, `ProductAnalyticsPHPInstructions`, which renders instructions for integrating PostHog's product analytics with a PHP application. It includes instructions for installing the PHP SDK, a code snippet demonstrating how to capture an event with a distinct user ID, and instructions for setting event properties. The component utilizes other components like `SDKInstallPHPInstructions`, `PHPCaptureSnippet`, `PersonModeEventPropertyInstructions`, and `CodeSnippet` to display the information in a structured and user-friendly manner.\n\nHere's a list of high-level product features demonstrated by this code:\n\n*   **PHP SDK Installation Instructions:** Provides guidance on installing the PostHog PHP SDK.\n*   **Event Tracking:** Demonstrates how to capture events using the PHP SDK.\n*   **User Identification:** Shows how to associate events with distinct users using a `distinctId`.\n*   **Event Properties:** Provides instructions on how to set event properties.\n*   **Code Snippets:** Displays code examples for easy copy-pasting and implementation.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/product-analytics",
        "summary": "The provided code files detail the onboarding process for integrating PostHog's product analytics features into a wide variety of applications and platforms. The system offers tailored instructions for each SDK, guiding users through installation, event tracking, user identification, and configuration. The onboarding process is designed to be step-by-step and user-friendly, often combining platform-specific instructions with general JavaScript setup steps where applicable, and providing code snippets for easy implementation. The system also supports integrations with LLM observability platforms like Traceloop, Langfuse, and Helicone, allowing users to export data from these platforms into PostHog for analysis.\n\nHere's a list of high-level product features:\n\n*   **SDK Installation Instructions:** Provides platform-specific guides for installing PostHog SDKs across various environments (web, mobile, backend).\n*   **Event Tracking:** Demonstrates how to capture user actions and events within applications.\n*   **User Identification:** Guides users on how to identify users and set user properties for segmentation and analysis.\n*   **Platform Support:** Offers integration instructions for a wide range of platforms and frameworks, including JavaScript frameworks (React, Angular, Vue.js, Svelte, Next.js, Nuxt.js, Remix, Astro), mobile platforms (Android, iOS, React Native, Flutter), backend languages (Node.js, Python, Django, PHP, Ruby, Go, Elixir, Laravel), and low-code platforms (Bubble, Framer, Webflow).\n*   **LLM Observability Integration:** Supports integration with LLM observability platforms like Traceloop, Langfuse, and Helicone.\n*   **Code Snippets:** Provides code examples for easy copy-pasting and implementation.\n*   **Automatic Event Capture:** Implies automatic event capture capabilities in some SDKs.\n*   **Mobile Session Replay:** Advertises mobile session replay functionality.\n*   **API Integration:** Offers instructions for integrating via a generic API.\n*   **Step-by-Step Guidance:** Provides a structured, step-by-step approach to integrating product analytics.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay/angular.tsx",
        "summary": "This code defines a React component called `AngularInstructions` that renders instructions for installing the Sentry SDK in an Angular application with session replay enabled. It leverages two sub-components: `SDKInstallAngularInstructions` which likely provides the core SDK installation steps specific to Angular, and `SessionReplayFinalSteps` which probably outlines the final steps needed to enable and configure session replay functionality.\n\n**Features:**\n\n*   **Angular SDK Installation Instructions:** Provides step-by-step guidance for installing the Sentry SDK in an Angular project.\n*   **Session Replay Configuration:** Guides the user through the necessary steps to enable and configure session replay within their Angular application.\n*   **Combined Instructions:** Presents both SDK installation and session replay configuration in a single, unified view.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay/flutter.tsx",
        "summary": "The `FlutterInstructions` component renders instructions for installing the PostHog SDK in a Flutter application with session replay enabled. It combines the `SDKInstallFlutterInstructions` component, which provides the core installation steps, with the `SessionReplayFinalSteps` component, which likely contains steps specific to finalizing the session replay setup.\n\nHere's a list of high-level product features this code supports:\n\n*   **Flutter SDK Installation Instructions:** Provides guidance on integrating the PostHog SDK into Flutter applications.\n*   **Session Replay:** Enables the capture and playback of user sessions within Flutter apps.\n*   **Step-by-step Installation Guide:** Offers a structured approach to installing the SDK and configuring session replay.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay/js-web.tsx",
        "summary": "The `JSWebInstructions` component renders instructions for installing the PostHog SDK for JavaScript web applications, specifically focusing on session replay functionality. It combines the standard SDK installation steps with final steps tailored for session replay setup.\n\n**Features:**\n\n*   **JavaScript Web SDK Installation Instructions:** Provides guidance on integrating the PostHog SDK into JavaScript web projects.\n*   **Session Replay Specific Setup:** Includes steps necessary to enable and configure session replay within the JavaScript web environment.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay/webflow.tsx",
        "summary": "This code defines a React component called `WebflowInstructions` that renders instructions for installing the PostHog SDK in a Webflow project. It leverages two pre-existing components: `SDKInstallWebflowInstructions` which likely contains the Webflow-specific installation steps, and `SessionReplayFinalSteps` which probably includes generic steps to finalize the session replay setup.\n\n**Features:**\n\n*   **Webflow SDK Installation Instructions:** Provides step-by-step guidance for integrating the PostHog SDK into a Webflow website.\n*   **Session Replay Setup Completion:** Guides the user through the final steps required to enable and configure session replay functionality.\n*   **Reusability:** Leverages shared components for common installation steps, promoting code maintainability and consistency.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay/astro.tsx",
        "summary": "The `AstroInstructions` component renders instructions for installing the PostHog SDK in an Astro project, specifically for session replay functionality. It combines the general Astro SDK installation steps with the final steps required to enable session replay.\n\n**Features:**\n\n*   **Astro SDK Installation Instructions:** Provides guidance on installing the PostHog SDK within an Astro project.\n*   **Session Replay Configuration:** Guides users through the necessary steps to configure session replay after installing the SDK.\n*   **Combined Instructions:** Presents a consolidated view of both SDK installation and session replay setup for Astro projects.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay/ios.tsx",
        "summary": "The `iOSInstructions` component renders instructions for installing the PostHog iOS SDK with session replay enabled. It leverages two sub-components: `SDKInstallIOSInstructions` which provides the core installation steps, and `SessionReplayFinalSteps` which likely contains steps specific to finalizing the session replay setup.\n\n**Features:**\n\n*   **iOS SDK Installation Instructions:** Provides instructions for installing the PostHog iOS SDK.\n*   **Session Replay Integration:** Guides users through enabling session replay functionality within the iOS SDK.\n*   **Step-by-step Guidance:** Offers a structured approach to integrating PostHog with an iOS application, ensuring a smooth onboarding experience.\n*   **Finalization Steps:** Includes specific steps to finalize the session replay setup.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay/remix.tsx",
        "summary": "The `RemixInstructions` component renders instructions for installing the PostHog SDK in a Remix.js application. It uses the `SDKInstallRemixJSInstructions` component to display the core installation steps specific to Remix.js and the `SessionReplayFinalSteps` component to show the final steps required to enable session replay.\n\nHere's a list of high-level product features:\n\n*   **Remix.js SDK Installation Instructions:** Provides step-by-step guidance for installing the PostHog SDK in a Remix.js project.\n*   **Session Replay Setup:** Guides users through the final steps needed to enable session replay functionality after SDK installation.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay/svelte.tsx",
        "summary": "The `SvelteInstructions` component renders instructions for installing the PostHog SDK in a Svelte application, specifically for session replay functionality. It leverages two sub-components: `SDKInstallSvelteJSInstructions` to provide the core SDK installation steps tailored for Svelte, and `SessionReplayFinalSteps` to guide the user through the final configuration steps required to enable session replay.\n\nHere's a list of high-level product features this code relates to:\n\n*   **Svelte SDK Installation Instructions:** Provides step-by-step guidance for installing the PostHog SDK in Svelte applications.\n*   **Session Replay Setup:** Guides users through the necessary steps to enable and configure session replay within their Svelte application.\n*   **Platform-Specific Instructions:** Offers tailored instructions based on the user's chosen framework (Svelte in this case).\n*   **Onboarding Assistance:** Helps new users get started with PostHog by providing clear and concise installation and configuration instructions.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay/react-native.tsx",
        "summary": "This React component, `RNInstructions`, is designed to guide users through the process of integrating session replay functionality into their React Native applications. It leverages two sub-components: `SDKInstallRNInstructions` (with the `includeReplay` prop set to `true`) to provide React Native-specific installation instructions, and `SessionReplayFinalSteps` to outline the concluding steps necessary to complete the session replay setup.\n\nHere's a list of high-level product features this component supports:\n\n*   **React Native SDK Installation Instructions:** Provides step-by-step guidance for installing the PostHog SDK in a React Native project.\n*   **Session Replay Integration:** Guides users through enabling session replay functionality within their React Native application.\n*   **Final Setup Steps:** Outlines the concluding steps required to fully configure and activate session replay.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay/bubble.tsx",
        "summary": "The `BubbleInstructions` component combines two sub-components, `SDKInstallBubbleInstructions` and `SessionReplayFinalSteps`, to guide users through the process of installing an SDK and configuring session replay. This component likely forms part of an onboarding flow, providing step-by-step instructions and final configuration steps for setting up session replay functionality.\n\nHere's a list of high-level product features:\n\n*   **SDK Installation Instructions:** Provides guidance on installing the necessary SDK for session replay.\n*   **Session Replay Configuration:** Guides users through the final steps required to configure session replay.\n*   **Onboarding Flow Integration:** Integrates into an onboarding flow to assist new users with setting up session replay.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay/nuxt.tsx",
        "summary": "This code defines a React component called `NuxtJSInstructions` that renders instructions for installing the PostHog SDK in a Nuxt.js application, specifically for session replay functionality. It combines the `SDKInstallNuxtJSInstructions` component, which likely provides Nuxt.js specific installation steps, with the `SessionReplayFinalSteps` component, which probably outlines the final steps needed to enable session replay after the initial SDK installation.\n\nHere's a list of high-level product features this code relates to:\n\n*   **SDK Installation Instructions:** Provides users with instructions on how to install the PostHog SDK.\n*   **Nuxt.js Support:** Offers specific installation instructions tailored for Nuxt.js applications.\n*   **Session Replay:** Enables the recording and replaying of user sessions for debugging and analysis.\n*   **Onboarding:** Guides new users through the process of setting up PostHog in their application.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay/framer.tsx",
        "summary": "The `FramerInstructions` component combines two sub-components: `SDKInstallFramerInstructions` and `SessionReplayFinalSteps`. This suggests that the component is designed to guide users through the process of installing and configuring the PostHog SDK specifically for session replay functionality within a Framer environment. It likely provides instructions tailored to Framer for SDK installation, followed by general steps needed to finalize the session replay setup.\n\nHere's a list of high-level product features this component supports:\n\n*   **Framer SDK Installation Guide:** Provides instructions on how to install the PostHog SDK in a Framer project.\n*   **Session Replay Setup Instructions:** Guides users through the final steps required to enable and configure session replay.\n*   **Framer-Specific Configuration:** Offers configuration steps tailored to the Framer environment.\n*   **Onboarding Assistance:** Helps new users get started with session replay in PostHog.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay/android.tsx",
        "summary": "This React component, `AndroidInstructions`, renders instructions for integrating PostHog session replay with an Android application. It leverages two sub-components: `SDKInstallAndroidInstructions` (configured to include session replay) and `SessionReplayFinalSteps`. This provides a step-by-step guide for developers to set up session replay within their Android apps.\n\nHere's a list of high-level product features this component supports:\n\n*   **Android SDK Installation Instructions:** Provides guidance on installing the PostHog Android SDK.\n*   **Session Replay Integration:** Guides users through enabling session replay functionality within their Android application.\n*   **Final Setup Steps:** Offers a checklist or final steps to ensure session replay is correctly configured and functioning.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay/vue.tsx",
        "summary": "The `VueInstructions` component renders instructions for installing the PostHog SDK in a Vue.js application, specifically focusing on session replay functionality. It leverages two sub-components: `SDKInstallVueInstructions` which likely provides the core installation steps for the PostHog SDK within a Vue context, and `SessionReplayFinalSteps` which probably outlines the final configuration or verification steps required to ensure session replay is correctly set up and functioning.\n\nHere's a list of high-level product features this code relates to:\n\n*   **Vue.js SDK Installation:** Guides users through the process of installing the PostHog SDK in a Vue.js application.\n*   **Session Replay Setup:** Provides specific instructions for enabling and configuring session replay within a Vue.js application.\n*   **Step-by-Step Instructions:** Offers a clear, step-by-step guide to ensure successful integration.\n*   **Platform Support:** Explicitly supports Vue.js as a platform for PostHog integration.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay/html-snippet.tsx",
        "summary": "This code defines a React component called `HTMLSnippetInstructions` that renders instructions for installing an SDK using an HTML snippet, specifically for session replay functionality. It combines two sub-components: `SDKHtmlSnippetInstructions` (likely providing the core HTML snippet and installation steps) and `SessionReplayFinalSteps` (likely outlining the final steps to ensure session replay is correctly configured and functioning).\n\n**Features:**\n\n*   **HTML Snippet Generation:** Provides a dynamically generated HTML snippet for SDK installation.\n*   **Installation Instructions:** Guides users through the process of embedding the HTML snippet into their website.\n*   **Session Replay Configuration:** Offers final steps and configuration guidance specific to session replay functionality.\n*   **User Interface:** Renders a user-friendly interface for displaying the snippet and instructions.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay/SessionReplaySDKInstructions.tsx",
        "summary": "This code defines a mapping of SDK keys to their respective installation instructions for Session Replay, covering a wide range of web and mobile platforms. It also includes a component to advertise the availability of Session Replay for mobile platforms (Android, iOS, React Native, and Flutter) within onboarding flows, providing a link to setup instructions.\n\nHere's a list of high-level product features:\n\n*   **Session Replay Installation Instructions:** Provides platform-specific instructions for integrating Session Replay into various web and mobile applications.\n*   **Web Platform Support:** Offers installation guides for JavaScript, HTML Snippets, Angular, Astro, Next.js, Nuxt.js, React, Remix, Svelte, Vue.js, and Webflow.\n*   **Mobile Platform Support:** Includes installation guides for iOS, Android, React Native, and Flutter.\n*   **Mobile Replay Advertisement:** Promotes the beta availability of Session Replay for mobile platforms during onboarding.\n*   **Onboarding Integration:** Seamlessly integrates with onboarding flows, guiding users to the appropriate installation instructions.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay/react.tsx",
        "summary": "The `ReactInstructions` component renders instructions for installing the PostHog SDK in a React application, specifically for session replay. It leverages two sub-components: `SDKInstallReactInstructions` which likely provides the core installation steps, and `SessionReplayFinalSteps` which probably outlines the final configuration or verification steps needed to ensure session replay is properly set up.\n\n**Features:**\n\n*   **React SDK Installation Instructions:** Provides step-by-step guidance for installing the PostHog SDK in a React project.\n*   **Session Replay Configuration:** Guides the user through the necessary steps to configure and enable session replay functionality within their React application.\n*   **Code Snippets:** Includes code snippets to copy and paste into the React application.\n*   **Final Verification Steps:** Provides instructions to verify that session replay is correctly set up and functioning.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay/next-js.tsx",
        "summary": "This React component, `NextJSInstructions`, is designed to guide users through setting up session replay functionality in a Next.js application. It leverages two sub-components: `SDKInstallNextJSInstructions`, which likely provides instructions on installing and configuring the necessary SDK for Next.js, and `SessionReplayFinalSteps`, which probably outlines the concluding steps to ensure session replay is fully operational. Essentially, this component serves as a consolidated onboarding guide for session replay within a Next.js environment.\n\nHere's a list of high-level product features this code contributes to:\n\n*   **Next.js Session Replay Integration:** Provides specific instructions for integrating session replay functionality into Next.js applications.\n*   **SDK Installation Guidance:** Guides users through the process of installing and configuring the required SDK for session replay.\n*   **Step-by-Step Onboarding:** Offers a structured, step-by-step guide to setting up session replay, ensuring a smooth user experience.\n*   **Final Configuration Assistance:** Provides guidance on the final steps needed to ensure session replay is fully functional and capturing data correctly.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay/index.tsx",
        "summary": "This code aggregates and exports various components related to session replay SDK onboarding for different platforms and frameworks. It serves as a central point for accessing onboarding guides and instructions tailored to specific technologies.\n\nHere's a list of high-level product features based on the code:\n\n*   **Android Session Replay SDK Onboarding:** Guides users through integrating the session replay SDK into Android applications.\n*   **Angular Session Replay SDK Onboarding:** Provides instructions for setting up session replay in Angular projects.\n*   **Astro Session Replay SDK Onboarding:** Offers onboarding support for Astro-based web applications.\n*   **Bubble Session Replay SDK Onboarding:** Supports session replay integration within the Bubble no-code platform.\n*   **Flutter Session Replay SDK Onboarding:** Enables session replay functionality in Flutter apps.\n*   **Framer Session Replay SDK Onboarding:** Facilitates session replay setup in Framer web projects.\n*   **HTML Snippet Session Replay Onboarding:** Provides a generic HTML snippet for basic session replay integration.\n*   **iOS Session Replay SDK Onboarding:** Guides users in integrating the session replay SDK into iOS applications.\n*   **JavaScript Web Session Replay SDK Onboarding:** Offers instructions for setting up session replay in vanilla JavaScript web projects.\n*   **Next.js Session Replay SDK Onboarding:** Provides specific guidance for Next.js applications.\n*   **Nuxt.js Session Replay SDK Onboarding:** Offers tailored onboarding for Nuxt.js projects.\n*   **React Session Replay SDK Onboarding:** Supports session replay integration in React applications.\n*   **React Native Session Replay SDK Onboarding:** Enables session replay functionality in React Native apps.\n*   **Remix Session Replay SDK Onboarding:** Provides specific guidance for Remix applications.\n*   **Svelte Session Replay SDK Onboarding:** Offers onboarding support for Svelte-based web applications.\n*   **Vue.js Session Replay SDK Onboarding:** Provides instructions for setting up session replay in Vue.js projects.\n*   **Webflow Session Replay SDK Onboarding:** Supports session replay integration within the Webflow website builder.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/session-replay",
        "summary": "This collection of code files focuses on providing comprehensive onboarding and setup instructions for integrating PostHog's session replay functionality into a wide array of web and mobile application platforms. The code leverages reusable components to deliver platform-specific guidance for SDK installation and configuration, ensuring a smooth user experience for developers looking to implement session replay in their projects. The onboarding flows are designed to be clear, concise, and tailored to each platform, making it easier for users to quickly get started with session replay.\n\n**Features:**\n\n*   **Platform-Specific SDK Installation Guides:** Provides tailored instructions for integrating the PostHog SDK into various platforms, including Android, iOS, React Native, Flutter, JavaScript, HTML Snippets, Angular, Astro, Next.js, Nuxt.js, React, Remix, Svelte, Vue.js, Webflow, Bubble and Framer.\n*   **Session Replay Configuration Assistance:** Guides users through the necessary steps to enable and configure session replay functionality within their applications.\n*   **Step-by-Step Onboarding Flows:** Offers structured, step-by-step guides to setting up session replay, ensuring a smooth user experience.\n*   **Reusable Components:** Leverages shared components for common installation steps, promoting code maintainability and consistency.\n*   **Mobile Replay Advertisement:** Promotes the availability of Session Replay for mobile platforms during onboarding.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/hooks/useInstallationComplete.tsx",
        "summary": "This React hook, `useInstallationComplete`, is designed to determine if a specific installation step has been completed for a team. It leverages the `kea` library for state management and actions, and the `useInterval` hook for periodic checks. The hook takes a `teamPropertyToVerify` as input, which is a property on the team object that indicates completion. It then periodically checks if this property is set on the current team. If the property is not set, it reloads the team data. To avoid indefinite checking, it stops checking after 5 seconds. The hook returns a boolean value indicating whether the installation is complete.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Installation Status Tracking:** Provides a mechanism to track the completion status of specific installation steps for a team.\n*   **Real-time Verification:** Periodically verifies the installation status, ensuring that the UI reflects the most up-to-date information.\n*   **Automatic Data Refresh:** Automatically refreshes team data when the installation is not yet complete.\n*   **Timeout Mechanism:** Prevents indefinite checking for installation completion, improving performance and user experience.\n*   **Dynamic Property Verification:** Allows specifying the team property to verify, making the hook reusable for different installation steps.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/hooks",
        "summary": "The `useInstallationComplete` hook provides a way to track the completion of specific installation steps for a team by periodically checking a designated property on the team object. It automatically refreshes team data if the installation is not complete and includes a timeout mechanism to prevent indefinite checking. This hook enables real-time verification of installation status and offers a dynamic approach to verifying different installation steps.\n\nHere's a list of high-level product features:\n\n*   Installation Status Tracking\n*   Real-time Verification\n*   Automatic Data Refresh\n*   Timeout Mechanism\n*   Dynamic Property Verification\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/ios.tsx",
        "summary": "The `iOSInstructions` component provides a set of instructions for integrating PostHog web analytics into an iOS application. It guides the user through the installation process, final setup steps, and screen tracking implementation. The component leverages shared instruction components for installation and final steps, and provides specific instructions for tracking screens in an iOS environment.\n\nHere's a list of the high-level features provided by this component:\n\n*   **Installation Instructions:** Provides instructions for installing the PostHog iOS SDK.\n*   **Final Setup Steps:** Guides the user through the final steps required to complete the integration.\n*   **Screen Tracking Instructions:** Explains how to track screen views within the iOS application using the PostHog SDK.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/webflow.tsx",
        "summary": "The `WebflowInstructions` component renders instructions for installing the PostHog web analytics SDK in a Webflow project. It uses two sub-components: `SDKInstallWebflowInstructions` to provide Webflow-specific installation steps and `WebAnalyticsAllJSFinalSteps` to handle the final steps common to all JavaScript-based web analytics integrations.\n\nHere's a list of high-level product features:\n\n*   **Webflow Installation Instructions:** Provides step-by-step guidance for integrating PostHog into Webflow projects.\n*   **JavaScript SDK Support:** Supports installation of the PostHog JavaScript SDK.\n*   **Final Installation Steps:** Guides the user through the final steps required to complete the integration.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/angular.tsx",
        "summary": "The `AngularInstructions` component provides instructions for integrating PostHog web analytics into an Angular application. It leverages two sub-components: `SDKInstallAngularInstructions`, which likely contains the core installation steps specific to Angular, and `WebAnalyticsAllJSFinalSteps`, which probably outlines the final steps applicable to all JavaScript-based web analytics integrations.\n\nHere's a list of high-level product features:\n\n*   **Angular SDK Installation Instructions:** Provides step-by-step guidance for installing the PostHog web analytics SDK in an Angular project.\n*   **Web Analytics Integration:** Enables tracking user behavior and events within an Angular application.\n*   **Final Integration Steps:** Guides users through the final configuration and verification steps common to all JavaScript web analytics integrations.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/flutter.tsx",
        "summary": "The `FlutterInstructions` component provides a set of instructions for integrating PostHog web analytics into a Flutter application. It guides the user through the installation process, final setup steps, and screen tracking implementation. The component leverages other components like `SDKInstallFlutterInstructions`, `WebAnalyticsMobileFinalSteps`, and `SDKInstallFlutterTrackScreenInstructions` to deliver a comprehensive onboarding experience.\n\nHere's a list of high-level product features:\n\n*   **Flutter SDK Installation Instructions:** Provides step-by-step guidance for installing the PostHog Flutter SDK.\n*   **Web Analytics Mobile Final Steps:** Guides the user through the final configuration and verification steps for web analytics on mobile.\n*   **Flutter Screen Tracking Instructions:** Explains how to implement screen tracking within a Flutter application to monitor user navigation.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/html-snippet.tsx",
        "summary": "This code defines a React component called `HTMLSnippetInstructions` that renders instructions for installing a web analytics SDK using an HTML snippet. It combines two sub-components: `SDKHtmlSnippetInstructions` (likely providing the core HTML snippet and placement instructions) and `WebAnalyticsAllJSFinalSteps` (presumably outlining the final steps after the snippet is added). The component serves as a consolidated view for guiding users through the complete installation process.\n\n**Features:**\n\n*   **HTML Snippet Display:** Shows the HTML snippet required for installing the web analytics SDK.\n*   **Snippet Placement Instructions:** Guides the user on where to place the HTML snippet within their website's HTML.\n*   **Final Steps Guidance:** Provides instructions on the final steps to complete the SDK installation and verification process.\n*   **Consolidated Installation View:** Combines the core snippet instructions and final steps into a single, easy-to-follow view.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/vue.tsx",
        "summary": "The `VueInstructions` component renders instructions for installing the PostHog web analytics SDK in a Vue.js application. It leverages two sub-components: `SDKInstallVueInstructions`, which likely provides Vue-specific installation steps, and `WebAnalyticsAllJSFinalSteps`, which probably outlines the final steps applicable to all JavaScript-based web analytics integrations.\n\nHere's a list of high-level product features:\n\n*   **Vue.js Installation Instructions:** Provides step-by-step guidance for integrating the PostHog web analytics SDK into Vue.js projects.\n*   **SDK Installation Instructions:** Offers general instructions for installing the PostHog SDK.\n*   **Final Steps:** Guides the user through the final configuration and verification steps after installing the web analytics SDK.\n*   **Web Analytics Integration:** Facilitates the integration of web analytics capabilities into a Vue.js application.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/react.tsx",
        "summary": "The `ReactInstructions` component combines two sub-components to guide users through integrating PostHog web analytics into a React application. It first uses `SDKInstallReactInstructions` to provide instructions specific to React-based installations. Then, it uses `WebAnalyticsAllJSFinalSteps` to guide the user through the final steps of setting up web analytics, likely common across all JavaScript-based web analytics setups.\n\nHere's a list of high-level product features:\n\n*   **React-Specific Installation Guide:** Provides tailored instructions for installing the PostHog SDK in a React application.\n*   **Web Analytics Setup:** Guides users through the necessary steps to configure web analytics after SDK installation.\n*   **Final Steps Guidance:** Offers a common set of final steps applicable to all JavaScript web analytics setups.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/FinalSteps.tsx",
        "summary": "This code defines two React components, `WebAnalyticsAllJSFinalSteps` and `WebAnalyticsMobileFinalSteps`, which are likely used as final steps in an onboarding process for web analytics. `WebAnalyticsAllJSFinalSteps` instructs users to generate events by interacting with their website and provides an optional code snippet for manually sending events using `posthog.capture`. `WebAnalyticsMobileFinalSteps` explains how the web analytics dashboard can also be used to track screen views in mobile apps, instructing users to navigate through their app to generate events.\n\nHere's a list of high-level product features implied by the code:\n\n*   **Automatic Event Capture:** The system automatically captures user interactions as events.\n*   **Manual Event Tracking:** Users can manually define and send custom events.\n*   **Web Analytics Dashboard:** A dashboard exists for analyzing web analytics data.\n*   **Mobile App Screen View Tracking:** The web analytics dashboard can also track screen views in mobile applications.\n*   **Code Snippets:** The system provides code snippets to help users implement event tracking.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/android.tsx",
        "summary": "This code defines a React component called `AndroidInstructions` that renders a series of instructions for integrating PostHog's web analytics SDK into an Android application. It displays instructions for initial SDK installation, final setup steps common to mobile web analytics, and instructions for tracking screen views. The component combines three sub-components to guide the user through the necessary steps for a successful integration.\n\n**Features:**\n\n*   **SDK Installation Instructions:** Provides step-by-step instructions for installing the PostHog Android SDK.\n*   **Final Setup Steps:** Guides the user through the final configuration and verification steps for mobile web analytics.\n*   **Screen Tracking Instructions:** Explains how to implement screen view tracking within the Android application using the PostHog SDK.\n*   **Replay Exclusion:** Explicitly excludes replay functionality from the initial SDK installation instructions.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/react-native.tsx",
        "summary": "This React component provides instructions for integrating PostHog web analytics into a React Native application. It includes steps for installing the SDK, an optional code snippet demonstrating how to manually send events using the `usePostHog` hook, and final steps to complete the integration process.\n\nHere's a list of high-level features:\n\n*   **SDK Installation Instructions:** Guides users through the process of installing the PostHog React Native SDK.\n*   **Manual Event Tracking:** Demonstrates how to manually capture custom events within a React Native component using the `usePostHog` hook.\n*   **Autocapture Events:** Explains that the SDK automatically captures events, reducing the need for manual tracking in many cases.\n*   **Final Steps:** Provides a checklist or further guidance to finalize the web analytics integration.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/bubble.tsx",
        "summary": "This code defines a React component called `BubbleInstructions` that renders instructions for installing an SDK, specifically for web analytics. It combines two sub-components: `SDKInstallBubbleInstructions` which likely provides the initial steps for installing the SDK, and `WebAnalyticsAllJSFinalSteps` which probably outlines the final steps to complete the web analytics setup using JavaScript. The component serves as a consolidated guide for users integrating the web analytics SDK into their projects.\n\nHere's a list of high-level product features based on the code:\n\n*   **SDK Installation Instructions:** Provides step-by-step guidance for installing the web analytics SDK.\n*   **Initial Setup Instructions:** Guides users through the initial configuration of the SDK.\n*   **Final Setup Instructions:** Provides the final steps required to complete the web analytics setup using JavaScript.\n*   **Consolidated Guide:** Combines initial and final setup instructions into a single, easy-to-follow guide.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/nuxt.tsx",
        "summary": "The `NuxtJSInstructions` component renders instructions for installing the PostHog web analytics SDK in a Nuxt.js application. It leverages two sub-components: `SDKInstallNuxtJSInstructions` which likely provides the core installation steps specific to Nuxt.js, and `WebAnalyticsAllJSFinalSteps` which probably contains the final steps applicable to all JavaScript-based web analytics integrations.\n\nHere's a list of high-level product features this code contributes to:\n\n*   **Nuxt.js SDK Installation Guide:** Provides step-by-step instructions for integrating PostHog web analytics into Nuxt.js projects.\n*   **Web Analytics Integration:** Enables tracking user behavior and website analytics within Nuxt.js applications.\n*   **Generic JavaScript Web Analytics Finalization:** Offers final configuration steps common to all JavaScript web analytics setups.\n*   **Onboarding Assistance:** Guides new users through the process of setting up web analytics in their Nuxt.js application.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/astro.tsx",
        "summary": "The `AstroInstructions` component combines two sub-components: `SDKInstallAstroInstructions` and `WebAnalyticsAllJSFinalSteps`. This suggests a multi-step process for integrating web analytics into an Astro-based website. The component likely guides the user through the installation of an SDK tailored for Astro and then provides final steps applicable to all JavaScript-based web analytics integrations.\n\nHere's a list of high-level product features:\n\n*   **Astro SDK Installation Guide:** Provides instructions for installing a web analytics SDK specifically designed for Astro websites.\n*   **Generic JavaScript Web Analytics Finalization:** Offers a set of final steps applicable to all JavaScript-based web analytics integrations, regardless of the specific framework used.\n*   **Step-by-Step Integration Process:** Guides users through the complete process of integrating web analytics into their Astro website, from SDK installation to final configuration.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/framer.tsx",
        "summary": "The `FramerInstructions` component combines two sub-components: `SDKInstallFramerInstructions` and `WebAnalyticsAllJSFinalSteps`. This suggests a guided onboarding experience for integrating web analytics into a Framer project. The component likely provides instructions on how to install the necessary SDK and then guides the user through the final steps required to complete the integration.\n\nHere's a list of high-level product features:\n\n*   **SDK Installation Instructions:** Provides step-by-step guidance on installing the web analytics SDK within a Framer project.\n*   **Framer Project Integration Support:** Specifically tailored instructions for Framer projects.\n*   **Final Steps Guidance:** Walks the user through the concluding steps to fully integrate and activate web analytics.\n*   **Onboarding Experience:** A guided flow to help users set up web analytics in their Framer projects.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/next-js.tsx",
        "summary": "The `NextJSInstructions` component combines two sets of instructions for setting up web analytics in a Next.js application. It renders the `SDKInstallNextJSInstructions` component, which likely guides the user through the initial steps of installing the PostHog SDK in a Next.js project. Following that, it renders the `WebAnalyticsAllJSFinalSteps` component, which probably provides the concluding steps applicable to all JavaScript-based web analytics setups, regardless of the specific framework.\n\nHere's a list of high-level product features:\n\n*   **Next.js SDK Installation Guide:** Provides step-by-step instructions for installing the PostHog SDK in a Next.js project.\n*   **Framework-Specific Instructions:** Tailors the installation process to the Next.js framework.\n*   **Generic Web Analytics Finalization:** Offers final setup steps applicable to all JavaScript web analytics implementations.\n*   **Combined Instruction Set:** Integrates framework-specific and generic instructions into a single, cohesive guide.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/js-web.tsx",
        "summary": "The `JSWebInstructions` component renders instructions for installing the PostHog web analytics SDK using JavaScript. It displays the initial installation steps via the `SDKInstallJSWebInstructions` component and then presents the final steps using the `WebAnalyticsAllJSFinalSteps` component. This provides a complete guide for users to integrate PostHog web analytics into their JavaScript-based web applications.\n\nHere's a list of high-level product features:\n\n*   **Installation Instructions:** Provides step-by-step guidance for installing the PostHog web analytics SDK in JavaScript web applications.\n*   **Initial Setup:** Guides users through the initial setup and configuration of the SDK.\n*   **Finalization Steps:** Provides the concluding steps required to complete the integration process.\n*   **Web Analytics Integration:** Enables users to integrate PostHog web analytics into their JavaScript web applications.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/svelte.tsx",
        "summary": "The `SvelteInstructions` component combines two other components: `SDKInstallSvelteJSInstructions` and `WebAnalyticsAllJSFinalSteps`. This suggests a step-by-step guide for integrating web analytics into a Svelte.js application. The guide likely covers the initial installation of the SDK, followed by final steps to ensure the analytics are correctly set up and functioning.\n\nHere's a list of high-level product features:\n\n*   **Svelte.js SDK Installation Guide:** Provides instructions for installing the web analytics SDK in a Svelte.js project.\n*   **Step-by-Step Instructions:** Offers a clear, sequential process for integrating web analytics.\n*   **Final Setup Verification:** Guides users through the final steps to verify the analytics implementation.\n*   **Web Analytics Integration:** Enables tracking and analysis of user behavior within a Svelte.js web application.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/remix.tsx",
        "summary": "The `RemixInstructions` component combines two sub-components to guide users through integrating web analytics into a Remix.js application. It renders the `SDKInstallRemixJSInstructions` component, which likely provides instructions on installing and configuring the PostHog SDK within a Remix.js project. Following that, it renders the `WebAnalyticsAllJSFinalSteps` component, which probably outlines the final steps needed to complete the integration and begin collecting data, potentially including verification and best practices.\n\nHere's a list of high-level product features:\n\n*   **Remix.js SDK Installation Instructions:** Step-by-step guidance for installing the PostHog SDK in a Remix.js project.\n*   **Remix.js SDK Configuration Instructions:** Instructions for configuring the SDK within the Remix.js environment.\n*   **Web Analytics Integration Final Steps:** A checklist or guide for completing the web analytics integration process.\n*   **Web Analytics Verification:** Instructions or tools to verify that the integration is working correctly and data is being collected.\n*   **Best Practices for Web Analytics:** Recommendations for optimal usage and data collection strategies.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/WebAnalyticsSDKInstructions.tsx",
        "summary": "This code defines a mapping between SDK keys and their corresponding instruction components for web analytics onboarding. It essentially acts as a registry, associating each supported platform or framework (like JavaScript, React, iOS, Android, etc.) with the specific instructions needed to integrate the PostHog web analytics SDK. This allows the onboarding process to dynamically display the correct instructions based on the user's chosen platform.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Platform-Specific Onboarding:** Provides tailored instructions for integrating the web analytics SDK into various web and mobile platforms.\n*   **Guided Setup:** Simplifies the integration process by offering step-by-step guidance.\n*   **SDK Support:** Supports a wide range of SDKs including JavaScript, React, iOS, Android, and more.\n*   **Dynamic Instruction Display:** Adapts the displayed instructions based on the user's selected platform.\n*   **Framework Compatibility:** Offers specific instructions for popular web frameworks like Next.js, Nuxt.js, Angular, Vue.js, Svelte, and Remix.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics/index.tsx",
        "summary": "This code serves as an index file that exports various components related to web analytics SDK onboarding for different platforms and frameworks. It essentially aggregates and makes available a collection of modules, each likely containing instructions or tools to integrate web analytics into a specific environment. This allows users to easily access the relevant onboarding resources based on their chosen technology stack.\n\nHere's a list of high-level product features that can be inferred from the code:\n\n*   **Android SDK Onboarding:** Guides users through integrating the web analytics SDK into Android applications.\n*   **Angular SDK Onboarding:** Provides instructions and tools for integrating the SDK into Angular projects.\n*   **Astro SDK Onboarding:** Supports integration with Astro-based websites.\n*   **Bubble SDK Onboarding:** Offers guidance for integrating with Bubble no-code platform.\n*   **Flutter SDK Onboarding:** Enables integration with Flutter applications.\n*   **Framer SDK Onboarding:** Supports integration with Framer websites.\n*   **HTML Snippet Integration:** Provides a basic HTML snippet for simple website integration.\n*   **iOS SDK Onboarding:** Guides users through integrating the web analytics SDK into iOS applications.\n*   **JavaScript Web SDK Onboarding:** Offers a generic JavaScript SDK integration for web applications.\n*   **Next.js SDK Onboarding:** Provides specific instructions and tools for Next.js projects.\n*   **Nuxt.js SDK Onboarding:** Offers specific instructions and tools for Nuxt.js projects.\n*   **React SDK Onboarding:** Provides specific instructions and tools for React projects.\n*   **React Native SDK Onboarding:** Enables integration with React Native applications.\n*   **Remix SDK Onboarding:** Supports integration with Remix web applications.\n*   **Svelte SDK Onboarding:** Provides specific instructions and tools for Svelte projects.\n*   **Vue SDK Onboarding:** Provides specific instructions and tools for Vue projects.\n*   **Webflow SDK Onboarding:** Offers guidance for integrating with Webflow websites.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/web-analytics",
        "summary": "The provided code snippets detail a comprehensive onboarding experience for integrating a web analytics SDK into various platforms and frameworks. The system offers tailored instructions for each platform, including web frameworks like React, Angular, Vue, Next.js, Nuxt.js, Svelte, Remix, Astro, and Framer, as well as mobile platforms like iOS, Android, and React Native, and even no-code platforms like Bubble and Webflow. The onboarding process typically involves platform-specific installation instructions followed by generic finalization steps applicable to all JavaScript-based integrations, ensuring a smooth and consistent experience across different environments.\n\nHere's a list of high-level product features:\n\n*   **Platform-Specific SDK Installation Guides:** Tailored instructions for integrating the web analytics SDK into various platforms and frameworks (React, Angular, Vue, Next.js, Nuxt.js, Svelte, Remix, Astro, Framer, iOS, Android, React Native, Bubble, Webflow, etc.).\n*   **Generic JavaScript Web Analytics Finalization:** Offers final configuration steps common to all JavaScript web analytics setups.\n*   **Mobile App Screen View Tracking:** Enables tracking screen views in mobile applications.\n*   **Automatic Event Capture:** Automatically captures user interactions as events.\n*   **Manual Event Tracking:** Allows users to manually define and send custom events.\n*   **Web Analytics Dashboard:** Provides a dashboard for analyzing web analytics data.\n*   **HTML Snippet Integration:** Provides a basic HTML snippet for simple website integration.\n*   **Code Snippets:** Offers code snippets to help users implement event tracking.\n*   **Replay Exclusion:** Allows excluding replay functionality from the initial SDK installation instructions.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/surveys/react.tsx",
        "summary": "The `ReactInstructions` component is a simple wrapper that renders the `SDKInstallReactInstructions` component. This component likely provides instructions for installing and integrating the PostHog SDK into a React application.\n\nHere's a list of high-level product features:\n\n*   **React SDK Installation Instructions:** Provides instructions for installing the PostHog React SDK.\n*   **React SDK Integration Guide:** Guides users on how to integrate the PostHog React SDK into their React application.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/surveys/next-js.tsx",
        "summary": "The `NextJSInstructions` component is a simple wrapper around the `SDKInstallNextJSInstructions` component. It renders the instructions for installing the PostHog SDK in a Next.js project.\n\nHere's a list of high-level product features:\n\n*   **Next.js SDK Installation Instructions:** Provides instructions for installing the PostHog SDK in a Next.js project.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/surveys/remix.tsx",
        "summary": "The `RemixInstructions` component is a simple wrapper that renders the `SDKInstallRemixJSInstructions` component. This suggests the application provides specific instructions for installing and integrating the SDK within a Remix.js project.\n\n**Features:**\n\n*   **Remix.js SDK Installation Instructions:** Provides step-by-step guidance for installing and integrating the SDK into a Remix.js application.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/surveys/svelte.tsx",
        "summary": "The code defines a SvelteInstructions component that renders the SDKInstallSvelteJSInstructions component. This component likely provides instructions for installing and integrating the PostHog SDK into a Svelte.js project.\n\n**Features:**\n\n*   Displays instructions for installing the PostHog SDK in a Svelte.js project.\n*   Provides code snippets for SDK installation and initialization.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/surveys/vue.tsx",
        "summary": "The `VueInstructions` component is a simple wrapper that renders the `SDKInstallVueInstructions` component. This component likely provides instructions for installing the PostHog SDK in a Vue.js project.\n\nHere's a list of high-level product features:\n\n*   **Vue.js SDK Installation Instructions:** Provides guidance on how to install the PostHog SDK within a Vue.js application.\n*   **Step-by-step guide:** Offers a clear, sequential process for integrating the SDK.\n*   **Code snippets:** Includes copy-and-paste code examples to facilitate easy setup.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/surveys/angular.tsx",
        "summary": "The `AngularInstructions` component is a simple wrapper that renders the `SDKInstallAngularInstructions` component. This component likely provides instructions and guidance for installing and integrating the product's SDK into an Angular project.\n\nHere's a list of high-level product features based on this code:\n\n*   **Angular SDK Installation Instructions:** Provides step-by-step instructions for installing the product's SDK in an Angular project.\n*   **SDK Integration Support:** Offers guidance and resources for integrating the SDK into an existing Angular application.\n*   **Onboarding Assistance:** Helps new users get started with the product by providing specific instructions for their chosen framework (Angular).\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/surveys/html-snippet.tsx",
        "summary": "The `HTMLSnippetInstructions` component is a simple wrapper around the `SDKHtmlSnippetInstructions` component. It renders the `SDKHtmlSnippetInstructions` component, which likely provides instructions and code snippets for installing a PostHog SDK using HTML.\n\nHere's a list of high-level product features:\n\n*   **HTML Snippet Installation Instructions:** Provides instructions for installing the PostHog SDK using an HTML snippet.\n*   **Code Snippet Display:** Displays the HTML code snippet required for installation.\n*   **SDK Integration:** Facilitates integration of the PostHog SDK into web applications.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/surveys/astro.tsx",
        "summary": "The `AstroInstructions` component is a simple wrapper around the `SDKInstallAstroInstructions` component. It serves as a container to render the specific instructions for installing the SDK within an Astro project.\n\nHere's a list of high-level product features:\n\n*   **Astro SDK Installation Instructions:** Provides instructions for installing the SDK in an Astro project.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/surveys/framer.tsx",
        "summary": "The `FramerInstructions` component in `frontend/src/scenes/onboarding/sdks/surveys/framer.tsx` serves as a simple wrapper to render the `SDKInstallFramerInstructions` component. This component likely displays instructions or guidance for installing and integrating a specific SDK within a Framer project, potentially as part of an onboarding flow or setup guide.\n\n**Features:**\n\n*   **Framer SDK Installation Instructions:** Provides step-by-step instructions for installing and integrating an SDK within a Framer project.\n*   **Onboarding Support:**  Facilitates the onboarding process for users integrating the SDK into their Framer projects.\n*   **SDK Integration Guidance:** Offers guidance and best practices for effectively using the SDK within the Framer environment.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/surveys/js-web.tsx",
        "summary": "The `JSWebInstructions` component is a simple wrapper around the `SDKInstallJSWebInstructions` component. It renders the instructions for installing the PostHog Javascript Web SDK.\n\nHere's a list of high-level product features:\n\n*   **SDK Installation Instructions:** Provides instructions for installing the PostHog Javascript Web SDK.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/surveys/webflow.tsx",
        "summary": "The `WebflowInstructions` component in `frontend/src/scenes/onboarding/sdks/surveys/webflow.tsx` serves as a simple wrapper to render the `SDKInstallWebflowInstructions` component. This component likely displays instructions for installing a software development kit (SDK) within a Webflow project, guiding users through the necessary steps to integrate the SDK into their Webflow website.\n\nHere's a list of high-level product features:\n\n*   **Webflow SDK Installation Guide:** Provides step-by-step instructions for integrating an SDK into a Webflow project.\n*   **SDK Integration Support:** Offers specific guidance tailored to the Webflow platform for SDK installation.\n*   **Onboarding Assistance:** Helps new users onboard by providing clear instructions for setting up the SDK within their Webflow environment.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/surveys/bubble.tsx",
        "summary": "The `BubbleInstructions` component is a simple wrapper around the `SDKInstallBubbleInstructions` component. It's responsible for rendering the instructions for installing an SDK, specifically in a \"bubble\" format, likely as part of an onboarding survey or tutorial.\n\nHere's a list of high-level product features:\n\n*   **SDK Installation Instructions:** Provides guidance on how to install an SDK.\n*   **Bubble Presentation:** Presents the installation instructions in a bubble-like UI element.\n*   **Onboarding Survey/Tutorial Integration:** Designed to be used within an onboarding flow or survey.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/surveys/SurveysSDKInstructions.tsx",
        "summary": "This code defines a mapping between SDK keys and their corresponding instruction components for integrating surveys into different web frameworks and platforms. The `SurveysSDKInstructions` object acts as a lookup table, allowing the application to dynamically select the appropriate instructions based on the chosen SDK. This enables a tailored onboarding experience for users integrating surveys into their projects.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **SDK-Specific Integration Instructions:** Provides tailored instructions for integrating surveys into various web frameworks and platforms.\n*   **Support for Multiple Frameworks:** Supports a wide range of frameworks including JavaScript, HTML, Angular, Astro, Bubble, Framer, Next.js, Nuxt.js, React, Remix, Svelte, Vue.js, and Webflow.\n*   **Dynamic Instruction Display:** Allows the application to dynamically display the correct integration instructions based on the user's selected SDK.\n*   **Simplified Onboarding:** Streamlines the onboarding process for users integrating surveys into their web applications.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/surveys/index.tsx",
        "summary": "This code exports all modules from various files related to SDK onboarding surveys for different web frameworks and platforms. It essentially aggregates and re-exports survey components or functionalities tailored for Angular, Astro, Bubble, Framer, HTML Snippets, JavaScript Web, Next.js, Nuxt, React, Remix, Svelte, Vue, and Webflow.\n\nHere's a list of high-level product features implied by this code:\n\n*   **Onboarding Surveys:** Provides interactive surveys to guide users through the SDK integration process.\n*   **Framework-Specific Guidance:** Offers tailored onboarding experiences for different web frameworks (Angular, React, Vue, etc.).\n*   **Platform Support:** Includes onboarding flows for platforms like Bubble, Framer, and Webflow.\n*   **Code Snippet Integration:** Guides users on how to integrate HTML snippets for SDK functionality.\n*   **JavaScript Web Support:** Provides general onboarding for JavaScript-based web applications.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/surveys/nuxt.tsx",
        "summary": "The code defines a React component `NuxtJSInstructions` that renders the `SDKInstallNuxtJSInstructions` component. This component likely provides instructions for installing and configuring the PostHog SDK within a Nuxt.js project. It serves as a specific guide within a larger onboarding flow for users integrating PostHog into their Nuxt.js applications.\n\nHere's a list of high-level product features this code contributes to:\n\n*   **SDK Installation Guides:** Provides step-by-step instructions for installing the PostHog SDK.\n*   **Nuxt.js Integration Support:** Offers specific guidance tailored to Nuxt.js projects.\n*   **Onboarding Flow:** Integrates into a larger onboarding process to help new users set up PostHog.\n*   **Framework-Specific Instructions:** Supports multiple frameworks by providing framework-specific installation instructions.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/surveys",
        "summary": "The provided code implements a comprehensive onboarding experience focused on guiding users through the integration of an SDK into various web frameworks and platforms. The system offers tailored instructions and code snippets for each supported environment, streamlining the setup process and ensuring a smooth user experience. This is achieved through a modular design, where individual components provide framework-specific guidance, all accessible through a central mapping that dynamically displays the appropriate instructions based on the user's selection.\n\nHere's a list of high-level product features:\n\n*   **Onboarding Surveys:** Interactive surveys guide users through the SDK integration process.\n*   **Framework-Specific Guidance:** Tailored onboarding experiences for different web frameworks (Angular, React, Vue, Next.js, Nuxt.js, Svelte, Remix, Astro).\n*   **Platform Support:** Onboarding flows for platforms like Bubble, Framer, and Webflow.\n*   **Code Snippet Integration:** Guides users on how to integrate HTML snippets for SDK functionality.\n*   **JavaScript Web Support:** General onboarding for JavaScript-based web applications.\n*   **SDK Installation Instructions:** Step-by-step instructions for installing the product's SDK in various environments.\n*   **SDK Integration Support:** Guidance and resources for integrating the SDK into existing applications.\n*   **Dynamic Instruction Display:** Dynamically displays the correct integration instructions based on the user's selected SDK.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks/AlternativeSDKs.tsx",
        "summary": "This code defines a React component called `AlternativeSDKs` that guides users through the process of installing an SDK for PostHog. It provides a list of available SDKs, allows users to search and filter them by tags, and displays detailed installation instructions in a modal. The component also includes a real-time check indicator to verify the installation and a button to proceed to the next step in the onboarding process or skip the installation. It also allows users to invite a developer or get help via a support form.\n\nHere's a list of high-level product features:\n\n*   **SDK Selection:** Displays a list of available SDKs with names and logos.\n*   **SDK Filtering and Search:** Allows users to filter SDKs by tags and search by name.\n*   **Detailed Installation Instructions:** Provides step-by-step instructions for installing the selected SDK in a modal.\n*   **Real-time Installation Verification:** Verifies the SDK installation by listening for a specific event.\n*   **Onboarding Flow Integration:** Integrates with the PostHog onboarding flow, allowing users to proceed to the next step or skip the installation.\n*   **Invite Developer:** Allows users to invite a developer to help with the installation.\n*   **Support Form:** Provides access to a support form for users who need help with the installation.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/sdks",
        "summary": "This code collectively implements a comprehensive and adaptable onboarding experience for integrating PostHog's various features into a wide array of platforms and frameworks. It provides users with tailored SDK installation instructions, code snippets, and real-time verification tools to ensure a smooth and successful integration process. The system supports a diverse range of technologies, from web and mobile applications to backend services and no-code platforms, offering platform-specific guidance and promoting related features like session replay and experimentation. The onboarding flow is designed to be user-friendly, with options for filtering SDKs, inviting team members for assistance, and skipping the installation process if needed.\n\nHere's a list of high-level product features:\n\n*   **SDK Support:** Provides SDKs for a wide range of platforms and frameworks, including web, mobile, server-side, and LLM.\n*   **Integration Support:** Offers integrations with popular tools and platforms.\n*   **Platform Categorization:** Organizes SDKs by platform tags for easy filtering and discovery.\n*   **Recommended SDKs:** Highlights recommended SDKs for common use cases.\n*   **Documentation Links:** Provides direct links to the documentation for each SDK.\n*   **Visual Identification:** Includes logos for each SDK.\n*   **Conditional SDK Installation Steps:** Dynamically display different SDK installation steps based on feature flags.\n*   **Alternative SDK Options:** Provides users with alternative SDK installation methods or options.\n*   **Standard SDK Installation:** Guides users through the standard SDK installation process.\n*   **Feature Flag Controlled Onboarding:** Uses feature flags to control and experiment with different onboarding flows.\n*   **SDK Selection and Filtering:** Allows users to select an SDK from a list, filtering by source, search term, and tags.\n*   **SDK Instructions Display:** Shows instructions for the selected SDK, potentially in a side-by-side view.\n*   **Snippet Event Detection:** Detects snippet events to provide a more tailored onboarding experience.\n*   **URL-based SDK Selection:** Allows selecting an SDK directly via a URL parameter.\n*   **SDK Usage Reporting:** Reports the selected SDK for usage tracking.\n*   **Multi-Install Product Handling:** Supports products that can be installed in multiple places.\n*   **SDK Integration Instructions:** Displays instructions tailored to integrate PostHog with a specific SDK.\n*   **Installation Verification:** Automatically checks if the SDK has been successfully installed by listening for incoming events.\n*   **Responsive Layout:** Adapts the layout to different screen sizes for optimal user experience.\n*   **Team Collaboration:** Provides an option to invite team members for assistance.\n*   **Skip Installation:** Allows users to skip the installation process and proceed to the next step.\n*   **Dynamic Source Filtering:** Filters SDK options based on the selected source type.\n*   **Live Event Display:** Shows a table of live events.\n*   **Real-time Installation Verification:** Provides immediate feedback on whether the PostHog SDK has been successfully installed.\n*   **Session Replay Onboarding Instructions:** Guides users on how to generate initial session recordings.\n*   **Person Profile Processing Control:** Allows users to disable person profile creation for specific events.\n*   **Event Tracking:** Demonstrates how to capture user actions and events within applications.\n*   **User Identification:** Guides users on how to identify users and set user properties for segmentation and analysis.\n*   **LLM Observability Integration:** Supports integration with LLM observability platforms.\n*   **Onboarding Surveys:** Interactive surveys guide users through the SDK integration process.\n*   **Framework-Specific Guidance:** Tailored onboarding experiences for different web frameworks.\n*   **Invite Developer:** Allows users to invite a developer to help with the installation.\n*   **Support Form:** Provides access to a support form for users who need help with the installation.\n*   **Experiment Implementation Snippets:** Offers code examples demonstrating how to implement experiment tracking and feature flags using different SDKs.\n*   **Multi-Platform Support:** Supports a wide range of platforms and frameworks, including web, mobile, and backend technologies.\n*   **Client-Side and Server-Side Rendering Support:** Provides specific instructions and code snippets for both client-side and server-side rendering scenarios where applicable.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/OnboardingSessionReplayConfiguration.tsx",
        "summary": "This component, `OnboardingSessionReplayConfiguration`, is a step in the onboarding process that prompts the user to enable or disable session replay. It provides a description of session replay and its benefits, including understanding user behavior, identifying UI/UX issues, and improving customer support. The component presents the user with two options: enabling session replay or skipping it, which updates the current team's settings accordingly and proceeds to the next onboarding step.\n\nHere's a list of high-level product features:\n\n*   **Onboarding Step Integration:** Seamlessly integrates into the onboarding flow.\n*   **Session Replay Configuration:** Allows users to enable or disable session replay during onboarding.\n*   **Session Replay Explanation:** Provides a clear explanation of the benefits of session replay.\n*   **Team Settings Update:** Updates the team's session recording preferences based on user choice.\n*   **Navigation:** Enables navigation to the next step in the onboarding process.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/OnboardingReverseProxy.tsx",
        "summary": "This code defines an onboarding step in the PostHog application that guides users through setting up a reverse proxy. The component provides information about the benefits of using a reverse proxy, such as avoiding tracking blockers and capturing more usage data. It also includes links to documentation for various popular reverse proxy options and offers the option to invite team members for assistance with the setup process.\n\nHere's a list of high-level product features:\n\n*   **Onboarding Step: Reverse Proxy Setup:** Guides users through the optional process of setting up a reverse proxy.\n*   **Informational Content:** Explains the benefits of using a reverse proxy for event tracking.\n*   **Documentation Links:** Provides links to documentation for various reverse proxy options (AWS CloudFront, Caddy, Cloudflare, Kubernetes Ingress Controller, Netlify, Next.js, Vercel, Nuxt).\n*   **Team Collaboration:** Allows users to invite team members for assistance with the setup process.\n*   **UI elements:** Uses LemonDivider and Lemon-UI components.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/web-analytics/OnboardingWebAnalyticsAuthorizedDomainsStep.tsx",
        "summary": "This React component, `OnboardingWebAnalyticsAuthorizedDomainsStep`, is a step within an onboarding flow focused on configuring authorized domains for web analytics. It utilizes the `AuthorizedUrlList` component to manage a list of URLs that PostHog is authorized to track for web analytics purposes. The component enforces that at least one authorized domain must be added before proceeding and restricts the use of wildcards in domain entries, requiring concrete, launchable URLs.\n\nHere's a list of high-level product features:\n\n*   **Authorized Domain Management:** Allows users to specify the domains where PostHog is authorized to collect web analytics data.\n*   **Domain Validation:** Enforces restrictions on domain entries, such as disallowing wildcards and requiring concrete URLs.\n*   **Onboarding Integration:** Serves as a step within the onboarding process to guide users through the configuration of authorized domains.\n*   **Web Analytics Scope Definition:** Defines the scope of web analytics tracking based on the authorized domains.\n*   **Toolbar URL Control:** Controls where the PostHog toolbar is enabled based on the authorized domains.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/OnboardingProductConfiguration.tsx",
        "summary": "The `OnboardingProductConfiguration` component is a step in the onboarding process that allows users to configure product settings. It dynamically renders a list of configuration options, which can be toggles or select dropdowns, based on the product being configured. These options are fetched and managed using kea-logic. The component also integrates with `pipelineDefaultEnabledLogic` to display and control default enabled plugins, filtering out plugins that are denied for the specific product being configured. The component persists the configuration changes when the user proceeds to the next step.\n\nHere's a list of high-level product features:\n\n*   **Dynamic Configuration Options:** Display configuration options (toggles, selects) based on the product.\n*   **Plugin Management:** Display and toggle default enabled plugins.\n*   **Product-Specific Plugin Filtering:** Filter out plugins that are not allowed for a specific product during onboarding.\n*   **Configuration Persistence:** Save the configuration settings when the user proceeds.\n*   **Real-time Updates:** Updates the configuration options in real-time as the user interacts with the controls.\n*   **Onboarding Step Integration:** Integrates as a step within the onboarding flow."
    },
    {
        "path": "frontend/src/scenes/onboarding/OnboardingStep.tsx",
        "summary": "This React component, `OnboardingStep`, is a reusable UI element designed to guide users through a series of onboarding steps. It provides a structured layout with breadcrumbs for navigation, a title and subtitle for context, and customizable content areas. The component also includes options for skipping steps, accessing help, and proceeding to the next step or finishing the onboarding process. It leverages the `onboardingLogic` and `supportLogic` to manage the onboarding flow and provide support access.\n\nHere's a list of high-level product features provided by the `OnboardingStep` component:\n\n*   **Structured Onboarding Flow:** Provides a clear, step-by-step guide for new users.\n*   **Breadcrumb Navigation:** Allows users to easily navigate between onboarding steps.\n*   **Customizable Content:** Supports various content types within each step, adapting to different onboarding needs.\n*   **Skip Functionality:** Enables users to skip steps they are not interested in or cannot complete immediately.\n*   **Help Access:** Offers a direct link to support resources for assistance.\n*   **Dynamic Progression:** Manages the transition between steps and completion of the onboarding process.\n*   **Customizable Actions:** Supports custom actions and overrides for the continue button.\n*   **Disabled Continue Button:** Visually indicates when the user cannot proceed and provides a reason.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/onboardingLogic.tsx",
        "summary": "This code defines the logic for the onboarding flow in PostHog, managing the state and navigation through different onboarding steps for various products like Product Analytics, Web Analytics, Session Replay, Feature Flags, and Surveys. It handles setting the current product, managing the onboarding steps, tracking user progress, and redirecting users upon completion. The logic also integrates with other parts of the application, such as billing, team management, user settings, and feature flags, to tailor the onboarding experience.\n\nHere's a list of high-level product features derived from the code:\n\n*   **Product-Specific Onboarding:** Guides users through tailored onboarding flows for different PostHog products.\n*   **Step-by-Step Navigation:** Allows users to navigate forward and backward through a series of onboarding steps.\n*   **Onboarding Progress Tracking:** Tracks the user's progress through the onboarding flow.\n*   **Dynamic Step Display:** Determines which onboarding steps to show based on product type, feature flags, and user subscription status.\n*   **Integration with Billing:** Checks billing status and potentially includes a billing step in the onboarding flow.\n*   **Team Configuration:** Allows setting team properties during onboarding, such as enabling session recording.\n*   **Redirection on Completion:** Redirects users to the appropriate product page or a default page upon completing onboarding.\n*   **Side Panel Activation:** Opens the activation side panel upon completing the first product onboarding.\n*   **URL-Based Navigation:** Uses the URL to manage and persist the current onboarding step.\n*   **Data Warehouse Step:** Conditionally shows a data warehouse onboarding step based on feature flags."
    },
    {
        "path": "frontend/src/scenes/onboarding/Onboarding.tsx",
        "summary": "The `Onboarding.tsx` file defines the onboarding flow for different PostHog products: Product Analytics, Web Analytics, and Session Replay. It uses a wrapper component `OnboardingWrapper` to handle common steps like billing, inviting teammates, and data warehouse/reverse proxy setup. Each product-specific onboarding flow includes steps for SDK installation, product configuration (e.g., enabling autocapture, heatmaps), and potentially steps specific to the product, such as authorized domains for Web Analytics or masking configuration for Session Replay. The onboarding flow dynamically adjusts based on feature flags and user selections.\n\nHere's a list of high-level product features implemented in the onboarding flow:\n\n*   **Product-Specific Onboarding Flows:** Tailored onboarding experiences for Product Analytics, Web Analytics, and Session Replay.\n*   **SDK Installation Instructions:** Guides users through installing the appropriate SDK for their chosen product.\n*   **Product Configuration:** Allows users to configure product settings like autocapture, heatmaps, and session recording preferences.\n*   **Billing Integration:** Handles billing and plan upgrades as part of the onboarding process.\n*   **Team Invitation:** Prompts users to invite teammates to the PostHog project.\n*   **Data Warehouse Integration:** Guides users through linking data warehouse sources.\n*   **Reverse Proxy Setup:** Provides instructions for setting up a reverse proxy.\n*   **Session Replay Configuration:** Enables users to configure session recording settings, including masking levels and console/network capture.\n*   **Web Analytics Domain Authorization:** Guides users through authorizing domains for web analytics tracking.\n*   **Dashboard Template Selection and Configuration:** Allows users to select and configure pre-built dashboard templates (behind a feature flag)."
    },
    {
        "path": "frontend/src/scenes/onboarding/web-analytics",
        "summary": "The `OnboardingWebAnalyticsAuthorizedDomainsStep` component is a crucial part of the onboarding process, guiding users to configure authorized domains for web analytics within PostHog. It leverages the `AuthorizedUrlList` component to manage a list of URLs, ensuring that at least one valid domain is added before users can proceed. The component enforces domain validation rules, prohibiting wildcards and requiring concrete, launchable URLs to ensure accurate and controlled web analytics tracking. This step defines the scope of web analytics tracking and controls where the PostHog toolbar is enabled.\n\nHere's a list of high-level product features:\n\n*   **Authorized Domain Management:** Allows users to specify the domains where PostHog is authorized to collect web analytics data.\n*   **Domain Validation:** Enforces restrictions on domain entries, such as disallowing wildcards and requiring concrete URLs.\n*   **Onboarding Integration:** Serves as a step within the onboarding process to guide users through the configuration of authorized domains.\n*   **Web Analytics Scope Definition:** Defines the scope of web analytics tracking based on the authorized domains.\n*   **Toolbar URL Control:** Controls where the PostHog toolbar is enabled based on the authorized domains.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/utils.tsx",
        "summary": "This code defines a data structure `availableOnboardingProducts` that maps product keys to objects containing information about different product features available for onboarding. Each product object includes the product's name, an icon and its color, a URL to access the product, and the corresponding scene within the application. This structure is used to present and guide users through the onboarding process for various PostHog features.\n\nHere's a list of the high-level product features:\n\n*   Product Analytics\n*   Web Analytics\n*   Data Warehouse\n*   Session Replay\n*   Feature Flags\n*   Experiments\n*   Surveys"
    },
    {
        "path": "frontend/src/scenes/onboarding/billing/OnboardingUpgradeStep.tsx",
        "summary": "The `OnboardingUpgradeStep` component guides users through selecting a billing plan during the onboarding process. It displays a loading spinner while billing information is being fetched. If the user isn't already subscribed, it presents a set of `PlanCards` for them to choose from. If the user is already subscribed, it displays a celebratory message with a \"Superman Hog\" animation and confetti, congratulating them on unlocking all features for their chosen product.\n\nHere's a list of high-level product features:\n\n*   **Plan Selection:** Allows users to view and select different billing plans.\n*   **Loading State:** Displays a loading indicator while billing information is being retrieved.\n*   **Subscription Confirmation:** Shows a celebratory message and animation upon successful subscription.\n*   **Onboarding Integration:** Seamlessly integrates into the onboarding flow.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/OnboardingInviteTeammates.tsx",
        "summary": "The `OnboardingInviteTeammates` component is a step in the onboarding process that allows users to invite teammates to their PostHog project. It dynamically adjusts the displayed text based on the specific PostHog product being used (e.g., Product Analytics, Session Replay, Feature Flags, Surveys). The component leverages the `InviteTeamMatesComponent` to handle the actual invitation process, and it checks for email service availability to determine whether to send invites automatically or generate invite links for manual sharing. The component also uses the `OnboardingStep` component to provide a consistent look and feel for the onboarding process.\n\nHere's a list of high-level features:\n\n*   **Teammate Invitation:** Allows users to invite teammates to collaborate on their PostHog project.\n*   **Product-Specific Messaging:** Tailors the invitation message based on the specific PostHog product being used.\n*   **Email Service Detection:** Checks if the PostHog instance is configured to send emails.\n*   **Automatic/Manual Invite Handling:** Automatically sends invites if email service is available, otherwise generates invite links for manual sharing.\n*   **Onboarding Integration:** Seamlessly integrates into the onboarding flow as a dedicated step.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/billing/FreeTierLimits.tsx",
        "summary": "The `FreeTierLimits` component displays a summary of the free tier limits available to users during onboarding. It fetches billing product information using the `billingLogic` and filters for products relevant to onboarding.  It then extracts the free tier allocation for each product, formats the values, and renders them as a list of items, each showing the product name, icon, and the amount of free usage available.\n\nHere's a list of high-level product features implemented by the code:\n\n*   **Display of Free Tier Limits:** Shows users the limits of the free tier for different product features.\n*   **Dynamic Icon Display:** Uses icons to visually represent each free tier limit.\n*   **Formatted Value Display:** Formats the numerical values of the free tier limits for better readability.\n*   **Data Fetching from Billing Logic:** Retrieves billing product information to determine free tier limits.\n*   **Filtering of Onboarding Products:** Filters the billing products to only show those relevant to the onboarding process.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/billing/PlanCards.tsx",
        "summary": "The `PlanCards.tsx` component displays a set of plan options for PostHog, allowing users to select a plan during onboarding. It fetches billing product information and feature flags to tailor the plan details and upgrade options. The component renders individual `PlanCard` components, each representing a different pricing tier with its associated features, price, and call-to-action. It uses data from the billing logic to determine the appropriate upgrade link or payment entry modal, and tracks user interactions with the plan selection.\n\nHere's a list of high-level product features implemented in the code:\n\n*   **Plan Selection:** Displays available PostHog plans (Free, Ridiculously Cheap) with details like title, subtitle, price, and features.\n*   **Feature Comparison:** Lists features available in each plan, indicating whether they are included or not.\n*   **Billing Upgrade:** Provides a call-to-action button to upgrade to a paid plan, linking to the billing page or opening a payment entry modal.\n*   **Free Tier Limits:** Displays information about the limits of the free tier.\n*   **Usage Tracking:** Tracks user interactions with the plan selection, such as clicking the upgrade button.\n*   **Dynamic Plan Details:** Fetches plan details (data retention, project limits) from the billing API to display accurate information.\n*   **Conditional Rendering:** Uses feature flags to determine whether to show the in-app payment entry modal or redirect to the billing page for upgrades.\n*   **Visual Highlighting:** Highlights the \"Ridiculously Cheap\" plan to draw attention to it.\n*   **Hedgehog Animation:** Adds a playful hedgehog animation to the plan cards.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/billing",
        "summary": "The onboarding billing components provide a user-friendly interface for selecting a PostHog plan during the initial setup. Users are presented with a clear overview of the free tier limits, allowing them to understand the usage constraints. They can then compare different paid plans, view their features and pricing, and easily upgrade to a paid plan through a streamlined process. The system dynamically fetches plan details and uses feature flags to tailor the experience, and provides visual cues and animations to guide and engage the user.\n\nHere's a list of high-level product features:\n\n*   **Free Tier Limit Display:** Shows users the limits of the free tier for different product features with icons and formatted values.\n*   **Plan Selection & Comparison:** Displays available PostHog plans with details like title, subtitle, price, and feature comparison.\n*   **Billing Upgrade:** Provides a call-to-action button to upgrade to a paid plan, linking to the billing page or opening a payment entry modal.\n*   **Loading State:** Displays a loading indicator while billing information is being retrieved.\n*   **Subscription Confirmation:** Shows a celebratory message and animation upon successful subscription.\n*   **Usage Tracking:** Tracks user interactions with the plan selection.\n*   **Dynamic Plan Details:** Fetches plan details from the billing API to display accurate information.\n*   **Onboarding Integration:** Seamlessly integrates into the onboarding flow.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/productAnalyticsSteps/onboardingTemplateConfigLogic.ts",
        "summary": "This code defines the `onboardingTemplateConfigLogic` Kea logic, which manages the state and actions related to configuring dashboard templates during the onboarding process. It handles the selection of dashboard templates, configuration of template variables, creation of dashboards from templates, and tracking of user interactions during the onboarding flow. It also manages a modal for requesting new dashboard templates and integrates with the onboarding flow to navigate between steps.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dashboard Template Selection:** Allows users to select pre-built dashboard templates during onboarding.\n*   **Template Variable Configuration:** Enables users to configure variables within the selected dashboard template.\n*   **Custom Event Configuration:** Supports the configuration of custom events as part of the template variables.\n*   **Dashboard Creation from Template:** Facilitates the creation of a new dashboard based on the selected and configured template.\n*   **Onboarding Flow Integration:** Integrates with the overall onboarding flow, guiding users through the dashboard creation process.\n*   **Template Request Feature:** Provides a modal for users to request new dashboard templates.\n*   **Event Tracking:** Tracks user interactions during the onboarding process for analytics purposes.\n*   **Navigation Control:** Controls navigation between onboarding steps based on template configuration status.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/productAnalyticsSteps/DashboardTemplateSelectStep.tsx",
        "summary": "This React component, `OnboardingDashboardTemplateSelectStep`, is a step in the onboarding process that allows users to select a pre-built dashboard template to quickly gain insights from their events. It provides a `DashboardTemplateChooser` component to display available templates and allows users to request a different template if none of the existing ones meet their needs, opening a modal with a form to submit the request. Users can also skip this step and proceed to the next one.\n\nHere's a list of high-level product features implemented in this component:\n\n*   **Dashboard Template Selection:** Allows users to choose from a list of pre-built dashboard templates tailored for different markets and industries.\n*   **Template Preview/Selection Handling:** Handles the selection of a template, potentially navigating the user to the next onboarding step based on the template's configuration.\n*   **Template Request Feature:** Enables users to request new dashboard templates if the existing options are insufficient.\n*   **Skip Template Selection:** Allows users to bypass the template selection step and proceed with a blank dashboard or other onboarding steps.\n*   **Modal for Template Request:** Displays a modal form where users can submit their template requests.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/productAnalyticsSteps/DashboardTemplateVariables.tsx",
        "summary": "This code defines a React component, `DashboardTemplateVariables`, which is responsible for guiding users through the process of configuring variables within a dashboard template. It allows users to select elements from their website using an iframe-based selector, specify pageviews or screenviews, or define custom events to populate the dashboard template with relevant data. The component provides a step-by-step interface, displaying information about each variable, allowing users to select values, and providing options to reset or continue to the next variable.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Dashboard Template Variable Configuration:** Allows users to define and configure variables within a dashboard template.\n*   **Visual Element Selection:** Enables users to select elements directly from their website using an iframe-based visual selector.\n*   **Pageview and Screenview Selection:** Provides options to use specific or any pageview/screenview events as variable values.\n*   **Custom Event Definition:** Allows users to define and use custom events as variable values.\n*   **Step-by-Step Guidance:** Guides users through the variable configuration process with a clear, step-by-step interface.\n*   **Variable Reset:** Allows users to reset the value of a configured variable.\n*   **Contextual Information:** Displays descriptions and tips for each variable to guide the user.\n*   **Progress Tracking:** Indicates which variables have been configured and allows navigation to the next untouched variable.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/productAnalyticsSteps/DashboardTemplateConfigureStep.tsx",
        "summary": "This code defines a React component, `OnboardingDashboardTemplateConfigureStep`, which is a step in the onboarding process focused on configuring a dashboard from a template. It allows users to select a website to track events from using an embedded browser or manually define custom event names. The component integrates with an iframe to browse the selected website and identify elements for tracking. It also includes functionality to manage dashboard template variables, create a dashboard from the template, and handle the overall onboarding flow.\n\nHere's a list of high-level product features implemented in this code:\n\n*   **Dashboard Template Configuration:** Allows users to configure a dashboard based on a pre-defined template.\n*   **Website Selection via iFrame:** Enables users to select a website to track events from using an embedded browser.\n*   **Visual Element Selection:** Provides a visual interface (iFrame) to select specific elements on a website for event tracking.\n*   **Custom Event Name Input:** Allows users to manually define custom event names for tracking if website selection is not possible or desired.\n*   **Dashboard Template Variable Management:** Manages and allows users to define variables within the dashboard template.\n*   **Automated Dashboard Creation:** Creates a new dashboard based on the selected template and configured variables.\n*   **Onboarding Flow Integration:** Integrates seamlessly into the overall onboarding process, guiding users through the steps.\n*   **Authorized URL Management:** Manages the list of authorized URLs for the embedded browser.\n*   **Snippet Installation Guidance:** Guides users to install the PostHog snippet if no website events are detected.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/productAnalyticsSteps",
        "summary": "The onboarding flow for product analytics features a guided experience for new users to quickly set up dashboards and gain insights. Users can select from pre-built dashboard templates tailored to different needs, configure variables within those templates using a visual selector to identify elements on their website, and define custom events. If the available templates don't meet their requirements, users can request new ones. The system tracks user interactions throughout the process and seamlessly integrates with the overall onboarding flow, guiding users through each step.\n\n*   Dashboard Template Selection\n*   Visual Configuration of Template Variables\n*   Custom Event Definition\n*   Automated Dashboard Creation from Templates\n*   Website Selection via iFrame\n*   Template Request Feature\n*   Step-by-Step Guidance for Configuration\n*   Onboarding Flow Integration\n*   Event Tracking\n*   Skip Template Selection\n"
    },
    {
        "path": "frontend/src/scenes/onboarding/onboardingProductConfigurationLogic.ts",
        "summary": "This code defines a Kea logic module named `onboardingProductConfigurationLogic` that manages the configuration of product settings during onboarding. It allows for defining configuration options as either toggles or select dropdowns, each associated with a team property. The logic handles setting initial values, saving configurations by updating the current team with the selected values, and inverting toggle values if needed. It uses LemonSelectOptions for select dropdowns and provides a way to define custom onChange handlers for more complex configuration updates.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Configurable Product Settings:** Allows defining various product settings that can be toggled on/off or selected from a list of options.\n*   **Onboarding Configuration:** Provides a mechanism to configure these settings during the onboarding process.\n*   **Team-Specific Settings:** The settings are stored and managed at the team level, allowing for different configurations for different teams.\n*   **Toggle and Select Input Types:** Supports both toggle switches and select dropdowns as input methods for configuring settings.\n*   **Customizable Update Logic:** Allows defining custom logic to be executed when a setting is changed, enabling more complex configuration scenarios.\n*   **Initial Value Setting:** Supports setting initial values for configuration options, either from existing team settings or static defaults.\n*   **Inverse Toggle Support:** Provides the ability to invert the value of a toggle before saving, useful for \"opt-out\" type settings.\n"
    },
    {
        "path": "frontend/src/scenes/onboarding",
        "summary": "The provided code snippets detail various aspects of the onboarding process within the PostHog application, focusing on guiding new users through initial setup and configuration. The onboarding flow is product-specific, offering tailored experiences for Product Analytics, Web Analytics, Session Replay, Feature Flags, and Surveys. Key features include connecting data sources, installing SDKs, configuring product settings, inviting teammates, setting up reverse proxies, managing billing, and selecting dashboard templates. The system dynamically adjusts based on feature flags, user selections, and billing status, ensuring a personalized and efficient onboarding experience.\n\nHere's a list of high-level product features:\n\n*   **Product-Specific Onboarding Flows:** Tailored onboarding experiences for different PostHog products.\n*   **Data Source Connection:** Streamlines the process of connecting data sources to a user's data warehouse.\n*   **SDK Installation Guidance:** Provides step-by-step instructions and code snippets for integrating PostHog's SDKs into various platforms.\n*   **Product Configuration:** Allows users to configure product settings such as autocapture, heatmaps, and session recording preferences.\n*   **Team Collaboration:** Facilitates inviting teammates to collaborate on the PostHog project.\n*   **Reverse Proxy Setup:** Guides users through setting up a reverse proxy for improved event tracking.\n*   **Billing Management:** Integrates billing and plan upgrades into the onboarding process.\n*   **Dashboard Template Selection:** Enables users to select and configure pre-built dashboard templates.\n*   **Authorized Domain Management:** Allows users to specify the domains where PostHog is authorized to collect web analytics data.\n*   **Session Replay Configuration:** Enables users to configure session recording settings, including masking levels and console/network capture.\n"
    },
    {
        "path": "frontend/src/scenes/debug/debugSceneLogic.ts",
        "summary": "This code defines a Kea logic module called `debugSceneLogic` that manages two query strings, `query1` and `query2`, for a debug query scene. It provides actions to set these queries (`setQuery1`, `setQuery2`) and reducers to store their values. The logic also integrates with the URL, updating the URL's `q` and `q2` parameters when the queries are changed and vice versa, ensuring that the query state is reflected in the URL and persisted across page reloads. The default query is set to a predefined HogQLRaw example.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dual Query Input:** Supports two independent query input fields for debugging purposes.\n*   **Query Persistence via URL:** Query states are maintained in the URL, allowing for easy sharing and bookmarking of specific query configurations.\n*   **Bi-directional URL Sync:** Changes to the query input fields update the URL, and changes to the URL update the query input fields.\n*   **Default Query:** Provides a default query to get users started quickly.\n"
    },
    {
        "path": "frontend/src/scenes/debug/HogDebug.tsx",
        "summary": "This code defines two React components, `HogQueryEditor` and `HogDebug`, for editing and debugging HogQL queries. The `HogQueryEditor` component provides a code editor with syntax highlighting, save functionality, and keyboard shortcuts for running queries. The `HogDebug` component allows users to execute HogQL queries and view the results, bytecode, colored bytecode, and stdout. It also includes features for reloading queries and displaying elapsed time. The debug component leverages LemonTabs to switch between different output formats.\n\nHere's a list of high-level product features:\n\n*   **HogQL Query Editor:**\n    *   Code editor with syntax highlighting for HogQL.\n    *   Save and run query functionality.\n    *   Keyboard shortcut for saving and running queries (Ctrl/Cmd + Enter).\n*   **HogQL Query Debugger:**\n    *   Execute HogQL queries.\n    *   Display query results in JSON or text format.\n    *   Display query bytecode (raw and colored).\n    *   Display query standard output (stdout).\n    *   Tabbed interface for switching between results, bytecode, and stdout.\n    *   Reload query functionality.\n    *   Display elapsed time for query execution.\n*   **Monaco Editor Integration:**\n    *   Leverages the Monaco editor for code editing features.\n    *   Customizable editor options (minimap, word wrap, etc.).\n"
    },
    {
        "path": "frontend/src/scenes/debug/hog/HogRepl.tsx",
        "summary": "This code implements a HogQL REPL (Read-Eval-Print Loop) within the PostHog application, providing an interactive environment for executing and debugging HogQL code. The REPL allows users to enter HogQL code snippets, execute them, and view the results in various formats, including tables, JSON, and raw output. It maintains a history of executed code chunks, displays the status of each chunk (pending, success, error), and provides error messages for failed executions. The REPL also features a code editor with syntax highlighting and autocompletion, and allows users to edit previous code chunks.\n\nHere's a list of high-level product features:\n\n*   **Interactive HogQL Execution:** Allows users to execute HogQL code snippets in real-time.\n*   **Multi-Format Output:** Displays results in table, JSON, and raw string formats.\n*   **Code History:** Maintains a history of executed code chunks.\n*   **Status Indicators:** Shows the status of each code chunk (pending, success, error).\n*   **Error Reporting:** Displays error messages for failed executions.\n*   **Code Editor with Syntax Highlighting:** Provides a code editor with syntax highlighting and autocompletion for HogQL.\n*   **Edit Previous Chunks:** Allows users to edit and re-run previous code snippets.\n*   **Loading State:** Displays a loading animation while code is executing.\n"
    },
    {
        "path": "frontend/src/scenes/debug/QueryTabs.tsx",
        "summary": "The `QueryTabs` component provides a tabbed interface for debugging and inspecting queries within a PostHog application. It dynamically renders tabs based on the query type and the response received, offering insights into errors, visualizations, data tables, result JSON, HogQL and Clickhouse queries, execution plans, timings, full responses, and metadata. The component leverages LemonTabs for the tabbed layout, CodeEditor for displaying code snippets, and other Lemon UI components for a consistent user experience. It also includes error boundaries to prevent crashes and displays timing information for different parts of the query execution.\n\nHere's a list of high-level product features provided by the `QueryTabs` component:\n\n*   **Error Display:** Shows error messages when a query fails.\n*   **Visualization Tab:** Renders a visualization of the query results (if applicable).\n*   **Insight Tab:** Displays an insight derived from the query.\n*   **Data Table Tab:** Presents the query results in a tabular format.\n*   **Result JSON Tab:** Shows the raw JSON result of the query.\n*   **HogQL Tab:** Displays the generated HogQL query.\n*   **Clickhouse Tab:** Shows the Clickhouse query executed.\n*   **Explain Tab:** Presents the execution plan of the query.\n*   **Timings Tab:** Provides timing information for different stages of query execution.\n*   **Full Response Tab:** Displays the complete response object.\n*   **Metadata Tab:** Shows metadata about the query, including errors, warnings, and notices with line and column numbers.\n"
    },
    {
        "path": "frontend/src/scenes/debug/hog/hogReplLogic.ts",
        "summary": "This code defines a Kea logic module called `hogReplLogic` that manages the state and behavior of a HogQL REPL (Read-Eval-Print Loop) within the PostHog application. It allows users to execute HogQL code snippets, view the results, bytecode, and VM state, and step through the execution. The logic handles code execution, error handling, printing, and state management, and persists the REPL state in the URL.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **HogQL REPL Interface:** Provides an interactive environment for writing and executing HogQL code.\n*   **Code Execution:** Executes HogQL code snippets and displays the result.\n*   **Error Handling:** Catches and displays errors that occur during code execution.\n*   **Bytecode Inspection:** Allows users to view the generated bytecode for their code.\n*   **VM State Inspection:** Enables users to inspect the state of the HogVM during execution, including the stack, call stack, and upvalues.\n*   **Printing:** Supports the `print` function within HogQL to output values during execution.\n*   **REPL History:** Maintains a history of executed code snippets and their results.\n*   **Code Editing:** Allows users to edit previous code snippets and re-run them.\n*   **URL Persistence:** Saves the REPL state (code and results) in the URL, allowing users to share or revisit their session.\n*   **State Management:** Manages the state of the HogVM across multiple code executions.\n"
    },
    {
        "path": "frontend/src/scenes/debug/hog",
        "summary": "The HogQL REPL provides an interactive environment within PostHog for users to write, execute, and debug HogQL code. It features a code editor with syntax highlighting and autocompletion, allowing users to input and execute HogQL snippets. The REPL displays results in multiple formats (table, JSON, raw), maintains a history of executed code chunks with status indicators, and provides detailed error reporting. Users can also inspect the generated bytecode and VM state, step through execution, and utilize the `print` function for debugging. The REPL state is persisted in the URL, enabling sharing and revisiting sessions.\n\nHere's a list of the high-level product features:\n\n*   HogQL REPL Interface\n*   Interactive HogQL Execution\n*   Code Execution\n*   Error Handling\n*   Bytecode Inspection\n*   VM State Inspection\n*   Printing\n*   REPL History\n*   Code Editing\n*   URL Persistence\n*   State Management\n*   Multi-Format Output\n*   Status Indicators\n*   Error Reporting\n*   Code Editor with Syntax Highlighting\n*   Edit Previous Chunks\n*   Loading State\n"
    },
    {
        "path": "frontend/src/scenes/debug/DebugScene.tsx",
        "summary": "The `DebugScene` component provides a user interface for debugging queries, primarily focusing on HogQL. It features a page header with buttons to load example queries, including HogQL raw queries, HogQL table queries, and other sample queries selectable from a dropdown. The scene allows users to input and edit queries in two separate panels, enabling comparison and splitting of queries for debugging purposes. The component leverages Kea for state management and feature flags to conditionally display certain functionalities.\n\nHere's a list of high-level product features:\n\n*   **Query Input Panels:** Two independent panels for inputting and editing queries.\n*   **Example Query Loading:** Buttons to quickly load predefined example queries.\n*   **HogQL Debugging:** Specific support for debugging HogQL queries.\n*   **Query Splitting:** Ability to copy the content of one query panel to the other for comparison or modification.\n*   **Feature Flag Integration:** Conditionally display features based on feature flag status.\n*   **Sample Query Selection:** Dropdown to select from a variety of sample queries.\n"
    },
    {
        "path": "frontend/src/scenes/debug/DebugSceneQuery.tsx",
        "summary": "This React component, `DebugSceneQuery`, provides a debugging interface for PostHog queries. It takes a query string as input, parses it, and renders different debugging tools based on the query type (HogQL, HogQuery, or generic query). It allows users to edit the query, view the response, and modify query parameters. The component leverages other components like `HogDebug`, `HogQLDebug`, `QueryEditor`, `Modifiers`, and `QueryTabs` to provide a comprehensive debugging experience.\n\nHere's a list of high-level product features:\n\n*   **Query Type Detection:** Automatically detects the type of query (HogQL, HogQuery, or generic) and renders the appropriate debugging interface.\n*   **Query Editing:** Allows users to edit the query string directly within the interface.\n*   **Response Viewing:** Displays the response data returned by the query.\n*   **Query Modification:** Provides tools to modify query parameters and modifiers.\n*   **Tabbed Interface:** Organizes query information and response data into a tabbed interface for easy navigation.\n*   **HogQL Debugging:** Provides a dedicated debugging interface for HogQL queries.\n*   **HogQuery Debugging:** Provides a dedicated debugging interface for HogQuery queries.\n"
    },
    {
        "path": "frontend/src/scenes/debug/HogQLDebug.tsx",
        "summary": "The `HogQLDebug` component provides a debugging interface for HogQL queries. It allows users to edit and run HogQL queries, view the results in different tab formats, and modify the query using modifiers. The component also displays the elapsed time while the query is running and provides options to reload the query, adjust the date range, and filter events by properties.\n\nHere's a list of high-level product features:\n\n*   **HogQL Query Editor:** Allows users to write and edit HogQL queries.\n*   **Query Execution and Result Display:** Executes HogQL queries and displays the results in a user-friendly format using tabs.\n*   **Query Modifiers:** Provides tools to modify the query, potentially through a visual interface.\n*   **Real-time Query Status:** Displays the query execution status, including loading state and elapsed time.\n*   **Date Range Filtering:** Allows users to filter the query results by a specific date range.\n*   **Event Property Filtering:** Enables users to filter events based on their properties.\n*   **Query Reload:** Provides a button to easily re-run the current query.\n"
    },
    {
        "path": "frontend/src/scenes/debug/Modifiers.tsx",
        "summary": "This React component, `Modifiers`, provides a user interface for adjusting HogQL query modifiers. It renders a series of LemonSelect components, each associated with a specific query modifier, such as Persons on Events mode, Persons ArgMax version, In Cohort Via method, Materialization Mode, Optimization of joined filters, and Property Groups mode.  The component allows users to modify these modifiers and update the query accordingly, providing granular control over query execution and behavior.\n\nHere's a list of high-level product features:\n\n*   **Persons on Events Mode Selection:** Allows users to choose how persons are associated with events in queries (disabled, properties on events with event-based person ID, properties on events with overridden person ID, properties on persons with overridden person ID).\n*   **Persons ArgMax Version Selection:** Enables users to select the version of the Persons ArgMax algorithm used in queries.\n*   **In Cohort Via Method Selection:** Provides options for how cohort membership is determined in queries (auto, left join, subquery, left join conjoined).\n*   **Materialization Mode Selection:** Allows users to control how null values are handled in query results (auto, legacy string, legacy null, disabled).\n*   **Optimize Joined Filters Toggle:** Enables or disables optimization of joined filters in queries.\n*   **Property Groups Mode Selection:** Allows users to control how property groups are handled in queries (enabled, disabled, enabled with optimizations).\n"
    },
    {
        "path": "frontend/src/scenes/debug",
        "summary": "The provided code collectively implements a comprehensive debugging suite for HogQL queries within the PostHog application. It offers a rich set of features for writing, executing, inspecting, and optimizing queries, including a code editor with syntax highlighting, multiple output formats (JSON, table, bytecode, stdout), a tabbed interface for organizing results, and tools for modifying query parameters and modifiers. The suite also supports query persistence via URL, example query loading, and detailed error reporting, empowering users to effectively debug and fine-tune their HogQL queries.\n\nHere's a list of high-level product features:\n\n*   **HogQL Query Editor:** Code editor with syntax highlighting, save functionality, and keyboard shortcuts for running queries.\n*   **HogQL Query Debugger:** Executes HogQL queries and displays results, bytecode, and stdout in a tabbed interface.\n*   **Query Type Detection:** Automatically detects the type of query (HogQL, HogQuery, or generic) and renders the appropriate debugging interface.\n*   **Query Modification:** Tools to modify query parameters and modifiers.\n*   **Query Persistence via URL:** Query states are maintained in the URL.\n*   **Example Query Loading:** Buttons to quickly load predefined example queries.\n*   **Error Display:** Shows error messages when a query fails, including line and column numbers.\n*   **Visualization Tab:** Renders a visualization of the query results (if applicable).\n*   **Data Table Tab:** Presents the query results in a tabular format.\n*   **HogQL Tab:** Displays the generated HogQL query.\n*   **Clickhouse Tab:** Shows the Clickhouse query executed.\n*   **Explain Tab:** Presents the execution plan of the query.\n*   **Timings Tab:** Provides timing information for different stages of query execution.\n*   **Full Response Tab:** Displays the complete response object.\n*   **Metadata Tab:** Shows metadata about the query, including errors, warnings, and notices.\n*   **HogQL REPL Interface:** Interactive environment for writing, executing, and debugging HogQL code.\n*   **Query Modifiers:** UI for adjusting HogQL query modifiers like Persons on Events mode, In Cohort Via method, etc.\n"
    },
    {
        "path": "frontend/src/scenes/moveToPostHogCloud/MoveToPostHogCloud.tsx",
        "summary": "The `MoveToPostHogCloud.tsx` component is a scene that promotes migrating from self-hosted PostHog to PostHog Cloud. It highlights the benefits of the cloud offering, emphasizing that PostHog handles the infrastructure, allowing users to focus on their product. The component showcases a list of features that come with PostHog Cloud, such as managed hosting, data location options, easy migration, auto-scaling, high availability, automatic upgrades and backups, access to premium features, world-class support, and compliance certifications. It also includes a call-to-action button to move to PostHog Cloud and a visual element featuring the ExperimentsHog component.\n\nHere's a list of the high-level product features promoted by this component:\n\n*   **Managed Hosting:** No server, database, or data ingestion management required.\n*   **Data Location:** Option to host data in EU or US data centers.\n*   **Easy Migration:** Simplified data migration from self-hosted to Cloud.\n*   **Auto-Scaling:** Automatically scales with product growth to handle data spikes and prevent downtime.\n*   **High Availability:** Ensures data is always accessible.\n*   **Automatic Updates:** Always up-to-date with the latest features and security updates.\n*   **Automatic Backups:** Data backups are managed automatically.\n*   **Full Feature Access:** Access to premium features like group analytics, data pipelines, and experiments.\n*   **World-Class Support:** Access to PostHog's support team.\n*   **SOC 2 Compliance:** SOC 2 compliant for data security.\n*   **HIPAA Compliance:** HIPAA compliant for customer data security."
    },
    {
        "path": "frontend/src/scenes/moveToPostHogCloud",
        "summary": "The MoveToPostHogCloud component is a promotional scene designed to encourage users of self-hosted PostHog instances to migrate to PostHog Cloud. It emphasizes the reduced operational overhead and enhanced feature set available on the cloud platform, highlighting benefits such as managed hosting, data location choices, simplified migration, automatic scaling, high availability, automatic updates and backups, access to premium features, world-class support, and compliance certifications. The scene includes a call to action button to initiate the migration process.\n\nHere's a list of the high-level product features promoted by this component:\n\n*   Managed Hosting\n*   Data Location Options (EU/US)\n*   Easy Migration\n*   Auto-Scaling\n*   High Availability\n*   Automatic Updates\n*   Automatic Backups\n*   Full Feature Access (Group Analytics, Data Pipelines, Experiments)\n*   World-Class Support\n*   SOC 2 Compliance\n*   HIPAA Compliance\n"
    },
    {
        "path": "frontend/src/scenes",
        "summary": "The PostHog platform offers a comprehensive suite of features for product analytics, experimentation, and data management, empowering users to gain deep insights into user behavior, optimize their products, and drive growth.  From user-friendly dashboards and interactive visualizations to advanced data warehousing and AI-powered analysis, PostHog provides the tools necessary to understand and act on data.  The platform also emphasizes collaboration, security, and customization, ensuring a seamless and secure experience for teams of all sizes.\n\nHere's a list of high-level product features:\n\n*   **Product Analytics:** Trends, funnels, retention, paths, session recordings, heatmaps, web analytics, user cohorts, and more.\n*   **Experimentation:** A/B testing, feature flags, holdout groups, and experiment analysis.\n*   **Data Management:** Data warehouse integration, data pipelines, event and property definitions, data governance, and data quality monitoring.\n*   **AI Assistant:** Natural language querying, automated analysis, and data visualization generation.\n*   **Collaboration:** Notebooks, comments, shared dashboards, and role-based access control.\n*   **Customization:** Custom CSS theming, dashboard templates, and customizable settings.\n*   **User Management:** Organization and project management, user authentication, and access control.\n*   **Integrations:** Integration with various data sources, destinations, and third-party services.\n*   **Automation:** Automated messaging, data pipelines, and scheduled tasks.\n*   **Alerting:** Real-time alerts for errors, usage limits, and other critical events.\n*   **Mobile Support:** Support for mobile app analytics and session recordings.\n*   **Data Privacy and Security:** Data anonymization, encryption, and compliance certifications.\n*   **Onboarding:** Guided onboarding experiences for new users and features.\n*   **Billing and Subscription Management:** Transparent billing, usage tracking, and subscription management.\n*   **Surveys:** User surveys and feedback collection.\n*   **Error Tracking:** Real-time error monitoring and debugging.\n*   **Data Model Visualization:** Interactive data model visualization and management.\n*   **Instance Management:** Tools for managing self-hosted PostHog instances.\n*   **API and SDKs:** Comprehensive API and SDKs for integrating PostHog into various platforms.\n*   **Customer Success Dashboards:** Tailored dashboards for customer success insights.\n*   **Group Analytics:** Analysis and management of groups of users or entities.\n*   **Data Pipelines:** Ingest, transform, and export data with ease.\n*   **Feature Flag Permissions:** Role-based access control for feature flags.\n*   **Preflight Checks:** System readiness assessment.\n*   **Site Navigation:** Breadcrumbs for navigating within a specific site.\n*   **Toolbar Launch:** Central launchpad for the PostHog toolbar.\n*   **Move to PostHog Cloud:** Promotional scene designed to encourage users of self-hosted PostHog instances to migrate to PostHog Cloud.\n*   **Integrations Management:** Allows users to connect and manage integrations with external services.\n*   **Unsubscribe:** Allows users to unsubscribe from email lists.\n*   **Activity:** Explore and monitor events within the application.\n*   **Data Theme Management:** Allows users to define and manage custom color palettes for data visualizations.\n*   **Product Selection:** Allows users to select multiple products from a list.\n*   **Annotations:** Mark significant events and their impact on metrics.\n*   **Team Activity Descriptions:** Describe changes made to a team's configuration.\n*   **Setup Wizard:** Authentication Setup Wizard.\n*   **App Context Synchronization:** Ensures the application's context is consistent with the server-side data.\n*   **Feature Flag Permissions:** Role-Based Access Control (RBAC) for Feature Flags.\n*   **Toolbar Launch:** Central launchpad for the PostHog toolbar.\n*   **Integrations Redirect:** Handle redirection of users to external services or specific pages within the application during the integration process.\n*   **Team/Environment Management:** Creating, updating, deleting teams/environments.\n*   **Project Creation:** Allows users to create new projects.\n*    **Data Model Visualization:** Displaying a data model as a graph of interconnected nodes with automatic hierarchical layout.\n"
    },
    {
        "path": "frontend/src/layout/ErrorNetwork.tsx",
        "summary": "The `ErrorNetwork` component displays a user-friendly error message when there's a network issue preventing a resource from loading. It includes a title, a descriptive message, and a button that allows the user to reload the page, attempting to resolve the network problem.\n\n**Features:**\n\n*   **Network Error Display:** Shows a specific error page when a network error occurs.\n*   **Informative Message:** Provides a clear message to the user explaining the network issue.\n*   **Page Reload Button:** Offers a button with an icon to easily reload the page and retry loading the resource.\n"
    },
    {
        "path": "frontend/src/layout/FeaturePreviews/featurePreviewsLogic.tsx",
        "summary": "This code defines the logic for managing feature previews within the application. It fetches a list of early access features from PostHog, enriches them with information about their enabled state based on feature flags, and allows users to toggle their enrollment in these features. The logic also handles collecting and submitting user feedback on specific early access features through Zendesk tickets. Additionally, it provides functionality to copy a link to a specific feature preview for sharing.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Feature Preview Enrollment:** Allows users to opt-in or opt-out of early access features.\n*   **Feature Flag Management:** Integrates with feature flags to determine the availability and state of early access features.\n*   **User Feedback Collection:** Enables users to submit feedback on specific early access features.\n*   **Zendesk Integration:** Submits user feedback as Zendesk tickets for review and action.\n*   **Shareable Feature Preview Links:** Generates links to specific feature previews for easy sharing.\n*   **Constrained Previews:** Supports feature previews that are only available to users with a specific preview flag.\n"
    },
    {
        "path": "frontend/src/initKea.ts",
        "summary": "This code initializes the Kea context for the PostHog frontend, configuring it with a suite of plugins to manage application state, routing, forms, data loading, local storage, subscriptions, and asynchronous operations. It also includes error handling for loader actions, displaying user-friendly error messages while filtering out specific actions to avoid unnecessary alerts. Additionally, it provides a logger plugin for debugging and integrates with Sentry for error tracking. The code also manages the addition and removal of project IDs from URLs for routing purposes.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **State Management:** Centralized state management using Kea logic.\n*   **Local Storage Persistence:** Persisting data in local storage.\n*   **Window Value Management:** Accessing and reacting to window properties.\n*   **Routing:** Managing application routes and URL parameters, including project ID handling.\n*   **Form Management:** Simplifying form handling and validation.\n*   **Asynchronous Data Loading:** Managing data loading states and handling errors.\n*   **Subscriptions:** Reacting to changes in Kea logic.\n*   **Asynchronous Operations:** Waiting for specific conditions to be met.\n*   **Error Handling:** Displaying user-friendly error messages and logging errors to Sentry.\n*   **Debugging:** Verbose logging of Kea actions and state changes.\n"
    },
    {
        "path": "frontend/src/loadPostHogJS.tsx",
        "summary": "This code initializes PostHog analytics with various configurations, including error tracking via Sentry, feature flag support, session recording, and integration with Cypress for testing. It configures PostHog to capture user interactions, performance metrics, and rage clicks, while also providing mechanisms for opting in/out of capturing based on the environment and user identity. The code also handles specific scenarios like impersonated sessions and Cypress testing environments, ensuring proper data capture and session management.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Analytics Tracking:** Captures user interactions (autocapture, rage clicks, copied text) and performance metrics (web vitals).\n*   **Session Recording:** Records user sessions for analysis and debugging.\n*   **Feature Flag Support:** Integrates with PostHog's feature flag system to control feature availability.\n*   **Error Tracking:** Integrates with Sentry to capture and report errors during PostHog data transmission.\n*   **User Identity Management:** Handles user identification and session management, including support for impersonated sessions.\n*   **Testing Support:** Provides mechanisms for Cypress testing, including capturing events and registering properties.\n*   **Data Persistence:** Uses localStorage and cookies for data persistence.\n*   **Opt-in/Opt-out:** Allows users to opt-in or opt-out of data capturing.\n"
    },
    {
        "path": "frontend/src/layout/FeaturePreviews/FeaturePreviews.tsx",
        "summary": "This code implements a \"Feature Previews\" section within a web application, likely for a product like PostHog. It allows users to explore and interact with upcoming or experimental features. The section is divided into two tabs: \"Previews\" (for beta features) and \"Coming Soon\" (for concept features). Users can toggle beta features on/off, provide feedback on them, and express interest in concept features to receive notifications when they become available. The component fetches and displays a list of these features, providing descriptions, links to documentation, and feedback mechanisms.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Feature Preview Display:** Shows a list of upcoming or experimental features, categorized by stage (beta/concept).\n*   **Beta Feature Toggle:** Allows users to enable or disable beta features.\n*   **Feedback Submission:** Enables users to provide feedback on beta features through a text area and submit it.\n*   **Documentation Links:** Provides links to documentation for beta features.\n*   **\"Coming Soon\" Registration:** Allows users to register interest in concept features to receive notifications.\n*   **External Feature Preview Link:** Allows users to copy a link to share the feature preview.\n*   **Loading State:** Displays a spinner while feature data is loading.\n*   **Empty State:** Shows a message when no feature previews are available.\n*   **Focus Feature:** When navigating to the page, the feature with the matching flag key will be scrolled into view."
    },
    {
        "path": "frontend/src/layout/FeaturePreviews",
        "summary": "The code implements a comprehensive \"Feature Previews\" system within the application, allowing users to discover, enroll in, and provide feedback on upcoming and experimental features. This system is divided into \"Previews\" (beta features) and \"Coming Soon\" (concept features) sections, providing a structured way to showcase new functionalities. Users can toggle beta features on/off, submit feedback via Zendesk integration, access documentation, and register interest in concept features. The system also supports feature flag management, shareable feature preview links, and constrained previews based on specific user flags.\n\nHere's a list of high-level product features:\n\n*   Feature Preview Enrollment (Beta Feature Toggle)\n*   Feature Preview Display (Categorized by Beta/Concept)\n*   User Feedback Collection (Zendesk Integration)\n*   Documentation Links\n*   \"Coming Soon\" Registration (Interest Notification)\n*   Shareable Feature Preview Links\n*   Feature Flag Management\n*   Constrained Previews (Based on User Flags)\n*   Loading State\n*   Empty State\n*   Focus Feature\n"
    },
    {
        "path": "frontend/src/layout/ErrorBoundary/index.ts",
        "summary": "The code exports the `ErrorBoundary` component from the `./ErrorBoundary` file. This component likely provides a mechanism to catch and handle errors that occur within its child components, preventing the entire application from crashing and providing a more graceful user experience.\n\n**Features:**\n\n*   **Error Catching:** Catches JavaScript errors anywhere in the component tree below it.\n*   **Fallback UI:** Renders a fallback UI when an error occurs, instead of crashing the application.\n*   **Error Logging:** Likely includes functionality to log error information for debugging purposes.\n*   **Component Tree Isolation:** Isolates errors to specific parts of the application, preventing them from affecting other areas.\n"
    },
    {
        "path": "frontend/src/layout/ErrorBoundary/ErrorBoundary.tsx",
        "summary": "The `ErrorBoundary` component is a React component that wraps around other components to catch errors and display a fallback UI. It uses Sentry for error tracking and reporting, and provides a button to email an engineer for support. The component also adds tags to Sentry events, including the team ID and any custom tags passed as props. If Sentry is initialized, the fallback UI displays the Sentry event ID.\n\nHere's a list of high-level product features:\n\n*   **Error Boundary:** Catches errors within React components to prevent the entire application from crashing.\n*   **Sentry Integration:** Reports errors to Sentry for tracking and analysis.\n*   **Team ID Tagging:** Automatically tags Sentry events with the current team ID.\n*   **Custom Tagging:** Allows adding custom tags to Sentry events.\n*   **Fallback UI:** Displays a user-friendly error message with error details.\n*   **Sentry Event ID Display:** Shows the Sentry event ID in the fallback UI when Sentry is initialized.\n*   **Email Support Button:** Provides a button to email an engineer for support.\n"
    },
    {
        "path": "frontend/src/layout/ErrorBoundary",
        "summary": "The `ErrorBoundary` component enhances application stability by catching errors within React components and preventing crashes. It integrates with Sentry for error tracking, automatically tagging events with team ID and allowing custom tags. When an error occurs, a user-friendly fallback UI is displayed, potentially showing the Sentry event ID and providing an option to email support.\n\n**Features:**\n\n*   Error Catching & Prevention of App Crashes\n*   Fallback UI on Error\n*   Sentry Integration for Error Tracking\n*   Automated Tagging of Sentry Events (Team ID, Custom Tags)\n*   Display of Sentry Event ID in Fallback UI\n*   Email Support Button in Fallback UI\n"
    },
    {
        "path": "frontend/src/layout/navigation/SideBar/SidebarChangeNotice.tsx",
        "summary": "This code defines a React component, `SidebarChangeNotice`, that displays notices to users about changes in the sidebar navigation. It uses feature flags to control which notices are displayed based on user properties and a date. The component filters a predefined list of notices based on the current sidebar identifier and whether the corresponding feature flag is enabled. When a user acknowledges a notice, an event is captured in PostHog, and a user property is set to prevent the notice from being displayed again. The component returns a list of notices to display and a function to call when the user acknowledges the notices.\n\nHere's a list of high-level product features:\n\n*   **Sidebar Change Notices:** Display informational notices in the sidebar to inform users about changes to navigation or feature locations.\n*   **Feature Flag Controlled Notices:** Use feature flags to target specific users with relevant notices based on their properties and join date.\n*   **Acknowledgement Tracking:** Track when users acknowledge a notice to avoid showing it again.\n*   **PostHog Integration:** Capture events in PostHog when a user acknowledges a notice to track notice effectiveness.\n*   **Dynamic Notice Content:** Display different notices based on the current sidebar section.\n"
    },
    {
        "path": "frontend/src/layout/navigation/SideBar",
        "summary": "The `SidebarChangeNotice` component provides a mechanism for displaying targeted informational notices to users within the application's sidebar. These notices are designed to inform users about changes to navigation or feature locations and are controlled by feature flags, allowing for targeted delivery based on user properties and join date. The system tracks user acknowledgement of notices to prevent repeated display and integrates with PostHog to capture events related to notice interactions, enabling analysis of notice effectiveness. The content of the notices is dynamic, adapting to the specific sidebar section the user is currently viewing.\n\nHere's a list of high-level product features:\n\n*   **Sidebar Change Notices:** Display informational notices in the sidebar.\n*   **Feature Flag Controlled Notices:** Target specific users with relevant notices.\n*   **Acknowledgement Tracking:** Prevent repeated display of acknowledged notices.\n*   **PostHog Integration:** Capture events to track notice effectiveness.\n*   **Dynamic Notice Content:** Display different notices based on the current sidebar section.\n"
    },
    {
        "path": "frontend/src/layout/navigation/OrganizationSwitcher.tsx",
        "summary": "The `OrganizationSwitcher.tsx` component provides a user interface for switching between different organizations within the PostHog application. It displays the current organization and a list of other organizations the user belongs to, allowing them to switch between them. It also includes a button to create a new organization, subject to feature availability and preflight checks. The component leverages various PostHog libraries and logic hooks to manage organization data, user actions, and UI elements.\n\nHere's a list of high-level product features implemented by the code:\n\n*   **Organization Switching:** Allows users to switch between different organizations they are a member of.\n*   **Organization Creation:** Enables users to create new organizations (subject to feature flags and permissions).\n*   **Organization Access Level Indication:** Displays the user's access level within each organization.\n*   **Organization Logo Display:** Shows the logo for each organization in the switcher.\n*   **Feature Guarding:** Prevents users from creating new organizations if the feature is not available in their current plan.\n"
    },
    {
        "path": "frontend/src/layout/navigation/navigationLogic.ts",
        "summary": "This code defines the logic for the main navigation bar in the PostHog frontend. It manages the state of the account popover and project switcher, determines the appropriate project-level notices to display based on various conditions (demo project, no events ingested, unverified email, etc.), and handles dismissing these notices. It also fetches system status and manages window-related values like fullscreen mode and mobile layout detection.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Account Management:** Allows users to open and close an account popover, likely for managing their profile and settings.\n*   **Project Switching:** Enables users to switch between different PostHog projects.\n*   **Contextual Project Notices:** Displays relevant notices to users based on the state of their project (e.g., demo project, no events ingested, invite teammates).\n*   **System Status Monitoring:** Displays the health of the PostHog system, including async migrations.\n*   **Responsive Layout:** Adapts the layout based on the screen size, providing a better experience on mobile devices.\n*   **Fullscreen Detection:** Detects when the browser is in fullscreen mode.\n"
    },
    {
        "path": "frontend/src/layout/navigation/environmentsSwitcherLogic.tsx",
        "summary": "This code defines the logic for an environment switcher component in a web application. It manages the display and searching of teams and projects within an organization, allowing users to switch between different environments (teams) and projects. The logic fetches data about the current user, team, and organization, sorts teams and projects based on relevance (current team/project first), and provides a search functionality to filter teams by name or project name. The results are structured into a map of projects and their associated teams, optimized for display in the environment switcher.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Environment Switching:** Allows users to switch between different environments (teams) within an organization.\n*   **Project Switching:** Enables users to navigate and select different projects.\n*   **Searchable Environments:** Provides a search bar to quickly find specific teams by name or project name.\n*   **Prioritized Display:** Sorts and displays teams and projects with the current team/project at the top for easy access.\n*   **Organization Context:** Fetches and utilizes organization data to display relevant teams and projects.\n"
    },
    {
        "path": "frontend/src/layout/navigation/ProjectSwitcher.tsx",
        "summary": "The `ProjectSwitcher.tsx` component provides a UI for users to switch between different PostHog projects within their organization. It displays a list of available projects, highlighting the currently active project, and allows users to navigate to other projects or create new ones. The component also integrates with feature flags to conditionally render environment-specific project switching if the `ENVIRONMENTS` feature flag is enabled. It also handles permission checks for project creation and displays appropriate tooltips if project creation is forbidden.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Project Switching:** Allows users to switch between different projects within an organization.\n*   **Current Project Highlighting:** Clearly indicates the currently active project.\n*   **Project Creation:** Provides a button to create new projects, subject to permission checks.\n*   **Project Settings Navigation:** Provides quick access to project settings for each project.\n*   **Environment Switching (Conditional):** If the `ENVIRONMENTS` feature flag is enabled, it renders an environment switcher instead of a project switcher.\n*   **Demo Project Indication:** Visually indicates if a project is a demo project.\n*   **Permission Handling:** Disables the \"New project\" button and shows a tooltip if the user doesn't have permission to create projects."
    },
    {
        "path": "frontend/src/layout/navigation/TopBar/AccountPopover.tsx",
        "summary": "This code defines the `AccountPopoverOverlay` component, which renders a popover menu accessible from the top navigation bar. This popover provides access to user account settings, organization settings, billing information, the ability to switch between organizations, invite new members, toggle the theme, view the changelog, access feature previews, and sign out. Additionally, for staff users, it includes links to the Django admin panel and instance settings. For non-cloud instances, it offers a link to try PostHog Cloud.\n\nHere's a list of high-level product features provided by the AccountPopover:\n\n*   **Account Management:** Access to user profile settings (name, email, etc.).\n*   **Organization Management:** Access to organization settings (name, logo, etc.).\n*   **Billing Management:** Access to billing information and usage dashboards.\n*   **Organization Switching:** Ability to switch between multiple organizations.\n*   **Team Collaboration:** Ability to invite new members to the current organization.\n*   **UI Customization:** Theme switching (light/dark mode).\n*   **Product Updates:** Access to the product changelog.\n*   **Feature Discovery:** Access to feature previews.\n*   **Sign Out:** Ability to log out of the application.\n*   **Admin Access (Staff Only):** Links to Django admin and instance settings for staff users.\n*   **Cloud Migration (Non-Cloud Only):** Option to try PostHog Cloud for self-hosted instances.\n"
    },
    {
        "path": "frontend/src/layout/navigation/ProjectNotice.tsx",
        "summary": "The `ProjectNotice` component displays a banner at the top of the PostHog application to communicate important information to the user. The banner's message, type (info, warning, success, error), and actions are determined by the `projectNoticeVariant` prop, which selects a predefined notice configuration. These notices can inform users about demo projects, projects without events, the need to invite teammates, unverified email addresses, impersonation status, or internet connection issues. The component also handles countdown timers for time-sensitive notices and provides actions like navigating to onboarding wizards, inviting teammates, sending verification emails, logging out of impersonation sessions, or reloading the page.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Displaying Demo Project Notices:** Informs users when they are in a demo project and guides them to set up a real project.\n*   **Guiding New Users:** Notifies users when a project has no events and directs them to the onboarding wizard or project settings.\n*   **Promoting Team Collaboration:** Encourages users to invite teammates to PostHog.\n*   **Email Verification Reminders:** Prompts users to verify their email address.\n*   **Impersonation Status Indication:** Informs users when they are logged in as a customer and provides a countdown timer for the impersonation session.\n*   **Connectivity Issue Alerts:** Notifies users of potential internet connection problems.\n*   **Customizable Banner Messages:** Displays different messages based on the `projectNoticeVariant`.\n*   **Actionable Notifications:** Provides buttons or links within the banner to take relevant actions.\n*   **Closeable Notifications:** Allows users to dismiss certain notifications.\n"
    },
    {
        "path": "frontend/src/layout/navigation/TopBar",
        "summary": "The `AccountPopoverOverlay` component provides a centralized menu for users to manage their account and organization settings, customize their experience, and access important information. It offers features such as account and organization management, billing information, organization switching, team collaboration tools, UI customization through theme switching, access to product updates and feature previews, and a sign-out option. Additionally, it provides staff users with access to admin panels and instance settings, while non-cloud users are presented with an option to try PostHog Cloud.\n\nHere's a list of high-level product features provided by the AccountPopover:\n\n*   Account Management\n*   Organization Management\n*   Billing Management\n*   Organization Switching\n*   Team Collaboration (Invite Members)\n*   UI Customization (Theme Switching)\n*   Product Updates (Changelog)\n*   Feature Discovery (Feature Previews)\n*   Sign Out\n*   Admin Access (Staff Only)\n*   Cloud Migration (Non-Cloud Only)\n"
    },
    {
        "path": "frontend/src/layout/navigation/EnvironmentSwitcher.tsx",
        "summary": "The `EnvironmentSwitcher.tsx` component provides a user interface for switching between different PostHog projects and environments (teams). It displays a menu overlay with options to switch to existing projects and environments, create new projects and environments, and search for specific projects or environments. The component uses data from various logics like `organizationLogic`, `teamLogic`, and `environmentSwitcherLogic` to dynamically generate the menu items and their associated actions. It also handles feature gating for creating new projects and environments, directing users to upgrade their plan if necessary.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Project and Environment Switching:** Allows users to quickly switch between different projects and their associated environments.\n*   **Project and Environment Search:** Enables users to search for specific projects and environments by name.\n*   **Project and Environment Creation:** Provides options to create new projects and environments directly from the switcher.\n*   **Feature Gating:** Integrates with feature flags to control access to project and environment creation based on the user's plan.\n*   **Settings Navigation:** Provides quick access to project and environment settings pages.\n*   **Visual Differentiation:** Uses icons and tags to visually distinguish between projects and environments.\n*   **Emoji Support:** Handles project names that start with emojis.\n"
    },
    {
        "path": "frontend/src/layout/navigation/Breadcrumbs/breadcrumbsLogic.tsx",
        "summary": "This code defines the logic for generating and managing breadcrumbs in the PostHog frontend. It uses Kea to manage state, connect to other logic files, and define selectors for deriving breadcrumb data based on the current scene, user, organization, project, and other relevant application state. The logic handles both application-level and scene-specific breadcrumbs, allowing for customization and dynamic updates based on the user's navigation and the current context. It also manages renaming breadcrumbs and updating the document title to reflect the current location within the application.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dynamic Breadcrumb Navigation:** Generates breadcrumbs based on the user's current location within the application, including organization, project, and scene context.\n*   **Organization and Project Switching:** Integrates with organization and project switcher overlays, allowing users to easily navigate between different contexts.\n*   **Customizable Breadcrumb Names:** Allows for tentative renaming of breadcrumbs, providing a way to customize the displayed names.\n*   **Context-Aware Breadcrumbs:** Displays different breadcrumb information based on the current scene, user permissions, and feature flags.\n*   **Document Title Updates:** Dynamically updates the document title to reflect the current page or section of the application.\n*   **Visual Breadcrumb Customization:** Supports displaying organization logos within breadcrumbs for visual identification.\n*   **Instance Level Breadcrumbs:** Supports displaying the instance name in the breadcrumbs for instance-level views.\n"
    },
    {
        "path": "frontend/src/layout/navigation/Breadcrumbs",
        "summary": "The breadcrumbs logic manages the navigation aid within the PostHog frontend, dynamically generating breadcrumbs based on the user's location, organization, project, and scene. It integrates with organization and project switching, allows for customizable breadcrumb names, and adapts the displayed information based on context, user permissions, and feature flags. Furthermore, it updates the document title to reflect the current page and supports visual customization with organization logos and instance names.\n\nHere's a list of high-level product features enabled by this code:\n\n*   Dynamic Breadcrumb Navigation\n*   Organization and Project Switching\n*   Customizable Breadcrumb Names\n*   Context-Aware Breadcrumbs\n*   Document Title Updates\n*   Visual Breadcrumb Customization\n*   Instance Level Breadcrumbs\n"
    },
    {
        "path": "frontend/src/layout/navigation",
        "summary": "The navigation components in the PostHog frontend provide a comprehensive suite of features for users to navigate the application, manage their accounts and organizations, and stay informed about important updates and project status. These components work together to offer a seamless and intuitive user experience, adapting to different screen sizes and user roles. Key functionalities include switching between organizations, projects, and environments, displaying contextual notices and alerts, managing account settings, and providing breadcrumb navigation for easy orientation.\n\nHere's a list of high-level product features:\n\n*   **Account Management:** Allows users to manage their profile, settings, and billing information.\n*   **Organization Management:** Enables users to switch between and create new organizations.\n*   **Project Management:** Facilitates switching between projects, creating new projects, and accessing project settings.\n*   **Environment Management:** Supports switching between different environments (teams) within an organization.\n*   **Contextual Notifications:** Displays relevant notices and alerts based on project status, user actions, and system health.\n*   **Dynamic Navigation:** Provides breadcrumbs and other navigation aids that adapt to the user's current location and context.\n*   **UI Customization:** Allows users to customize the appearance of the application through theme switching.\n*   **Feature Discovery:** Highlights new features and product updates.\n*   **Responsive Design:** Adapts the layout to different screen sizes for optimal viewing on various devices.\n*   **Permission Management:** Controls access to features and functionalities based on user roles and permissions.\n*   **Analytics Integration:** Tracks user interactions with notices and other navigation elements to measure effectiveness.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/sidePanelSettingsLogic.tsx",
        "summary": "This code defines the logic for managing the settings panel within a side panel navigation component. It uses Kea to manage state, connect to feature flags, and interact with the overall side panel state. The logic handles opening the settings panel, setting settings, and persisting the settings state. It also connects to the feature flag logic to potentially gate settings based on feature flags.\n\n**Features:**\n\n*   **Settings Panel Management:** Opens and manages the settings panel within the side navigation.\n*   **State Management:** Uses Kea for state management of settings.\n*   **Persistence:** Persists settings state.\n*   **Feature Flag Integration:** Connects to feature flags to control settings visibility.\n*   **Side Panel Integration:** Integrates with the side panel state logic to open the settings panel as a tab.\n"
    },
    {
        "path": "frontend/src/layout/Error404.tsx",
        "summary": "The `Error404.tsx` component in the frontend application renders a \"Not Found\" page when a user attempts to access a route that doesn't exist. It utilizes a shared `NotFound` component, passing in the object type as \"page\" and a descriptive caption to inform the user that the requested page could not be found and suggests using the navigation to try again.\n\nHere's a list of high-level product features:\n\n*   **404 Error Handling:** Displays a user-friendly \"Not Found\" page when a user navigates to a non-existent route.\n*   **Informative Error Message:** Provides a clear and helpful message explaining why the page is not found and suggesting a solution (using navigation).\n*   **Consistent UI:** Leverages a shared `NotFound` component to maintain a consistent look and feel across the application for error pages.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/SidePanelFeaturePreviews.tsx",
        "summary": "This React component, `SidePanelFeaturePreviews`, renders a side panel within the PostHog application that displays feature previews. It utilizes the `FeaturePreviews` component to show a list of available features and their status. The component also includes a header for the panel and uses `sidePanelStateLogic` to manage the selected tab options, allowing a specific feature flag to be focused.\n\n**Features:**\n\n*   **Displays a list of feature previews:** Shows available features and their current status (enabled/disabled).\n*   **Side panel integration:** Renders within a side panel for easy access and management.\n*   **Focus feature flag:** Allows focusing on a specific feature flag for detailed information.\n*   **Header:** Includes a header for the side panel to clearly indicate its purpose.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/activity/SidePanelActivitySubscriptions.tsx",
        "summary": "This React component, `SidePanelActivitySubscriptions`, renders a section within a side panel dedicated to managing activity subscriptions. It displays a descriptive message and utilizes the `LinkedHogFunctions` component to handle the underlying logic for subscribing to activity log events. Specifically, it configures `LinkedHogFunctions` to manage subscriptions to `$activity_log_entry_created` events, treating them as internal destinations and using the \"activity-log\" sub-template.\n\nHere's a list of high-level product features:\n\n*   **Activity Subscription Management:** Allows users to subscribe to receive notifications about team activity.\n*   **Activity Log Integration:** Connects to an activity log to track and manage events.\n*   **Event Filtering:** Enables filtering of specific events (e.g., `$activity_log_entry_created`) for subscription.\n*   **Internal Destination Handling:** Treats activity subscriptions as internal destinations for notifications.\n"
    },
    {
        "path": "frontend/src/layout/ErrorProjectUnavailable.tsx",
        "summary": "The `ErrorProjectUnavailable` component in the PostHog frontend handles scenarios where a user lacks access to any projects within an organization. It displays different messages and options based on whether the user belongs to an organization, has access to any projects within that organization, or if their access has been explicitly removed. The component suggests actions like creating a new project (if allowed), switching to an accessible project, or contacting an administrator. If the user isn't part of an organization, it prompts them to create one.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Project Access Management:** Handles scenarios where a user doesn't have access to a project.\n*   **Organization Creation Prompt:** Guides users to create an organization if they don't belong to one.\n*   **Actionable Suggestions:** Provides users with options to resolve the \"no project access\" issue, such as creating a project, switching projects, or contacting an administrator.\n*   **Dynamic Messaging:** Displays different messages based on the user's organization and project access status.\n*   **Link to Project Creation:** Provides a direct link to create a new project if the user has permission.\n"
    },
    {
        "path": "frontend/src/layout/GlobalModals.tsx",
        "summary": "This code defines a React component called `GlobalModals` that renders a series of modals used throughout the application. It leverages the `kea` library for state management, specifically for controlling the visibility of modals related to creating organizations, projects, and environments. The component also includes modals for user invites, upgrades, authentication, session recording playback, custom CSS preview, two-factor authentication setup, a \"Hedgehog Buddy\" component, and payment entry. The visibility of the invite modal is managed by the `inviteLogic` also using `kea`.\n\nHere's a list of high-level product features implemented by these modals:\n\n*   **Organization Creation:** Allows users to create new organizations.\n*   **Project Creation:** Enables users to create new projects within an organization.\n*   **Environment Creation:** Facilitates the creation of new environments within a project.\n*   **User Invitation:** Allows inviting new users to the organization.\n*   **Account Upgrades:** Promotes and manages account upgrades.\n*   **Authentication:** Handles time-sensitive authentication processes.\n*   **Session Recording Playback:** Provides a modal for playing back recorded user sessions.\n*   **Custom CSS Preview:** Allows previewing custom CSS themes.\n*   **Two-Factor Authentication Setup:** Guides users through setting up two-factor authentication.\n*   **User Assistance (Hedgehog Buddy):** Offers in-app assistance and guidance.\n*   **Payment Management:** Enables users to enter and manage payment information."
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/activity/SidePanelActivityMetalytics.tsx",
        "summary": "This component, `SidePanelActivityMetalytics`, displays internal analytics about how organization members are using PostHog, specifically focusing on views of dashboards, insights, playlists, and other apps. It shows the total number of views, the number of unique viewers, and a list of recent viewers (up to 30) for a selected scope (e.g., a specific dashboard or app). The component uses tooltips to provide context for each metric and displays loading spinners while data is being fetched. If no instance ID is available, it displays a message prompting the user to open an app to see the viewership data.\n\nHere's a list of high-level product features:\n\n*   **View Count:** Displays the total number of times an app or scope has been viewed.\n*   **Unique Viewers:** Shows the number of unique organization members who have viewed the app or scope.\n*   **Recent Viewers:** Lists the most recent users who have viewed the app or scope (limited to the last 30 days).\n*   **Contextual Tooltips:** Provides explanations for each metric displayed.\n*   **Loading Indicators:** Displays spinners while data is being fetched.\n*   **Scope Selection:** Allows users to view analytics for different scopes (e.g., dashboards, insights, playlists, or the entire app).\n*   **Informative Empty State:** Displays a message when no instance ID is available, guiding the user on how to access the data.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/SidePanelSupport.tsx",
        "summary": "This code defines the `SidePanelSupport` component, which provides a help and support interface within the PostHog application. It offers several avenues for users to find assistance, including searching documentation, exploring product-specific documentation links, viewing system status, and contacting support via an email form. The component also integrates with AI-powered support through \"Max the Hedgehog\" (if enabled via feature flags), and displays support response time information based on the user's billing plan.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Documentation Search:** Allows users to search PostHog documentation directly from the side panel.\n*   **Product Documentation Links:** Provides quick access to documentation for various PostHog products (e.g., Product Analytics, Feature Flags).\n*   **System Status Display:** Shows the current operational status of PostHog, including any outages or issues.\n*   **AI-Powered Support (Max the Hedgehog):** Integrates with an AI assistant to answer support questions and provide guidance.\n*   **Email Support Form:** Enables users to submit support requests directly to the PostHog team.\n*   **Support Response Time Information:** Displays average support response times based on the user's current billing plan.\n*   **Holiday Support Message Override:** Displays a custom support message during holiday periods.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/sidePanelContextLogic.ts",
        "summary": "This code defines a Kea logic module called `sidePanelContextLogic` that manages the context for side panels in the application. It connects to the `sceneLogic` to access the current scene configuration and uses it to determine the appropriate context for the side panel. The logic calculates the `sceneSidePanelContext` based on the current scene's configuration, potential activity scope (derived from the URL), and any context provided by the active scene logic. It also handles extracting `activity_scope` and `activity_item_id` from the URL based on the scene configuration.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Contextual Side Panels:** Dynamically display relevant information and actions in side panels based on the current scene or page the user is viewing.\n*   **Activity-Scoped Filtering:** Filter activities displayed in the side panel based on the current item or entity being viewed (e.g., filtering events related to a specific user or project).\n*   **URL-Driven Context:** Automatically derive context for the side panel from the URL, allowing for deep linking and consistent behavior across different parts of the application.\n*   **Extensible Context:** Allow individual scenes to provide their own context for the side panel, enabling customization and flexibility.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/activity/SidePanelActivity.tsx",
        "summary": "The `SidePanelActivity` component provides a user interface for viewing team activity and notifications within a PostHog application. It features tabbed navigation to switch between unread notifications, all activity, metalytics (if enabled), and subscriptions (if enabled). The component fetches and displays activity logs, allows filtering of activity by scope and user, and supports marking notifications as read. It also handles loading older activity as the user scrolls and integrates with a paygate to restrict access based on feature availability.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Activity Feed:** Displays a chronological list of team activity logs.\n*   **Notifications:** Shows a list of unread notifications for the user.\n*   **Tabbed Navigation:** Allows users to switch between different activity views (notifications, all activity, metalytics, subscriptions).\n*   **Activity Filtering:** Enables filtering activity logs by scope (e.g., project, event) and user.\n*   **Mark as Read:** Provides functionality to mark all notifications as read.\n*   **Infinite Scroll:** Loads older activity logs as the user scrolls down.\n*   **Feature Gating:** Restricts access to certain tabs (Metalytics, Subscriptions) based on feature flags.\n*   **Paywall Integration:** Integrates with a paygate to restrict access to the activity log feature based on the user's subscription.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/sidePanelMaxChatInterface.tsx",
        "summary": "This code defines the MaxChatInterfaceContent component, which provides a chat interface within a side panel. It allows users to interact with an AI assistant (\"Max\") by sending messages and receiving responses. The component handles message submission, displays chat history, and provides visual cues for loading states and potential errors. It also includes features to display and analyze the AI's thought process, search reflections, and quality scores behind its responses, offering insights into how the AI arrived at its conclusions.\n\nHere's a list of high-level product features:\n\n*   **AI Chat Interface:** Enables users to communicate with an AI assistant (Max) through a chat-like interface.\n*   **Message Submission:** Allows users to send text-based messages to the AI.\n*   **Chat History Display:** Presents a chronological view of user and AI messages.\n*   **Loading State Indicators:** Shows visual cues (e.g., spinners) when the AI is processing or searching for information.\n*   **Error Handling:** Displays messages when the AI encounters rate limits or server errors.\n*   **AI Thought Process Analysis:** Provides insights into the AI's reasoning by displaying \"thinking\" blocks, search reflections, and quality scores.\n*   **Markdown Support:** Renders AI responses with Markdown formatting for improved readability.\n*   **Greeting Message:** Displays an initial greeting message from the AI upon entering the chat.\n*   **Tips and Guidelines:** Provides users with helpful tips and guidelines for interacting with the AI.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/activity/sidePanelActivityLogic.tsx",
        "summary": "This code defines the logic for the activity side panel in a PostHog application. It manages the display of activity logs, including unread notifications, all activity, and potentially metalytics or subscription-related activities. The logic handles fetching activity data from the API, marking notifications as read, polling for new changes, and filtering activities based on scope, item ID, or user. It also incorporates a feature flag for displaying changelog notifications within the activity feed.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Activity Feed:** Displays a chronological list of user and system activities within PostHog.\n*   **Unread Notifications:** Highlights new and unread activities to keep users informed.\n*   **Activity Filtering:** Allows users to filter activities based on scope (e.g., specific feature, project), item ID, or user.\n*   **Real-time Updates:** Polls the server for new activity and displays them automatically.\n*   **Mark All as Read:** Provides a way to quickly clear all unread notifications.\n*   **Changelog Notifications:** Injects important product updates and changelog information directly into the activity feed.\n*   **Tabbed Views:** Organizes activity into different categories (Unread, All, etc.) for easier browsing.\n*   **Pagination:** Loads older activities as the user scrolls down the list.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/SidePanel.tsx",
        "summary": "The `SidePanel` component in `SidePanel.tsx` provides a customizable sidebar for PostHog, offering various tools and information panels. It allows users to select from a range of tabs, each displaying specific content like user settings, feature previews, activity logs, documentation, support resources, and more. The component supports resizing, modal display, and dynamic tab visibility, enhancing the user experience by providing quick access to essential features and information within the PostHog platform.\n\nHere's a list of high-level product features implemented by the `SidePanel` component:\n\n*   **Customizable Sidebar:** Allows users to access various tools and information panels.\n*   **Dynamic Tab Visibility:** Enables showing or hiding tabs based on context or user roles.\n*   **Resizable Panel:** Users can adjust the width of the sidebar to their preference.\n*   **Modal Display:** Supports displaying panel content in a modal window.\n*   **Themed Styling:** Adapts to the current theme of the application.\n*   **Tabbed Navigation:** Provides easy access to different functionalities through tabs.\n*   **Context Provider:** Wraps panel content with a context provider for side panel specific state.\n*   **Various Information Panels:** Includes panels for user settings, feature previews, activity logs, documentation, support, system status, access control, and more.\n*   **External Tab Integration:** Allows opening additional tabs in the side panel via a menu.\n*   **Notebook Integration:** Provides a dedicated panel for notebooks.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/sidePanelLogic.tsx",
        "summary": "This code defines the logic for the side panel navigation in the PostHog frontend. It manages which tabs are enabled, visible, and considered \"extra\" based on feature flags, user permissions, preflight status, team creation date, and the current context. The logic connects to various other kea logics to access feature flags, user information, team details, and the state of other side panel components like activity and status. It also handles opening and closing the side panel and determining whether certain tabs, like Activity or Status, should be highlighted based on unread counts or non-operational status.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dynamic Side Panel Navigation:** The side panel tabs adapt based on feature flags, user permissions, and the current context within the application.\n*   **Activity Notifications:** Highlights the Activity tab when there are unread activity items, drawing user attention to important events.\n*   **System Status Indicators:** Highlights the Status tab when the system is not fully operational, providing users with immediate awareness of potential issues.\n*   **Contextual Access Control:** Displays an Access Control tab when the user is viewing a resource that supports role-based access control.\n*   **Team Activation Guidance:** Shows an Activation tab to guide new teams through the initial setup process.\n*   **Feature Previews:** Provides a dedicated tab for users to explore and enable experimental features.\n*   **Support Access:** Provides a dedicated tab for users to access support resources.\n*   **Notebooks Access:** Provides a dedicated tab for users to access notebooks.\n*   **Docs Access:** Provides a dedicated tab for users to access documentation.\n*   **Settings Access:** Provides a dedicated tab for users to access settings.\n*   **Exports Access:** Provides a dedicated tab for users to access exports.\n*   **Discussions Access:** Provides a dedicated tab for users to access discussions.\n*   **Artificial Hog Access:** Provides a dedicated tab for users to access Artificial Hog.\n*   **Max Access:** Provides a dedicated tab for users to access Max."
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/activity",
        "summary": "The activity side panel provides a comprehensive view of user and system activities within PostHog, offering features for monitoring team engagement, tracking product updates, and managing notifications. Users can view a chronological activity feed, filter activities by scope and user, and mark notifications as read. The panel also includes metalytics to track views of dashboards and apps, and subscription management for receiving notifications about specific activity log events.\n\n*   **Activity Feed:** Displays a chronological list of user and system activities.\n*   **Notifications:** Highlights unread activities and allows marking them as read.\n*   **Activity Filtering:** Enables filtering activities by scope, item ID, or user.\n*   **Real-time Updates:** Polls for new activity and displays them automatically.\n*   **Changelog Notifications:** Injects product updates into the activity feed.\n*   **Metalytics:** Tracks views of dashboards, insights, and apps, showing total views, unique viewers, and recent viewers.\n*   **Activity Subscription Management:** Allows users to subscribe to receive notifications about specific activity log events.\n*   **Tabbed Navigation:** Organizes activity into different categories (Unread, All, Metalytics, Subscriptions).\n*   **Infinite Scroll:** Loads older activities as the user scrolls down.\n*   **Feature Gating/Paywall Integration:** Restricts access to certain features based on feature flags and subscription status.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/SidePanelSettings.tsx",
        "summary": "This code defines a `SidePanelSettings` component for a React application, likely within a larger platform like PostHog. It renders a settings panel within a side panel, allowing users to view and modify settings related to a specific level or section. The component leverages Kea logic for state management and actions, and it integrates with a `Settings` component (likely from another part of the application) to display the actual settings form. It also provides a button to navigate to the full settings page.\n\n**Features:**\n\n*   **Side Panel Integration:** Displays settings within a side panel, providing a contextual settings experience.\n*   **Settings Display:** Renders settings using a dedicated `Settings` component, allowing for a consistent settings UI.\n*   **Section and Level Filtering:** Allows settings to be filtered and displayed based on a selected section or level.\n*   **Navigation to Full Settings:** Provides a button to navigate to the full settings page for more comprehensive configuration.\n*   **State Management:** Uses Kea logic for managing the state of the settings panel, including selected section and level.\n*   **Dynamic Header:** Displays the current settings level in the side panel header.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/activation/SidePanelActivation.tsx",
        "summary": "This code defines the \"Quick Start\" guide within the PostHog application's side panel, designed to help users learn about PostHog's features and capabilities. It displays a progress bar indicating overall completion, followed by a series of expandable sections representing different product areas. Each section contains a list of tasks that users can complete, with visual cues indicating completion status, locked tasks, and the ability to skip certain tasks. The component also handles the display of hidden sections, allowing users to toggle their visibility.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Interactive Quick Start Guide:** Provides a guided onboarding experience for new users.\n*   **Progress Tracking:** Visually displays the user's progress through the guide.\n*   **Expandable Sections:** Organizes tasks into logical sections for better navigation.\n*   **Task Management:** Allows users to complete, skip, and view the status of individual tasks.\n*   **Task Locking:** Indicates tasks that are currently unavailable due to dependencies or other reasons.\n*   **Hidden Section Toggle:** Enables users to view and add additional product sections.\n*   **External Link Navigation:** Allows tasks to link to external resources or specific parts of the application.\n*   **Event Tracking:** Tracks user interactions with the Quick Start guide for analytics purposes."
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/activation/activationLogic.tsx",
        "summary": "This code defines the logic for an activation sidebar in PostHog, guiding users through key product features and onboarding tasks. It manages the state of tasks (completed, skipped, locked), sections (open, visible), and user progress. The logic connects to various PostHog features, including product analytics, session replay, feature flags, and data warehouse, and provides actions to navigate to relevant settings and pages. It also tracks user interactions with the sidebar and updates the team's onboarding status.\n\nHere's a list of high-level product features:\n\n*   **Task Management:** Allows users to view, run, mark as completed, and skip activation tasks.\n*   **Section Management:** Enables users to toggle the visibility and open/close state of different sections in the activation sidebar.\n*   **Progress Tracking:** Calculates and displays the user's completion percentage of visible activation tasks.\n*   **Product Intent Tracking:** Records the user's intent to use specific PostHog products.\n*   **Navigation:** Provides actions to navigate to different parts of the PostHog application based on the selected task.\n*   **Onboarding Guidance:** Guides new users through essential setup steps and product features.\n*   **Custom Event Tracking:** Tracks the number of custom events and marks the corresponding task as completed.\n*   **Reverse Proxy Detection:** Checks for the presence of a reverse proxy.\n*   **Persistence:** Persists the state of open sections across sessions."
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/activation",
        "summary": "The provided code implements an interactive \"Quick Start\" guide within the PostHog application, designed to onboard new users and guide them through key product features. This guide is presented as a side panel with expandable sections, each containing a list of tasks that users can complete, skip, or view the status of. The system tracks user progress, manages task dependencies, and allows users to toggle the visibility of hidden sections, providing a personalized and efficient onboarding experience.\n\nHere's a list of high-level product features:\n\n*   Interactive Quick Start Guide\n*   Progress Tracking\n*   Expandable Sections\n*   Task Management (Complete, Skip, View Status, Lock)\n*   Hidden Section Toggle\n*   External Link Navigation\n*   Event Tracking\n*   Product Intent Tracking\n*   Navigation to relevant settings and pages\n*   Onboarding Guidance\n*   Custom Event Tracking\n*   Reverse Proxy Detection\n*   Persistence of open sections\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/exports/sidePanelExportsLogic.ts",
        "summary": "This code defines a Kea logic module called `sidePanelExportsLogic` responsible for managing the display of exports within a side panel. It connects to the `exportsLogic` to access export data and the `sidePanelStateLogic` to control the side panel's state. Upon mounting, it loads the exports. The logic module makes available exports and fresh undownloaded exports. It also makes available actions to open the side panel, load exports, and remove fresh exports.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Displaying a list of exports:** Shows the user a list of available exports.\n*   **Indicating fresh, undownloaded exports:** Highlights new exports that haven't been downloaded yet.\n*   **Loading exports on demand:** Fetches the export data when the side panel is opened or the component is mounted.\n*   **Opening the side panel:** Allows the user to open the side panel to view exports.\n*   **Removing fresh export indicators:** Allows the user to remove the \"fresh\" indicator after downloading an export.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/sidePanelStatusLogic.tsx",
        "summary": "This code defines the `sidePanelStatusLogic` using Kea, a state management library. It fetches and manages the status of PostHog components from a status page, displaying an indicator in the side panel if any relevant components are experiencing degraded performance or outages. The logic periodically refreshes the status and persists the status to avoid flashes on page load. It filters components based on a hostname-specific group mapping.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Status Page Integration:** Fetches status information from an external status page (status.posthog.com).\n*   **Component Status Monitoring:** Tracks the operational status of individual PostHog components.\n*   **Side Panel Indicator:** Displays a status indicator in the side panel to alert users of potential issues.\n*   **Hostname-Based Filtering:** Filters status information based on the hostname to show relevant components for the current environment (e.g., US, EU, localhost).\n*   **Automatic Refresh:** Periodically refreshes the status information to ensure it's up-to-date.\n*   **Persistence:** Persists the status to avoid visual flickering when the page loads.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/exports/SidePanelExports.tsx",
        "summary": "This code defines a React component, `SidePanelExports`, which is a panel within a side navigation that allows users to view and download their exported data assets. It fetches a list of exports, displays them with relevant information like filename, creation date, expiration date, and download status, and provides functionality to refresh the list and download the assets. The component also indicates the number of fresh, undownloaded exports with a badge on the side panel icon.\n\nHere's a list of high-level product features:\n\n*   **Display Exported Assets:** Shows a list of available exports with details like filename, creation date, and expiration date.\n*   **Download Functionality:** Allows users to download exported assets.\n*   **Download Status Indication:** Indicates whether an export has been downloaded or not.\n*   **Asynchronous Export Handling:** Handles exports that are generated asynchronously, showing a loading spinner while the export is being prepared.\n*   **Refresh Exports List:** Provides a button to refresh the list of available exports.\n*   **Notification of New Exports:** Displays a badge indicating the number of new, undownloaded exports.\n*   **Expiry Information:** Shows when an export will expire.\n*   **Disabled State with Reason:** Disables the download button and shows a reason if the export is not ready."
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/exports",
        "summary": "The provided code implements a side panel feature for managing and downloading exported data assets. It displays a list of available exports with details such as filename, creation date, and expiration date, and allows users to download these assets. The system also indicates the download status of each export, handles asynchronous export generation, and provides a mechanism to refresh the list of exports. A badge notifies users of new, undownloaded exports, and the download button can be disabled with a reason if an export is not ready. The Kea logic module manages the display of exports, connects to export data, controls the side panel's state, and provides actions to open the side panel, load exports, and remove fresh export indicators.\n\n**Features:**\n\n*   Display Exported Assets with Details\n*   Download Functionality\n*   Download Status Indication\n*   Asynchronous Export Handling\n*   Refresh Exports List\n*   Notification of New Exports\n*   Expiry Information\n*   Disabled State with Reason\n*   Loading Exports on Demand\n*   Removing Fresh Export Indicators\n*   Open Side Panel\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/access_control/AccessControlPopoutCTA.tsx",
        "summary": "This React component, `AccessControlPopoutCTA`, is a call-to-action displayed to users to encourage them to use the new access control system. It features a banner explaining that permissions are moving to the new system and a button that, when clicked, opens the access control side panel and triggers a callback function. The component tracks user interaction with the CTA using PostHog.\n\nHere's a list of high-level product features:\n\n*   **Access Control Promotion:** Displays a banner and button to promote the new access control system.\n*   **Side Panel Integration:** Opens the access control side panel when the button is clicked.\n*   **Event Tracking:** Tracks user clicks on the CTA using PostHog for analytics.\n*   **Resource Type Awareness:** Displays information specific to the resource type being controlled.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/SidePanelStatus.tsx",
        "summary": "This code defines a React component, `SidePanelStatus`, that displays the current status of PostHog's systems within a side panel. It fetches status information using `sidePanelStatusLogic` and presents it with an icon indicating the overall status (operational, degraded, outage). The component also includes a button to open the full status page in a new tab. A skeleton loader is displayed while the status page iframe is loading.\n\n**Features:**\n\n*   **System Status Indicator:** Displays an icon with a badge reflecting the current system status (operational, degraded, outage).\n*   **Tooltip Status Description:** Shows a tooltip with a more detailed description of the system status.\n*   **External Status Page Link:** Provides a button to open the full PostHog status page in a new tab.\n*   **Loading State:** Displays a skeleton loader while the status page iframe is loading.\n*   **Real-time Status Updates:** Fetches and displays real-time status updates from PostHog's status page.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/SidePanelDocs.tsx",
        "summary": "This code defines a `SidePanelDocs` component for a PostHog application, which embeds documentation within a side panel using an iframe. It allows users to navigate the documentation, toggle the theme, and open the current documentation page in a new tab. The component uses `kea` for state management and provides a skeleton loading state while the iframe content is loading. It also handles theme synchronization between the parent application and the iframe content.\n\n**Features:**\n\n*   **Embedded Documentation:** Displays PostHog documentation within a side panel.\n*   **Navigation:** Allows users to navigate the documentation using a select dropdown.\n*   **Home Button:** Provides a button to navigate to the main documentation page.\n*   **Theme Synchronization:** Synchronizes the theme (light/dark mode) between the PostHog application and the embedded documentation.\n*   **Open in New Tab:** Enables users to open the current documentation page in a new browser tab.\n*   **Loading State:** Displays a skeleton loading state while the documentation is loading in the iframe.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/access_control/SidePanelAccessControl.tsx",
        "summary": "The `SidePanelAccessControl` component provides a user interface for managing access control for specific resources within a scene. It leverages the `sidePanelContextLogic` to retrieve the resource type and ID for which access control needs to be managed. If a resource and ID are available, it renders the `AccessControlObject` component, passing the resource information to it. Otherwise, it displays a \"Not supported\" message. The component is structured with a header and a scrollable content area for displaying the access control interface.\n\n**Features:**\n\n*   **Access Control Management:** Provides a UI for managing access control settings.\n*   **Resource-Specific Access Control:** Allows managing access control for specific resources identified by type and ID.\n*   **Dynamic Content Rendering:** Conditionally renders the access control interface based on the availability of resource information.\n*   **\"Not Supported\" Message:** Displays a message when access control management is not supported for the current context.\n*   **Integration with Side Panel Context:** Uses `sidePanelContextLogic` to access the current resource context.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/sidePanelMaxAILogic.ts",
        "summary": "This code defines the logic for a side panel Max AI assistant feature using Kea, a state management library. It handles sending user messages to the Max AI API, displaying responses, managing rate limits, and handling server errors. The logic includes actions for submitting messages, clearing chat history, appending assistant messages, setting loading states, and managing rate limiting and server error states. It also includes reducers to manage the chat message history, loading state, rate limit status, and server error status. The code uses loaders to handle the asynchronous API call to send messages and listeners to retry messages after a rate limit period.\n\nHere's a list of high-level product features based on the code:\n\n*   **Chat Interface:** Allows users to interact with an AI assistant through a chat-like interface.\n*   **Message Submission:** Enables users to submit text messages to the AI assistant.\n*   **AI Assistant Responses:** Displays responses from the AI assistant in the chat interface.\n*   **Loading State:** Indicates when the AI assistant is processing a request.\n*   **Rate Limit Handling:** Manages rate limits imposed by the AI assistant API, including displaying messages to the user and retrying messages after a delay.\n*   **Error Handling:** Handles server errors and displays appropriate messages to the user.\n*   **Chat History:** Maintains a history of chat messages.\n*   **Clear Chat History:** Allows users to clear the chat history.\n*   **Automatic Retries:** Automatically retries sending messages after encountering a rate limit.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/access_control/accessControlLogic.ts",
        "summary": "This code defines the logic for managing access control settings for various resources within PostHog, such as projects. It fetches and updates access levels for users and roles, providing granular control over resource permissions. The logic handles loading existing access controls, updating default access levels, and managing access for specific members and roles. It also integrates with PostHog's feature flagging and user tracking to capture access control changes.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Role-Based Access Control (RBAC):** Allows assigning access levels to roles, enabling efficient management of permissions for groups of users.\n*   **Member-Specific Access Control:** Enables setting access levels for individual users, providing fine-grained control over resource access.\n*   **Default Access Level Configuration:** Allows setting a default access level for a resource, simplifying initial permission setup.\n*   **Access Level Management UI:** Provides a user interface for viewing and modifying access control settings for different resources.\n*   **Audit Logging:** Tracks changes to access control settings, providing a history of permission modifications.\n*   **Integration with User and Role Management:** Seamlessly integrates with PostHog's user and role management systems.\n*   **Resource-Specific Access Control:** Supports access control for various resource types within PostHog, such as projects.\n*   **Upgrade Modal Integration:** Integrates with the upgrade modal to guard features based on the current plan.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/access_control/RolesAndResourceAccessControls.tsx",
        "summary": "This code defines the Roles and Resource Access Controls panel within the PostHog application. It allows administrators to manage roles, assign permissions to those roles based on resources, and manage role memberships. The panel displays a table of roles with their members and associated resource access levels, and provides functionality to add new roles, edit existing roles, and manage role memberships. It also integrates with a paywall to restrict access to the role-based access control feature based on the user's subscription.\n\nHere's a list of high-level product features:\n\n*   **Role Management:** Create, edit, and delete roles within the organization.\n*   **Resource Access Control:** Define access levels for each role based on specific resources (e.g., projects, dashboards).\n*   **Role Membership Management:** Add and remove users from roles.\n*   **User Interface:** Display roles in a table with expandable rows for detailed information and membership management.\n*   **Paywall Integration:** Restrict access to the feature based on the user's subscription level.\n*   **Member Search and Addition:** Search for and add members to a role using a select component.\n*   **Role Editing Modal:** A modal for creating and editing roles, including setting the role name.\n*   **Role Deletion:** Ability to delete roles with a confirmation dialog.\n*   **Access Level Overrides:** Ability to override default access levels for specific roles and resources.\n*   **\"You\" Indicator:** Clearly indicates the current user in the member list."
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/access_control/roleBasedAccessControlLogic.ts",
        "summary": "This code defines the logic for managing role-based access control (RBAC) within a PostHog project. It handles loading, updating, creating, and deleting roles, as well as managing the access levels associated with each role for different resources (e.g., feature flags, dashboards, insights, notebooks). The logic also manages the assignment of users to roles and provides selectors for deriving relevant data for the UI, such as available access levels, default access levels, and a combined structure of roles and their associated resource access controls. It uses kea for state management, API calls for data persistence, and integrates with other parts of the application like member management and feature availability checks.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Role Management:** Create, update, and delete roles within a PostHog project.\n*   **Access Control Configuration:** Define and modify access levels for different resources (feature flags, dashboards, etc.) on a per-role basis.\n*   **User Role Assignment:** Assign users to specific roles, granting them the corresponding access privileges.\n*   **Default Access Levels:** Configure default access levels for resources when no specific role is assigned.\n*   **UI Integration:** Provides data and actions to support a user interface for managing roles and access controls.\n*   **Feature Flag Dependency:** Enables RBAC functionality based on the availability of the `ROLE_BASED_ACCESS` feature flag.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/access_control/AccessControlObject.tsx",
        "summary": "This code defines the `AccessControlObject` component, which is responsible for managing access control settings for a specific resource within PostHog. It allows administrators to configure default access levels, manage individual user permissions, and manage role-based permissions, all within a Lemon UI framework. The component leverages Kea logic for state management and asynchronous actions, and integrates with PostHog's feature flagging system to control access to advanced permission features. It provides a user interface for adding and removing users and roles, and for setting their respective access levels.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Default Access Control:** Allows setting a default access level for a resource.\n*   **User-Based Access Control:** Enables administrators to grant or revoke access to specific users for a resource.\n*   **Role-Based Access Control:** Enables administrators to grant or revoke access to specific roles for a resource.\n*   **Access Level Management:** Provides a UI for selecting and assigning access levels to users and roles.\n*   **Permission Checks:** Enforces permission checks to ensure only authorized users can modify access control settings.\n*   **User Interface:** Provides a Lemon UI based interface for managing access controls.\n*   **Feature Flag Integration:** Integrates with PostHog's feature flagging system to control access to advanced permission features.\n*   **Search and Add Users/Roles:** Provides a modal for searching and adding users or roles to the access control list.\n*   **Display Current Access:** Displays a table of current users and roles with their assigned access levels.\n*   **Remove Access:** Allows removing access for specific users or roles."
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/access_control",
        "summary": "The provided code collectively implements a comprehensive access control system within PostHog, enabling administrators to manage permissions for various resources at different levels of granularity. This system incorporates role-based access control, individual user permissions, and default access settings, all managed through a user-friendly interface. The system also integrates with PostHog's feature flagging and user tracking to control access to advanced features and monitor user interactions with the access control system.\n\nHere's a list of high-level product features:\n\n*   **Role Management:** Create, edit, and delete roles, and manage role memberships.\n*   **Resource-Specific Access Control:** Define access levels for roles and individual users based on specific resources (e.g., projects, dashboards, feature flags).\n*   **User-Based Access Control:** Grant or revoke access to specific users for a resource.\n*   **Role-Based Access Control:** Grant or revoke access to specific roles for a resource.\n*   **Default Access Control:** Set a default access level for a resource.\n*   **Access Level Management:** Select and assign access levels to users and roles.\n*   **User Interface:** Lemon UI based interface for managing access controls.\n*   **Feature Flag Integration:** Control access to advanced permission features.\n*   **Access Control Promotion:** Promote the new access control system.\n*   **Event Tracking:** Track user interactions with the access control system.\n*   **Audit Logging:** Track changes to access control settings.\n*   **Paywall Integration:** Restrict access to the feature based on the user's subscription level.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/discussion/sidePanelDiscussionLogic.ts",
        "summary": "This code defines the `sidePanelDiscussionLogic` using Kea, a state management library. It manages the comment count for discussions within a side panel, specifically when the discussions feature flag is enabled. The logic fetches the comment count from the API based on the current context (activity scope and item ID) and resets the count when the context changes or the feature flag is disabled. It also connects to the `featureFlagLogic` to check if the discussions feature flag is enabled and to `sidePanelContextLogic` to get the current context.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Display Comment Count:** Shows the number of comments associated with a specific item in the side panel.\n*   **Context-Aware Discussions:** Loads comments relevant to the currently viewed item or activity within the application.\n*   **Feature Flag Controlled Discussions:** Enables or disables the discussion feature based on a feature flag.\n*   **Real-time Comment Count Updates:** Automatically updates the comment count when the context changes.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/sidePanelMaxAPI.ts",
        "summary": "This code defines an API client for interacting with a \"Max\" chat service. It provides a single function, `sendMessage`, which sends a user message to the Max service, including a session ID (stored in `sessionStorage` to maintain conversation context). The function handles creating a new session ID if one doesn't exist. It then makes a POST request to the `/max/chat/` endpoint with the message, role, and session ID. Upon success, it returns the content of the response and rate limit information.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Chat Interface:** Enables users to send messages to a \"Max\" service.\n*   **Session Management:** Maintains conversation history using session IDs stored in `sessionStorage`.\n*   **API Integration:** Communicates with a backend API endpoint (`/max/chat/`) to process messages.\n*   **Rate Limit Handling:** Provides rate limit information to the user, allowing them to manage their usage of the service.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/discussion/SidePanelDiscussion.tsx",
        "summary": "This code implements a discussion panel within a side panel, likely in a larger application like PostHog. The panel allows users to view and add comments related to specific items like Insights, Dashboards, or Notebooks. It features a header indicating the discussion scope, a list of comments, and a composer for adding new comments. The component uses Kea for state management and displays a warning message if discussions are not supported for the current context.\n\n**Features:**\n\n*   **Discussion Threading:** Enables users to have threaded discussions around specific items (Insights, Dashboards, etc.).\n*   **Commenting:** Allows users to add new comments to the discussion thread.\n*   **Contextual Scope:** Displays the scope of the discussion (e.g., \"about this Insight\").\n*   **Experimental Feature Tag:** Indicates that the discussion feature is experimental and subject to change.\n*   **Comment Count Icon:** Displays the number of comments in the discussion thread via an icon.\n*   **Reply Functionality:** Allows users to reply to specific comments within the thread.\n*   **Comments List:** Displays a list of comments associated with the discussion.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/discussion",
        "summary": "This code implements a discussion panel within a side panel of the application, allowing users to engage in threaded conversations around specific items like Insights, Dashboards, or Notebooks. The panel dynamically displays the number of comments, allows users to add new comments and reply to existing ones, and indicates the scope of the discussion. The feature is controlled by a feature flag and displays a warning message if discussions are not supported for the current context.\n\nHere's a list of high-level product features:\n\n*   Display Comment Count\n*   Context-Aware Discussions\n*   Feature Flag Controlled Discussions\n*   Real-time Comment Count Updates\n*   Discussion Threading\n*   Commenting\n*   Contextual Scope\n*   Reply Functionality\n*   Comments List\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/SidePanelMax.tsx",
        "summary": "This code defines a React component called `SidePanelMax` that renders an instance of the `MaxInstance` component from the `scenes/max/Max` module. The `sidePanel` prop is passed to the `MaxInstance` component, indicating that it should be rendered in a side panel context. This suggests the `MaxInstance` component is versatile and can be displayed in different layouts based on the `sidePanel` prop.\n\nHere's a list of high-level product features:\n\n*   **Side Panel Integration:** The application supports displaying the \"Max\" functionality within a side panel layout.\n*   **Reusable Max Instance:** The \"MaxInstance\" component is designed to be reusable and adaptable to different contexts (e.g., full page or side panel).\n*   **Max Functionality:** The application includes a feature or module called \"Max\" (details of which are not in this file).\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels/sidePanelDocsLogic.ts",
        "summary": "This code defines the logic for displaying PostHog documentation within a side panel of the application. It manages the state of the documentation iframe, including its path, readiness, and menu options. The logic handles communication between the parent application and the documentation iframe, enabling navigation, external link handling, and menu updates. It also persists the last viewed documentation path for a seamless user experience.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **In-app Documentation:** Display PostHog documentation directly within the application's side panel.\n*   **Navigation within Documentation:** Allow users to navigate the documentation without leaving the application.\n*   **External Link Handling:** Seamlessly handle links to external PostHog resources (e.g., blog posts, community pages).\n*   **Persistent Documentation State:** Remember the user's last viewed documentation page for future sessions.\n*   **Dynamic Menu Updates:** Display and update the documentation menu based on data received from the documentation iframe.\n*   **Deep Linking to Docs:** Open the side panel to a specific documentation page via a URL.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/panels",
        "summary": "The provided code implements a comprehensive suite of features within the PostHog application, primarily focused on enhancing user experience and providing contextual information and support through side panels. These side panels offer a variety of functionalities, including AI-powered assistance, access control management, activity tracking, documentation access, settings configuration, system status monitoring, feature preview management, and data export management. The system leverages Kea for state management, integrates with feature flags for controlled rollouts, and provides a consistent and user-friendly interface for accessing these features.\n\nHere's a list of high-level product features:\n\n*   **AI Assistant (Max):** Provides an AI-powered chat interface for answering questions, offering guidance, and analyzing AI thought processes.\n*   **Access Control Management:** Enables administrators to manage permissions for various resources through role-based and user-based access control.\n*   **Activity Tracking:** Displays a chronological feed of user and system activities, allowing users to monitor team engagement and track product updates.\n*   **In-App Documentation:** Embeds PostHog documentation within the application, providing easy access to help resources.\n*   **Settings Configuration:** Allows users to view and modify settings related to specific levels or sections of the application.\n*   **System Status Monitoring:** Displays the current operational status of PostHog components, alerting users to potential issues.\n*   **Feature Preview Management:** Shows a list of available features and their current status, allowing users to explore upcoming functionality.\n*   **Data Export Management:** Enables users to manage and download exported data assets.\n*   **Interactive Quick Start Guide:** Onboards new users and guides them through key product features with an interactive guide.\n*   **Contextual Side Panels:** Dynamically display relevant information and actions in side panels based on the current scene or page.\n*   **Discussion Panel:** Allows users to engage in threaded conversations around specific items like Insights, Dashboards, or Notebooks.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/types.ts",
        "summary": "This code defines the types and context related to a side panel in a React application. It introduces the `SidePanelSceneContext` type, which enables scenes to provide context to the side panel, allowing for richer features. This context includes information about access control resources, activity scope, and activity item IDs. A constant `SIDE_PANEL_CONTEXT_KEY` is also defined, likely used for accessing the context within the application.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Access Control Integration:** Allows the side panel to display information and actions related to access control resources.\n*   **Activity Logging:** Enables the side panel to show activity logs related to specific items or scopes.\n*   **Contextual Side Panel:** Provides a mechanism for different scenes to customize the side panel's content and functionality based on the current context.\n*   **Dynamic Content Loading:** Facilitates loading relevant information into the side panel based on the selected resource or activity.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/components/SidePanelPaneHeader.tsx",
        "summary": "This React component, `SidePanelPaneHeader`, renders the header for a side panel pane. It displays a title (if provided), any custom children elements, and a close button. The header's styling adapts based on whether the side panel is in \"modal mode,\" adjusting padding, margins, and font sizes accordingly. The close button, when clicked, triggers the `closeSidePanel` action from the `sidePanelStateLogic`, closing the side panel.\n\nHere's a list of high-level product features:\n\n*   **Side Panel Header Rendering:** Displays a header for side panel panes.\n*   **Title Display:** Shows a title for the pane, truncating it if it's too long.\n*   **Custom Content Support:** Allows adding custom elements within the header.\n*   **Close Button:** Provides a button to close the side panel.\n*   **Modal Mode Adaptation:** Adjusts styling based on whether the side panel is in modal mode.\n*   **Tooltip on Close Button:** Displays a tooltip on the close button, with text changing based on modal mode.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/components",
        "summary": "The `SidePanelPaneHeader` component is a versatile React component designed to provide a consistent and customizable header for side panel panes within the application. It dynamically renders a title, supports the inclusion of custom child elements for enhanced functionality, and features a close button to dismiss the side panel. The component intelligently adapts its styling based on the side panel's modal state, ensuring a visually appropriate presentation in different contexts.\n\nHere's a list of high-level product features:\n\n*   Side Panel Header Rendering\n*   Title Display\n*   Custom Content Support\n*   Close Button\n*   Modal Mode Adaptation\n*   Tooltip on Close Button\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel/sidePanelStateLogic.tsx",
        "summary": "This code defines the logic for managing the state of a side panel in a web application. It uses Kea, a state management library, to handle actions, reducers, listeners, and URL synchronization. The logic allows opening and closing the side panel, selecting a tab within the panel, setting options for the selected tab, and persisting the panel's open state and selected tab in local storage. It also integrates with PostHog for tracking when the sidebar is opened or closed. The side panel state is also reflected in the URL hash, allowing for deep linking and sharing of specific panel states.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Open/Close Side Panel:** Allows users to open and close a side panel for accessing additional features or information.\n*   **Tabbed Navigation:** Supports tabbed navigation within the side panel, allowing users to switch between different sections or functionalities.\n*   **State Persistence:** Remembers the user's preferred side panel state (open/closed) and selected tab across sessions.\n*   **URL Synchronization:** Reflects the side panel's state (selected tab and options) in the URL, enabling deep linking and sharing of specific panel configurations.\n*   **Dynamic Options:** Allows passing dynamic options to the selected tab, enabling customization and context-specific behavior.\n*   **Event Tracking:** Tracks side panel interactions (open/close) using PostHog for analytics and user behavior insights.\n*   **Responsive Design:** Adapts the side panel's behavior based on screen size (modal mode on smaller screens).\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidepanel",
        "summary": "The provided code collectively implements a dynamic and customizable side panel navigation system within the PostHog application. This system provides users with easy access to a variety of tools, information, and settings, enhancing their overall experience and productivity. The side panel's behavior and content are context-aware, adapting based on feature flags, user permissions, and the current application state. It also leverages state management and URL synchronization to ensure a consistent and shareable user experience.\n\nHere's a list of high-level product features:\n\n*   **Dynamic Side Panel Navigation:** Adapts based on feature flags, user permissions, and context.\n*   **Customizable Sidebar:** Allows users to access various tools and information panels.\n*   **Tabbed Navigation:** Provides easy access to different functionalities through tabs.\n*   **Contextual Information Panels:** Includes panels for user settings, feature previews, activity logs, documentation, support, system status, access control, and more.\n*   **AI Assistant (Max):** Provides an AI-powered chat interface.\n*   **Activity Notifications:** Highlights the Activity tab when there are unread activity items.\n*   **System Status Indicators:** Highlights the Status tab when the system is not fully operational.\n*   **State Persistence:** Remembers the user's preferred side panel state across sessions.\n*   **URL Synchronization:** Reflects the side panel's state in the URL, enabling deep linking and sharing.\n*   **Access Control Management:** Enables administrators to manage permissions for various resources.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidebars/utils.ts",
        "summary": "This code provides a utility function, `findSearchTermInItemName`, that highlights search terms within a given string. It takes a string (`name`) and a search term (`searchTerm`) as input, and returns a `SearchMatch` object containing the ranges of indices where the search term is found within the string. The function performs a case-insensitive search and returns `null` if no match is found or if either the name or search term is empty. This utility is primarily intended for server-side search implementations where precise match data is not readily available.\n\n**Features:**\n\n*   **Search Term Highlighting:** Highlights instances of a search term within a string.\n*   **Case-Insensitive Search:** Performs search in a case-insensitive manner.\n*   **Server-Side Search Support:** Designed for use cases where detailed search match information is not provided by the server.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidebars/annotations.tsx",
        "summary": "This code defines the logic for an annotations sidebar within a larger application, likely a product analytics platform. It manages the display of annotations, allows users to create new annotations via a modal, and provides search functionality to filter annotations based on content or date. The sidebar displays a list of annotations with details like content, date, and creator, and includes options to delete annotations. The logic connects to a global annotations model to fetch and manage annotation data.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Annotation Display:** Shows a list of annotations in a sidebar.\n*   **Annotation Creation:** Allows users to create new annotations via a modal.\n*   **Annotation Search:** Enables users to search and filter annotations by content or date.\n*   **Annotation Deletion:** Provides an option to delete existing annotations.\n*   **Annotation Details:** Displays annotation content, date, and creator information.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidebars/insights.ts",
        "summary": "This code defines the logic for the insights sidebar within a larger navigation system. It manages the display of a list of insights, allowing users to search, load more insights as they scroll, and perform actions like editing, duplicating, renaming, and deleting insights. The logic connects to the saved insights and project logic to fetch and manipulate insight data, and it integrates with the overall navigation system to highlight the active insight.\n\n**Features:**\n\n*   **Display of Insights List:** Fetches and displays a paginated list of insights with names and links.\n*   **Infinite Scrolling:** Loads more insights as the user scrolls down the list.\n*   **Search:** Filters the displayed insights based on a search term.\n*   **Insight Actions:** Provides options to edit, duplicate, rename, and delete individual insights.\n*   **Active Insight Highlighting:** Highlights the currently active insight in the sidebar.\n*   **Dynamic Loading:** Only loads insight data when it's needed, improving performance.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidebars/dashboards.tsx",
        "summary": "This code defines the logic for the dashboards sidebar in a PostHog application. It manages the display of dashboards, including pinned dashboards, and allows users to search, create, edit, duplicate, pin/unpin, rename, and delete dashboards. The logic connects to the dashboards model to fetch and update dashboard data and uses a Fuse search library to enable searching of dashboards by name, description, and tags.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dashboard Listing:** Displays a list of available dashboards in the sidebar.\n*   **Dashboard Search:** Allows users to search for dashboards by name, description, or tags.\n*   **Pinned Dashboards:** Supports pinning dashboards for easy access.\n*   **Dashboard Creation:** Enables users to create new dashboards via a modal.\n*   **Dashboard Editing:** Allows users to edit existing dashboards.\n*   **Dashboard Duplication:** Enables users to duplicate existing dashboards.\n*   **Dashboard Pinning/Unpinning:** Allows users to pin or unpin dashboards from the sidebar.\n*   **Dashboard Renaming:** Enables users to rename dashboards.\n*   **Dashboard Deletion:** Allows users to delete dashboards.\n*   **Active Dashboard Indication:** Highlights the currently active dashboard in the sidebar.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidebars/personsAndGroups.ts",
        "summary": "This code defines a Kea logic module named `personsAndGroupsSidebarLogic` responsible for managing the display of persons within a sidebar navigation component. It fetches person data, handles infinite scrolling, and highlights the currently active person based on the active scene and URL parameters. The logic also incorporates search functionality, filtering the displayed persons based on a search term.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Display of Persons in Sidebar:** Shows a list of persons in a sidebar for easy navigation.\n*   **Infinite Scrolling:** Loads more persons as the user scrolls, allowing for efficient handling of large datasets.\n*   **Active Person Highlighting:** Highlights the currently selected person in the sidebar based on the current page/route.\n*   **Search Functionality:** Filters the list of persons based on a search term entered by the user.\n*   **Remote Data Loading:** Fetches person data from a remote source, enabling dynamic updates.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidebars/cohorts.ts",
        "summary": "This code defines the logic for the cohorts sidebar in the PostHog navigation. It fetches cohorts, handles searching, and provides data for rendering the sidebar items. The sidebar displays a list of cohorts with their names, summaries (number of people), creation dates, and creators. Users can rename or delete cohorts directly from the sidebar. The sidebar also highlights search matches within cohort names.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Cohort Listing:** Displays a list of cohorts in the sidebar.\n*   **Cohort Details:** Shows cohort name, member count, creation date, and creator.\n*   **Cohort Search:** Allows users to search for cohorts by name.\n*   **Search Highlighting:** Highlights matching text in cohort names during search.\n*   **Cohort Renaming:** Enables users to rename cohorts directly from the sidebar.\n*   **Cohort Deletion:** Allows users to delete cohorts from the sidebar.\n*   **Navigation:** Provides links to individual cohort pages.\n*   **\"Add Cohort\" Action:** Provides a link to create a new cohort.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidebars/experiments.ts",
        "summary": "This code defines the logic for the experiments sidebar in a navigation component. It uses the `kea` library for state management and connects to the `experimentsLogic` and `sceneLogic` to fetch experiments and determine the active scene. The sidebar displays a list of experiments with details like name, status, creation date, and creator. It also supports searching experiments and provides actions like deleting an experiment. The sidebar dynamically updates based on the search term and highlights matching text in the experiment names.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Experiment Listing:** Displays a list of experiments with key details (name, status, creation/running time, creator).\n*   **Experiment Status Indication:** Uses ribbons to visually indicate the status of each experiment (draft, running, complete).\n*   **Experiment Search:** Allows users to search for experiments by name and description.\n*   **Search Highlighting:** Highlights matching text in experiment names during search.\n*   **Experiment Navigation:** Provides links to individual experiment pages.\n*   **Experiment Creation:** Provides a link to create a new experiment.\n*   **Experiment Deletion:** Allows users to delete experiments from the sidebar.\n*   **Dynamic Updates:** The sidebar content updates automatically when experiments are loaded or the search term changes.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidebars/toolbar.ts",
        "summary": "This code defines the logic for the toolbar sidebar in the PostHog navigation 3000. It manages a list of authorized URLs (sites) that are displayed in the sidebar, allowing users to add, remove, edit, and launch these URLs with the toolbar in a new tab. It also handles suggestions for URLs and integrates with a search functionality to filter the displayed URLs based on a search term. The logic uses Fuse.js for fuzzy searching of URLs.\n\nHere's a list of high-level product features:\n\n*   **Display Authorized URLs:** Shows a list of authorized URLs (sites) in the toolbar sidebar.\n*   **Add New URLs:** Allows users to add new URLs to the authorized list.\n*   **Remove URLs:** Enables users to remove URLs from the authorized list.\n*   **Edit URLs:** Provides functionality to edit existing URLs in the list.\n*   **Launch URLs with Toolbar:** Allows users to open a URL with the PostHog toolbar in a new tab.\n*   **URL Suggestions:** Suggests URLs to the user, potentially based on their browsing history or other factors.\n*   **Fuzzy Search:** Implements a fuzzy search functionality to filter the displayed URLs based on a search term.\n*   **Visual Highlighting:** Highlights matching portions of URLs in the search results.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidebars/dataManagement.ts",
        "summary": "This code defines a Kea logic module named `dataManagementSidebarLogic` responsible for managing the data displayed in a sidebar related to data management. It fetches and organizes event definitions, property definitions, and actions, making them available for display in a sidebar. The logic supports searching and filtering these items, as well as infinite scrolling to handle large datasets. It also determines the currently active item in the sidebar based on the active scene.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Display of Event Definitions:** Lists event definitions with links to view recordings.\n*   **Display of Property Definitions:** Lists property definitions with links to view details.\n*   **Display of Actions:** Lists actions with links to edit them.\n*   **Search Functionality:** Allows users to search for specific event definitions, property definitions, and actions.\n*   **Infinite Scrolling:** Loads event definitions and property definitions in batches as the user scrolls.\n*   **Active Item Highlighting:** Highlights the currently selected item in the sidebar based on the active scene.\n*   **Navigation:** Provides URLs for navigating to event definitions, property definitions, and actions.\n*   **\"Add Action\" Button:** Provides a button to create a new action."
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidebars/featureFlags.tsx",
        "summary": "This code defines a Kea logic module named `featureFlagsSidebarLogic` responsible for managing and displaying feature flags within a sidebar navigation component. It fetches feature flag data, handles searching and filtering, and provides actions for editing, enabling/disabling, copying, and deleting feature flags. The logic also determines the active list item based on the current scene and parameters, and formats the feature flag data for display in the sidebar, including search highlights and menu options.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Feature Flag Listing:** Displays a list of feature flags in a sidebar.\n*   **Feature Flag Search:** Allows users to search for feature flags by key, description, or tags.\n*   **Feature Flag Status Indication:** Shows whether a feature flag is enabled or disabled.\n*   **Feature Flag Editing:** Provides a link to edit a feature flag.\n*   **Feature Flag Enabling/Disabling:** Allows users to toggle the active state of a feature flag.\n*   **Feature Flag Key Copying:** Enables users to copy the feature flag key to the clipboard.\n*   **Feature Flag Usage in Insights:** Provides a link to try out a feature flag in Insights.\n*   **Feature Flag Deletion:** Allows users to delete a feature flag with undo functionality.\n*   **Permission Handling:** Respects user permissions when editing or deleting feature flags.\n*   **Active Feature Flag Highlighting:** Highlights the currently active feature flag in the sidebar.\n*   **Feature Flag Summaries:** Displays a summary of the feature flag's filters.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/sidebars",
        "summary": "The provided code snippets define the logic for various sidebars within a larger application, likely a product analytics platform. These sidebars provide navigation and management capabilities for key features such as insights, annotations, data management (event/property definitions, actions), persons, authorized URLs (for a toolbar), experiments, dashboards, feature flags, and cohorts.  Each sidebar focuses on displaying a list of items, providing search functionality, and offering actions like creation, editing, deletion, and other item-specific operations.  A common theme is highlighting the currently active item and providing dynamic updates based on user interactions and data changes.\n\nHere's a list of high-level product features:\n\n*   **Insights Management:** Display, search, edit, duplicate, rename, and delete insights.\n*   **Annotation Management:** Display, create, search, and delete annotations.\n*   **Data Management:** Display, search, and navigate event definitions, property definitions, and actions.\n*   **Person Management:** Display, search, and navigate persons.\n*   **Toolbar URL Management:** Display, add, remove, edit, launch, and search authorized URLs for a toolbar.\n*   **Experiment Management:** Display, search, create, and delete experiments.\n*   **Dashboard Management:** Display, search, create, edit, duplicate, pin/unpin, rename, and delete dashboards.\n*   **Feature Flag Management:** Display, search, edit, enable/disable, copy, and delete feature flags.\n*   **Cohort Management:** Display, search, rename, and delete cohorts.\n*   **Search Highlighting:** Highlights search terms within displayed items.\n*   **Active Item Highlighting:** Highlights the currently active item in the sidebar.\n*   **Infinite Scrolling:** Loads more data as the user scrolls.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/components/SearchHighlight.tsx",
        "summary": "This code provides two React components, `SearchHighlight` and `SearchHighlightMultiple`, designed to highlight substrings within a given string. `SearchHighlight` highlights a single substring, while `SearchHighlightMultiple` highlights multiple substrings, even when they are space-delimited. Both components perform case-insensitive matching and apply a background color to the highlighted portions of the text. The components also handle truncation and allow for custom CSS classes to be applied.\n\nHere's a list of high-level product features:\n\n*   **Single Substring Highlighting:** Highlights a single specified substring within a larger string.\n*   **Multiple Substring Highlighting:** Highlights multiple substrings within a larger string, supporting space or slash delimited search terms.\n*   **Case-Insensitive Matching:** Performs substring matching regardless of case.\n*   **Customizable Highlighting Style:** Allows customization of the highlight style via CSS classes.\n*   **Text Truncation:** Truncates the displayed text to prevent overflow.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/components/MinimalNavigation.tsx",
        "summary": "The `MinimalNavigation` component provides a simplified navigation bar for the PostHog application. It includes a logo button that navigates to the project homepage, a project switcher (if the organization has multiple teams), and an account popover for managing user settings. The project switcher allows users to switch between different projects (teams) within the organization, while the account popover provides access to user-specific settings and actions.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Project Homepage Navigation:** Allows users to navigate to the project homepage via a logo button.\n*   **Project Switching:** Enables users to switch between different projects (teams) within an organization if multiple teams exist.\n*   **Account Management:** Provides access to user account settings and actions through an account popover.\n*   **User Identification:** Displays the user's name or email address in the account button.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/components/NavbarBottom.tsx",
        "summary": "The `NavbarBottom` component provides a bottom navigation bar with quick access to key features and settings. It includes buttons for activation, search, toolbar, settings, system status (if unhealthy), and user account management. The component leverages various PostHog icons and Lemon UI components for a consistent user experience. Keyboard shortcuts are displayed for search functionality. The visibility of certain buttons, like the activation button, depends on the configured visible tabs.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Quick Start Activation:** Provides access to a quick start guide or activation panel.\n*   **Global Search:** Enables users to search across the application.\n*   **Toolbar Access:** Allows users to launch the PostHog toolbar.\n*   **Settings Access:** Provides a direct link to the project settings.\n*   **System Status Monitoring:** Displays a warning and link to system status if there are issues.\n*   **Account Management:** Allows users to manage their account settings and profile.\n*   **Keyboard Shortcut Support:** Exposes keyboard shortcuts for faster navigation and actions.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/components/SidebarAccordion.tsx",
        "summary": "The `SidebarAccordion` component is a collapsible section within a sidebar navigation. It displays a category title, an expand/collapse icon, a loading spinner when data is being fetched, and a button to create new items within that category. When expanded, it renders a list of items within the category using the `SidebarList` component, or a custom empty state component if the category is empty and defined. The component manages its collapsed/expanded state using the `navigation3000Logic` kea logic.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Collapsible Navigation Categories:** Allows users to expand and collapse sections in the sidebar for better organization and focus.\n*   **Loading State Indication:** Displays a spinner to indicate when category data is being loaded.\n*   **Empty State Handling:** Provides a mechanism to display a custom component when a category is empty.\n*   **\"Create New\" Action:** Includes a button to create new items within a specific category.\n*   **Dynamic Category Title Pluralization:** Automatically pluralizes the category title based on the provided noun.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/components/KeyboardShortcut.tsx",
        "summary": "This React component, `KeyboardShortcut`, is designed to display keyboard shortcuts in a user-friendly format. It takes a set of boolean props representing the keys in the shortcut and renders them as symbols or key names within a `kbd` element. The component handles platform-specific modifier keys (Command on Mac, Ctrl on other platforms), sorts the keys to ensure a consistent display order (modifiers first), and hides the shortcut entirely on mobile devices where a physical keyboard is unlikely to be present.\n\nHere's a list of high-level product features:\n\n*   **Display Keyboard Shortcuts:** Renders keyboard shortcuts using appropriate symbols and key names.\n*   **Platform-Specific Modifiers:** Adapts modifier key display based on the operating system (Mac vs. others).\n*   **Consistent Key Order:** Sorts keys to ensure a consistent display order, prioritizing modifier keys.\n*   **Mobile Device Detection:** Hides keyboard shortcuts on mobile devices.\n*   **Customizable Styling:** Allows for custom styling through the `className` prop.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/components/Sidebar.tsx",
        "summary": "The `Sidebar.tsx` file defines the main sidebar component for the application's navigation. It dynamically renders content based on the selected navbar item, including a search bar with debounced input, and a list or accordion of links. The sidebar also supports an overlay for displaying additional content. The component handles resizing, overslide effects, and search functionality, providing a flexible and interactive navigation experience.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Dynamic Sidebar Content:** The sidebar content changes based on the selected navbar item.\n*   **Searchable Navigation:** Users can search for specific items within the sidebar.\n*   **Debounced Search:** Search queries are debounced to prevent excessive requests.\n*   **Accordion and List Views:** The sidebar can display content in either an accordion or a simple list format.\n*   **Sidebar Overlay:** Supports displaying an overlay for additional content on top of the sidebar.\n*   **Resizing Support:** The sidebar width can be adjusted.\n*   **Overslide Effect:** Visual effect when the sidebar is sliding in or out.\n*   **Loading Indicators:** Displays a loading spinner during search or data loading.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/components/NewItemButton.tsx",
        "summary": "The `NewItemButton` component is a button that allows users to create new items within a specified category in the navigation sidebar. It leverages the `navigation3000Logic` Kea logic to manage the state and actions related to creating new items. The button's appearance and behavior are determined by the `category` prop, which includes information such as the category's key, noun, and an `onAdd` handler that can be either a URL or a function to initiate the creation process. The button is only rendered if the category has an `onAdd` handler defined. It also displays a tooltip indicating the type of item being created and highlights the button when a new item is being created in that category.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **New Item Creation:** Allows users to create new items (e.g., dashboards, experiments) within different categories directly from the navigation sidebar.\n*   **Category-Specific Creation:** The creation process is tailored to the specific category selected, using either a URL redirect or a custom function.\n*   **Visual Indication of Active Creation:** Highlights the button when a new item is being created in the corresponding category.\n*   **Tooltip Help:** Provides a tooltip to inform the user about the type of item being created.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/components/TopBar.tsx",
        "summary": "The `TopBar.tsx` component provides a dynamic top navigation bar that adapts to the user's scroll position and screen size. It displays breadcrumbs, allows renaming of items in the breadcrumb trail, and integrates with mobile navigation controls. The component also features Metalytics summaries and a designated area for actions. The top bar compacts as the user scrolls down the page, and it includes features for mobile responsiveness, such as a hamburger menu to toggle the main navigation.\n\nHere's a list of high-level product features implemented by the `TopBar.tsx` component:\n\n*   **Dynamic Breadcrumbs:** Displays the current location within the application, allowing users to navigate up the hierarchy.\n*   **Item Renaming:** Enables users to rename items directly within the breadcrumb trail.\n*   **Mobile Responsiveness:** Adapts the layout and functionality for mobile devices, including a hamburger menu for navigation.\n*   **Scroll-Based Compaction:** Compacts the top bar as the user scrolls down the page to maximize screen real estate.\n*   **Metalytics Integration:** Displays Metalytics summaries within the top bar.\n*   **Action Area:** Provides a designated area for displaying actions related to the current context.\n*   **Onboarding Support:** Special handling for onboarding flows, such as displaying \"Onboarding\" as the current location.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/components/AlgoliaSearch.tsx",
        "summary": "This code implements a search component using Algolia for indexing and searching documentation, questions, and tutorials on the PostHog website. It features a search input, tag-based filtering, and a results display with keyboard navigation. The component leverages React InstantSearch for seamless integration with Algolia and provides a user-friendly interface for finding relevant resources.\n\nHere's a list of high-level product features:\n\n*   **Real-time Search:** Provides instant search results as the user types, powered by Algolia.\n*   **Categorized Search:** Allows users to filter search results by category (Docs, Questions, Tutorials) using tags.\n*   **Keyboard Navigation:** Enables users to navigate search results and tags using the keyboard.\n*   **Result Highlighting:** Highlights the active search result for easy identification.\n*   **External Link Navigation:** Opens the selected search result in a new tab on the PostHog website.\n*   **Virtual List Rendering:** Uses react-virtualized to efficiently render large search result sets.\n*   **Tag Filtering:** Filters search results based on selected tags, providing a focused search experience.\n*   **UI Component Integration:** Leverages Lemon UI components for a consistent and visually appealing user interface."
    },
    {
        "path": "frontend/src/layout/navigation-3000/components/Navbar.tsx",
        "summary": "The `Navbar.tsx` component defines the main navigation bar for the application. It dynamically renders navigation items based on configuration, feature flags, and user interactions. The navbar supports collapsible sections, a resizable width (on desktop), and a mobile-friendly overlay that hides the navigation when clicked. It utilizes kea-logic for state management and actions, and renders `NavbarButton` components for each navigation item.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Dynamic Navigation Rendering:** Navigation items are rendered based on configuration data.\n*   **Feature Flag Support:** Navigation items can be enabled or disabled based on feature flags.\n*   **Collapsible Sections:** The navigation bar can be collapsed to save screen space.\n*   **Resizable Width (Desktop):** Users can resize the width of the navigation bar on desktop.\n*   **Mobile-Friendly Overlay:** On mobile, an overlay allows users to hide the navigation bar.\n*   **Theming:** The navigation bar's style is customizable via theming.\n*   **Sidebar Integration:** Clicking a navigation item can show or hide a related sidebar.\n*   **Scrollable Content:** The navigation bar content is scrollable with visual shadows to indicate scrollable areas.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/components/SidebarList.tsx",
        "summary": "This code defines the `SidebarList` component, which is responsible for rendering a dynamic, searchable, and interactive list of items within a sidebar navigation. It utilizes React Virtualized for efficient rendering of large lists and supports features like infinite loading, keyboard navigation, item renaming, and nested accordion structures. The component handles different item types, including links, buttons, tentative items (for creating new items inline), and accordion categories. It also integrates with PostHog's Lemon UI library for styling and notifications, and Sentry for error tracking.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Dynamic Sidebar Navigation:** Renders a list of navigation items fetched from a data source.\n*   **Searchable Items:** Highlights search terms within list items to improve discoverability.\n*   **Infinite Loading:** Loads more items as the user scrolls, enabling efficient handling of large datasets.\n*   **Keyboard Navigation:** Allows users to navigate the list using keyboard shortcuts.\n*   **Inline Item Creation:** Enables users to create new items directly within the list.\n*   **Item Renaming:** Allows users to rename existing items.\n*   **Accordion Categories:** Supports nested navigation structures with collapsible categories.\n*   **Customizable Item Types:** Handles different item types, including links, buttons, and custom components.\n*   **Visual Feedback:** Provides visual cues for active items, loading states, and validation errors.\n*   **Error Handling:** Integrates with Sentry to capture and report errors.\n*   **Contextual Information:** Supports displaying extra contextual information alongside list items."
    },
    {
        "path": "frontend/src/layout/navigation-3000/types.ts",
        "summary": "This code defines the types and interfaces for the navigation components in the PostHog frontend, specifically focusing on the sidebar and navbar. It includes definitions for sidebar categories, list items (basic and extended), and navbar items, supporting features like search highlighting, item renaming, infinite loading, and custom empty states. The code also defines the structure for sidebar logic using Kea.\n\nHere's a list of high-level product features supported by this code:\n\n*   **Configurable Navigation:** Allows defining navbar and sidebar items with icons, labels, and links to different scenes or sidebar logics.\n*   **Sidebar Categories:** Organizes sidebar items into categories with customizable icons, nouns, and loading states.\n*   **List Items:** Supports both single-row (basic) and double-row (extended) list items with features like search highlighting, tags, markers, and context information.\n*   **Dynamic Item Creation:** Enables adding new items to sidebar categories with validation and different creation methods (new scene, modal, or direct input).\n*   **Infinite Loading:** Supports loading large lists of items in batches for improved performance.\n*   **Customizable Empty States:** Allows defining custom components to display when a sidebar category is empty.\n*   **Item Renaming:** Provides functionality for renaming list items with validation.\n*   **Search Highlighting:** Highlights matching fields and name ranges in search results.\n*   **Accordion Support:** Enables nested categories within the sidebar using accordions.\n*   **Tentative List Items:** Supports temporary list items during the creation process.\n*   **Button List Items:** Supports list items that act as buttons with custom icons and click handlers."
    },
    {
        "path": "frontend/src/layout/navigation-3000/components/NavbarButton.tsx",
        "summary": "This React component, `NavbarButton`, is a customizable button designed for a navigation bar, specifically within the PostHog application. It leverages Lemon UI components and PostHog's feature flagging system to dynamically render button content, tooltips, and side actions based on the navigation state, user settings, and feature flags. The button adapts its appearance and behavior depending on whether the navigation is collapsed, the current active scene, and the presence of any associated sidebar change notices.\n\nHere's a list of high-level product features implemented by the `NavbarButton` component:\n\n*   **Dynamic Content Rendering:** Displays either a short title or full title, with optional tags (alpha, beta, new) to indicate the status of the feature.\n*   **Adaptive Tooltips:** Shows tooltips with the full title when the navigation is collapsed or on hover (if forced), indicating the current location.\n*   **Side Actions:** Supports side actions with dividers and custom data attributes for menu items.\n*   **Active State Indication:** Highlights the button when the corresponding scene is active or part of the breadcrumb trail.\n*   **Navigation Collapse Handling:** Adjusts the button's content and behavior based on whether the navigation is collapsed.\n*   **Sidebar Change Notices:** Displays tooltips with change notices related to the sidebar item, with acknowledgement functionality.\n*   **Mobile Navigation Handling:** Hides the navigation on mobile devices when the button is clicked (if it navigates to a new route).\n*   **Feature Flag Integration:** Uses feature flags to control the button's appearance and behavior (e.g., using the new navigation style).\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/components",
        "summary": "The provided code implements a comprehensive navigation system for the PostHog application, offering a dynamic, searchable, and customizable user experience. The system comprises several interconnected components, including a sidebar with expandable categories and inline item creation, a top bar with breadcrumbs and contextual actions, a navigation bar with collapsible sections and feature flag support, and a bottom navigation bar for quick access to key features. The system also incorporates keyboard shortcuts, mobile responsiveness, and Algolia-powered search for documentation and tutorials.\n\nHere's a list of high-level product features:\n\n*   **Dynamic Navigation Rendering:** Navigation items are rendered based on configuration data, feature flags, and user interactions.\n*   **Searchable Content:** Users can search for specific items within the sidebar and access Algolia-powered documentation search.\n*   **Customizable Layout:** The navigation system supports collapsible sections, resizable widths, and mobile-friendly overlays.\n*   **Inline Item Creation and Renaming:** Users can create new items and rename existing items directly within the navigation interface.\n*   **Contextual Actions:** The top bar provides a designated area for displaying actions related to the current context.\n*   **Keyboard Navigation:** Allows users to navigate the interface using keyboard shortcuts.\n*   **Account and Project Management:** Provides access to user account settings and allows users to switch between different projects.\n*   **System Status Monitoring:** Displays a warning and link to system status if there are issues.\n*   **Visual Feedback:** Provides visual cues for active items, loading states, and validation errors.\n*   **Mobile Responsiveness:** Adapts the layout and functionality for mobile devices.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/themeLogic.ts",
        "summary": "This code defines the logic for managing the application's theme, including dark mode preference, custom themes, and custom CSS. It uses Kea to manage state, actions, and selectors related to the theme. The logic connects to userLogic and featureFlagLogic to determine the theme based on user preferences, system settings, and feature flags. It also handles persisting and previewing custom CSS.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Theme Selection:** Allows users to select a preferred theme for the application.\n*   **Dark Mode:** Supports dark mode based on user preference, system settings, or a selected theme.\n*   **Custom CSS Themes:** Enables users to customize the application's appearance with custom CSS (controlled by a feature flag).\n*   **Theme Persistence:** Saves the user's theme and custom CSS preferences across sessions.\n*   **System Theme Sync:** Automatically syncs the application theme with the user's system-wide dark mode preference.\n*   **Custom CSS Preview:** Allows users to preview custom CSS changes before saving them.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/themes.ts",
        "summary": "This code defines a theming system for the frontend application. It exports an interface `Theme` which defines the structure of a theme, including properties for an ID, name, dark mode setting, and CSS styles for the sidebar, main content area, and boxes. It also exports an array called `themes` which contains a list of predefined themes, each with its own unique styling, including background images and colors.\n\nHere's a list of high-level product features that can be derived from this code:\n\n*   **Theme Selection:** Users can select from a list of predefined themes to customize the look and feel of the application.\n*   **Customizable Appearance:** The application's appearance can be customized through themes, affecting the sidebar, main content area, and individual boxes.\n*   **Dark Mode Support:** Themes can specify whether they are dark or light, allowing for a dark mode feature.\n*   **Branding/Personalization:** Themes can be tailored to reflect different brands or user preferences through custom background images and styles.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/Navigation.tsx",
        "summary": "The `Navigation` component serves as the main layout structure for the PostHog application, adapting its appearance and functionality based on feature flags, user settings (theme, mobile layout), and the current scene configuration. It provides different navigation modes (full, minimal), a top bar, sidebar, and main content area. The component also includes features like billing alerts, project notices, a command bar, and a side panel. It also handles accessibility by providing a \"skip to content\" link.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Main Application Layout:** Provides the overall structure for the PostHog application's user interface.\n*   **Navigation Modes:** Supports different navigation modes (full, minimal) to cater to various user preferences or screen sizes.\n*   **Top Bar:** Displays a top navigation bar, likely containing global actions and information.\n*   **Sidebar Navigation:** Implements a sidebar for navigating through different sections of the application.\n*   **Content Area:** Renders the main content of the current scene or page.\n*   **Billing Alerts:** Displays alerts related to billing and account status.\n*   **Project Notices:** Shows important notices or announcements related to the current project.\n*   **Command Bar:** Provides a command palette for quick access to various actions and features.\n*   **Side Panel:** Implements a side panel for additional information or settings.\n*   **Theme Support:** Applies a user-selected theme to the application's appearance.\n*   **Mobile Layout:** Adapts the layout for mobile devices.\n*   **Accessibility:** Includes accessibility features like a \"skip to content\" link.\n"
    },
    {
        "path": "frontend/src/layout/navigation-3000/navigationLogic.tsx",
        "summary": "This code defines the logic for the main navigation in the PostHog application, specifically the \"Navigation 3000\" version. It manages the state of the sidebar, including its visibility, width, and content, as well as the overall navigation layout (collapsed/expanded, mobile/desktop). It handles user interactions such as resizing the sidebar, toggling navigation elements, and initiating the creation of new items within the sidebar. The logic connects to other parts of the application, such as feature flags, dashboards, and session recordings, to dynamically generate the navigation items and their associated actions.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Sidebar Management:** Controls the visibility, width, and resizing of the sidebar.\n*   **Navigation Layout:** Manages the overall navigation layout, including collapsed/expanded states and mobile/desktop responsiveness.\n*   **Dynamic Navigation Items:** Generates navigation items based on feature flags, dashboards, session recordings, and other application data.\n*   **Item Creation:** Allows users to initiate the creation of new items within the sidebar, such as dashboards or insights.\n*   **Keyboard Navigation:** Supports keyboard shortcuts for navigating the sidebar.\n*   **Search Functionality:** Enables searching within the navigation.\n*   **Accordion Functionality:** Allows users to collapse and expand sections within the sidebar.\n*   **Persistence:** Persists user preferences for sidebar width, collapsed state, and accordion states.\n*   **Responsiveness:** Adapts the navigation layout to different screen sizes and devices.\n*   **Customizable Sidebar Content:** Allows different sidebars to be plugged in based on the active navbar item."
    },
    {
        "path": "frontend/src/layout/navigation-3000",
        "summary": "The provided code collectively implements a highly customizable and dynamic navigation system for the PostHog application. This system provides users with intuitive access to various tools, settings, and information panels through a combination of sidebars, top bars, and navigation bars. The navigation adapts to user permissions, feature flags, and application state, offering a personalized and efficient experience. Key features include dynamic navigation rendering, searchable content, customizable layouts, inline item creation, contextual actions, theme selection, and mobile responsiveness, all contributing to a seamless and productive user journey.\n\nHere's a list of high-level product features:\n\n*   Dynamic Side Panel Navigation\n*   Customizable Sidebars with Management Capabilities (Insights, Annotations, Data, Persons, URLs, Experiments, Dashboards, Feature Flags, Cohorts)\n*   Configurable Navigation Items (Navbar and Sidebar)\n*   Search Functionality with Highlighting\n*   Inline Item Creation and Renaming\n*   Contextual Actions in Top Bar\n*   Keyboard Navigation\n*   Account and Project Management\n*   System Status Monitoring\n*   Theme Selection and Customization (including Dark Mode and Custom CSS)\n*   Mobile Responsiveness\n*   Accessibility Features\n*   Billing Alerts and Project Notices\n*   Command Bar\n*   State Persistence and URL Synchronization\n*   AI Assistant (Max)\n*   Activity Notifications\n"
    },
    {
        "path": "frontend/src/layout/panel-layout/PersonsTree/PersonsTree.tsx",
        "summary": "This React component, `PersonsTree`, renders a tree view of persons within a panel layout. It fetches person data using `personsTreeLogic` and displays it in a `LemonTree` component. The component also sets a reference to the tree for use by the parent `panelLayoutLogic`. The tree data consists of an icon, an ID, and a name for each person. The component is wrapped in a `PanelLayoutPanel` which provides a search bar.\n\nHere's a list of high-level product features:\n\n*   **Person Tree View:** Displays a hierarchical tree structure of persons.\n*   **Data Fetching:** Fetches person data to populate the tree.\n*   **Search Functionality:** Allows users to search for specific people within the tree.\n*   **Icon Representation:** Displays an icon next to each person's name in the tree.\n*   **Panel Layout Integration:** Integrates seamlessly within a panel layout structure.\n"
    },
    {
        "path": "frontend/src/layout/panel-layout/PersonsTree/personsTreeLogic.tsx",
        "summary": "This code defines a Kea logic module called `personsTreeLogic` responsible for fetching and processing person data for a panel layout. It fetches data from two API endpoints: one for general search results and another specifically for persons. The logic combines and ranks these results based on a search term provided by the `panelLayoutLogic`. The module then exposes the combined and ranked person results via the `personsResults` selector. Upon mounting, the logic automatically loads the initial person data.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Person Search:** Allows users to search for persons within the application.\n*   **Search Result Ranking:** Ranks search results based on relevance to the search term.\n*   **Data Aggregation:** Combines search results from multiple sources (general search and person-specific search).\n*   **Real-time Updates:** Automatically updates the person list when the search term changes.\n*   **Panel Integration:** Integrates with a panel layout to display the search results.\n"
    },
    {
        "path": "frontend/src/layout/panel-layout/PersonsTree",
        "summary": "The provided code implements a person search and display feature within a panel layout. It fetches person data from multiple sources, ranks the results based on a search term, and presents them in a hierarchical tree view with icons. The component integrates with a panel layout, providing a search bar for filtering the person tree.\n\nHere's a list of high-level product features:\n\n*   Person Search\n*   Search Result Ranking\n*   Data Aggregation\n*   Real-time Updates\n*   Panel Integration\n*   Person Tree View\n*   Data Fetching\n*   Search Functionality\n*   Icon Representation\n"
    },
    {
        "path": "frontend/src/layout/panel-layout/ProjectTree/types.ts",
        "summary": "This code defines TypeScript interfaces and types related to a project tree component in a frontend application. It specifies the structure for actions that can be performed on the project tree, such as moving, creating, or deleting files or folders. It also defines the possible states of a folder within the tree, indicating whether it's loading, loaded, has more content to load, or has encountered an error.\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **File/Folder Management:** Users can move, create, and delete files and folders within the project.\n*   **Asynchronous Loading:** Folders in the project tree load their contents asynchronously, potentially supporting large projects.\n*   **Loading State Indicators:** The UI provides visual feedback on the loading state of folders, improving the user experience.\n*   **Error Handling:** The project tree handles errors during folder loading and likely displays error messages to the user.\n"
    },
    {
        "path": "frontend/src/layout/panel-layout/OrganizationDropdownMenu.tsx",
        "summary": "This React component, `OrganizationDropdownMenu`, provides a dropdown menu for users to switch between different organizations they belong to within the PostHog application. It displays the current organization's logo and name, and allows users to select another organization from the list. The component also includes functionality to create a new organization, subject to preflight checks and feature availability. The dropdown dynamically updates to reflect the currently selected organization and handles the UI state for the dropdown's open/closed status.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Organization Switching:** Allows users to switch between different organizations they are a member of.\n*   **Organization Identification:** Displays the current organization's logo and name in the dropdown trigger.\n*   **Organization Listing:** Lists all available organizations in the dropdown menu.\n*   **New Organization Creation:** Provides an option to create a new organization, gated by feature availability and preflight checks.\n*   **Visual Indication of Access Level:** Displays the access level for each organization.\n*   **UI State Management:** Manages the open/closed state of the dropdown menu.\n"
    },
    {
        "path": "frontend/src/layout/panel-layout/ProjectDropdownMenu.tsx",
        "summary": "This code defines a React component called `ProjectDropdownMenu` that provides a dropdown menu for switching between PostHog projects within an organization. It displays the current project and a list of other projects in the organization, allowing users to quickly switch between them. The menu also includes a button to create a new project, subject to feature availability and user permissions. The component uses Lemon UI components for styling and interacts with various PostHog logic layers to manage project switching, settings navigation, and feature gating.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Project Switching:** Allows users to switch between different PostHog projects within their organization.\n*   **Project Settings Navigation:** Provides a direct link to the settings page for each project.\n*   **Current Project Indication:** Clearly indicates the currently active project.\n*   **New Project Creation:** Enables users to create new projects within their organization (subject to feature availability).\n*   **Demo Project Highlighting:** Visually distinguishes demo projects from regular projects.\n*   **Organization Project Listing:** Displays a list of all projects within the user's organization.\n"
    },
    {
        "path": "frontend/src/layout/panel-layout/panelLayoutLogic.tsx",
        "summary": "This code defines the logic for a panel layout within a larger application, likely a web application. It manages the visibility and state of a navigation bar and a panel, including whether the panel is pinned, visible, and closeable. It also handles the active panel identifier, search term within the panel, and references to the panel's tree structure and the main content area. The logic is built using Kea, a state management library, and connects to the navigation logic to respond to changes in the mobile layout.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Collapsible/Expandable Panel:** Allows users to show or hide a side panel.\n*   **Pinning Panel:** Allows users to pin the panel open, preventing it from collapsing automatically.\n*   **Mobile-Responsive Layout:** Adapts the layout for mobile devices, potentially changing the behavior of the navigation bar and panel.\n*   **Navigation:** Manages the active item in the panel's navigation.\n*   **Search:** Enables searching within the panel's content.\n*   **Navigation Bar Visibility Control:** Allows showing or hiding the navigation bar.\n"
    },
    {
        "path": "frontend/src/layout/panel-layout/ProjectTree/utils.tsx",
        "summary": "This code provides utility functions for converting a file system-like structure (represented by `FileSystemEntry` and `FileSystemImport` types) into a tree data structure (`TreeDataItem`) suitable for display in a UI component like a file explorer. It handles nested folders, lazy loading of folder contents, and navigation via routing. The code also includes functions for manipulating paths (splitting, joining, escaping) and searching within the generated tree. There are two main conversion functions, one that creates a hierarchical tree and another that creates a flat list suitable for search results.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Project Tree Visualization:** Display a hierarchical representation of files and folders.\n*   **File System Navigation:** Allow users to navigate through the project's file structure.\n*   **Lazy Loading:** Load folder contents on demand to improve performance for large projects.\n*   **File/Folder Icons:** Display appropriate icons for different file types and folders.\n*   **Routing Integration:** Navigate to specific files or folders within the application when a tree item is clicked.\n*   **Search Functionality:** Support searching for files and folders within the project.\n*   **Search Highlighting:** Highlight search terms within file and folder names in the search results.\n*   **Path Manipulation:** Provides utilities for splitting, joining, and escaping file paths.\n"
    },
    {
        "path": "frontend/src/layout/panel-layout/PanelLayoutPanel.tsx",
        "summary": "The `PanelLayoutPanel` component provides a consistent layout for panels within the application, featuring a project dropdown menu, search functionality, and a pin/unpin option to control the panel's visibility. It includes a search input with clear functionality and keyboard navigation support, a project selection dropdown, and a pin/unpin button. The component is designed to be flexible, accepting custom actions and rendering child components within its structured layout.\n\nHere's a list of high-level product features provided by the component:\n\n*   **Project Selection:** Allows users to select a project from a dropdown menu.\n*   **Panel Pinning:** Enables users to pin or unpin the panel, potentially affecting its visibility or behavior.\n*   **Search Functionality:** Provides a search input field to filter the contents of the panel.\n*   **Clear Search:** Offers a button to quickly clear the search input.\n*   **Keyboard Navigation:** Supports keyboard navigation within the panel, specifically using the down arrow key to focus on the first visible item in the panel tree.\n*   **Custom Actions:** Accepts custom actions to be rendered in the panel header.\n*   **Mobile Layout Responsiveness:** Adapts to mobile layouts.\n"
    },
    {
        "path": "frontend/src/layout/panel-layout/ProjectTree/ProjectTree.tsx",
        "summary": "The `ProjectTree` component provides a file system-like navigation for a project, allowing users to browse, create, rename, delete, and move files and folders within a hierarchical structure. It integrates with a panel layout, offering search functionality and actions to manage pending changes. The component utilizes a tree view to display the project structure and provides context menus and side actions for item-specific operations.\n\nHere's a list of high-level product features:\n\n*   **Hierarchical Project Navigation:** Display project files and folders in a tree structure.\n*   **File and Folder Management:**\n    *   Create new folders.\n    *   Rename existing files and folders.\n    *   Delete files and folders.\n    *   Move files and folders via drag and drop.\n*   **Context Menus:** Provide context-sensitive actions for files and folders (e.g., create folder, rename, copy path, delete).\n*   **Pending Changes Management:** Allow users to save or cancel multiple changes (create, rename, delete, move) at once.\n*   **Search Functionality:** Enable users to search for files and folders within the project.\n*   **Path Copying:** Allow users to copy the path of a file or folder to the clipboard.\n*   **Visual Indication of Active Item:** Highlight the currently selected file or folder.\n*   **Lazy Loading:** Load folder contents on demand when expanding a folder.\n"
    },
    {
        "path": "frontend/src/layout/panel-layout/PanelLayout.tsx",
        "summary": "The `PanelLayout` component provides a flexible layout structure for displaying a navigation bar and a main content area. It adapts to both mobile and desktop environments, offering features like pinning the panel, toggling panel visibility, and displaying an overlay to dismiss the panel. The component utilizes `kea` for state management and actions, and `class-variance-authority` for managing CSS classes based on different layout states. It also includes a `ProjectTree` component within the navigation bar when the \"Project\" panel is active.\n\nHere's a list of high-level product features:\n\n*   **Adaptive Layout:** Adjusts the layout based on the device (mobile or desktop).\n*   **Panel Pinning:** Allows pinning the navigation panel for persistent visibility on desktop.\n*   **Panel Visibility Toggle:** Enables showing or hiding the navigation panel.\n*   **Overlay Dismissal:** Provides an overlay to dismiss the navigation panel on mobile and desktop (when not pinned).\n*   **Dynamic Panel Content:** Renders different content within the navigation panel based on the active panel identifier (e.g., `ProjectTree` for the \"Project\" panel).\n*   **Project Tree Navigation:** Displays a project tree within the navigation panel for project-related navigation.\n"
    },
    {
        "path": "frontend/src/layout/panel-layout/ProjectTree/projectTreeLogic.tsx",
        "summary": "This code defines the logic for a project tree component in a PostHog application. It manages the display and organization of files and folders within a project, including loading, creating, deleting, moving, and searching for items. The logic handles both persisted file system entries and temporary \"unfiled\" items, as well as managing pending actions to ensure data consistency. It also integrates with PostHog's groups feature, displaying links to group management pages within the tree.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **File and Folder Management:** Allows users to organize their project files into a hierarchical tree structure.\n*   **CRUD Operations:** Supports creating, reading, updating, and deleting files and folders.\n*   **Drag and Drop Support:** Enables users to move files and folders within the tree using drag and drop.\n*   **Search Functionality:** Provides a search feature to quickly locate files and folders within the project.\n*   **Unfiled Items:** Allows users to work with temporary, unfiled items before permanently saving them.\n*   **Pending Actions:** Manages a queue of pending file system operations to ensure data consistency.\n*   **Group Integration:** Integrates with PostHog's groups feature, displaying links to group management pages within the project tree.\n*   **Visual Feedback:** Provides visual cues for loading states, expanded/collapsed folders, and the currently viewed item.\n*   **Persistence:** Persists the expanded state of folders across sessions.\n"
    },
    {
        "path": "frontend/src/layout/panel-layout/PanelLayoutNavBar.tsx",
        "summary": "This code defines the `PanelLayoutNavBar` component, which serves as the main navigation bar for the PostHog application within the panel layout. It provides access to core features and settings through a combination of static navigation items and dynamically generated product links. The component handles panel visibility, navigation, search, and account management, offering a centralized hub for users to interact with the application.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Core Navigation:** Provides access to key areas like the project homepage, dashboards, notebooks, data management, and user management.\n*   **Project Panel:** Enables users to open and close a dedicated project panel for focused project-related actions.\n*   **Search:** Integrates with the command bar to allow users to search across the application.\n*   **Organization Management:** Allows users to switch between different organizations.\n*   **Dynamic Product Links:** Displays a list of available products based on feature flags and configuration.\n*   **Account Management:** Provides access to user account settings and information.\n*   **Keyboard Navigation:** Supports keyboard interactions for enhanced accessibility.\n*   **Scrollable Navigation:** Implements scrollable shadows for long lists of navigation items.\n*   **Visual Feedback:** Highlights the active navigation item and provides visual cues for panel state (pinned/unpinned)."
    },
    {
        "path": "frontend/src/layout/panel-layout/ProjectTree/defaultTree.tsx",
        "summary": "This code defines the structure and content of the default project tree displayed in the PostHog frontend. It specifies the items that appear in the tree, their icons, the URLs they link to, and any feature flags that control their visibility. The tree is organized into \"Create new\" and \"Explore\" sections, offering options to create various items like AI chats, features, repls, surveys, SQL queries, and data pipeline components, as well as explore data management tools, cohorts, activity, and other features.\n\nHere's a list of high-level product features represented in the project tree:\n\n*   **AI Chat Creation:** Allows users to create AI chat interfaces.\n*   **Feature Management:** Enables users to create and manage product features.\n*   **REPL (Read-Eval-Print Loop) Interface:** Provides a REPL interface for debugging.\n*   **Survey Creation:** Facilitates the creation of user surveys.\n*   **SQL Query Editor:** Offers an interface for writing and executing SQL queries.\n*   **Data Pipeline Management:** Supports the creation and management of data pipelines with sources, destinations, transformations, and site apps.\n*   **Data Management Tools:** Provides access to event definitions, property definitions, annotations, data management history, revenue tracking, and ingestion warnings.\n*   **Data Warehouse Exploration:** Allows users to explore the data warehouse.\n*   **Cohort Management:** Enables the creation and management of user cohorts.\n*   **Activity Monitoring:** Provides views for exploring and monitoring user activity.\n*   **LLM Observability:** Offers tools for observing and monitoring Large Language Models.\n*   **Error Tracking:** Provides error tracking and monitoring capabilities.\n*   **Heatmaps:** Allows users to view and analyze heatmaps of user interactions."
    },
    {
        "path": "frontend/src/layout/panel-layout/ProjectTree",
        "summary": "The project tree component provides a file system-like navigation experience within the PostHog frontend, enabling users to organize and manage their project files and folders in a hierarchical structure. It supports a wide range of features, including creating, renaming, deleting, and moving files and folders, along with search functionality, context menus, and pending changes management. The component integrates with other PostHog features like groups and data management tools, offering a centralized location for accessing and managing various aspects of a project.\n\nHere's a list of high-level product features:\n\n*   Hierarchical Project Navigation\n*   File and Folder Management (Create, Read, Update, Delete, Move)\n*   Search Functionality\n*   Context Menus\n*   Pending Changes Management\n*   Asynchronous Loading & Loading State Indicators\n*   Error Handling\n*   Path Copying\n*   Visual Indication of Active Item\n*   Lazy Loading\n*   File/Folder Icons\n*   Routing Integration\n*   Search Highlighting\n*   Unfiled Items\n*   Group Integration\n*   Data Management Tools Integration (Event Definitions, Property Definitions, Annotations, Data Management History, Revenue Tracking, Ingestion Warnings)\n*   AI Chat Creation\n*   Feature Management\n*   REPL Interface\n*   Survey Creation\n*   SQL Query Editor\n*   Data Pipeline Management\n*   Data Warehouse Exploration\n*   Cohort Management\n*   Activity Monitoring\n*   LLM Observability\n*   Error Tracking\n*   Heatmaps\n"
    },
    {
        "path": "frontend/src/layout/panel-layout",
        "summary": "The provided code collectively implements a comprehensive panel layout system for the PostHog application, offering a flexible and feature-rich user interface. It focuses on providing intuitive navigation, efficient project and organization management, and powerful search capabilities, all within an adaptive layout that caters to both desktop and mobile environments. The system leverages state management and UI component libraries to deliver a seamless and responsive user experience.\n\nHere's a list of high-level product features:\n\n*   **Adaptive Panel Layout:** Dynamically adjusts to different screen sizes and devices, providing an optimized experience on both desktop and mobile.\n*   **Project and Organization Management:** Enables users to easily switch between different projects and organizations, with clear visual indicators and access to settings.\n*   **Hierarchical Project Navigation:** Provides a file system-like tree view for organizing and managing project files and folders.\n*   **Comprehensive Search Functionality:** Allows users to search across the application, including within the panel content and project files.\n*   **Panel Pinning and Visibility Control:** Offers options to pin the panel for persistent visibility or toggle its visibility as needed.\n*   **Dynamic Navigation and Content:** Displays different content within the navigation panel based on the active panel and user context.\n*   **Account and Settings Management:** Provides access to user account settings and application-wide configurations.\n*   **Core Navigation:** Provides access to key areas like the project homepage, dashboards, notebooks, data management, and user management.\n*   **New Resource Creation:** Enables users to create new projects, organizations, files, and folders directly from the panel.\n"
    },
    {
        "path": "frontend/src/layout",
        "summary": "The PostHog frontend incorporates a variety of features focused on enhancing user experience, managing application stability, and providing intuitive navigation. These features range from error handling and informative error messages to comprehensive navigation systems, feature previews, and account management tools. The application also includes global modals for various actions like creating organizations, inviting users, and managing payments, as well as adaptive panel layouts for optimal viewing on different devices.\n\nHere's a list of high-level product features:\n\n*   Error Handling and Fallback UI\n*   Network Error Display with Page Reload\n*   Feature Previews (Beta and Coming Soon) with Enrollment and Feedback\n*   Comprehensive Navigation System with Dynamic Side Panel and Customizable Items\n*   Account, Organization, Project, and Environment Management\n*   Contextual Notifications and Alerts\n*   Global Modals for Creation, Invitation, and Management\n*   Adaptive Panel Layout for Desktop and Mobile\n*   Search Functionality with Highlighting\n*   User Assistance and Guidance\n*   Theme Selection and Customization\n*   Project Access Management\n*   Dynamic Messaging Based on User Status\n*   AI Assistant\n*   Activity Notifications\n"
    },
    {
        "path": "frontend/src/toolbar/index.tsx",
        "summary": "This code initializes and renders the PostHog toolbar application within a web page. It dynamically creates a container element, appends it to the document body, and then uses React to render the `ToolbarApp` component inside the container. The toolbar is initialized via the `ph_load_toolbar` function, which takes toolbar parameters and a PostHog instance as input. It also handles a deprecated function `ph_load_editor` for backwards compatibility. The code also checks if the PostHog instance supports feature flags and displays a warning if it doesn't.\n\nHere's a list of high-level product features:\n\n*   **Toolbar Initialization:** Loads and initializes the PostHog toolbar on a webpage.\n*   **Dynamic Rendering:** Dynamically creates and appends the toolbar container to the document body.\n*   **React-based UI:** Renders the toolbar UI using React components.\n*   **Parameter Handling:** Accepts and processes toolbar parameters, including action and experiment IDs.\n*   **PostHog Integration:** Integrates with the PostHog library for feature flag support and other functionalities.\n*   **Feature Flag Warning:** Warns users if the PostHog instance doesn't support feature flags.\n*   **Backwards Compatibility:** Maintains compatibility with older versions through a deprecated function.\n"
    },
    {
        "path": "frontend/src/toolbar/web-vitals/webVitalsToolbarLogic.ts",
        "summary": "This code defines the logic for a web vitals toolbar feature, responsible for fetching and displaying web performance metrics (LCP, FCP, CLS, INP) within a toolbar. It fetches these metrics from a backend API endpoint, and also listens for `$web_vitals` events captured by PostHog to update the metrics in real-time. The logic handles cases where web vitals autocapture is disabled, ensuring no unnecessary API calls are made. It also persists the logic using `permanentlyMount` and resets/fetches data when the URL changes.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Display Web Vitals Metrics:** Shows LCP, FCP, CLS, and INP metrics in a toolbar.\n*   **Fetch Metrics from API:** Fetches web vitals data from a backend API endpoint.\n*   **Real-time Updates:** Listens for PostHog `$web_vitals` events to update metrics in real-time.\n*   **Autocapture Check:** Respects the web vitals autocapture setting, avoiding API calls when disabled.\n*   **URL-based Refresh:** Resets and refetches web vitals data when the URL changes.\n*   **Local Metric Storage:** Stores web vitals metrics locally in the state.\n"
    },
    {
        "path": "frontend/src/toolbar/web-vitals/WebVitalsToolbarMenu.tsx",
        "summary": "This code defines a React component, `WebVitalsToolbarMenu`, which is a toolbar menu that displays web vitals metrics for the current page. It fetches and displays both local (current page load) and remote (aggregated P90 from the last 7 days) web vitals data, including INP, LCP, FCP, and CLS. The component also provides links to the full web vitals report and documentation, and displays a warning banner if web vitals autocapture is not enabled. Each metric is displayed in a card with a tooltip explaining the metric and its performance thresholds.\n\nHere's a list of high-level product features:\n\n*   **Display of Web Vitals Metrics:** Shows key web vitals metrics (INP, LCP, FCP, CLS) in the toolbar.\n*   **Local and Remote Data:** Displays metrics for the current page load and aggregated P90 metrics for the path over the last 7 days.\n*   **Performance Threshold Indicators:** Uses color-coding to indicate whether a metric is within acceptable performance thresholds.\n*   **Metric Descriptions:** Provides tooltips with detailed explanations of each metric and its performance thresholds.\n*   **Links to Reports and Documentation:** Offers links to the full web vitals report and web vitals documentation.\n*   **Autocapture Status Indication:** Displays a warning banner if web vitals autocapture is not enabled, with a link to enable it in settings.\n*   **Loading State:** Shows a spinner while web vitals data is loading.\n"
    },
    {
        "path": "frontend/src/toolbar/web-vitals",
        "summary": "The provided code implements a web vitals toolbar feature that displays key performance metrics directly within the user interface. It fetches both real-time and historical web vitals data, providing insights into the performance of the current page and aggregated trends over time. The toolbar also offers guidance and links to further resources, such as detailed reports and documentation, and alerts users if autocapture is disabled.\n\nHere's a consolidated list of high-level product features:\n\n*   Display of Web Vitals Metrics (INP, LCP, FCP, CLS)\n*   Local (current page load) and Remote (aggregated P90 over 7 days) Data\n*   Performance Threshold Indicators (color-coding)\n*   Metric Descriptions (tooltips)\n*   Links to Reports and Documentation\n*   Autocapture Status Indication (warning banner)\n*   Real-time Updates via PostHog `$web_vitals` events\n*   URL-based Refresh of data\n*   Loading State indicator\n"
    },
    {
        "path": "frontend/src/toolbar/flags/flagsToolbarLogic.ts",
        "summary": "This code defines the logic for a feature flags toolbar, allowing users to view, search, and override feature flag values directly from the toolbar. It fetches user flags from the PostHog API, stores local overrides, and interacts with the PostHog client to apply these overrides. The logic also includes functionality for managing payload overrides, including editing and validating JSON payloads.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Display Feature Flags:** Fetches and displays a list of feature flags and their current values for the user.\n*   **Search Feature Flags:** Allows users to search for specific feature flags by name or key.\n*   **Override Feature Flag Values:** Enables users to override the value of a feature flag for their current session.\n*   **Persist Overrides Locally:** Stores feature flag overrides locally, so they persist across page reloads.\n*   **Payload Overrides:** Supports overriding feature flags with a JSON payload.\n*   **Payload Editor:** Provides a JSON editor for creating and validating payload overrides.\n*   **Integration with PostHog Client:** Interacts with the PostHog client to apply and manage feature flag overrides.\n*   **Display Override Status:** Indicates which feature flags have been overridden.\n"
    },
    {
        "path": "frontend/src/toolbar/flags/FlagsToolbarMenu.tsx",
        "summary": "This React component, `FlagsToolbarMenu`, provides a user interface within a toolbar for managing feature flags. It allows users to search for feature flags, toggle their overridden state for the current browser, and edit/save payload overrides for individual flags. The component fetches feature flags and their current values from both the PostHog client and local storage, displaying them in a searchable list with controls to override the flag's value and edit its payload.\n\nHere's a list of high-level product features:\n\n*   **Feature Flag Search:** Allows users to search for specific feature flags by name.\n*   **Feature Flag Toggle:** Enables users to override the state (on/off) of a feature flag for the current browser session.\n*   **Variant Selection:** Supports feature flags with variants, allowing users to select a specific variant to activate.\n*   **Payload Override:** Provides a JSON editor to override the payload associated with a feature flag.\n*   **Persistent Overrides:** Stores feature flag and payload overrides locally in the browser.\n*   **External Link to Flag Definition:** Links to the feature flag definition in the PostHog project settings.\n*   **Loading State:** Displays a loading indicator while feature flags are being fetched.\n*   **No Flags Message:** Displays a message when no feature flags are found or match the search term.\n"
    },
    {
        "path": "frontend/src/toolbar/flags",
        "summary": "The feature flags toolbar provides a user-friendly interface for viewing, searching, and overriding feature flags directly within the application. Users can quickly find specific flags, toggle their values, and even define custom JSON payloads to simulate different scenarios. Overrides are stored locally, ensuring a consistent experience across sessions, and the toolbar integrates seamlessly with the PostHog client to apply these changes.\n\n**Features:**\n\n*   Display Feature Flags\n*   Search Feature Flags\n*   Override Feature Flag Values (Toggle On/Off)\n*   Variant Selection\n*   Payload Overrides with JSON Editor\n*   Persist Overrides Locally\n*   Integration with PostHog Client\n*   Display Override Status\n*   External Link to Flag Definition\n*   Loading State and No Flags Message\n"
    },
    {
        "path": "frontend/src/toolbar/experiments/WebExperimentVariantHeader.tsx",
        "summary": "This React component, `WebExperimentVariantHeader`, displays information about a specific variant within a web experiment in the PostHog toolbar. It shows the variant's name, indicates if it's the currently applied variant, and displays the rollout percentage. It also includes a button to remove the variant if it's not the control variant and removal is available. The component uses Kea logic for state management and actions.\n\nHere's a list of high-level product features associated with this component:\n\n*   **Display Variant Information:** Shows the name of the experiment variant.\n*   **Indicate Active Variant:** Highlights the variant that is currently applied.\n*   **Show Rollout Percentage:** Displays the percentage of users exposed to the variant.\n*   **Remove Variant:** Allows removal of non-control variants (subject to availability).\n"
    },
    {
        "path": "frontend/src/toolbar/experiments/WebExperimentTransformHeader.tsx",
        "summary": "This React component, `WebExperimentTransformHeader`, is a header for a single transformation within a web experiment variant. It displays the CSS selector associated with the transformation, provides a tooltip for the full selector string, and includes controls for editing the selector and removing the transformation. It also shows a count of elements matching the selector. The component is part of a larger experiment toolbar and interacts with the `experimentsTabLogic` Kea logic for managing experiment state and actions.\n\nHere's a list of high-level features provided by this component:\n\n*   **Display CSS Selector:** Shows the CSS selector for a web experiment transformation.\n*   **Selector Tooltip:** Provides a tooltip displaying the full CSS selector string.\n*   **Element Count:** Displays the number of elements matching the CSS selector.\n*   **Selector Editor:** Allows editing of the CSS selector.\n*   **Transformation Removal:** Enables the removal of the transformation from the experiment variant.\n"
    },
    {
        "path": "frontend/src/toolbar/experiments/ExperimentsListView.tsx",
        "summary": "The `ExperimentsListView.tsx` component displays a list of experiments within the PostHog toolbar. It fetches experiments data and loading state from `experimentsLogic` and uses `experimentsTabLogic` to handle experiment selection. The component renders a list of experiment names as clickable links, each displaying an index. If no experiments are found, it displays a \"No experiments found\" message, or a loading spinner while experiments are being fetched.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Display Experiment List:** Shows a list of available experiments.\n*   **Experiment Selection:** Allows users to select an experiment from the list.\n*   **Loading State:** Displays a loading indicator while experiments are being fetched.\n*   **Empty State:** Shows a message when no experiments are found.\n*   **Search Term Filtering:** Indicates if no matching experiments are found based on a search term.\n*   **Experiment Indexing:** Displays an index number for each experiment in the list.\n"
    },
    {
        "path": "frontend/src/toolbar/experiments/SelectorEditor.tsx",
        "summary": "This code defines a `SelectorEditor` component for the PostHog toolbar, specifically within the experiments tab. It allows users to edit the CSS selector associated with a variant in an experiment. The component provides a button to open a modal containing an input field where the selector can be modified. It validates the selector against the current document and provides feedback to the user. Upon saving, the component dispatches an action to update the selected element based on the new selector.\n\nHere's a list of high-level product features:\n\n*   **Edit CSS Selector:** Allows users to modify the CSS selector used to target elements for experiment variants.\n*   **Selector Validation:** Validates the entered CSS selector against the current document to ensure it's valid and finds an element.\n*   **Real-time Feedback:** Provides feedback to the user on the validity of the selector.\n*   **Modal Interface:** Uses a modal to provide a dedicated space for editing the selector.\n*   **Integration with Experiment Logic:** Dispatches an action to update the selected element in the experiment based on the edited selector.\n"
    },
    {
        "path": "frontend/src/toolbar/ToolbarContainer.tsx",
        "summary": "The `ToolbarContainer` component serves as the main container for the PostHog toolbar, orchestrating the visibility and arrangement of its various elements. It leverages Kea logic for managing the toolbar's configuration and theme, and utilizes React's `useRef` and context providers to manage the toolbar's floating container. The component includes the `Elements`, `ToolbarFixedZones`, `Toolbar`, and `HedgehogButton` components, all wrapped in a `Fade` component to control overall visibility.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Toolbar Visibility Control:** Dynamically shows or hides the toolbar based on configuration.\n*   **Theming:** Applies a theme to the toolbar.\n*   **Element Highlighting:** Provides a way to highlight elements on the page.\n*   **Fixed Toolbar Zones:** Includes fixed zones within the toolbar for specific actions or information.\n*   **Main Toolbar:** Displays the primary toolbar interface.\n*   **Hedgehog Button:** Includes a button, likely for accessing additional features or settings.\n"
    },
    {
        "path": "frontend/src/toolbar/experiments/WebExperimentVariant.tsx",
        "summary": "This component, `WebExperimentVariant`, renders the UI for configuring a specific variant within a web experiment. It allows users to define transformations for each variant, which modify elements on the page. For new variants, it provides an input field to set the variant key. It displays a list of transformations associated with the variant, allowing users to add new transformations and configure existing ones. If no transformations exist, it displays a message indicating that the variant doesn't modify any elements.\n\nHere's a list of high-level product features:\n\n*   **Variant Key Configuration:** Allows users to define or modify the key/name of a variant, especially when creating new experiments.\n*   **Transformation Management:** Enables users to add, view, and configure transformations for each variant.\n*   **Dynamic UI for Transformations:** Renders a dynamic UI for configuring transformations, including headers and fields for each transformation.\n*   **Visual Indication of Empty Variants:** Provides a clear message when a variant has no transformations defined.\n"
    },
    {
        "path": "frontend/src/toolbar/experiments/ExperimentsEditingToolbarMenu.tsx",
        "summary": "This React component, `ExperimentsEditingToolbarMenu`, provides a user interface for creating and editing experiments within a toolbar menu. It leverages the `kea` library for state management and form handling. The component allows users to define experiment names, add and manage variants (including a control variant), and save their experiment configurations. Error handling is included to display validation messages.\n\nHere's a list of high-level product features:\n\n*   **Experiment Creation:** Allows users to create new experiments with a specified name.\n*   **Experiment Editing:** Enables users to modify existing experiments.\n*   **Variant Management:** Supports adding, editing, and deleting variants for an experiment.\n*   **Control Variant:** Provides a designated \"control\" variant representing the original state.\n*   **Variant Selection:** Allows users to select and apply a specific variant for testing.\n*   **Form Validation:** Validates user input and displays error messages.\n*   **Draft Saving:** Supports saving experiments as drafts.\n*   **Toolbar Integration:** Integrates seamlessly within a toolbar menu.\n"
    },
    {
        "path": "frontend/src/toolbar/experiments/experimentsLogic.ts",
        "summary": "This code defines the `experimentsLogic` Kea logic module, responsible for managing and displaying web experiments within the toolbar. It fetches experiments from the PostHog API, handles searching and filtering, and provides selectors for accessing sorted experiments and their count. The logic also includes actions for setting the search term and loaders for fetching, updating, and deleting experiments. It also handles authentication if the user is not authorized to access the experiments.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Experiment Listing:** Fetches and displays a list of web experiments from the PostHog API.\n*   **Experiment Search:** Allows users to search for experiments by name.\n*   **Experiment Filtering:** Filters the list of experiments based on the search term.\n*   **Experiment Counting:** Provides a count of the total number of experiments.\n*   **Experiment Updating:** Updates the list of experiments after an experiment is updated.\n*   **Experiment Deletion:** Updates the list of experiments after an experiment is deleted.\n*   **Authentication Handling:** Handles authentication if the user is not authorized to access the experiments.\n"
    },
    {
        "path": "frontend/src/toolbar/toolbarConfigLogic.ts",
        "summary": "This code defines the logic for the PostHog toolbar configuration using Kea. It manages the toolbar's authentication state, user intent, and configuration persistence. The logic handles authentication, logout, token expiration, and persisting configuration to local storage. It also includes functionality for capturing toolbar events using `toolbarPosthogJS` and provides a `toolbarFetch` function for making authenticated API requests. The toolbar's visibility is also managed by this logic.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Authentication:** Allows users to authenticate with PostHog through the toolbar.\n*   **Logout:** Enables users to log out of their PostHog session from the toolbar.\n*   **Token Management:** Handles API token expiration and automatically prompts for re-authentication.\n*   **Configuration Persistence:** Saves toolbar configuration to local storage, preserving settings across sessions.\n*   **Event Tracking:** Captures toolbar-related events using PostHog for analytics and debugging.\n*   **API Request Authentication:** Provides a utility function (`toolbarFetch`) for making authenticated API requests from the toolbar.\n*   **Toolbar Visibility Control:** Allows showing or hiding the toolbar button.\n*   **User Intent Management:** Stores and clears user intent within the toolbar.\n"
    },
    {
        "path": "frontend/src/toolbar/experiments/ExperimentsToolbarMenu.tsx",
        "summary": "This code defines the `ExperimentsToolbarMenu` component, which is a toolbar menu for managing experiments within a PostHog toolbar. It displays either a list of experiments or an editing interface for a selected experiment. The list view includes a search bar (if there are more than 10 experiments), a list of experiments with their statuses, and options to view all experiments in the PostHog app or create a new experiment. It also displays a warning banner if web experiments are disabled in the PostHog configuration.\n\nHere's a list of high-level product features:\n\n*   **Experiment Listing:** Displays a list of available experiments.\n*   **Experiment Search:** Allows users to search for experiments by name.\n*   **Experiment Creation:** Enables users to create new experiments directly from the toolbar.\n*   **Experiment Editing:** Provides an interface for editing existing experiments (handled by a separate component `ExperimentsEditingToolbarMenu`).\n*   **External Link to Experiments:** Links to the full experiments view within the PostHog application.\n*   **Web Experiment Configuration Warning:** Displays a warning if web experiments are disabled in the PostHog configuration, with a link to documentation.\n"
    },
    {
        "path": "frontend/src/toolbar/experiments/WebExperimentTransformField.tsx",
        "summary": "This code defines a React component, `WebExperimentTransformField`, used within an experiment creation/editing interface. It allows users to visually modify elements on a webpage for A/B testing variants. Users can select an element on the page, then modify its inner HTML and CSS. The component updates both the experiment form state and the actual DOM element in real-time, providing a live preview of the changes.\n\nHere's a list of high-level product features:\n\n*   **Visual Element Selection:** Allows users to select specific elements on a webpage using a cursor-click interface.\n*   **Element Type Filtering:** Provides a dropdown to filter selectable elements by type (e.g., button, text).\n*   **Inner HTML Modification:** Enables users to edit the inner HTML content of a selected element.\n*   **CSS Modification:** Enables users to edit the CSS styles of a selected element.\n*   **Real-time Preview:** Updates the selected element on the page in real-time as the user modifies the HTML and CSS.\n*   **Experiment Form Integration:** Integrates with an experiment form to store the element selector, HTML, and CSS modifications as part of the experiment variant definition.\n"
    },
    {
        "path": "frontend/src/toolbar/experiments/experimentsTabLogic.tsx",
        "summary": "This code defines the logic for the experiments tab within a toolbar, likely used for A/B testing or feature flagging on a website. It manages the state and actions related to creating, editing, and selecting experiments, including variant selection, element targeting, and saving experiment configurations. The logic handles interactions with the PostHog API to persist experiment data and provides functionality for visually inspecting and modifying elements on the page as part of experiment variants.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Experiment Creation:** Allows users to create new web experiments with defined variants.\n*   **Experiment Editing:** Enables users to modify existing web experiments, including their name, variants, and element transformations.\n*   **Variant Management:** Supports adding, removing, and selecting different variants within an experiment.\n*   **Visual Element Targeting:** Provides tools to visually select and target specific HTML elements on a webpage for modification within experiment variants.\n*   **Element Transformation:** Allows users to modify the HTML and CSS of targeted elements for each variant.\n*   **Rollout Percentage Configuration:** Enables users to define the rollout percentage for each variant.\n*   **Experiment Saving:** Persists experiment configurations to the PostHog backend.\n*   **Experiment Selection:** Allows users to select an experiment to view or edit.\n*   **Toolbar Integration:** Integrates with a toolbar to provide a user interface for managing experiments directly on the webpage.\n*   **Real-time Visual Feedback:** Provides real-time visual feedback of experiment variants on the webpage.\n"
    },
    {
        "path": "frontend/src/toolbar/experiments",
        "summary": "The provided code snippets collectively implement a comprehensive suite of features for managing web experiments directly within a toolbar interface. This includes the ability to create, edit, and manage experiments, define variants with specific modifications to webpage elements, and visually preview these changes in real-time. The system also handles experiment listing, searching, and filtering, along with authentication and configuration warnings.\n\nHere's a list of high-level product features:\n\n*   Experiment Creation and Editing: Allows users to create new experiments and modify existing ones, including defining experiment names and managing variants.\n*   Variant Management: Supports adding, editing, deleting, and selecting variants for an experiment, including a designated \"control\" variant.\n*   Visual Element Targeting and Transformation: Provides tools to visually select and target specific HTML elements on a webpage and modify their HTML and CSS for each variant, with real-time previews.\n*   Experiment Listing, Search, and Filtering: Displays a list of available experiments, allows users to search for experiments by name, and filters the list based on the search term.\n*   Rollout Percentage Configuration: Enables users to define the rollout percentage for each variant.\n*   CSS Selector Editing and Validation: Allows users to modify the CSS selector used to target elements for experiment variants and validates the selector against the current document.\n*   Authentication and Configuration Handling: Handles authentication if the user is not authorized to access the experiments and displays a warning if web experiments are disabled in the PostHog configuration.\n*   Toolbar Integration: Integrates seamlessly within a toolbar menu for easy access and management of experiments directly on the webpage.\n"
    },
    {
        "path": "frontend/src/toolbar/elements/AutocaptureElement.tsx",
        "summary": "The `AutocaptureElement` component is a React component that renders a `div` element positioned absolutely on the page, based on the provided `rect` (ElementRect) prop. It takes `rect`, `style`, `onClick`, `onMouseOver`, and `onMouseOut` props to determine its position, size, styling, and event handling. If no `rect` is provided, the component renders nothing. The component is used to highlight and interact with elements on a webpage for autocapture functionality.\n\nHere's a list of high-level product features that this component enables:\n\n*   **Visual Element Highlighting:** Highlights specific elements on a webpage based on their coordinates.\n*   **Click Interaction:** Allows users to click on highlighted elements.\n*   **Hover Interaction:** Provides visual feedback (e.g., change in style) when the user hovers over a highlighted element.\n*   **Autocapture Support:** Enables the automatic capture of user interactions with specific elements on a webpage.\n"
    },
    {
        "path": "frontend/src/toolbar/toolbarPosthogJS.ts",
        "summary": "This code initializes a PostHog instance specifically for the toolbar, using a separate API key and configuration to avoid interfering with the main application's PostHog setup. It configures PostHog to run in memory, avoiding persistence, and provides a React hook `useToolbarFeatureFlag` to easily access and react to feature flag values within the toolbar components. The hook subscribes to changes in the specified feature flag and updates the component's state, allowing for dynamic UI updates based on feature flag status.\n\nHere's a list of high-level product features:\n\n*   **Separate PostHog Instance:** Creates a dedicated PostHog instance for the toolbar, isolated from the main application.\n*   **In-Memory Event Tracking:** Configures PostHog to store events in memory only, preventing data persistence.\n*   **Feature Flag Access Hook:** Provides a React hook (`useToolbarFeatureFlag`) to easily access and react to feature flag values within toolbar components.\n*   **Dynamic UI Updates:** Enables dynamic UI updates in the toolbar based on feature flag status changes.\n*   **PostHog Debug Mode:** Enables debug mode when running inside PostHog and self capture is enabled.\n"
    },
    {
        "path": "frontend/src/toolbar/elements/ElementStatistic.tsx",
        "summary": "The `ElementStatistic` component is a simple React component that displays a title and a value, optionally with a prefix and suffix. It's designed to present key statistics or metrics in a clear and concise manner within the user interface. The component accepts props for the title, value, prefix, and suffix, allowing for flexible customization of the displayed information.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Displaying Key Metrics:** Allows developers to easily display important numerical data or statistics to the user.\n*   **Customizable Formatting:** Provides options for adding prefixes and suffixes to the displayed value, enabling flexible formatting for different types of data (e.g., currency symbols, units of measurement).\n*   **Clear and Concise Presentation:** Presents information in a structured format with a title and value, making it easy for users to understand the data.\n*   **Reusable Component:** Can be used in various parts of the application to display different statistics, promoting code reuse and consistency.\n"
    },
    {
        "path": "frontend/src/toolbar/elements/useMousePosition.ts",
        "summary": "This code defines a custom React hook called `useMousePosition`. This hook tracks the current position of the mouse cursor within the browser window. It utilizes the `useState` hook to store the x and y coordinates of the mouse and the `useEffect` hook to add and remove a `mousemove` event listener on the window. The hook returns an object containing the x and y coordinates of the mouse.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Mouse Position Tracking:** Provides real-time tracking of the mouse cursor's coordinates.\n*   **Dynamic UI Updates:** Enables UI elements to react and update based on the mouse position.\n*   **Interactive Elements:** Supports the creation of interactive elements that respond to mouse movements.\n*   **Crosshair/Targeting Systems:** Can be used to implement crosshairs or targeting systems within the application.\n*   **Drag and Drop Functionality:** Can be a building block for implementing drag-and-drop features.\n"
    },
    {
        "path": "frontend/src/toolbar/elements/FocusRect.tsx",
        "summary": "The `FocusRect` component is responsible for visually highlighting a specific element on the page by drawing a beam or focus rectangle around it. It calculates the element's position and dimensions relative to the viewport and document, then creates a series of divs positioned around the element to form the focus effect. The focus effect is created using absolute positioning and linear gradients to create a visual separation between the element and the rest of the page.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Element Highlighting:** Draws a visual focus rectangle around a selected element.\n*   **Dynamic Positioning:** Calculates and updates the focus rectangle's position based on the element's location and size.\n*   **Viewport Awareness:** Adjusts the focus rectangle's position based on the current viewport.\n*   **Visual Styling:** Uses linear gradients and background blending to create a visually appealing focus effect.\n"
    },
    {
        "path": "frontend/src/toolbar/elements/ElementInfoWindow.tsx",
        "summary": "This code defines a React component, `ElementInfoWindow`, which displays information about a selected or hovered element on a webpage within the PostHog toolbar. It dynamically positions the information window near the element, ensuring it remains within the viewport. The window displays `ElementInfo` and includes a close button if an element is selected, allowing the user to deselect it. The component uses the `elementsLogic` Kea logic to manage the state of selected and hovered elements and their metadata.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Element Information Display:** Shows detailed information about a selected or hovered element on the page.\n*   **Dynamic Positioning:** Positions the information window intelligently near the element, adapting to the viewport size and element location.\n*   **Viewport Awareness:** Ensures the information window remains within the visible area of the browser window.\n*   **Element Deselection:** Provides a close button to deselect the currently selected element.\n*   **Hover and Selection States:** Differentiates between hovered and selected elements, potentially displaying different information or interactions.\n"
    },
    {
        "path": "frontend/src/toolbar/elements/AutocaptureElementLabel.tsx",
        "summary": "This code defines a React component called `AutocaptureElementLabel` that displays a label next to an HTML element on the page. The label is styled with a distinctive yellow background and dark text, designed to stand out. The component receives the element's rectangle dimensions (`rect`), an alignment option (`align`), and the label's text (`children`) as props. It calculates the label's position based on the element's location and the specified alignment, ensuring the label stays within the viewport bounds. The component returns `null` if no rectangle is provided.\n\nHere's a list of high-level product features:\n\n*   **Element Labeling:** Displays a visually distinct label next to a specified HTML element.\n*   **Dynamic Positioning:** Calculates the label's position dynamically based on the element's location and alignment.\n*   **Viewport Awareness:** Ensures the label remains visible within the browser's viewport.\n*   **Customizable Alignment:** Supports left or right alignment of the label relative to the element.\n*   **Styling:** Applies predefined styles for visual prominence (yellow background, dark text, shadow).\n"
    },
    {
        "path": "frontend/src/toolbar/elements/ElementInfo.tsx",
        "summary": "The `ElementInfo` component in the PostHog toolbar provides detailed information about a selected element on a webpage. It displays the element's action step, statistics such as clicks, ranking, autocapture clicks, and rageclicks within a specified date range. It also shows a list of existing actions that include the selected element, and provides a button to create a new action based on the element, with the button's text changing based on whether automatic action creation is enabled.\n\nHere's a list of high-level product features implemented by the code:\n\n*   **Element Selection and Information Display:** Allows users to select an element on a webpage and view its properties.\n*   **Action Step Display:** Shows the action step associated with the selected element.\n*   **Element Statistics:** Displays statistics related to the selected element, including click count, ranking, autocapture clicks, and rageclicks.\n*   **Date Range Filtering:** Allows users to filter element statistics by a specified date range.\n*   **Action Association:** Shows a list of existing actions that include the selected element.\n*   **Action Creation:** Enables users to create a new action based on the selected element.\n*   **Automatic Action Creation Toggle:** Adapts the action creation button based on whether automatic action creation is enabled."
    },
    {
        "path": "frontend/src/toolbar/elements/ScrollDepth.tsx",
        "summary": "This code implements a scroll depth heatmap feature for a toolbar, likely used for website analytics. It visualizes how far users scroll on a page by overlaying color-coded bars, with color intensity representing the percentage of users who scrolled to that depth. A tooltip provides more precise percentage information based on the current mouse position. The heatmap is only displayed when scroll depth heatmap is enabled and configured, and it handles cases where data is loading or unavailable.\n\nHere's a list of high-level product features:\n\n*   **Scroll Depth Heatmap Visualization:** Overlays a heatmap on the page to show scroll depth.\n*   **Color-Coded Depth Indication:** Uses color intensity to represent the percentage of users reaching a specific scroll depth.\n*   **Real-time Mouse Position Percentage:** Displays a tooltip with the percentage of users who scrolled to the mouse's current Y position.\n*   **Loading State Handling:** Shows a \"Loading...\" message while heatmap data is being fetched.\n*   **Data Availability Indication:** Displays a message when no scroll data is available for the current dimension range.\n*   **Customizable Color Palette:** Allows users to select from different color palettes (default, red, green, blue) for the heatmap visualization.\n"
    },
    {
        "path": "frontend/src/toolbar/types.ts",
        "summary": "This code defines various data structures and types used in the PostHog toolbar, primarily focusing on representing user interactions, heatmaps, actions, and web experiments. It includes types for elements events (autocapture, rage clicks), heatmap data, HTML element metadata, action definitions, web experiment drafts and forms, and web experiment variants with conditions and transforms. These types are used to manage and manipulate data related to user behavior tracking, action recording, and A/B testing within the PostHog platform.\n\nHere's a list of high-level product features that can be inferred from the code:\n\n*   **Autocapture and Rage Click Tracking:** Captures user interactions like clicks and rage clicks on web elements.\n*   **Heatmap Visualization:** Generates heatmaps based on user interaction data, showing areas of high activity.\n*   **Action Recording:** Defines and records user actions, including steps and element selectors.\n*   **Web Experiment (A/B Testing) Management:** Creates, edits, and manages web experiments with variants, conditions, and transforms.\n*   **Element Metadata Extraction:** Extracts metadata from HTML elements, such as position, size, and z-index.\n*   **Visual Editor Integration:** Supports a visual editor for defining actions and web experiment variants.\n"
    },
    {
        "path": "frontend/src/toolbar/elements/Heatmap.tsx",
        "summary": "This code defines a React component called `Heatmap` that visualizes user interaction data as a heatmap overlay on the current webpage. It uses the `heatmap.js` library to render the heatmap based on data fetched via the `heatmapLogic` kea logic hook. The component dynamically updates the heatmap based on window size, color palette selection, and the underlying data. It also displays a tooltip with the heatmap value at the current mouse position, which is displayed when the shift key is pressed or when a heatmap value exists at the mouse position.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Heatmap Visualization:** Overlays a heatmap on the webpage to visualize user interaction data.\n*   **Dynamic Data Updates:** Updates the heatmap in real-time as the underlying data changes.\n*   **Customizable Color Palette:** Allows users to select from different color palettes (blue, green, red, or default) for the heatmap.\n*   **Mouse Position Tooltip:** Displays a tooltip showing the heatmap value at the current mouse position.\n*   **Shift Key Activation:** Shows the tooltip when the shift key is pressed, even if the heatmap value is zero.\n*   **Dynamic Resizing:** Recreates the heatmap canvas when the window dimensions change to ensure proper scaling.\n*   **Conditional Rendering:** Only renders the heatmap when it is enabled and the heatmap type is not \"scrolldepth\".\n"
    },
    {
        "path": "frontend/src/toolbar/elements/Elements.tsx",
        "summary": "This code defines the `Elements` component, which is responsible for rendering interactive elements on a webpage within the PostHog toolbar. It displays autocapture elements, heatmap overlays, scroll depth, and element information windows. The component uses Kea logic for state management and interactions, allowing users to inspect elements, view click heatmaps, and understand scroll depth. It dynamically highlights elements on hover and selection, providing visual feedback to the user.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Autocapture Element Highlighting:** Highlights elements on the page that can be autocaptured.\n*   **Element Inspection:** Allows users to select and inspect individual elements on the page.\n*   **Click Heatmap Visualization:** Displays a heatmap overlay showing click density on different elements.\n*   **Rage Click Visualization:** Displays rage click counts on elements.\n*   **Scroll Depth Indication:** Visualizes the scroll depth of the page.\n*   **Element Information Window:** Shows detailed information about a selected element.\n*   **Hover Effects:** Provides visual feedback on hover for interactive elements.\n"
    },
    {
        "path": "frontend/src/toolbar/elements/elementsLogic.ts",
        "summary": "This code defines the `elementsLogic` Kea logic which manages the state and behavior related to element selection, highlighting, and inspection within the PostHog toolbar. It handles enabling/disabling inspect mode, managing hover and selected elements, updating element rectangles, and mapping elements to actions. The logic connects to other Kea logics like `actionsTabLogic`, `currentPageLogic`, `toolbarConfigLogic`, `heatmapLogic`, and `experimentsTabLogic` to access and update relevant state. It also calculates and provides selectors for various element-related data, including elements to display, labels to display, and metadata for selected and hovered elements.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Element Inspection:** Allows users to inspect elements on the page and view their properties.\n*   **Action Creation:** Enables users to create actions based on selected elements.\n*   **Element Highlighting:** Highlights elements on the page based on hover or selection.\n*   **Heatmap Integration:** Integrates with heatmap functionality to display heatmap data on elements.\n*   **Experiment Targeting:** Supports targeting elements for experiments.\n*   **Visual Action Editing:** Provides visual feedback for action steps by highlighting corresponding elements.\n*   **Action Association:** Displays actions associated with specific elements.\n*   **Toolbar Element Display:** Manages the display of elements within the PostHog toolbar.\n"
    },
    {
        "path": "frontend/src/toolbar/utils.ts",
        "summary": "This code provides utility functions for the PostHog toolbar, focusing on identifying and interacting with elements on a webpage for autocapture and action step creation. It includes functions for generating CSS selectors, extracting text content, finding clickable elements, determining element visibility, and converting elements into action steps. Additionally, it offers functionalities for calculating element bounding rectangles, handling zoom levels, and generating heatmap hues for visual representation.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Autocapture Element Identification:** Automatically identifies and selects relevant elements on a webpage for event tracking.\n*   **CSS Selector Generation:** Generates unique CSS selectors for elements, enabling precise targeting for event tracking and action definition.\n*   **Clickable Element Detection:** Detects elements with click handlers or pointer cursors, facilitating the identification of interactive elements.\n*   **Action Step Creation:** Converts selected elements into action steps, defining user interactions to be tracked.\n*   **Element Visibility Check:** Determines if an element is visible on the page, ensuring that only visible elements are considered for tracking.\n*   **Element Bounding Rectangle Calculation:** Calculates the bounding rectangle of an element, providing positional information for visual representation and interaction.\n*   **Heatmap Visualization:** Generates heatmap hues based on event counts, enabling visual representation of user interaction intensity.\n*   **Toolbar Element Handling:** Prevents the toolbar itself from being selected as a target for autocapture.\n*   **URL Matching:** Compares the current URL with the URL specified in an action step, allowing for conditional event tracking based on the page URL.\n*   **Zoom Level Handling:** Accounts for zoom levels when calculating element rectangles, ensuring accurate positioning on zoomed pages."
    },
    {
        "path": "frontend/src/toolbar/elements/heatmapLogic.ts",
        "summary": "This code defines the logic for handling heatmap and clickmap functionality within a toolbar. It manages the state of heatmap settings, fetches element statistics and raw heatmap data from the backend, and processes this data to identify and highlight elements on the page based on their interaction counts. The logic also includes features for filtering heatmap data by date range, URL, and other criteria, as well as options for customizing the heatmap's appearance and behavior.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Heatmap Visualization:** Displays a heatmap overlay on the current webpage, visually representing user interaction intensity on different elements.\n*   **Clickmap Visualization:** Displays a clickmap overlay on the current webpage, visually representing user click intensity on different elements.\n*   **Element Statistics:** Fetches and displays statistics about user interactions with specific elements on the page.\n*   **Data Filtering:** Allows users to filter heatmap data by date range, URL (exact or wildcard), and other properties.\n*   **Customizable Heatmap Appearance:** Provides options to customize the heatmap's color palette and other visual settings.\n*   **Scroll Depth Tracking:** Supports tracking and visualizing scroll depth as part of the heatmap data (if the PostHog version supports it).\n*   **Fixed Position Mode:** Allows the heatmap to be displayed in a fixed position relative to the viewport.\n*   **Dynamic Element Identification:** Identifies elements on the page based on their selectors, even within shadow DOMs.\n*   **Toolbar Integration:** Integrates with the toolbar configuration and authentication logic.\n*   **Data Attribute Handling:** Respects data attributes when identifying elements.\n*   **Link Matching:** Provides options to match links by href.\n"
    },
    {
        "path": "frontend/src/toolbar/elements",
        "summary": "The code collectively implements a suite of features focused on visual website analytics and interactive element inspection within a toolbar environment. It provides real-time tracking of user interactions, including clicks, rage clicks, and scroll depth, visualized through heatmaps and clickmaps. Users can select and inspect individual elements to view detailed statistics, associated actions, and create new actions based on those elements. The system dynamically highlights elements on hover or selection, ensuring visual clarity and ease of use, and adapts to viewport changes for consistent presentation.\n\nHere's a list of high-level product features:\n\n*   **Heatmap Visualization:** Displays user interaction intensity on a webpage as a heatmap overlay.\n*   **Clickmap Visualization:** Displays user click intensity on a webpage as a clickmap overlay.\n*   **Scroll Depth Visualization:** Visualizes how far users scroll on a page.\n*   **Element Inspection:** Allows users to select and inspect elements on a webpage.\n*   **Element Highlighting:** Highlights elements on hover and selection for visual clarity.\n*   **Element Statistics:** Displays statistics about user interactions with specific elements.\n*   **Action Creation:** Enables users to create new actions based on selected elements.\n*   **Dynamic Positioning:** Positions UI elements (labels, information windows) dynamically based on element location and viewport size.\n*   **Data Filtering:** Allows users to filter heatmap data by date range, URL, and other properties.\n*   **Customizable Appearance:** Provides options to customize the appearance of heatmaps and other visual elements.\n"
    },
    {
        "path": "frontend/src/toolbar/actions/SelectorCount.tsx",
        "summary": "This React component, `SelectorCount`, takes a CSS selector string as input and displays the number of elements on the page that match that selector. It uses `querySelectorAllDeep` to query the DOM, including within shadow DOMs. If the selector is invalid, it displays an error message. The component only renders when a selector is provided.\n\n**Features:**\n\n*   **Selector Matching:** Counts the number of DOM elements that match a given CSS selector.\n*   **Shadow DOM Support:** Uses `querySelectorAllDeep` to search within shadow DOMs.\n*   **Error Handling:** Displays an error message if the provided selector is invalid.\n*   **Dynamic Updates:** Recalculates the match count whenever the selector changes.\n*   **Conditional Rendering:** Only renders when a selector is provided.\n"
    },
    {
        "path": "frontend/src/toolbar/actions/ActionsListView.tsx",
        "summary": "This React component, `ActionsListView`, displays a list of actions within the PostHog toolbar. It fetches actions data and loading state using Kea logic. The component renders a list of action names as clickable links. Clicking a link triggers the `selectAction` function, likely to display action details elsewhere. A loading spinner is shown while actions are loading, and a \"no actions found\" message is displayed when no actions are available or match the current search term.\n\nHere's a list of high-level product features:\n\n*   **Display Action List:** Renders a list of available actions.\n*   **Action Selection:** Allows users to select an action from the list.\n*   **Loading State:** Shows a loading indicator while actions are being fetched.\n*   **Search Results:** Displays a \"no actions found\" message when no actions match the search.\n*   **Action Naming:** Displays \"Untitled\" when an action has no name.\n"
    },
    {
        "path": "frontend/src/toolbar/actions/ActionStep.tsx",
        "summary": "This React component, `ActionStep`, is responsible for rendering the attributes of a specific action step within a toolbar or interface for managing user actions. It dynamically displays attributes like `text`, `name`, `href`, and `selector` based on the `actionStep` prop it receives. The component also conditionally renders the `url` attribute based on whether automatic action creation is enabled. It utilizes the `ActionAttribute` component to display and potentially edit each attribute.\n\nHere's a list of high-level features provided by this component:\n\n*   **Dynamic Attribute Display:** Renders action step attributes (text, name, href, selector) based on the provided data.\n*   **Conditional URL Display:** Shows or hides the URL attribute based on the automatic action creation setting.\n*   **Attribute Editing:** Leverages the `ActionAttribute` component, implying the ability to edit the displayed attributes.\n*   **Action Step Visualization:** Provides a structured view of the properties associated with a specific action step.\n"
    },
    {
        "path": "frontend/src/toolbar/actions/ActionAttribute.tsx",
        "summary": "This code defines a React component, `ActionAttribute`, that displays an attribute of an action step within a PostHog actions tab. It renders the attribute's value with an appropriate icon and formatting, including links for `href` attributes and special formatting for `selector` attributes. It also includes a LemonSwitch component that allows users to toggle whether the attribute should be included in automatically created actions, controlled by the `actionsTabLogic`.\n\nHere's a list of high-level product features:\n\n*   **Display Action Attributes:** Shows key-value pairs representing properties of an action step (e.g., text, href, selector).\n*   **Formatted Attribute Values:** Renders attribute values in a user-friendly format, including clickable links for URLs and special formatting for CSS selectors.\n*   **Automatic Action Creation Control:** Allows users to specify which attributes should be included when automatically creating actions based on user interactions.\n*   **Unique Selector Highlighting:** Highlights the last part of a CSS selector string for better readability.\n*   **Selector Generation Guidance:** Provides guidance to users on how to improve selector generation by adding unique `id` or `data-attr` attributes to elements.\n"
    },
    {
        "path": "frontend/src/toolbar/actions/actionsLogic.ts",
        "summary": "This code defines a Kea logic module named `actionsLogic` responsible for managing and displaying a list of actions fetched from the PostHog API within the toolbar. It handles fetching actions, searching through them, and sorting them alphabetically. The logic also includes reducers for managing the search term and selectors for deriving sorted and filtered action lists, as well as the total action count. It also handles authentication if the API returns a 403 error.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Fetch Actions:** Fetches a list of actions from the PostHog API.\n*   **Action Search:** Allows users to search for actions by name using fuzzy search.\n*   **Action Sorting:** Sorts the list of actions alphabetically by name.\n*   **Action Display:** Provides a sorted and filtered list of actions for display in the UI.\n*   **Action Management:** Provides functionality to update and delete actions in the list.\n*   **Action Count:** Exposes the total number of actions.\n*   **Authentication Handling:** Handles authentication with the PostHog API.\n"
    },
    {
        "path": "frontend/src/toolbar/actions/SelectorEditingModal.tsx",
        "summary": "This React component, `SelectorEditingModal`, provides a modal interface for editing CSS selectors. It displays a chain of HTML elements, allowing users to interactively build a selector by clicking on elements and their attributes. The modal includes \"Cancel\" and \"Apply\" buttons, enabling users to discard or save their changes. The `HTMLElementsDisplay` component within the modal handles the interactive element selection and selector generation.\n\nHere's a list of high-level product features:\n\n*   **Interactive CSS Selector Editing:** Allows users to visually build and modify CSS selectors by interacting with a displayed chain of HTML elements.\n*   **HTML Element Chain Display:** Presents a structured view of the HTML element hierarchy, enabling users to understand the context of the selector.\n*   **Real-time Selector Generation:** Dynamically updates the CSS selector as the user interacts with the HTML elements.\n*   **Uniqueness Checking:** Validates the generated selector to ensure it uniquely identifies the target element.\n*   **Modal Interface:** Provides a focused and isolated environment for editing selectors, preventing interference with other parts of the application.\n*   **Cancel and Apply Actions:** Allows users to discard or save the changes made to the CSS selector.\n"
    },
    {
        "path": "frontend/src/toolbar/actions/ActionsToolbarMenu.tsx",
        "summary": "This code defines the `ActionsToolbarMenu` component, which is responsible for displaying and managing actions within the PostHog toolbar. It features a search input for filtering actions, a list view to display the actions, and options to create a new action or view/edit all actions in the PostHog application. The component dynamically switches between displaying a list of actions and an editing interface for a selected action. It fetches and displays actions, providing a user interface for interacting with them directly from the toolbar.\n\nHere's a list of high-level product features:\n\n*   **Action Search:** Allows users to search for specific actions within the toolbar.\n*   **Action List View:** Displays a list of available actions.\n*   **Action Creation:** Enables users to create new actions directly from the toolbar.\n*   **External Action Management Link:** Provides a link to view and edit all actions in the main PostHog application.\n*   **Dynamic Menu Switching:** Switches between the action list view and an action editing interface based on whether an action is selected.\n*   **Loading State:** Displays a spinner while actions are being fetched.\n"
    },
    {
        "path": "frontend/src/toolbar/ToolbarApp.tsx",
        "summary": "This code defines the main application component for the PostHog toolbar, which is injected into a webpage as a shadow DOM element. It dynamically loads the toolbar's CSS from the PostHog CDN, manages the mounting of other toolbar features, and renders the core `ToolbarContainer` component. It also includes a workaround to prevent conflicts with other libraries that might be listening to global mouse events. The component uses `react-toastify` to display toast notifications.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Toolbar Injection:** Injects the PostHog toolbar into a webpage as a shadow DOM element.\n*   **Dynamic CSS Loading:** Loads the toolbar's CSS dynamically from the PostHog CDN, with cache-busting.\n*   **Web Vitals Tracking:** Collects and displays web vitals metrics.\n*   **Event Debugging:** (Implied by TODO) Provides tools for debugging events on the page.\n*   **UI Components:** Renders the core toolbar UI, including buttons, panels, and other interactive elements.\n*   **Toast Notifications:** Displays toast notifications for important events or messages.\n*   **Conflict Resolution:** Implements a workaround to prevent conflicts with other libraries that might be listening to global mouse events.\n"
    },
    {
        "path": "frontend/src/toolbar/actions/ActionsEditingToolbarMenu.tsx",
        "summary": "This code defines the `ActionsEditingToolbarMenu` component, which is a form within a toolbar menu used for creating or editing actions. It allows users to define the action's name and specify a series of steps, each representing an element interaction. For each step, users can select an element on the page using the toolbar's inspection tool, define CSS selectors, link targets (href), text content, and page URLs to precisely target the interaction. The component also includes functionality to add, remove, and edit these steps, as well as delete the entire action.\n\nHere's a list of high-level product features:\n\n*   **Action Creation/Editing:** Allows users to create new actions or modify existing ones.\n*   **Action Naming:** Enables users to define a descriptive name for each action.\n*   **Multi-Step Definition:** Supports defining actions as a sequence of element interactions (steps).\n*   **Element Selection via Inspection:** Integrates with the toolbar's inspection tool to visually select elements on the page for each step.\n*   **CSS Selector Definition:** Allows users to manually define or edit CSS selectors for each element interaction.\n*   **Targeting by Link (href), Text, and URL:** Provides options to further refine element targeting based on link targets, text content, and the page URL.\n*   **Step Management:** Enables users to add, remove, and reorder steps within an action.\n*   **Action Deletion:** Allows users to delete existing actions.\n*   **Manual Selector Editing:** Opens a modal to manually edit the CSS selector for a step."
    },
    {
        "path": "frontend/src/toolbar/actions/StepField.tsx",
        "summary": "This code defines a `StepField` component used within a form for defining action steps, likely in a web application toolbar. The component allows users to specify and configure different properties of an action step, such as the URL, href, text, or selector. Each property has a checkbox to enable/disable it, a segmented button to select the matching type (exact, regex, contains) for URL, href, and text, and an input field (either text area or regular input) to enter the value. It also displays selector counts for href and selector types and provides hints for URL matching.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Action Step Configuration:** Allows users to define and configure individual steps within a larger action.\n*   **Property Selection:** Enables users to select which properties (URL, href, text, selector) are relevant for a specific action step.\n*   **Matching Type Specification:** Provides options to define how a property should be matched (exact, regex, contains).\n*   **Input Fields for Properties:** Offers input fields (text area or regular input) for users to enter the values for each selected property.\n*   **Selector Count Display:** Shows the number of elements matching a given selector or href, providing immediate feedback to the user.\n*   **URL Matching Hints:** Displays helpful hints based on the selected URL matching type.\n*   **Enable/Disable fields:** Allows users to enable or disable fields via a checkbox.\n"
    },
    {
        "path": "frontend/src/toolbar/actions/actionsTabLogic.tsx",
        "summary": "This code defines the logic for the \"Actions\" tab within a toolbar, likely for a product analytics tool like PostHog. It manages the creation, editing, and deletion of actions, which are user interactions tracked on a website. The logic handles form state, API interactions, and UI updates related to action management. It also supports automatic action creation during onboarding.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Action Creation:** Allows users to create new actions by specifying a name and defining steps based on element interactions.\n*   **Action Editing:** Enables users to modify existing actions, including their name and steps.\n*   **Action Deletion:** Provides the ability to remove actions.\n*   **Visual Action Definition:** Supports visually selecting elements on a webpage to define action steps.\n*   **Automatic Action Creation:** Facilitates automatic action creation during onboarding, simplifying the initial setup process.\n*   **Action Step Configuration:** Allows users to configure properties to include in action steps.\n*   **Form Management:** Manages the state and validation of the action form.\n*   **API Integration:** Interacts with the backend API to save, update, and delete actions.\n*   **UI Updates:** Updates the UI to reflect changes in action state, such as selection and form values.\n*   **Tooltip Display:** Shows a tooltip for actions.\n*   **Element Selector Editing:** Allows editing of the element selector for action steps."
    },
    {
        "path": "frontend/src/toolbar/actions",
        "summary": "The provided code collectively implements a comprehensive action management system within a toolbar interface, likely for a product analytics platform. This system allows users to create, edit, and manage user interaction actions directly from the toolbar, streamlining the process of defining and tracking key events on a website.  The system features visual element selection, CSS selector editing, multi-step action definition, and integration with the PostHog API for persistent storage and retrieval of actions.\n\nHere's a list of high-level product features:\n\n*   **Action Creation and Editing:**  Create new actions or modify existing ones with a user-friendly interface.\n*   **Visual Element Selection:**  Visually select elements on a webpage to define action steps using an inspection tool.\n*   **CSS Selector Management:**  Define, edit, and validate CSS selectors for precise element targeting, including interactive editing and uniqueness checking.\n*   **Multi-Step Action Definition:**  Define actions as a sequence of element interactions, allowing for complex event tracking.\n*   **Action Search and Filtering:**  Search for specific actions by name.\n*   **Action List Display:**  Display a list of available actions with loading and empty state indicators.\n*   **Action Attribute Configuration:**  Configure properties to include in action steps, such as URL, href, text, and selector, with options for matching types (exact, regex, contains).\n*   **Automatic Action Creation:**  Facilitate automatic action creation during onboarding.\n*   **API Integration:**  Interact with the backend API to save, update, and delete actions.\n*   **Action Management:** Delete and sort actions.\n"
    },
    {
        "path": "frontend/src/toolbar/bar/ToolbarFixedZones.tsx",
        "summary": "This code defines React components for displaying fixed zones on a toolbar while an element is being dragged. The `ToolbarFixedZones` component renders a set of `ToolbarFixedZone` components, which are visual indicators representing potential drop locations for the dragged element. These zones are positioned based on coordinates defined in the `fixedPositions` state within the `toolbarLogic`. The appearance of a zone changes (opacity and scale) to indicate whether it's the currently selected drop target.\n\n**Features:**\n\n*   **Visual Drop Zones:** Displays visual cues to guide users where they can drop a dragged element on the toolbar.\n*   **Dynamic Positioning:** Drop zones are positioned dynamically based on predefined coordinates.\n*   **Selected Zone Highlighting:** Highlights the currently selected drop zone to provide clear feedback to the user.\n*   **Drag-and-Drop Integration:** Designed to work in conjunction with a drag-and-drop interaction, providing visual assistance during the drag operation.\n"
    },
    {
        "path": "frontend/src/toolbar/bar/ToolbarMenu.tsx",
        "summary": "This code defines a `ToolbarMenu` component in React, composed of `Header`, `Body`, and `Footer` sub-components. It provides a structured way to create menus within a toolbar, with built-in styling for layout, scrolling, and consistent appearance. The component uses `clsx` for conditional class names, allowing for customization through the `className` prop.\n\nHere's a list of high-level features:\n\n*   **Toolbar Menu Container:** A main container component to hold the menu elements.\n*   **Header Section:** A dedicated section for the menu header, typically used for titles or descriptions.\n*   **Scrollable Body Section:** A scrollable area for the main content of the menu.\n*   **Footer Section:** A section at the bottom of the menu, often used for actions or additional information.\n*   **Customizable Styling:** Ability to apply custom CSS classes to each section for flexible styling.\n"
    },
    {
        "path": "frontend/src/toolbar/bar/ToolbarButton.tsx",
        "summary": "This code defines a `ToolbarButton` component for a React-based toolbar. The button handles click events, manages active states based on a visible menu, and displays tooltips for accessibility, especially when the toolbar is minimized. It utilizes the `kea` library for state management and `clsx` for conditional styling. The button also prevents actions when the user is dragging.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Interactive Toolbar Buttons:** Provides clickable buttons within a toolbar interface.\n*   **Active State Indication:** Visually highlights the currently active button.\n*   **Tooltip Support:** Displays helpful tooltips on hover, especially when the toolbar is minimized.\n*   **Menu Integration:** Connects buttons to specific menu states, controlling menu visibility.\n*   **Drag Prevention:** Prevents button actions during drag operations.\n*   **Flexible Styling:** Allows for flexible styling and layout within the toolbar.\n"
    },
    {
        "path": "frontend/src/toolbar/bar/Toolbar.tsx",
        "summary": "This code defines the main toolbar component for a PostHog web application. The toolbar provides a set of tools for inspecting the page, managing feature flags, debugging events, viewing web vitals, and running experiments. It includes features like authentication, minimization, drag-and-drop positioning, theme switching, and a \"hedgehog mode\" for advanced debugging. The toolbar dynamically renders different menus based on the selected tool and user authentication status.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Toolbar Minimization/Expansion:** Allows users to collapse the toolbar to a smaller icon.\n*   **Drag and Drop Positioning:** Enables users to move the toolbar around the screen.\n*   **Authentication:** Requires users to authenticate to access advanced toolbar features.\n*   **Element Inspection:** Provides a tool to inspect elements on the page.\n*   **Heatmap Visualization:** Integrates with heatmap functionality to visualize user interaction.\n*   **Feature Flag Management:** Allows users to view and manage feature flags.\n*   **Event Debugging:** Provides a tool to debug events happening on the page.\n*   **Web Vitals Monitoring:** Displays key web performance metrics.\n*   **Experiment Management:** Enables users to manage and view experiments (A/B tests).\n*   **Theme Switching:** Allows users to switch between light and dark themes.\n*   **Hedgehog Mode:** Offers advanced debugging options.\n*   **Keyboard Shortcuts:** Supports keyboard shortcuts for common actions.\n"
    },
    {
        "path": "frontend/src/toolbar/bar/toolbarLogic.ts",
        "summary": "This code defines the logic for a toolbar component within a web application, likely for PostHog. It manages the toolbar's state, including its visibility, theme, position, and interaction with other features like heatmap, actions, experiments, and a \"Hedgehog Buddy\" assistant. The toolbar can be dragged and repositioned, minimized, and themed. It also handles interactions with the window, such as resizing, and manages the display of different menus within the toolbar.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Toolbar Display and Customization:**\n    *   Toggle visibility of different menus (heatmap, actions, experiments, flags, inspect, hedgehog, debugger, web-vitals).\n    *   Theme selection (light/dark).\n    *   Minimization/expansion of the toolbar.\n    *   Draggable and repositionable toolbar.\n    *   Fixed position options (top-left, top-center, etc.).\n*   **Feature Integration:**\n    *   Integration with heatmap functionality (enabling/disabling, patching filters, setting color palette, etc.).\n    *   Integration with action creation and management.\n    *   Integration with experiments functionality.\n    *   Integration with element inspection tools.\n    *   Integration with a \"Hedgehog Buddy\" assistant (animations, dragging interaction).\n*   **User Interaction:**\n    *   Click and drag functionality for repositioning.\n    *   Menu display based on toolbar position and window size.\n    *   Blur handling (e.g., when clicking outside the toolbar).\n*   **State Management:**\n    *   Persistence of toolbar settings (theme, position, minimized state, hedgehog mode).\n    *   Window size awareness for positioning.\n"
    },
    {
        "path": "frontend/src/toolbar/bar",
        "summary": "The provided code collectively defines a highly customizable and feature-rich toolbar for a web application, likely PostHog, designed to aid in debugging, experimentation, and feature management. The toolbar offers a range of functionalities from basic UI elements like draggable positioning, theme switching, and button interactions to more advanced features such as element inspection, heatmap visualization, feature flag management, and experiment control. The toolbar's logic manages its state, persistence, and integration with other application features, while the menu components provide a structured way to organize and display options within the toolbar.\n\nHere's a list of high-level product features:\n\n*   Toolbar Minimization/Expansion\n*   Drag and Drop Positioning with Visual Drop Zones\n*   Authentication\n*   Theme Switching\n*   Interactive Toolbar Buttons with Active State Indication and Tooltips\n*   Element Inspection\n*   Heatmap Visualization and Configuration\n*   Feature Flag Management\n*   Event Debugging\n*   Web Vitals Monitoring\n*   Experiment Management\n*   Keyboard Shortcuts\n*   Customizable Menus with Header, Scrollable Body, and Footer Sections\n*   Hedgehog Mode for Advanced Debugging\n*   Persistence of Toolbar Settings\n"
    },
    {
        "path": "frontend/src/toolbar/hedgehog/HedgehogButton.tsx",
        "summary": "The `HedgehogButton` component in the PostHog toolbar provides an interactive HedgehogBuddy interface when Hedgehog mode is enabled. It manages the HedgehogBuddy's visibility, position synchronization with the toolbar, and integrates with heatmap functionality by setting the Hedgehog \"on fire\" when heatmaps are enabled. It also sets up keyboard listeners for the Hedgehog actor.\n\nHere's a list of high-level product features:\n\n*   **Hedgehog Mode Integration:** Enables and displays the HedgehogBuddy interface within the PostHog toolbar.\n*   **Interactive HedgehogBuddy:** Provides a visual and interactive element (HedgehogBuddy) for user interaction.\n*   **Position Synchronization:** Keeps the HedgehogBuddy's position in sync with the toolbar.\n*   **Heatmap Integration:** Visually indicates heatmap activation status on the HedgehogBuddy.\n*   **Keyboard Listener Setup:** Sets up keyboard listeners for the Hedgehog actor.\n"
    },
    {
        "path": "frontend/src/toolbar/hedgehog/HedgehogMenu.tsx",
        "summary": "The `HedgehogMenu.tsx` file defines a component within the PostHog toolbar that presents options related to the \"Hedgehog\" feature. It leverages the `ToolbarMenu` component for structure, displaying `HedgehogOptions` in the body and providing two buttons in the footer: one to disable \"Hedgehog Mode\" and another to close the menu and continue. The component uses `kea` actions to manage the state of the toolbar, specifically controlling the \"Hedgehog Mode\" and the visibility of the menu.\n\nHere's a list of high-level product features:\n\n*   **Hedgehog Mode Configuration:** Allows users to configure options related to the \"Hedgehog\" feature.\n*   **Enable/Disable Hedgehog Mode:** Provides a way to toggle the \"Hedgehog\" feature on or off.\n*   **Toolbar Menu Integration:** Integrates the Hedgehog options into the PostHog toolbar.\n*   **Menu Navigation:** Allows users to close the Hedgehog menu and return to the previous toolbar state.\n"
    },
    {
        "path": "frontend/src/toolbar/hedgehog",
        "summary": "The HedgehogMenu and HedgehogButton components work together to provide a user interface within the PostHog toolbar for interacting with the \"Hedgehog\" feature. The menu allows users to configure Hedgehog options and toggle Hedgehog mode on or off, while the button displays an interactive HedgehogBuddy that integrates with heatmap functionality and responds to keyboard input. The HedgehogBuddy's position is synchronized with the toolbar, providing a consistent user experience.\n\nHere's a list of high-level product features:\n\n*   **Hedgehog Mode Configuration:** Allows users to configure options related to the \"Hedgehog\" feature.\n*   **Enable/Disable Hedgehog Mode:** Provides a way to toggle the \"Hedgehog\" feature on or off.\n*   **Interactive HedgehogBuddy:** Provides a visual and interactive element (HedgehogBuddy) for user interaction.\n*   **Toolbar Menu Integration:** Integrates the Hedgehog options into the PostHog toolbar.\n*   **Menu Navigation:** Allows users to close the Hedgehog menu and return to the previous toolbar state.\n*   **Position Synchronization:** Keeps the HedgehogBuddy's position in sync with the toolbar.\n*   **Heatmap Integration:** Visually indicates heatmap activation status on the HedgehogBuddy.\n*   **Keyboard Listener Setup:** Sets up keyboard listeners for the Hedgehog actor.\n"
    },
    {
        "path": "frontend/src/toolbar/assets/Logomark.tsx",
        "summary": "The code defines a React component called `Logomark` that renders an SVG image. This SVG appears to be a stylized logo composed of several colored shapes. The logo is likely a visual element used for branding or identification within the application.\n\nHere's a list of high-level product features related to the code:\n\n*   **Visual Branding:** Displays a unique logomark to represent the application or company.\n*   **User Interface Element:** Provides a graphical element for the user interface, enhancing visual appeal.\n*   **Scalable Vector Graphic:** Uses SVG format to ensure the logo renders crisply at various sizes and resolutions.\n*   **Consistent Design:** Ensures a consistent visual identity across the application.\n"
    },
    {
        "path": "frontend/src/toolbar/assets/Logo.tsx",
        "summary": "The `Logo.tsx` file defines a React component called `Logo` that renders an SVG image representing the application's logo. The logo is constructed using various shapes and paths with specific fill colors defined by CSS variables. The component accepts an optional `style` prop to allow for custom styling of the SVG element.\n\nHere's a list of high-level product features related to the logo component:\n\n*   **Brand Representation:** Displays the application's logo, reinforcing brand identity.\n*   **Customizable Styling:** Allows for modification of the logo's appearance through the `style` prop.\n*   **Vector Graphics:** Uses SVG format for scalability and crisp rendering across different screen sizes.\n*   **Theming Support:** Leverages CSS variables for colors, enabling easy adaptation to different themes.\n"
    },
    {
        "path": "frontend/src/toolbar/assets",
        "summary": "The code defines two React components, `Logomark` and `Logo`, both responsible for rendering SVG images that serve as visual branding elements for the application. These components utilize SVG format for scalability and crisp rendering across various screen sizes and resolutions. The `Logo` component further supports customizable styling through a `style` prop and theming via CSS variables for colors.\n\nHere's a list of high-level product features:\n\n*   **Visual Branding:** Displays a unique logomark and logo to represent the application or company.\n*   **User Interface Element:** Provides graphical elements for the user interface, enhancing visual appeal.\n*   **Scalable Vector Graphics:** Uses SVG format to ensure the logo renders crisply at various sizes and resolutions.\n*   **Consistent Design:** Ensures a consistent visual identity across the application.\n*   **Customizable Styling:** Allows for modification of the logo's appearance through styling props.\n*   **Theming Support:** Leverages CSS variables for colors, enabling easy adaptation to different themes.\n"
    },
    {
        "path": "frontend/src/toolbar/stats/currentPageLogic.ts",
        "summary": "This code defines a Kea logic module called `currentPageLogic` that manages the current page's URL for the PostHog toolbar. It stores both the exact URL (`href`) and a \"wildcard\" version (`wildcardHref`) where dynamic parts like UUIDs and numbers are replaced with asterisks. The logic automatically updates the stored URLs when the actual URL changes, and it provides actions to manually set them. It also includes a mechanism to remove PostHog initialization fragments from the URL and a temporary fix for a previous bug related to URL storage.\n\nHere's a list of high-level product features provided by this code:\n\n*   **URL Tracking:** Tracks the current URL of the page the toolbar is active on.\n*   **Wildcard URL Generation:** Creates a generalized version of the URL by replacing dynamic segments with wildcards.\n*   **Automatic URL Updates:** Automatically updates the stored URLs when the page URL changes.\n*   **PostHog Fragment Removal:** Removes PostHog-specific initialization fragments from the URL.\n*   **URL Sanitization:** Sanitizes URLs by replacing UUIDs, digits, and long values with wildcards.\n*   **Bug Fix:** Implements a temporary fix for a previous URL storage issue.\n"
    },
    {
        "path": "frontend/src/toolbar/stats/HeatmapToolbarMenu.tsx",
        "summary": "This code defines the `HeatmapToolbarMenu` component, a React-based toolbar menu for configuring and displaying heatmaps and clickmaps within a PostHog toolbar. It allows users to filter data by URL (with wildcard support) and date range, toggle heatmaps and clickmaps, adjust heatmap settings (color palette, fixed position mode), and load more element stats for clickmaps. The component also displays warnings if heatmap collection is not enabled in the PostHog project or if the posthog-js version is outdated. For clickmaps, it shows a list of elements with their click counts and allows users to highlight and select elements.\n\nHere's a list of high-level product features:\n\n*   **Heatmap Visualization:** Enables the display of heatmaps overlaid on the current webpage.\n*   **Clickmap Visualization:** Enables the display of clickmaps overlaid on the current webpage.\n*   **URL Filtering with Wildcard Support:** Allows users to filter heatmap and clickmap data based on the URL of the page, with support for wildcard characters to match multiple URLs.\n*   **Date Range Filtering:** Allows users to filter heatmap and clickmap data based on a specific date range.\n*   **Heatmap Settings Configuration:** Provides settings to customize the appearance and behavior of heatmaps, such as color palette and fixed position mode.\n*   **Clickmap Element Statistics:** Displays a list of elements on the page with their corresponding click counts.\n*   **Element Highlighting and Selection:** Allows users to highlight elements on the page by hovering over them in the clickmap list and select elements for further inspection.\n*   **Heatmap Collection Status Indication:** Displays warnings if heatmap collection is not enabled or if the posthog-js version is outdated.\n*   **Link Matching Configuration:** Allows users to configure whether clickmaps should match links by their target URL.\n*   **Lazy Loading of Element Statistics:** Provides a \"Load more\" button to load additional element statistics for clickmaps."
    },
    {
        "path": "frontend/src/toolbar/stats",
        "summary": "The provided code implements a React-based toolbar menu and associated logic for visualizing and configuring heatmaps and clickmaps within a PostHog toolbar. The `HeatmapToolbarMenu` component allows users to filter data by URL (with wildcard support) and date range, toggle heatmap and clickmap visualizations, adjust heatmap settings, and view clickmap element statistics with highlighting and selection capabilities. The `currentPageLogic` module manages the current page's URL, generating a wildcard version and automatically updating it upon changes, while also sanitizing the URL and removing PostHog initialization fragments.\n\nHere's a list of high-level product features:\n\n*   Heatmap Visualization\n*   Clickmap Visualization\n*   URL Filtering with Wildcard Support\n*   Date Range Filtering\n*   Heatmap Settings Configuration\n*   Clickmap Element Statistics\n*   Element Highlighting and Selection\n*   Heatmap Collection Status Indication\n*   Link Matching Configuration\n*   Lazy Loading of Element Statistics\n*   URL Tracking\n*   Wildcard URL Generation\n*   Automatic URL Updates\n*   PostHog Fragment Removal\n*   URL Sanitization\n"
    },
    {
        "path": "frontend/src/toolbar/debug/EventDebugMenu.tsx",
        "summary": "The `EventDebugMenu.tsx` component provides a debugging tool within the PostHog toolbar, allowing developers to inspect events sent from the current page. It features a search bar to filter events, displays a list of events with timestamps and names, and allows expanding each event to view its properties in a key-value format. The menu also includes options to filter events by type (PostHog, custom, replay) and to hide PostHog-specific properties and flags, enhancing the debugging experience by focusing on relevant information.\n\nHere's a list of high-level product features:\n\n*   **Event Filtering:** Allows users to filter events displayed by type (PostHog events, custom events, replay events).\n*   **Event Search:** Enables users to search for specific events or properties within the event list.\n*   **Event Inspection:** Provides a detailed view of each event, including its timestamp and properties.\n*   **Property Hiding:** Offers options to hide PostHog-specific properties and flags for a cleaner view.\n*   **Real-time Event Display:** Shows events as they are generated from the page.\n*   **Event Expansion/Collapse:** Allows users to expand and collapse event rows to show or hide detailed properties.\n"
    },
    {
        "path": "frontend/src/toolbar/debug/eventDebugMenuLogic.ts",
        "summary": "This code defines the logic for a debug menu within a toolbar, specifically focused on displaying and filtering events captured by PostHog. It manages the state of events, search filters, selected event types (PostHog, custom, snapshot), and UI preferences like hiding PostHog properties and flags. The logic connects to the toolbar configuration to access the PostHog instance and listens for `eventCaptured` events to add them to the displayed list. It provides selectors to filter events based on search text and selected event types, and to control the expansion and visibility of event properties.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Event Capture and Display:** Captures events from PostHog and displays them in a list.\n*   **Event Filtering:** Allows filtering events by type (PostHog, custom, snapshot).\n*   **Search Functionality:** Enables searching for specific events based on their name.\n*   **Event Expansion:** Allows users to expand individual events to view their properties.\n*   **Property Filtering:** Provides options to hide PostHog-specific properties and flags from the expanded event view.\n*   **Real-time Updates:** Listens for new events and updates the display in real-time.\n"
    },
    {
        "path": "frontend/src/toolbar/debug",
        "summary": "The code enables a debugging tool within the PostHog toolbar that allows developers to inspect events sent from the current page in real-time. Users can filter events by type (PostHog, custom, snapshot/replay), search for specific events or properties, and expand events to view their details. The tool also offers options to hide PostHog-specific properties and flags, providing a cleaner and more focused debugging experience.\n\nHere's a list of high-level product features:\n\n*   Event Capture and Display: Captures events and displays them in a list.\n*   Event Filtering: Allows filtering events by type (PostHog, custom, snapshot/replay).\n*   Event Search: Enables searching for specific events based on their name or properties.\n*   Event Inspection: Provides a detailed view of each event, including its timestamp and properties.\n*   Property Hiding: Offers options to hide PostHog-specific properties and flags.\n*   Real-time Updates: Listens for new events and updates the display in real-time.\n*   Event Expansion/Collapse: Allows users to expand and collapse event rows to show or hide detailed properties.\n"
    },
    {
        "path": "frontend/src/toolbar",
        "summary": "The provided code implements a comprehensive suite of features for a PostHog toolbar, designed to be injected into web pages for debugging, experimentation, and visual analytics. The toolbar offers functionalities ranging from basic UI elements and configuration options to advanced features like element inspection, heatmap visualization, feature flag management, A/B testing, and real-time event debugging. It integrates with the PostHog platform for authentication, data persistence, and feature flag evaluation, while also providing a separate, isolated PostHog instance for the toolbar's internal event tracking. The toolbar is built with React and leverages Kea for state management, ensuring a dynamic and responsive user experience.\n\nHere's a list of high-level product features:\n\n*   Toolbar Injection and Dynamic CSS Loading\n*   Authentication and Configuration Persistence\n*   Theming and Customizable UI\n*   Drag and Drop Positioning\n*   Element Inspection and Highlighting\n*   Heatmap and Clickmap Visualization\n*   Web Vitals Monitoring\n*   Feature Flag Management and Overriding\n*   A/B Testing (Web Experiments) Management\n*   Action Recording and Management\n*   Real-time Event Debugging and Filtering\n*   Separate PostHog Instance for Toolbar Events\n*   Interactive \"Hedgehog\" Mode for Advanced Debugging\n*   Toast Notifications\n*   Keyboard Shortcuts\n*   Contextual Help and Documentation Links\n*   Autocapture Element Identification and CSS Selector Generation\n*   Dynamic UI Updates Based on Feature Flags\n"
    },
    {
        "path": "frontend/src/queries/nodes/WebOverview/EvenlyDistributedRows.tsx",
        "summary": "The `EvenlyDistributedRows` component is designed to distribute a set of child elements evenly across rows within a container, optimizing for visual balance when the number of elements doesn't perfectly divide into the available space. It dynamically calculates the number of items per row and the number of rows based on the container's width and a specified minimum width for each item, ensuring a more aesthetically pleasing layout than a simple flexbox approach. The component uses a ResizeObserver to react to changes in container size and recalculate the layout accordingly.\n\nHere's a list of high-level features:\n\n*   **Even Distribution of Items:** Distributes child elements evenly across rows, avoiding uneven splits when the number of items exceeds the available space in a row.\n*   **Dynamic Layout Adjustment:** Recalculates the layout based on the container's width and a minimum item width, adapting to different screen sizes and container dimensions.\n*   **Resize Observer Integration:** Uses a ResizeObserver to automatically update the layout when the container's size changes.\n*   **CSS Grid Implementation:** Uses CSS Grid to create the row layout, allowing for flexible and responsive arrangement of items.\n*   **Configurable Minimum Width:** Allows specifying a minimum width for each item, influencing the number of items per row.\n"
    },
    {
        "path": "frontend/src/queries/nodes/WebOverview/WebOverview.tsx",
        "summary": "This code defines a `WebOverview` component that displays key metrics related to website performance. It fetches data using a `WebOverviewQuery` and presents it in a grid of `WebOverviewItemCell` components. Each cell shows a metric's value, label, and trend compared to the previous period. The component also handles loading states with skeletons and displays a banner if data sampling is in use. It formats the data appropriately based on the metric type (percentage, duration, currency, etc.) and provides tooltips for detailed information. Some metrics, like revenue, link to their settings pages.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Website Performance Overview:** Displays a summary of key website metrics.\n*   **Metric Visualization:** Presents metrics with appropriate formatting (percentages, currency, duration).\n*   **Trend Indicators:** Shows trends (increase, decrease, or flat) for each metric compared to the previous period.\n*   **Data Sampling Awareness:** Informs the user if data sampling is being used.\n*   **Loading State Handling:** Provides visual feedback during data loading.\n*   **Detailed Tooltips:** Offers detailed information about each metric on hover.\n*   **Settings Linking:** Links to relevant settings pages for specific metrics (e.g., revenue settings).\n*   **Beta Tagging:** Marks metrics that are in beta."
    },
    {
        "path": "frontend/src/queries/nodes/WebOverview",
        "summary": "The provided code implements a website performance overview dashboard with evenly distributed metrics. The dashboard displays key website metrics with trend indicators, appropriate formatting, and detailed tooltips. It dynamically adjusts the layout based on screen size and informs users about data sampling. The system also provides links to relevant settings pages and handles loading states gracefully.\n\n**Features:**\n\n*   Website Performance Overview: Displays a summary of key website metrics.\n*   Metric Visualization: Presents metrics with appropriate formatting (percentages, currency, duration).\n*   Trend Indicators: Shows trends (increase, decrease, or flat) for each metric compared to the previous period.\n*   Data Sampling Awareness: Informs the user if data sampling is being used.\n*   Loading State Handling: Provides visual feedback during data loading.\n*   Detailed Tooltips: Offers detailed information about each metric on hover.\n*   Settings Linking: Links to relevant settings pages for specific metrics (e.g., revenue settings).\n*   Beta Tagging: Marks metrics that are in beta.\n*   Even Distribution of Items: Distributes child elements evenly across rows, avoiding uneven splits.\n*   Dynamic Layout Adjustment: Recalculates the layout based on container size.\n*   Resize Observer Integration: Automatically updates the layout when the container's size changes.\n"
    },
    {
        "path": "frontend/src/queries/nodes/HogQLX/render.tsx",
        "summary": "This code provides a rendering function `renderHogQLX` that takes a value, parses it using `parseHogQLX`, and renders it as a React component. The parsing function handles a custom data structure format denoted by the `__hx_tag` property, which allows for special rendering of specific components. The rendering logic supports JSON display, sparklines, recording buttons, links, and basic HTML elements like `strong` and `em`. Error boundaries are used to prevent rendering errors from crashing the application.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Custom Data Structure Parsing:** Ability to parse a custom data structure format (`HogQLX`) for flexible data representation.\n*   **JSON Visualization:** Renders generic objects as interactive JSON viewers.\n*   **Sparkline Charts:** Renders sparkline charts from data provided in the custom format.\n*   **Session Recording Button:** Renders a button to view session recordings, linking to specific sessions.\n*   **Hyperlink Rendering:** Renders hyperlinks with customizable targets.\n*   **Basic HTML Element Rendering:** Renders basic HTML elements like `strong` and `em` for text formatting.\n*   **Error Handling:** Uses error boundaries to prevent rendering errors from crashing the application.\n"
    },
    {
        "path": "frontend/src/queries/nodes/HogQLX",
        "summary": "The `renderHogQLX` function enables the rendering of a custom data structure format, `HogQLX`, into React components, providing specialized visualizations and interactions. It supports rendering generic objects as interactive JSON, displaying sparkline charts, creating session recording buttons that link to specific sessions, rendering hyperlinks, and formatting text with basic HTML elements. Error boundaries are implemented to ensure that rendering errors do not crash the application, maintaining a robust user experience.\n\nHere's a list of high-level product features enabled by this code:\n\n*   Custom Data Structure Parsing\n*   JSON Visualization\n*   Sparkline Charts\n*   Session Recording Button\n*   Hyperlink Rendering\n*   Basic HTML Element Rendering\n*   Error Handling\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/types.ts",
        "summary": "This code defines the types and data structures used for data visualization formatting rules and variable definitions. It includes definitions for column scalar types, formatting templates with comparison operators, and variable types such as String, Number, Boolean, List, and Date, each with specific properties like default values and value types. The formatting templates define a set of rules that can be applied to data columns based on their type, allowing for conditional formatting based on comparisons.\n\nHere's a list of high-level product features that can be derived from this code:\n\n*   **Column Type Handling:** The system supports various column data types, including Integer, Float, Datetime, Date, Boolean, Decimal, String, Tuple, and Array.\n*   **Data Formatting Rules:** Users can define rules to format data based on conditions like \"equals,\" \"not equals,\" \"greater than,\" \"less than,\" and null checks.\n*   **Conditional Formatting:** The system allows conditional formatting of data based on user-defined rules and input values.\n*   **Variable Definition:** Users can define variables of different types (String, Number, Boolean, List, Date) to be used in formatting rules or other data processing tasks.\n*   **Input Hiding:** The system supports hiding the input field for certain formatting templates, such as \"Is null\" and \"Is not null\".\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/ConditionalFormatting/ConditionalFormattingTab.tsx",
        "summary": "This code implements a conditional formatting tab within a data visualization tool. It allows users to define rules that change the color of cells in a table based on specific conditions. Users can add multiple rules, each targeting a specific column and applying a formatting template with a customizable input value and color. The UI provides options to select a column, choose a formatting template, specify a value for the condition, and pick a color for the cell. Each rule is displayed in a collapsible panel, and users can delete rules as needed.\n\n**Features:**\n\n*   **Add Conditional Formatting Rules:** Allows users to create new rules to format data cells based on conditions.\n*   **Column Selection:** Enables users to choose the specific column to which the formatting rule applies.\n*   **Formatting Template Selection:** Provides a selection of pre-defined formatting templates (e.g., \"greater than\", \"less than\", \"equals\") to apply to the selected column.\n*   **Input Value Specification:** Allows users to enter a value to be used in the conditional formatting logic (e.g., a number to compare against).\n*   **Color Selection:** Enables users to choose the color to apply to cells that meet the specified condition.\n*   **Rule Management (Edit/Delete):** Provides the ability to modify or remove existing conditional formatting rules.\n*   **Collapsible Rule Display:** Displays each rule in a collapsible panel for better organization and readability.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/seriesBreakdownLogic.ts",
        "summary": "This code defines a Kea logic module called `seriesBreakdownLogic` that manages the breakdown of data series in a data visualization component. It handles the selection of a breakdown column, calculates the data for each series based on the breakdown values, and formats the data for display. The logic connects to the `dataVisualizationLogic` to access the query, response, columns, and selected axes. It also persists the selected breakdown column in the query settings.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Series Breakdown Visualization:** Allows users to break down a data series by the unique values of a selected column, creating separate series for each value.\n*   **Dynamic Data Aggregation:** Aggregates data based on the selected breakdown column and x-axis values, summing y-values for each x-value within each breakdown series.\n*   **Data Formatting:** Applies formatting (e.g., decimal places, percentage style) from the selected y-axis to the breakdown series.\n*   **Persistence of Settings:** Saves the selected breakdown column in the query settings, so it persists across sessions.\n*   **Error Handling:** Handles cases where there are too many breakdown values, displaying an error message.\n*   **Unaggregated Data Detection:** Detects and flags when the underlying data is unaggregated.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/SeriesTab.tsx",
        "summary": "The `SeriesTab.tsx` file defines the UI components for configuring the series displayed in a data visualization. It allows users to select the X-axis and Y-axis data, add multiple Y-series, and customize the appearance and formatting of each series. The component uses Lemon UI components for a consistent look and feel, and Kea logic for state management and actions. It also includes functionality for adding a series breakdown, allowing users to further segment the data.\n\nHere's a list of high-level product features implemented in this code:\n\n*   **X-Axis Selection:** Allows users to choose the column to be used for the X-axis of the data visualization.\n*   **Y-Series Management:** Enables users to add, remove, and configure multiple Y-series to be displayed on the chart.\n*   **Column Selection:** Provides a dropdown to select the column for each Y-series.\n*   **Series Formatting:** Offers options to format the Y-series data, including style (number, percentage), prefix, suffix, and decimal places.\n*   **Series Display Customization:** Allows users to customize the display of each Y-series, including color, label, trend line, Y-axis position (left or right), and display type (auto, line, bar).\n*   **Series Breakdown:** Enables users to add a series breakdown to further segment the data.\n*   **Table Settings:** Provides a view for configuring columns in a tabular format."
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/ConditionalFormatting/conditionalFormattingLogic.ts",
        "summary": "This code defines the `conditionalFormattingLogic` Kea logic hook, responsible for managing the state and behavior of a single conditional formatting rule within a data visualization component. It handles user interactions such as selecting a column, updating input values, choosing a formatting template, selecting a color, and deleting the rule. The logic also compiles a \"hog\" (presumably a data transformation or filtering expression) based on the selected template and updates the rule's bytecode. It interacts with the `dataVisualizationLogic` to persist changes to the rule and uses an API to compile the hog expression.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Conditional Formatting Rule Management:** Create, edit, and delete conditional formatting rules for data visualizations.\n*   **Column Selection:** Choose a specific column to apply the conditional formatting rule to.\n*   **Input Value Configuration:** Define input values for the conditional formatting rule (e.g., a threshold value).\n*   **Formatting Template Selection:** Select from a set of pre-defined formatting templates (e.g., highlight cells above a certain value).\n*   **Color Selection:** Choose a color to apply to the formatted cells.\n*   **Dynamic Bytecode Generation:** Automatically generate bytecode based on the selected formatting template, enabling dynamic data transformation and filtering.\n*   **Real-time Rule Updates:** Persist changes to the conditional formatting rule in real-time.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/dataVisualizationLogic.ts",
        "summary": "This code defines the `dataVisualizationLogic` using Kea, a state management library. This logic is responsible for managing the state and behavior of data visualizations within a PostHog application. It handles tasks such as updating the query, managing chart settings, selecting axes, and managing conditional formatting rules. It connects to other logics like `teamLogic`, `dataNodeLogic`, and `themeLogic` to access team information, data, and theme settings. The logic also provides functionalities for formatting data based on user-defined settings and converting data types.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Data Visualization**: Enables users to visualize data from queries in various chart types.\n*   **Chart Configuration**: Allows users to configure chart settings such as axes, series, and display options.\n*   **Conditional Formatting**: Supports conditional formatting of data points based on defined rules.\n*   **Data Formatting**: Provides options to format data values with prefixes, suffixes, decimal places, and styles (number, percent).\n*   **Interactive Chart Editing**: Allows users to interactively edit and customize charts through a sidebar panel.\n*   **Dynamic Query Updates**: Updates the visualization based on changes to the underlying query.\n*   **Theme Integration**: Adapts the visualization to the current theme (light or dark mode).\n*   **Data Type Conversion**: Converts data values to appropriate types for visualization.\n*   **Dashboard Integration**: Supports embedding visualizations in dashboards with variable overrides."
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/ConditionalFormatting",
        "summary": "The provided code snippets detail the implementation of a conditional formatting feature within a data visualization tool. This feature empowers users to dynamically alter the appearance of data cells based on defined rules, enhancing data interpretation and highlighting key insights. Users can create, edit, and delete rules, each targeting a specific column and applying a formatting template with customizable input values and color selections. The system dynamically generates bytecode based on the selected template, enabling real-time data transformation and filtering.\n\n**Features:**\n\n*   Conditional Formatting Rule Management: Create, edit, and delete rules.\n*   Column Selection: Choose the column to apply the rule.\n*   Formatting Template Selection: Select from pre-defined templates (e.g., \"greater than\").\n*   Input Value Configuration: Define values for the conditional logic (e.g., a threshold).\n*   Color Selection: Choose the color to apply to formatted cells.\n*   Dynamic Bytecode Generation: Automatically generate bytecode for data transformation.\n*   Real-time Rule Updates: Persist changes to rules in real-time.\n*   Collapsible Rule Display: Organize rules in collapsible panels.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/TableDisplay.tsx",
        "summary": "This code defines a `TableDisplay` component that allows users to select the visualization type for data displayed in a table. It uses a `LemonSelect` component from PostHog's Lemon UI library to present a dropdown menu of available chart types, including table, big number, line chart, bar chart, stacked bar chart, and area chart. The selected visualization type is managed by the `dataVisualizationLogic` using kea actions and values.\n\n**Features:**\n\n*   **Visualization Type Selection:** Allows users to choose how data is displayed (e.g., table, chart).\n*   **Multiple Chart Types:** Supports various chart types, including table, big number, line, bar, stacked bar, and area charts.\n*   **Lemon UI Integration:** Uses PostHog's Lemon UI library for a consistent and user-friendly interface.\n*   **Kea State Management:** Leverages Kea for managing the selected visualization type.\n*   **Dropdown Menu:** Presents visualization options in a dropdown menu for easy selection.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/Charts/LineGraph.tsx",
        "summary": "The `LineGraph.tsx` component visualizes data using a line, bar, or area chart, leveraging the Chart.js library. It supports displaying data series with options for trendlines, stacking, and multiple Y-axes. The component handles data formatting, color assignment, and user interactions like tooltips and goal line annotations. It also includes logic for limiting the number of displayed series and displaying appropriate warnings.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Data Visualization:** Renders line, bar, and area charts from provided data.\n*   **Multiple Chart Types:** Supports line, bar, stacked bar, and area chart visualizations.\n*   **Series Breakdown:** Handles data with series breakdowns for detailed analysis.\n*   **Trendlines:** Displays trendlines for data series.\n*   **Multiple Y-Axes:** Supports charts with left and right Y-axes.\n*   **Goal Line Annotations:** Allows users to add and display goal lines on the chart.\n*   **Customizable Appearance:** Offers options for colors, legends, and axis settings.\n*   **Interactive Tooltips:** Provides interactive tooltips for data points.\n*   **Data Limiting:** Limits the number of displayed series to prevent performance issues.\n*   **Crosshair Interaction:** Includes crosshair functionality for precise data point selection.\n*   **Stacked Charts:** Supports stacked bar charts, including 100% stacked options.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/Charts",
        "summary": "The LineGraph component provides versatile data visualization capabilities by rendering line, bar, and area charts using Chart.js. It supports complex datasets with series breakdowns, trendlines, and multiple Y-axes, enhancing data analysis. Users can customize the chart's appearance with options for colors, legends, and axis settings, and interact with the data through tooltips and goal line annotations. To maintain performance, the component limits the number of displayed series and includes crosshair interaction for precise data point selection.\n\n**Features:**\n\n*   Data Visualization (Line, Bar, Area Charts)\n*   Multiple Chart Types (Stacked Bar, 100% Stacked)\n*   Series Breakdown Support\n*   Trendlines\n*   Multiple Y-Axes\n*   Goal Line Annotations\n*   Customizable Appearance\n*   Interactive Tooltips\n*   Data Limiting\n*   Crosshair Interaction\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/Variables/variableDataLogic.ts",
        "summary": "This code defines a Kea logic module named `variableDataLogic` responsible for managing variables related to data visualizations. It uses Kea Loaders to handle asynchronous operations for fetching and deleting variables. The logic fetches variables from the `api.insightVariables` endpoint and provides a function to delete variables by their ID, updating the state accordingly and displaying success or error messages using `lemonToast`.\n\n**Features:**\n\n*   **Variable Listing:** Fetches and stores a list of variables from an API endpoint.\n*   **Variable Deletion:** Allows deleting variables by ID via an API call.\n*   **State Management:** Manages the list of variables in the component's state.\n*   **Success/Error Notifications:** Provides user feedback on variable deletion success or failure using toast notifications.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/Variables/VariableCalendar.tsx",
        "summary": "The `VariableCalendar` component provides a date and time selection interface using the Lemon Calendar Select component. It allows users to select a date, and optionally a time, and updates a variable with the selected date and time in the appropriate format. The component includes a toggle to switch between date-only and date-time selection, and the granularity of the calendar adjusts accordingly.\n\nHere's a list of high-level features:\n\n*   **Date Selection:** Allows users to pick a specific date from a calendar interface.\n*   **Time Selection (Optional):** Provides a toggle to enable or disable time selection, allowing users to specify a particular time of day.\n*   **Granularity Control:** Adjusts the calendar's granularity based on whether time selection is enabled (minute) or disabled (day).\n*   **Variable Update:** Updates an external variable with the selected date and time, formatted as either \"YYYY-MM-DD\" or \"YYYY-MM-DD HH:mm:00\".\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/Variables/AddVariableButton.tsx",
        "summary": "This component provides a button that, when clicked, opens a menu to add a new or existing variable to a data visualization query. The menu allows users to create new variables of different types (String, Number, Boolean, List, Date) via a modal or select from a list of existing variables. Existing variables can be edited via a gear icon. The button and its associated functionality are only visible if the `INSIGHT_VARIABLES` feature flag is enabled and the editing UI is visible.\n\nHere's a list of high-level product features:\n\n*   **Add New Variable:** Allows users to create new variables of different data types (String, Number, Boolean, List, Date) for use in data visualizations.\n*   **Add Existing Variable:** Enables users to select and add pre-existing variables to their data visualization queries.\n*   **Variable Type Selection:** Provides options to define the data type of new variables (String, Number, Boolean, List, Date).\n*   **Variable Editing:** Allows users to modify existing variables.\n*   **Feature Flag Control:** Controls the visibility of the variable addition functionality based on a feature flag.\n*   **Conditional UI Display:** Shows or hides the button based on the visibility of the editing UI.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/Variables/variableModalLogic.ts",
        "summary": "This code defines a Kea logic module named `variableModalLogic` responsible for managing the state and actions related to a modal for creating and editing variables within a data visualization tool. It handles opening the modal in either \"new\" or \"existing\" variable modes, managing the variable type, updating the variable's properties, and saving the variable to the backend API. The logic also handles error display using lemonToast.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Variable Creation:** Allows users to create new variables of different types (String, Number, Boolean, List, Date) with default values.\n*   **Variable Editing:** Enables users to modify existing variables.\n*   **Modal Management:** Controls the opening and closing of a modal for variable creation and editing.\n*   **Variable Type Handling:** Manages the selection and handling of different variable types.\n*   **Data Persistence:** Saves and updates variables to a backend API.\n*   **Error Handling:** Displays error messages to the user when saving or updating variables fails.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/Variables/NewVariableModal.tsx",
        "summary": "This code defines a modal component, `NewVariableModal`, for creating and editing variables within a data visualization tool. The modal allows users to define the name, type (String, Number, Boolean, List, Date), and default value of a variable. The UI dynamically renders input fields based on the selected variable type, providing specific controls for each type (e.g., a segmented button for booleans, a date picker for dates, and a multi-select input for lists). It also includes functionality for deleting existing variables with a confirmation dialog.\n\nHere's a list of high-level product features:\n\n*   **Variable Creation:** Allows users to create new variables with a specified name and type.\n*   **Variable Editing:** Enables users to modify existing variables, including their name, type, and default value.\n*   **Type-Specific Input Fields:** Dynamically renders input fields based on the selected variable type (String, Number, Boolean, List, Date).\n*   **String Variable Support:** Provides a text input field for defining the default value of string variables.\n*   **Number Variable Support:** Provides a numeric input field for defining the default value of number variables.\n*   **Boolean Variable Support:** Provides a segmented button (true/false) for defining the default value of boolean variables.\n*   **List Variable Support:** Provides a multi-select input for defining a list of possible values and a dropdown for selecting a default value from the list.\n*   **Date Variable Support:** Provides a date picker for selecting the default value of date variables.\n*   **Variable Deletion:** Allows users to delete existing variables with a confirmation dialog.\n*   **Modal Interface:** Presents the variable creation/editing interface within a modal window.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/Variables/variablesLogic.ts",
        "summary": "This code defines the `variablesLogic` Kea logic component, responsible for managing variables within a data visualization context. It handles adding, removing, and updating variables, as well as synchronizing these changes with the underlying query. The logic connects to other Kea logics like `dataVisualizationLogic` and `variableDataLogic` to access and modify the query and variable definitions. It also interacts with feature flags to conditionally enable or disable variable-related functionality. The logic ensures that variable values are correctly typed and updates the source query with the latest variable values.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Variable Management:** Allows users to add, remove, and update variables associated with a data visualization query.\n*   **Query Synchronization:** Automatically updates the underlying query when variables are added, removed, or modified.\n*   **Type Conversion:** Converts variable values to the correct data type (Number, String, Boolean) based on the variable definition.\n*   **Feature Flag Control:** Enables or disables variable-related features based on feature flag settings.\n*   **Dashboard Integration:** Supports variable management within a dashboard context, with special handling for dashboard items.\n*   **Query Editor Integration:** Automatically detects variables used in the query editor and adds them to the variable management interface.\n*   **Read-Only Mode:** Supports a read-only mode where query changes are disabled, useful for viewing insights.\n*   **Variable Persistence:** Stores and retrieves variable values, ensuring they are maintained across sessions."
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/Variables/Variables.tsx",
        "summary": "This code defines React components for managing and displaying variables within PostHog insights and dashboards. It provides UI elements for viewing, editing, and overriding variable values, including different input types based on the variable's data type (String, Number, Boolean, List, Date). The components handle persistence of variable values, display HogQL code snippets for variable usage, and offer options for setting variables to null, copying HogQL code, removing variables from insights, and opening variable settings. The code differentiates between variable usage in dashboards and insights, offering tailored functionalities for each context.\n\nHere's a list of high-level product features:\n\n*   **Variable Management:** Allows users to define and manage variables for use in insights and dashboards.\n*   **Variable Value Overrides:** Enables users to override default variable values for specific insights or dashboards.\n*   **Data Type Specific Inputs:** Provides appropriate input controls (text fields, number fields, boolean switches, dropdowns, date pickers) based on the variable's data type.\n*   **HogQL Integration:** Displays the HogQL code snippet for each variable, allowing users to easily reference them in queries.\n*   **Null Value Support:** Allows users to explicitly set variable values to null.\n*   **Variable Persistence:** Saves variable values and overrides.\n*   **Insight/Dashboard Context:** Adapts the UI and functionality based on whether the variable is being used in an insight or a dashboard.\n*   **Variable Settings:** Provides access to variable settings (likely defined elsewhere).\n*   **Variable Removal:** Allows users to remove variables from insights.\n*   **Tooltip Information:** Displays helpful information about variable usage and the insights that use them.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/Variables",
        "summary": "This collection of code files implements a comprehensive variable management system for a data visualization tool. It provides users with the ability to create, edit, delete, and manage variables of various data types (String, Number, Boolean, List, Date) within the context of insights and dashboards. The system includes a modal interface for variable creation and editing, dynamic input fields based on variable type, integration with a backend API for persistence, and synchronization with the underlying query language (HogQL). Feature flags control the visibility of variable-related functionality, and the UI adapts based on whether the variable is being used in an insight or a dashboard.\n\nHere's a list of high-level product features:\n\n*   Variable Creation and Editing: Allows users to define new variables and modify existing ones, including name, type, and default value.\n*   Data Type Support: Handles variables of different data types (String, Number, Boolean, List, Date) with appropriate input controls.\n*   Variable Management: Provides a UI for viewing, editing, and overriding variable values.\n*   HogQL Integration: Displays HogQL code snippets for variables, enabling easy referencing in queries.\n*   Query Synchronization: Automatically updates the underlying query when variables are modified.\n*   Persistence: Saves and retrieves variable values, ensuring they are maintained across sessions.\n*   Dashboard and Insight Context: Adapts the UI and functionality based on the context of use.\n*   Variable Deletion: Allows users to remove variables.\n*   Feature Flag Control: Enables or disables variable-related features based on feature flag settings.\n*   Error Handling: Displays error messages to the user when saving or updating variables fails.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/DisplayTab.tsx",
        "summary": "The `DisplayTab` component provides a user interface for configuring the display settings of a data visualization chart. It allows users to toggle the visibility of the legend, adjust the scale and zero-basing of both left and right Y-axes, and control whether stacked bar charts should be displayed as 100% stacked. Additionally, it enables users to add, modify, and remove goal lines, each with a customizable label, value, and visibility toggle.\n\nHere's a list of high-level product features implemented by the code:\n\n*   **Toggle Legend Visibility:** Allows users to show or hide the chart legend.\n*   **Y-Axis Scaling:** Provides options to set the Y-axis scale to linear or logarithmic.\n*   **Y-Axis Zero Basing:** Enables users to force the Y-axis to start at zero.\n*   **Stacked Bar Chart Control:** Offers the ability to display stacked bar charts as 100% stacked.\n*   **Goal Line Management:**\n    *   Add goal lines to the chart.\n    *   Edit goal line labels and values.\n    *   Toggle goal line label visibility.\n    *   Remove goal lines."
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/SideBar.tsx",
        "summary": "This code defines the `SideBar` component for the data visualization feature. It uses LemonTabs from PostHog's Lemon UI library to create a tabbed interface for configuring different aspects of a data visualization. The tabs include \"Series\", \"Conditional formatting\", and \"Display\", each with its own content and visibility rules based on the selected chart display type. The component uses kea logic to manage the active tab and visualization type, allowing users to switch between tabs and configure the visualization settings.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Tabbed Interface:** Provides a structured way to access different configuration options for data visualizations.\n*   **Series Configuration:** Allows users to configure the data series displayed in the visualization.\n*   **Conditional Formatting:** Enables users to apply conditional formatting rules to data visualizations, specifically for ActionsTable display type.\n*   **Display Settings:** Provides options to customize the display of the visualization, excluding ActionsTable and BoldNumber display types.\n*   **Dynamic Tab Visibility:** Shows or hides tabs based on the selected chart display type.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/ySeriesLogic.ts",
        "summary": "This code defines the `ySeriesLogic` Kea logic for managing the settings and display options of a single Y-axis series in a data visualization component. It handles the state and actions related to opening/closing settings, selecting settings tabs (Formatting, Display), and managing form data for formatting (prefix, suffix, style, decimal places) and display (color, label, trend line, y-axis position, display type) settings. The logic connects to the parent `dataVisualizationLogic` to update the series configuration based on user input.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Y-Axis Series Configuration:** Allows users to customize the appearance and formatting of individual Y-axis data series in a chart.\n*   **Formatting Options:** Provides controls for setting prefixes, suffixes, styles, and decimal places for numerical values displayed on the Y-axis.\n*   **Display Settings:** Enables users to modify the color, label, trend line, Y-axis position (left or right), and display type (e.g., line, bar) of a Y-axis series.\n*   **Settings Panel:** Offers a user interface for accessing and modifying the formatting and display settings of a selected Y-axis series.\n*   **Real-time Updates:** Applies changes to the Y-axis series configuration dynamically as users interact with the settings panel.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components/Table.tsx",
        "summary": "This code defines a `Table` component for displaying data retrieved from a PostHog query. It uses LemonTable from `@posthog/lemon-ui` to render the data in a tabular format. The component fetches data and column definitions using `dataVisualizationLogic`, handles conditional formatting based on rules defined in the query, and provides loading and empty/error states. It also includes a \"Load Next\" button for pagination. The table cells are rendered using the `renderColumn` function, and the table columns are defined using the `renderColumnMeta` function.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Data Visualization in Tabular Format:** Displays query results in a table.\n*   **Dynamic Columns:** Columns are generated based on the query response.\n*   **Conditional Formatting:** Applies background colors to cells based on rules defined in the query.\n*   **Theming Support:** Adapts conditional formatting colors to light and dark themes.\n*   **Loading State:** Shows a loading indicator while data is being fetched.\n*   **Empty and Error States:** Displays appropriate messages when there is no data or an error occurs.\n*   **Pagination:** Implements pagination with a \"Load Next\" button.\n*   **Customizable Column Labels:** Allows customizing column labels.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/Components",
        "summary": "The data visualization tool offers a comprehensive suite of features for creating and customizing charts and tables. Users can select data for the X and Y axes, manage multiple Y-series with customizable formatting and display options, and break down series by unique column values. Conditional formatting allows dynamic styling of data cells based on defined rules. The tool supports various chart types (line, bar, area, stacked bar, big number) and table displays, with options for legend visibility, Y-axis scaling, zero-basing, and stacked bar chart control. A variable management system enables users to define and manage variables of different data types for use in queries. The user interface is organized with a tabbed sidebar for easy access to configuration options.\n\nHere's a list of high-level product features:\n\n*   **Data Selection and Mapping:** X-Axis Selection, Y-Series Management, Column Selection\n*   **Chart Customization:** Series Formatting, Series Display Customization, Multiple Chart Types, Customizable Appearance, Goal Line Annotations, Trendlines, Multiple Y-Axes\n*   **Data Breakdown and Aggregation:** Series Breakdown Visualization, Dynamic Data Aggregation\n*   **Conditional Formatting:** Conditional Formatting Rule Management, Column Selection, Formatting Template Selection, Input Value Configuration, Color Selection\n*   **Table Display:** Data Visualization in Tabular Format, Dynamic Columns, Theming Support, Pagination\n*   **Display Settings:** Toggle Legend Visibility, Y-Axis Scaling, Y-Axis Zero Basing, Stacked Bar Chart Control\n*   **Variable Management:** Variable Creation and Editing, Data Type Support, Variable Management, HogQL Integration, Query Synchronization, Persistence\n*   **User Interface:** Tabbed Interface, Dynamic Tab Visibility\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/displayLogic.ts",
        "summary": "This code defines the `displayLogic` Kea logic for managing goal lines in a data visualization component. It handles adding, removing, updating, and persisting goal lines within the chart settings of a query. The logic connects to `dataVisualizationLogic` to access chart data and settings, and it uses D3.js to calculate the average Y-axis value for initializing new goal lines. The goal lines are stored in the component's state and are automatically persisted to the query's chart settings whenever they are modified.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Add Goal Lines:** Allows users to add horizontal lines to a chart to represent goals or targets.\n*   **Automatic Goal Line Initialization:** Automatically sets the initial value of a new goal line to the average of the Y-axis data.\n*   **Remove Goal Lines:** Enables users to remove existing goal lines from the chart.\n*   **Update Goal Line Properties:** Allows users to modify the label, value, and display status of goal lines.\n*   **Persist Goal Lines:** Saves goal line configurations within the chart settings, ensuring they are retained across sessions.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization/DataVisualization.tsx",
        "summary": "This code defines a React component, `DataTableVisualization`, which provides a flexible interface for visualizing data retrieved through HogQL queries. It integrates various sub-components and logics to offer features such as query editing, variable management, data display in different chart formats (table, line graph, bold number), and export options. The component handles loading states, errors, and read-only modes, making it suitable for different contexts within the PostHog application.\n\nHere's a list of high-level product features:\n\n*   **HogQL Query Editor:** Allows users to write and edit HogQL queries to fetch data.\n*   **Data Visualization:** Displays query results in various formats, including tables, line graphs, and bold numbers.\n*   **Variable Management:** Enables users to define and manage variables within their queries.\n*   **Chart Settings Panel:** Provides options to configure the visualization of the data.\n*   **Data Export:** Allows users to export query results in CSV and XLSX formats.\n*   **Date Range Picker:** Enables users to filter data based on a specific date range.\n*   **Real-time Updates:** Features like \"Reload\" and \"Elapsed Time\" provide information on query execution and data freshness.\n*   **Database Table Explorer:** Allows users to browse available database tables and their schemas.\n*   **Error Handling:** Displays informative error messages when queries fail.\n*   **Loading State Management:** Provides visual feedback during data loading.\n*   **Read-Only Mode:** Restricts editing capabilities for shared or exported visualizations."
    },
    {
        "path": "frontend/src/queries/nodes/DataVisualization",
        "summary": "The provided code collectively enables a comprehensive data visualization tool within PostHog, allowing users to create, customize, and interact with charts and tables derived from HogQL queries. The tool offers a wide array of features, including data selection, chart type selection, conditional formatting, variable management, and display settings, all accessible through an intuitive user interface. Users can define rules to format data based on conditions, manage variables of different types, and add goal lines to represent targets. The visualizations can be exported, embedded in dashboards, and dynamically updated based on changes to the underlying query.\n\nHere's a list of high-level product features:\n\n*   **Data Visualization:** Display query results in various formats (tables, line graphs, bold numbers).\n*   **Chart Configuration:** Customize chart settings such as axes, series, display options, and chart types.\n*   **Conditional Formatting:** Apply dynamic styling to data cells based on user-defined rules and input values.\n*   **Variable Management:** Define and manage variables of different data types for use in queries and formatting rules.\n*   **Data Formatting:** Format data values with prefixes, suffixes, decimal places, and styles (number, percent).\n*   **Interactive Chart Editing:** Interactively edit and customize charts through a sidebar panel.\n*   **Dynamic Query Updates:** Update the visualization based on changes to the underlying query.\n*   **Data Export:** Export query results in CSV and XLSX formats.\n*   **Goal Lines:** Add horizontal lines to charts to represent goals or targets.\n*   **Dashboard Integration:** Embed visualizations in dashboards with variable overrides.\n*   **HogQL Query Editor:** Write and edit HogQL queries to fetch data.\n*   **Data Type Conversion:** Converts data values to appropriate types for visualization.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataNode/TestAccountFilters.tsx",
        "summary": "This code defines a `TestAccountFilters` component that allows users to toggle the filtering of test accounts in queries. It uses a `TestAccountFilterSwitch` component to provide a user interface for enabling or disabling the filter. The component handles different query types (`EventsQuery`, `HogQLQuery`, and `TracesQuery`) and updates the query object accordingly when the filter is toggled. It also interacts with `filterTestAccountsDefaultsLogic` to set the local default for the filter. The component only renders if the query is of a supported type.\n\nHere's a list of high-level product features:\n\n*   **Test Account Filtering:** Allows users to filter out test accounts from query results.\n*   **Toggle Switch UI:** Provides a simple toggle switch to enable or disable test account filtering.\n*   **Query Type Support:** Supports filtering for EventsQuery, HogQLQuery, and TracesQuery types.\n*   **Query Object Updates:** Updates the query object with the filter setting when toggled.\n*   **Local Default Setting:** Sets a local default for the test account filter setting.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataNode/dataNodeCollectionLogic.ts",
        "summary": "This code defines a Kea logic module named `dataNodeCollectionLogic` that manages a collection of data nodes. It handles mounting and unmounting data nodes, tracking their loading status (loading, success, failure), and providing actions to reload or cancel loading for all nodes in the collection. The logic maintains a list of mounted data nodes and their corresponding status, and it exposes a selector to determine if any of the nodes are currently loading.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Data Node Management:** Allows registering and unregistering data nodes within a collection.\n*   **Loading State Tracking:** Tracks the loading status (isLoading, hasError) of individual data nodes.\n*   **Bulk Actions:** Provides actions to reload or cancel loading for all data nodes in the collection.\n*   **Loading Status Indicator:** Exposes a selector to determine if any data nodes are currently loading, enabling UI elements to reflect the overall loading state.\n*   **Data Refresh:** Supports forced data refresh for all nodes, bypassing cache.\n*   **Query Cancellation:** Allows cancelling ongoing queries for individual data nodes.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataNode/DateRange.tsx",
        "summary": "This code defines a `DateRange` component that provides a date range filter for different types of queries: `EventsQuery`, `HogQLQuery`, `SessionAttributionExplorerQuery`, and `TracesQuery`. The component uses the `DateFilter` component from the `lib/components/DateFilter/DateFilter` library. It dynamically adjusts the date range based on the query type, updating the query object with the selected date range and calling the `setQuery` function to persist the changes.\n\nHere's a list of high-level product features:\n\n*   **Date Range Filtering:** Allows users to filter data based on a specific date range.\n*   **Query-Specific Date Handling:** Adapts the date range filtering mechanism to different query types (`EventsQuery`, `HogQLQuery`, `SessionAttributionExplorerQuery`, `TracesQuery`).\n*   **Real-time Query Updates:** Updates the query object with the selected date range and triggers a query update via the `setQuery` prop.\n*   **UI Component Integration:** Leverages a reusable `DateFilter` component for consistent date selection.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataNode/Reload.tsx",
        "summary": "This code defines two React components, `Reload` and `ReloadAll`, which provide functionality to refresh data nodes. The `Reload` component allows the user to reload a single data node, with the option to cancel the query if it's currently loading. It dynamically switches between a \"Reload\" button and a \"Cancel\" button with a spinner icon based on the loading state. The `ReloadAll` component provides a button to reload all data nodes in a collection. It also displays a spinner icon and disables the button while any of the data nodes are loading.\n\nHere's a list of high-level product features:\n\n*   **Single Data Node Reload:** Allows users to refresh the data for a specific data node.\n*   **Query Cancellation:** Enables users to cancel an ongoing data query for a single data node.\n*   **Visual Loading Indicator:** Provides a visual cue (spinner icon) to indicate when data is being loaded or refreshed.\n*   **Collection-Wide Data Reload:** Provides the ability to refresh data for all data nodes within a collection.\n*   **Disable Reload During Loading:** Prevents users from initiating multiple reloads simultaneously by disabling the \"Reload All\" button while data is loading.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataNode/DataNode.tsx",
        "summary": "This code defines a `DataNode` component in a React application, responsible for displaying the data returned by a query in a user-friendly format. It utilizes a Monaco code editor to present the data as formatted JSON. The component handles loading states with a spinner and displays errors if they occur. It also includes a button to open the query editor. The component leverages kea for state management and `react-virtualized` for dynamic sizing of the editor.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Data Visualization:** Renders query results as formatted JSON.\n*   **Code Editor Integration:** Uses Monaco editor for displaying and formatting JSON data.\n*   **Loading State Management:** Displays a spinner while data is loading.\n*   **Error Handling:** Displays error messages if the query fails.\n*   **Query Editor Integration:** Provides a button to open the query editor for the current data node.\n*   **Dynamic Sizing:** Adjusts the editor's height based on available space.\n*   **Cached Results Support:** Can display cached results when available.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataNode/ElapsedTime.tsx",
        "summary": "This code defines a React component, `ElapsedTime`, that displays the elapsed time of a query. It fetches the elapsed time, loading state, error status, timings, and query from the `dataNodeLogic` using `kea`. The component conditionally renders the elapsed time, updating it in real-time while loading. If `showTimings` is true and timings data is available, it renders the `ElapsedTimeWithTimings` component, which displays the elapsed time in a popover along with a breakdown of the timings for each step of the query. The popover shows the time taken by each step, highlighting steps that take a significant portion of the total time. It also calculates and displays the HTTP overhead.\n\nHere's a list of high-level product features:\n\n*   **Display Query Elapsed Time:** Shows the time taken for a query to execute.\n*   **Real-time Time Updates:** Updates the elapsed time dynamically while the query is running.\n*   **Error Highlighting:** Highlights the elapsed time in red if the query resulted in an error.\n*   **Detailed Timings Breakdown (Popover):** Provides a popover with a breakdown of the time taken by each step of the query.\n*   **HTTP Overhead Calculation:** Calculates and displays the HTTP overhead time.\n*   **Performance Analysis:** Highlights slow query steps to aid in performance analysis.\n*   **Cached Results Indication:** Indicates when cached results are being displayed.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataNode/LoadNext.tsx",
        "summary": "This component provides a \"Load More\" button and accompanying text to handle pagination and data loading for data nodes, particularly HogQL queries and data visualizations. It dynamically adjusts the button text based on the query type, data limits, number of rows, and loading state. The component also handles cases where a default data limit is reached, suggesting the user add a LIMIT clause to their query. A separate `LoadPreviewText` component displays a simple message indicating the number of entries currently shown in a preview.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **\"Load More\" Button:** Allows users to fetch and display additional data for a query.\n*   **Dynamic Button Text:** Provides context-aware messages about the data being displayed, including row counts, limits, and loading status.\n*   **HogQL Query Support:** Offers specific messaging and handling for HogQL queries, including suggestions for adding LIMIT clauses.\n*   **Data Visualization Integration:** Adapts the button and text for data visualization nodes.\n*   **Preview Text:** Displays a concise message indicating the number of entries shown in a preview.\n*   **Pagination Handling:** Manages pagination for large datasets, especially when no data limit is set.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataNode/dataNodeLogic.ts",
        "summary": "This code defines a Kea logic module (`dataNodeLogic`) responsible for fetching and managing data for various types of data nodes used in PostHog insights. It handles loading, refreshing, and caching query results, as well as managing the query lifecycle, including aborting and canceling queries. The logic also incorporates features like concurrency control, automatic data loading, and integration with dashboard filters and variables. It supports different refresh types (async, blocking, force) and prioritizes queries based on their load priority.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Data Fetching and Management:** Fetches data for different types of queries (Events, Actors, Groups, HogQL, etc.) and manages their lifecycle.\n*   **Query Caching:** Caches query results to improve performance and reduce unnecessary API calls.\n*   **Query Refreshing:** Supports different refresh strategies (async, blocking, force) to ensure data is up-to-date.\n*   **Automatic Data Loading:** Automatically loads data when the query changes or at specified intervals.\n*   **Concurrency Control:** Limits the number of concurrent queries to prevent overloading the system.\n*   **Query Prioritization:** Prioritizes queries based on their importance to improve the user experience.\n*   **Dashboard Integration:** Integrates with dashboard filters and variables to allow users to customize queries.\n*   **Query Aborting/Canceling:** Allows users to abort or cancel long-running queries.\n*   **Error Handling:** Handles errors that occur during data fetching and provides informative messages to the user.\n*   **Real-time Updates:** Supports real-time updates for queries that are still running.\n*   **Data Visualization:** Provides data to visualization components.\n*   **SQL Editor Integration:** Supports manual override of queries in the SQL editor.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataNode",
        "summary": "The provided code implements a comprehensive data management and visualization system for PostHog insights, focusing on efficient data fetching, user interaction, and performance optimization. It offers features for displaying query results, managing data loading states, providing detailed query timings, and enabling users to filter and refresh data. The system supports various query types, including HogQL, and integrates with dashboard filters and variables.\n\nHere's a list of high-level product features:\n\n*   Data Visualization: Renders query results as formatted JSON, with dynamic sizing and cached results support.\n*   Data Loading and Management: Fetches, caches, refreshes, and prioritizes data for various query types, with concurrency control and automatic loading.\n*   Query Performance Analysis: Displays elapsed time, provides detailed timings breakdown with HTTP overhead calculation, and highlights slow query steps.\n*   Data Filtering: Allows users to filter data based on date ranges and test accounts, with query-specific handling and local default settings.\n*   User Interaction: Provides \"Load More\" button for pagination, dynamic button text, reload/cancel buttons, and a query editor integration button.\n*   Loading State Management: Displays loading indicators, error messages, and disables actions during loading.\n*   Data Node Collection Management: Manages a collection of data nodes, tracks their loading status, and provides bulk actions to reload or cancel loading.\n"
    },
    {
        "path": "frontend/src/queries/nodes/SavedInsight/SavedInsight.tsx",
        "summary": "This code defines a `SavedInsight` component that renders a saved insight using the `Query` component. It fetches insight data and loading state using `insightLogic` and `insightDataLogic` based on the provided `shortId` from the `SavedInsightNode`. While the insight is loading, a loading bar is displayed. Once loaded, it merges the initial query with the fetched data and renders the `Query` component with the combined query, cached results (insight), and other context properties.\n\nHere's a list of high-level product features:\n\n*   **Display Saved Insights:** Renders saved insights based on a provided query.\n*   **Data Fetching:** Fetches insight data using `insightLogic` and `insightDataLogic`.\n*   **Loading State Management:** Displays a loading bar while insight data is being fetched.\n*   **Query Merging:** Merges the initial query with fetched data for a complete query object.\n*   **Contextual Rendering:** Passes context to the underlying `Query` component for customized rendering.\n*   **Embedded Support:** Supports rendering in embedded contexts.\n*   **Read-Only Mode:** Supports a read-only mode to disable editing.\n"
    },
    {
        "path": "frontend/src/queries/nodes/SavedInsight",
        "summary": "The `SavedInsight` component facilitates the rendering of pre-defined insights within the application. It retrieves insight data and manages loading states, displaying a loading indicator while data is being fetched. Upon successful retrieval, the component merges the initial query with the fetched data and renders a `Query` component, providing cached results and contextual properties for a comprehensive and customizable insight display. The component also supports embedded contexts and read-only modes.\n\nHere's a list of high-level product features:\n\n*   Display Saved Insights\n*   Data Fetching for Insights\n*   Loading State Management with Visual Indicator\n*   Query Merging for Complete Data\n*   Contextual Rendering of Insights\n*   Embedded Support\n*   Read-Only Mode\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/filters/InsightTestAccountFilter.tsx",
        "summary": "This code defines a React component, `InsightTestAccountFilter`, which provides a switch to toggle the filtering of test accounts in insight queries. It leverages the `TestAccountFilterSwitch` component and connects to `kea` logic for managing the state of test account filtering. The component allows users to enable or disable the filtering of test accounts for a specific insight query, and it also updates the local default setting for test account filtering. The switch's state is determined by the `filterTestAccounts` property of the `InsightQueryNode` and the presence of test account filters in the current team's settings.\n\nHere's a list of high-level product features:\n\n*   **Toggle Test Account Filtering:** Allows users to enable or disable the filtering of test accounts for a specific insight query.\n*   **Reflect Team Settings:** The initial state of the filter reflects the team's default test account filter settings.\n*   **Update Local Defaults:** Changing the filter updates the local default setting for test account filtering.\n*   **Disable with Reason:** Provides a mechanism to disable the filter with a descriptive reason.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/EditorFilterGroup.tsx",
        "summary": "This code defines a React component, `EditorFilterGroup`, that renders a collapsible group of filter components for an insight editor. It allows users to expand or collapse a group of filters, displaying a title and a set of filter components within the group. The component handles the expansion state and renders the appropriate UI elements, including a button to toggle the expansion and the filter components themselves, which are rendered using `LemonField` and passed `insightProps`.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Collapsible Filter Groups:** Organizes filters into collapsible sections for better UI organization.\n*   **Expand/Collapse Toggle:** Provides a button to expand or collapse filter groups.\n*   **Dynamic Filter Rendering:** Renders filter components based on configuration, allowing for flexible filter options.\n*   **Filter Labels and Tooltips:** Displays labels and tooltips for each filter, providing context and guidance to the user.\n*   **Optional Filter Display:** Allows filters to be marked as optional, providing a cleaner initial view.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/resultCustomizationsModalLogic.ts",
        "summary": "This code defines a Kea logic module named `resultCustomizationsModalLogic` that manages the state and actions for a modal that allows users to customize the appearance (specifically the color) of individual results within Insights visualizations, particularly Trends and Funnels. It handles opening and closing the modal, selecting a color, and saving the color customization to the insight filter. The logic connects to other Kea logics such as `insightVizDataLogic`, `trendsDataLogic`, `funnelDataLogic`, and `featureFlagLogic` to access relevant data and feature flags.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Result Color Customization:** Allows users to change the color of individual data series or steps within Insights visualizations.\n*   **Modal Interface:** Provides a modal interface for selecting and applying color customizations.\n*   **Trends and Funnels Support:** Supports color customization for both Trends and Funnels insights.\n*   **Persistent Customizations:** Saves color customizations to the insight filter, ensuring they are persisted across sessions.\n*   **Feature Flag Control:** Uses a feature flag (`FEATURE_FLAGS.INSIGHT_COLORS`) to control the availability of the color customization feature.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/filters",
        "summary": "The `InsightTestAccountFilter` component provides a user interface element for controlling the filtering of test accounts within insight queries. It allows users to toggle the inclusion or exclusion of test accounts in their insights, reflecting and updating the team's default test account filter settings. The component uses a switch to represent the filter's state and provides a way to disable the filter with a reason, ensuring users understand why the filter might be unavailable.\n\nHere's a list of high-level product features:\n\n*   Toggle Test Account Filtering: Allows users to enable or disable the filtering of test accounts for a specific insight query.\n*   Reflect Team Settings: The initial state of the filter reflects the team's default test account filter settings.\n*   Update Local Defaults: Changing the filter updates the local default setting for test account filtering.\n*   Disable with Reason: Provides a mechanism to disable the filter with a descriptive reason.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/PropertyGroupFilters/propertyGroupFilterLogic.ts",
        "summary": "This code defines a Kea logic module named `propertyGroupFilterLogic` that manages property group filters for insight visualizations, specifically for TrendsQuery and StickinessQuery types. It handles the state and actions related to manipulating nested property filters, including adding, removing, duplicating, and updating filter groups, as well as setting the logical operators (AND/OR) between them. The logic also reports usage events for changes to the filter configuration. The primary purpose is to provide a structured way to manage and update complex property filters within the insight visualization context, ensuring that changes are reflected in the query.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Nested Property Filters:** Allows users to create complex filter conditions by nesting property filters within groups.\n*   **Logical Operators:** Enables users to define the logical relationships (AND/OR) between filter groups and individual filters within groups.\n*   **Dynamic Filter Management:** Provides functionality to add, remove, and duplicate filter groups, allowing for flexible filter configuration.\n*   **Real-time Query Updates:** Automatically updates the underlying query when filter configurations are changed.\n*   **Usage Tracking:** Tracks user interactions with the filter configuration to gather insights and improve the user experience.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/PropertyGroupFilters/PropertyGroupFilters.tsx",
        "summary": "This React component, `PropertyGroupFilters`, allows users to create and manage groups of property filters for insights, trends, and stickiness queries within PostHog. It provides functionality to add, remove, duplicate, and modify filter groups, as well as specify the logical relationship (AND/OR) between both the groups themselves and the filters within each group. The component also integrates with the `InsightTestAccountFilter` and disables adding filter groups for data warehouse series, suggesting the use of individual series filters instead.\n\nHere's a list of high-level product features provided by the component:\n\n*   **Add Filter Groups:** Allows users to create new groups of filters.\n*   **Remove Filter Groups:** Enables users to delete existing filter groups.\n*   **Duplicate Filter Groups:** Provides a way to copy existing filter groups.\n*   **Modify Filter Groups:** Allows users to change the filters within a group.\n*   **AND/OR Logic for Filter Groups:** Enables users to specify the logical relationship between filter groups (e.g., \"show results where group A AND group B are true\").\n*   **AND/OR Logic within Filter Groups:** Enables users to specify the logical relationship between filters within a group.\n*   **Test Account Filtering:** Integrates with a test account filter to exclude test data from insights.\n*   **Data Warehouse Series Restriction:** Disables adding filter groups for data warehouse series, guiding users to use individual series filters."
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/PropertyGroupFilters/AndOrFilterSelect.tsx",
        "summary": "This component provides a user interface element for selecting the logical operator (AND or OR) that combines filters within a group. It uses a LemonSelect component from Lemon UI to present the user with options to match \"all\" or \"any\" of the filters in the group. The component also displays a prefix and suffix to provide context to the user, such as \"Match all filters in this group\" or \"Match any filter in this group\". The component takes a callback function `onChange` to notify the parent component when the selected logical operator changes.\n\nHere's a list of high-level product features:\n\n*   **Logical Operator Selection:** Allows users to choose between \"AND\" (all filters must match) and \"OR\" (any filter must match) logic for filter groups.\n*   **UI Integration:** Leverages Lemon UI's `LemonSelect` component for a consistent and accessible user experience.\n*   **Contextual Display:** Provides a prefix and suffix to clearly communicate the meaning of the selected logical operator within the filter group.\n*   **Customizable Appearance:** Supports customization of size and disabled state.\n*   **Tooltip Support:** Provides descriptive tooltips for each option, explaining the implications of choosing \"AND\" or \"OR\" logic.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/PropertyGroupFilters",
        "summary": "The provided code collectively enables a robust property filtering system for insight visualizations within PostHog. This system allows users to create and manage complex filter configurations by grouping properties, defining logical relationships between groups and individual filters, and integrating with other features like test account filtering and data warehouse series restrictions. The system provides a user-friendly interface for manipulating these filters and ensures that changes are reflected in real-time query updates.\n\n**Features:**\n\n*   **Filter Group Management:** Add, remove, duplicate, and modify groups of property filters.\n*   **Nested Property Filters:** Create complex filter conditions by nesting property filters within groups.\n*   **AND/OR Logic:** Define logical relationships (AND/OR) between filter groups and individual filters within groups.\n*   **Test Account Filtering:** Exclude test data from insights.\n*   **Data Warehouse Series Restriction:** Guide users to use individual series filters for data warehouse series.\n*   **Real-time Query Updates:** Automatically update the underlying query when filter configurations are changed.\n*   **Usage Tracking:** Track user interactions with the filter configuration.\n*   **Contextual UI:** Provides clear context and tooltips to explain the meaning of selected logical operators.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/ComputationTimeWithRefresh.tsx",
        "summary": "This component displays the computation time of an insight and provides a refresh button. It leverages various logics to determine the last refresh time, the reason for disabling the refresh button, and user permissions to bypass refresh restrictions. The component periodically re-renders to keep the \"time ago\" string up-to-date.\n\n**Features:**\n\n*   **Displays Computation Time:** Shows how long ago the insight data was last computed.\n*   **Manual Refresh:** Provides a button to manually refresh the insight data.\n*   **Refresh Button Disabling:** Disables the refresh button based on specific conditions, providing a tooltip explaining the reason.\n*   **Admin/Dev Bypass:** Allows staff users, impersonated users, and users in a development environment to bypass refresh restrictions.\n*   **Periodic Re-render:** Updates the displayed computation time dynamically.\n*   **Async/Blocking Query Handling:** Determines whether to force an async or blocking query when refreshing.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/InsightResultMetadata.tsx",
        "summary": "This React component, `InsightResultMetadata`, displays metadata about an insight's results. It leverages Kea logic to access insight properties and visualization data, specifically the sampling factor. The component conditionally renders the computation time (with optional refresh) and the percentage of users used for the calculation, providing context about the data's freshness and scope. Props allow disabling the display of the last computation time and its refresh functionality.\n\nHere's a list of high-level product features:\n\n*   **Display Insight Computation Time:** Shows when the insight data was last computed.\n*   **Refreshable Computation Time:** Allows users to refresh the computation time to see the latest update.\n*   **Sampling Factor Display:** Indicates the percentage of users used to calculate the insight results.\n*   **Conditional Display Options:** Enables hiding the computation time and its refresh option based on props.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/LifecycleToggles.tsx",
        "summary": "This code defines a React component called `LifecycleToggles` that allows users to filter insights based on user lifecycle stages. It provides checkboxes for \"new\", \"returning\", \"resurrecting\", and \"dormant\" users, each with a tooltip explaining the lifecycle stage and a corresponding color. The component uses the `insightVizDataLogic` to manage the state of the toggled lifecycle filters and update the insight filter accordingly.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Lifecycle Stage Filtering:** Allows users to filter insights based on user lifecycle stages (new, returning, resurrecting, dormant).\n*   **Visual Representation:** Uses colors to visually represent each lifecycle stage.\n*   **Tooltip Explanations:** Provides tooltips to explain the meaning of each lifecycle stage.\n*   **Toggle Functionality:** Enables users to easily toggle lifecycle stages on or off using checkboxes.\n*   **State Management:** Manages the state of the toggled lifecycle filters using `kea` logic.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/StickinessCriteria.tsx",
        "summary": "This React component, `StickinessCriteria`, provides a user interface for configuring stickiness criteria within an insight visualization. It allows users to define the conditions under which a user is considered \"sticky\" based on the number of times they perform an event within a given time interval. The component includes a dropdown to select an operator (less than or equal to, greater than or equal to, or exact) and a numerical input field to specify the value for the criteria. The selected operator and value are then used to update the insight filter, affecting the visualization.\n\n**Features:**\n\n*   **Operator Selection:** Allows users to choose the comparison operator for stickiness criteria (e.g., greater than or equal to, less than or equal to, exact).\n*   **Value Input:** Provides a numerical input field for users to specify the threshold value for the stickiness criteria.\n*   **Real-time Updates:** Updates the insight filter and visualization in real-time as the user modifies the operator and value.\n*   **Default Values:** Provides default values for the operator and value to ensure a functional initial state.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/CumulativeStickinessFilter.tsx",
        "summary": "This code defines a React component, `CumulativeStickinessFilter`, which provides a dropdown menu for selecting the stickiness computation mode in an insight visualization. It uses `LemonSelect` from `@posthog/lemon-ui` to present the user with two options: \"Non-cumulative\" and \"Cumulative\". The selected mode is then used to update the insight filter via the `insightVizDataLogic` kea logic. This component allows users to switch between viewing the exact number of users active for each number of days and viewing the number of users active for at least N days.\n\nHere's a list of high-level product features:\n\n*   **Stickiness Computation Mode Selection:** Allows users to choose between non-cumulative and cumulative stickiness calculations.\n*   **Dropdown Menu Interface:** Uses a dropdown menu for easy selection of the computation mode.\n*   **Insight Filter Update:** Updates the insight filter based on the selected computation mode.\n*   **Visual Representation Toggle:** Changes the insight visualization based on the selected stickiness mode (Non-cumulative vs Cumulative).\n*   **Tooltips:** Provides helpful tooltips to explain the difference between the two modes.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/Breakdown.tsx",
        "summary": "This code defines a `Breakdown` component for the frontend of a product analytics tool. It leverages the `TaxonomicBreakdownFilter` component to allow users to filter and break down data in insights visualizations. The component retrieves data and actions from the `insightVizDataLogic` using the `kea` library. It handles updating the breakdown filter and display settings, while also disabling the breakdown functionality under certain conditions, such as when dealing with multiple series types in a data warehouse context.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Data Breakdown Filtering:** Allows users to filter and segment data within insights visualizations.\n*   **Taxonomic Breakdown:** Supports a structured or hierarchical approach to data breakdown.\n*   **Insight Visualization Customization:** Enables users to customize the display of insights based on breakdown selections.\n*   **Conditional Breakdown Availability:** Disables breakdown functionality based on the type of data series being analyzed (e.g., multiple series in a data warehouse).\n*   **Real-time Updates:** Provides real-time updates to the visualization as breakdown filters are modified.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/ResultCustomizationsModal.tsx",
        "summary": "This code defines a modal component, `ResultCustomizationsModal`, that allows users to customize the color of query results in PostHog insights. The modal displays information about the series being customized, including the event/action and breakdown (if applicable). Users can select a color from a predefined theme to apply to the selected series. The customizations are saved and reflected on dashboards, providing a more meaningful and personalized appearance for data visualization.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Color Customization:** Allows users to change the color associated with a specific query result series.\n*   **Series Identification:** Clearly identifies the series being customized, including event/action and breakdown values.\n*   **Color Palette:** Provides a selection of predefined colors based on the current data theme.\n*   **Persistence:** Saves color customizations for future use and displays them on dashboards.\n*   **Contextual Information:** Displays information about how results are assigned colors (by rank or name).\n*   **Insight Type Handling:** Adapts the displayed information based on the insight type (Trends or Funnels).\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/utils.ts",
        "summary": "This code provides utility functions for handling insight queries and converting between different representations of insight data, particularly focusing on transitioning from filter-based insights to query-based insights. It includes functions for extracting event names from queries, caching query results, converting insight models and dashboards to a query-based format, generating default queries based on insight type, and converting filters to query nodes. The code ensures that insights and dashboards can be represented and manipulated using a unified query-based approach.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Insight Query Management:** Enables the creation, modification, and storage of insight queries.\n*   **Filter-to-Query Conversion:** Allows users to define insights using filters, which are then automatically converted into structured queries.\n*   **Cached Query Results:** Supports caching and retrieval of query results to improve performance and reduce redundant computations.\n*   **Default Query Generation:** Provides default query configurations for different insight types, simplifying the initial setup process.\n*   **Dashboard Conversion:** Facilitates the conversion of dashboards containing filter-based insights to dashboards with query-based insights.\n*   **Event Name Extraction:** Extracts event names from insight queries, enabling analysis and reporting on specific events.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/TrendsSeriesLabel.tsx",
        "summary": "This React component, `TrendsSeriesLabel`, is responsible for rendering a label and a button that toggles formula mode for insights in the PostHog application. It utilizes the `insightVizDataLogic` to determine the current state of the insight, including whether formula mode is enabled, the display type, and the number of series. The component dynamically enables or disables the formula mode toggle button based on the insight's configuration, providing a tooltip to explain the reasons for disabling the button.\n\nHere's a list of high-level product features associated with this component:\n\n*   **Formula Mode Toggle:** Allows users to switch between displaying raw series data and custom formulas derived from the series.\n*   **Dynamic Button State:** Enables or disables the formula mode toggle button based on the chart type and number of series, preventing invalid configurations.\n*   **Informative Tooltips:** Provides users with context on why the formula mode button might be disabled, guiding them towards valid configurations.\n*   **Series/Variables Label:** Dynamically displays \"Series\" or \"Variables\" depending on whether formula mode is enabled, clarifying the meaning of the subsequent list of items.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/TrendsFormula.tsx",
        "summary": "This code defines a React component, `TrendsFormula`, responsible for handling mathematical formulas within an insights visualization tool. It allows users to input, edit, add, and remove formulas used for trend analysis. The component manages both a single \"formula\" field (for backward compatibility) and a list of \"formulas\" for more complex calculations. It ensures that at least one formula input field is always available when the formula mode is enabled and updates the insight filters with the entered formulas, filtering out empty entries before updating the query. The component also restricts input to a set of allowed characters to ensure formula validity.\n\n**Features:**\n\n*   **Formula Input:** Provides input fields for users to enter mathematical formulas.\n*   **Multiple Formulas:** Supports defining multiple formulas for complex calculations.\n*   **Dynamic Formula Management:** Allows users to add and remove formula input fields dynamically.\n*   **Input Validation:** Restricts input to a predefined set of allowed characters.\n*   **Real-time Updates:** Updates the insight filters as formulas are edited (on blur and enter).\n*   **Backward Compatibility:** Supports a single \"formula\" field for compatibility with older versions.\n*   **Formula Persistence:** Preserves entered formulas even when toggling the formula switch.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/GlobalAndOrFilters.tsx",
        "summary": "This component, `GlobalAndOrFilters`, is responsible for rendering and managing global \"AND/OR\" filters within the Insights visualization editor. It leverages the `PropertyGroupFilters` component to handle the display and modification of these filters. It fetches necessary data such as actions, group types, and the current query from various Kea logics and models. It also defines the available taxonomic filter group types that can be used in the filters. The component then passes this data to the `PropertyGroupFilters` component, enabling users to create and modify complex filter logic for their insights.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Global \"AND/OR\" Filtering:** Allows users to apply filters that affect the entire insight, combining conditions with \"AND\" and \"OR\" logic.\n*   **Taxonomic Filter Support:** Enables filtering based on a wide range of taxonomic types, including event properties, person properties, feature flags, cohorts, elements, session properties, HogQL expressions, and data warehouse properties.\n*   **Integration with Insight Visualization Editor:** Seamlessly integrates with the insight editor, providing a user-friendly interface for creating and modifying filters.\n*   **Dynamic Filter Options:** Dynamically updates filter options based on available events, actions, and group types.\n*   **Data Warehouse Property Filtering:** Supports filtering based on properties stored in a data warehouse.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/InsightViz.tsx",
        "summary": "The `InsightViz` component is a React component that visualizes insights based on a provided query. It manages the display of the insight, including filters, data, and visualization options. The component handles data fetching, error boundaries, and different display modes (e.g., embedded, read-only). It leverages Kea logic for state management and feature flags for conditional rendering of certain features. The component also supports overriding filters and variables, and it integrates with other components like `EditorFilters` and `InsightVizDisplay` to provide a comprehensive insight visualization experience.\n\nHere's a list of high-level product features provided by the `InsightViz` component:\n\n*   **Insight Visualization:** Displays insights in various formats (charts, tables, etc.) based on a query.\n*   **Query Editor Integration:** Allows users to edit and refine the underlying query for the insight.\n*   **Filter Application:** Supports applying filters to the insight data, including dashboard-level overrides.\n*   **Data Fetching and Caching:** Fetches and caches data for the insight, optimizing performance.\n*   **Display Mode Customization:** Offers different display modes (e.g., embedded, full-screen) with configurable visibility of elements like headers, tables, and filters.\n*   **Error Handling:** Provides error boundaries to gracefully handle errors during insight rendering.\n*   **Feature Flag Support:** Enables or disables features based on feature flags.\n*   **Variable Overrides:** Allows overriding variables used in the insight query.\n*   **Horizontal Controls:** Provides horizontal layout for funnels and retention insights.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/TrendsSeries.tsx",
        "summary": "This code defines the `TrendsSeries` component, a React component responsible for rendering and managing the series of data displayed in trends, lifecycle, and stickiness insights within a PostHog application. It leverages Kea logic for state management and actions, and interacts with other components like `ActionFilter` and `AggregationSelect` to allow users to configure the data series being visualized. The component dynamically adjusts its behavior based on the type of insight being displayed (trends, lifecycle, or stickiness), and it handles the conversion of user-defined filters into a query node structure suitable for data fetching.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Data Series Configuration:** Allows users to define and customize the data series displayed in insights, including selecting events, actions, and properties.\n*   **Aggregation Control:** Enables users to specify how data is aggregated (e.g., unique users, event count) for lifecycle insights.\n*   **Dynamic UI based on Insight Type:** Adapts the user interface and available options based on the type of insight being viewed (trends, lifecycle, stickiness).\n*   **Filter Management:** Provides a mechanism for users to apply filters to the data series, refining the data being visualized.\n*   **Series Limit:** Enforces a limit on the number of series displayed for certain display types or insight types.\n*   **Visual Series Indication:** Displays a visual indicator for each series, helping users distinguish between them.\n*   **Integration with Taxonomic Filters:** Supports various taxonomic filter groups, including event properties, person properties, cohorts, and more.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/InsightVizDisplay.tsx",
        "summary": "The `InsightVizDisplay` component is a central component for rendering various types of insights in the PostHog application. It dynamically displays different visualizations like Trends, Stickiness, Lifecycle, Funnels, Retention, and Paths based on the `activeView` and `insightProps`. The component handles loading states, validation errors, and empty states, providing appropriate messages and actions to the user. It also includes features like exporting data, displaying detailed results in tables, showing computation metadata, and customizing result displays. The component adapts its presentation based on whether it's embedded, in shared mode, or in edit mode, and it integrates with other components like `InsightLegend`, `ExportButton`, and various visualization-specific components.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Insight Visualization:** Renders different insight types (Trends, Stickiness, Lifecycle, Funnels, Retention, Paths) based on user configuration.\n*   **Loading and Error Handling:** Displays loading states, validation errors, and timeout messages to provide feedback to the user.\n*   **Empty State Management:** Shows appropriate empty states with contextual messages and actions when no data is available.\n*   **Detailed Results Table:** Presents detailed results in a table format with export functionality.\n*   **Insight Legend:** Displays a legend for the insight visualization.\n*   **Funnel Correlation:** Shows a correlation table for funnel insights.\n*   **Result Customization:** Allows users to customize the display of insight results.\n*   **Computation Metadata:** Displays metadata about the last computation, including refresh options.\n*   **Exporting Data:** Enables users to export detailed results in CSV and XLSX formats.\n*   **Contextual Display:** Adapts the display based on the context (embedded, shared mode, edit mode).\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/InsightDisplayConfig.tsx",
        "summary": "This code defines the `InsightDisplayConfig` component, which provides a set of filters and options to customize the display of insights in PostHog. It dynamically renders various filters based on the insight type (Trends, Funnels, Retention, Paths, Stickiness, Lifecycle) and the selected display type. These filters include date ranges, intervals, smoothing, breakdown, path steps, comparisons, and chart-specific options. The component also includes an \"Options\" menu for advanced settings like value display on series, percentage stack view, legend visibility, y-axis scaling, decimal precision, and retention dashboard display.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Insight Date Filtering:** Allows users to specify a date range for the insight data.\n*   **Interval Selection:** Enables users to define the time interval for time-series insights (e.g., daily, weekly, monthly).\n*   **Smoothing:** Provides a smoothing function to reduce noise in time-series data.\n*   **Breakdown Filtering:** Allows users to segment data by specific properties or characteristics.\n*   **Path Step Selection:** Enables users to select specific steps in a path analysis.\n*   **Comparison:** Allows users to compare data across different time periods or segments.\n*   **Chart Type Selection:** Enables users to choose the chart type for the insight (e.g., line graph, bar chart).\n*   **Advanced Display Options:**\n    *   Displaying values on series.\n    *   Showing percentage stack view.\n    *   Controlling legend visibility.\n    *   Configuring Y-axis scale.\n    *   Setting decimal precision.\n    *   Configuring retention dashboard display.\n    *   Showing alert threshold lines.\n    *   Showing multiple Y axes.\n*   **Funnel-Specific Options:**\n    *   Funnel Display Layout Picker\n    *   Funnel Bins Picker\n*   **Result Customization:** Allows users to customize the appearance of individual results in insights.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz/EditorFilters.tsx",
        "summary": "This code defines the `EditorFilters` component, which is responsible for rendering a set of filters for different insight types (Trends, Funnels, Retention, Paths, Lifecycle, and Stickiness) within the PostHog application. The component dynamically displays relevant filter groups and individual filters based on the selected insight type and available features. It utilizes various sub-components for specific filter functionalities, such as breakdown, attribution, funnel steps, path event types, retention conditions, stickiness criteria, and more. The filters are organized into left and right columns, each containing groups of related filters.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Insight Type Specific Filters:** Dynamically displays relevant filters based on the selected insight type (Trends, Funnels, Retention, Paths, Lifecycle, Stickiness).\n*   **Trends Analysis Filters:** Includes filters for series selection, formula input, and breakdown options for trends insights.\n*   **Funnel Analysis Filters:** Provides filters for defining funnel steps, advanced funnel options, and attribution settings.\n*   **Retention Analysis Filters:** Offers filters for setting retention conditions and calculation options.\n*   **Paths Analysis Filters:** Includes filters for event types, SQL expressions (HogQL), wildcard groups, start/end targets, and advanced path options.\n*   **Lifecycle Analysis Filters:** Provides toggles for lifecycle-specific settings.\n*   **Stickiness Analysis Filters:** Offers filters for defining stickiness criteria and cumulative stickiness calculations.\n*   **Global Filters:** Allows applying global filters to the insight query.\n*   **Breakdown Options:** Enables breaking down insights by specific properties.\n*   **Advanced Options:** Provides access to advanced settings for paths and funnels insights.\n*   **Feature Flag Dependent Filters:** Shows or hides certain filters based on available feature flags (e.g., Paths Advanced).\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightViz",
        "summary": "The provided code collectively implements a comprehensive suite of features for creating, customizing, and visualizing insights within PostHog. These features empower users to analyze data through various insight types, apply complex filters, customize the appearance of results, and manage the display of visualizations. The system supports real-time updates, handles loading and error states, and integrates with feature flags for controlled feature rollouts.\n\nHere's a list of high-level product features:\n\n*   **Insight Creation and Visualization:** Supports various insight types (Trends, Funnels, Retention, Paths, Lifecycle, Stickiness) with dynamic visualization rendering.\n*   **Advanced Filtering:** Enables complex filtering with collapsible filter groups, AND/OR logic, property filters, test account filtering, and global filters.\n*   **Data Breakdown and Segmentation:** Allows users to break down data by various properties and characteristics.\n*   **Result Customization:** Provides options to customize the appearance of individual results, including color customization.\n*   **Formula Input and Management:** Supports mathematical formulas for trend analysis, with dynamic formula management and input validation.\n*   **Computation Time and Refresh:** Displays the computation time of insights and provides manual refresh options.\n*   **Data Export:** Enables users to export detailed results in CSV and XLSX formats.\n*   **Lifecycle Stage Filtering:** Allows filtering insights based on user lifecycle stages.\n*   **Stickiness Analysis:** Provides options for configuring stickiness criteria and computation modes.\n*   **Query Management:** Enables the creation, modification, and storage of insight queries, with filter-to-query conversion and cached query results.\n*   **Display Configuration:** Offers a wide range of display options, including date ranges, intervals, smoothing, chart types, and advanced settings.\n*   **Contextual UI:** Provides informative tooltips and adapts the UI based on the insight type and available features.\n*   **Error Handling and Loading States:** Displays loading states, validation errors, and timeout messages to provide feedback to the user.\n*   **Feature Flag Integration:** Enables or disables features based on feature flags.\n"
    },
    {
        "path": "frontend/src/queries/nodes/GroupsQuery/GroupsSearch.tsx",
        "summary": "This code defines a search component for filtering groups within a PostHog application. It utilizes a debounced input field to optimize search performance, updating the query only after a short delay following user input. The component also includes a tooltip providing guidance on search criteria, allowing users to search by group name or distinct ID.\n\n**Features:**\n\n*   **Group Search:** Enables users to search for specific groups.\n*   **Debounced Input:** Implements a debounced input field to improve search performance by reducing the frequency of query updates.\n*   **Search by Name or Distinct ID:** Allows users to search for groups using either their name or distinct ID.\n*   **Informative Tooltip:** Provides a tooltip to guide users on acceptable search criteria.\n"
    },
    {
        "path": "frontend/src/queries/nodes/GroupsQuery/GroupPropertyFilters.tsx",
        "summary": "This code defines a `GroupPropertyFilters` component that allows users to filter groups based on their properties. It utilizes the `PropertyFilters` component from the `lib/components/PropertyFilters` library to provide a user interface for defining and managing these filters. The component receives a `GroupsQuery` object as input, which contains the current filter settings, and a `setQuery` function to update the query when the filters are changed. It dynamically generates a unique page key for the `PropertyFilters` component and configures it with the appropriate taxonomic group type based on the `group_type_index` in the query.\n\nHere's a list of high-level product features:\n\n*   **Group Property Filtering:** Allows users to filter groups based on their properties.\n*   **Dynamic Filter Configuration:** Configures the filter UI based on the `group_type_index` from the query.\n*   **State Management:** Manages the filter state using the `GroupsQuery` object and the `setQuery` function.\n*   **Taxonomic Filtering:** Supports taxonomic filtering of group properties.\n*   **Error Handling:** Displays an error message if property groups are not supported.\n"
    },
    {
        "path": "frontend/src/queries/nodes/GroupsQuery",
        "summary": "The provided code snippets detail components for filtering and searching groups within a PostHog application. The `GroupPropertyFilters` component enables users to filter groups based on their properties, dynamically configuring the filter UI based on the group type and managing the filter state. The `GroupsSearch` component allows users to search for groups by name or distinct ID, utilizing a debounced input field and providing an informative tooltip for guidance.\n\nHere's a list of high-level product features:\n\n*   **Group Property Filtering:** Allows users to filter groups based on their properties with dynamic configuration based on group type.\n*   **Group Search:** Enables users to search for specific groups by name or distinct ID with debounced input for performance.\n*   **Taxonomic Filtering:** Supports taxonomic filtering of group properties.\n*   **Informative Tooltips:** Provides guidance to users on search and filtering criteria.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightQuery/defaults.ts",
        "summary": "This code defines default configurations for various types of insight queries within a product analytics platform. These queries are used to visualize and analyze user behavior data. The code provides default settings for Trends, Funnels, Retention, Paths, Stickiness, and Lifecycle queries, specifying default events, metrics, filters, and visualization types. These defaults serve as a starting point for users when creating new insights, allowing them to quickly explore their data without having to configure every setting from scratch.\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **Trends Analysis:** Visualize trends in event data over time.\n*   **Funnel Analysis:** Analyze user conversion rates through a series of steps.\n*   **Retention Analysis:** Track user retention rates over time.\n*   **Path Analysis:** Visualize common user paths through the application.\n*   **Stickiness Analysis:** Measure how frequently users perform specific actions.\n*   **Lifecycle Analysis:** Analyze user engagement throughout their lifecycle.\n*   **Customizable Queries:** Users can customize the default queries to fit their specific needs.\n*   **Default Query Configurations:** Pre-defined default settings for each query type to simplify setup.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightQuery/utils/cleanProperties.ts",
        "summary": "This code provides utility functions to clean and transform property filters used in insights queries. It handles different formats of property definitions, including old-style dictionaries, simple lists, and nested property group filters with AND/OR logic. The cleaning process involves standardizing property structures, fixing typos, setting default operators, and removing invalid or unnecessary keys. The code ensures that property filters are in a consistent and valid format for use in querying and filtering data.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Property Filtering:** Allows users to filter data based on event and user properties.\n*   **Complex Filter Logic:** Supports combining property filters with AND/OR logic for advanced filtering scenarios.\n*   **Data Standardization:** Ensures consistency in property filter formats, regardless of the input method.\n*   **Backward Compatibility:** Handles older property filter formats, ensuring existing insights continue to work.\n*   **Error Prevention:** Prevents errors by removing invalid or incomplete property definitions.\n*   **Cohort Filtering:** Enables filtering based on cohort membership.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightQuery/utils/legacy.ts",
        "summary": "This code defines a set of functions to detect whether a given filter configuration for different insight types (Trends, Funnels, Retention, Paths, Stickiness, and Lifecycle) uses a legacy format. Each function checks for the presence of specific keys within the filter object that are indicative of the older filter structure. This is likely used to maintain backward compatibility or to handle migrations from older versions of the application.\n\nHere's a list of high-level product features related to this code:\n\n*   **Insight Configuration Migration:** The system can detect and potentially migrate older insight configurations to a newer format.\n*   **Backward Compatibility:** The system can still interpret and display insights configured using older filter parameters.\n*   **Trends Insights:** Supports various display options for trends, including smoothing, legends, axis formatting, decimal places, and value display.\n*   **Funnels Insights:** Supports different funnel visualization types, step references, breakdown attribution, bin counts, window intervals, ordering, and aggregation.\n*   **Funnels Exclusion:** Supports excluding specific events or steps from funnels analysis.\n*   **Retention Insights:** Supports different retention types, references, total intervals, and entity targeting.\n*   **Paths Insights:** Supports path analysis with features like HOGQL expressions, event type inclusion/exclusion, start/end points, path groupings, funnel paths, step limits, path replacements, cleaning filters, and edge limits.\n*   **Stickiness Insights:** Supports displaying stickiness metrics with legends and value display options.\n*   **Lifecycle Insights:** Supports displaying values on series for lifecycle insights."
    },
    {
        "path": "frontend/src/queries/nodes/InsightQuery/utils/filtersToQueryNode.ts",
        "summary": "This code defines a function `filtersToQueryNode` that converts a set of filters from the frontend into a query node structure suitable for backend processing. It handles various insight types (Trends, Funnels, Retention, Paths, Stickiness, Lifecycle) and their corresponding filter types, mapping them to specific query node kinds. The code also includes helper functions for converting legacy entity formats, managing hidden legend keys, and sanitizing retention entities. It constructs query nodes with properties, date ranges, series data, breakdowns, comparisons, and other insight-specific configurations.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Insight Generation:** Allows users to create various types of insights (Trends, Funnels, Retention, Paths, Stickiness, Lifecycle) based on selected filters.\n*   **Data Filtering:** Supports filtering data based on events, actions, data warehouses, and properties.\n*   **Breakdown Analysis:** Enables users to break down insights by different properties and types.\n*   **Comparison Analysis:** Supports comparing data across different time periods or segments.\n*   **Funnel Analysis:** Provides features specific to funnel analysis, such as exclusion steps and conversion windows.\n*   **Data Visualization:** Configures visualization options like smoothing intervals, legend display, and axis formatting.\n*   **Customizable Metrics:** Allows users to define custom metrics using math formulas and properties.\n*   **Data Sanitization:** Cleans and sanitizes user-provided data to ensure data integrity.\n*   **Error Handling:** Implements error handling and reporting using Sentry."
    },
    {
        "path": "frontend/src/queries/nodes/InsightQuery/utils/queryNodeToFilter.ts",
        "summary": "This code provides utility functions to convert an `InsightQueryNode` (a representation of a PostHog insight query) into a `FilterType` object, which is used for querying the PostHog API. It handles different types of insight queries (Trends, Funnels, Retention, Paths, Stickiness, and Lifecycle) and extracts relevant filter parameters from the query node, including properties, date ranges, actions, events, breakdowns, and comparison filters. The code also converts camelCase properties to snake_case properties for legacy filters and handles specific configurations for each insight type, such as hidden legend keys, funnel exclusions, and retention settings.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Trends Insights:** Allows users to visualize trends in their data over time, with options for smoothing intervals, decimal places, aggregation axis formatting, and showing/hiding labels and legends.\n*   **Funnels Insights:** Enables users to analyze the conversion rates between different steps in a user journey, with features for defining exclusions, bin counts, breakdown attribution, and funnel visualization types.\n*   **Retention Insights:** Provides insights into user retention rates over time, with options for defining retention references, types, target entities, and showing cumulative retention.\n*   **Paths Insights:** Allows users to visualize the most common paths users take through their product, with features for setting edge limits, including/excluding event types, defining start/end points, and grouping paths.\n*   **Stickiness Insights:** Enables users to analyze how often users perform a specific action within a given time period, with options for showing/hiding legends and values on series.\n*   **Lifecycle Insights:** Provides insights into the different stages of a user's lifecycle, with options for showing values on series.\n*   **Data Warehouse Insights:** Allows users to query data directly from their data warehouse.\n*   **Conversion of Query Nodes to API Filters:** Converts a query node into a filter object that can be used to query the PostHog API.\n*   **Support for Actions and Events:** Allows users to filter insights by actions and events.\n*   **Support for Breakdowns and Comparisons:** Allows users to break down insights by properties and compare them across different segments.\n*   **Camel Case to Snake Case Conversion:** Converts camel case properties to snake case properties for legacy filters.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightQuery/utils",
        "summary": "This collection of code files provides the core functionality for creating, configuring, and querying insights within the PostHog platform. It encompasses features for defining complex filters, converting these filters into API queries, and handling legacy filter formats to ensure backward compatibility. The code supports a variety of insight types, including Trends, Funnels, Retention, Paths, Stickiness, and Lifecycle, each with its own set of configurable options and visualizations.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Insight Generation & Configuration:** Creation and customization of various insight types (Trends, Funnels, Retention, Paths, Stickiness, Lifecycle) with a wide range of configurable options.\n*   **Data Filtering & Segmentation:** Advanced filtering capabilities based on event properties, user properties, actions, cohorts, and custom metrics, with support for complex AND/OR logic.\n*   **Data Visualization & Analysis:** Visualization of data trends, funnels, retention rates, user paths, and stickiness metrics, with customizable display options such as smoothing, legends, axis formatting, and value display.\n*   **Backward Compatibility & Data Migration:** Handling of legacy filter formats and potential migration to newer formats, ensuring existing insights continue to function correctly.\n*   **API Integration:** Conversion of frontend filter configurations into API queries for efficient data retrieval and analysis.\n*   **Data Sanitization & Error Handling:** Cleaning and sanitizing user-provided data to ensure data integrity and robust error handling with reporting.\n"
    },
    {
        "path": "frontend/src/queries/nodes/InsightQuery",
        "summary": "This collection of code files defines the core functionality for creating, configuring, and querying insights within a product analytics platform. It provides default configurations for various types of insight queries, including Trends, Funnels, Retention, Paths, Stickiness, and Lifecycle queries, specifying default events, metrics, filters, and visualization types. The code also encompasses features for defining complex filters, converting these filters into API queries, and handling legacy filter formats to ensure backward compatibility.\n\nHere's a list of high-level product features:\n\n*   Insight Generation & Configuration: Creation and customization of various insight types (Trends, Funnels, Retention, Paths, Stickiness, Lifecycle) with a wide range of configurable options.\n*   Data Filtering & Segmentation: Advanced filtering capabilities based on event properties, user properties, actions, cohorts, and custom metrics, with support for complex AND/OR logic.\n*   Data Visualization & Analysis: Visualization of data trends, funnels, retention rates, user paths, and stickiness metrics, with customizable display options such as smoothing, legends, axis formatting, and value display.\n*   Backward Compatibility & Data Migration: Handling of legacy filter formats and potential migration to newer formats, ensuring existing insights continue to function correctly.\n*   API Integration: Conversion of frontend filter configurations into API queries for efficient data retrieval and analysis.\n*   Data Sanitization & Error Handling: Cleaning and sanitizing user-provided data to ensure data integrity and robust error handling with reporting.\n*   Trends Analysis: Visualize trends in event data over time.\n*   Funnel Analysis: Analyze user conversion rates through a series of steps.\n*   Retention Analysis: Track user retention rates over time.\n*   Path Analysis: Visualize common user paths through the application.\n*   Stickiness Analysis: Measure how frequently users perform specific actions.\n*   Lifecycle Analysis: Analyze user engagement throughout their lifecycle.\n*   Customizable Queries: Users can customize the default queries to fit their specific needs.\n*   Default Query Configurations: Pre-defined default settings for each query type to simplify setup.\n"
    },
    {
        "path": "frontend/src/queries/nodes/Node/EditHogQLButton.tsx",
        "summary": "This code defines a React component, `EditHogQLButton`, which is a button that allows users to edit a HogQL query directly. When clicked, the button navigates the user to a new insight page with the HogQL query pre-populated in the query editor. The button utilizes LemonButton from the Lemon UI library, displays a query editor icon, and includes a tooltip for clarity.\n\nHere's a list of the high-level product features:\n\n*   **HogQL Query Editing:** Allows users to directly edit HogQL queries.\n*   **Navigation to Insight Creation:** Navigates the user to a new insight page pre-populated with the HogQL query.\n*   **UI Integration:** Uses Lemon UI components for a consistent user experience.\n*   **Visual Cue:** Displays a query editor icon to indicate the button's function.\n*   **Tooltip:** Provides a tooltip to explain the button's purpose.\n"
    },
    {
        "path": "frontend/src/queries/nodes/Node/OpenEditorButton.tsx",
        "summary": "This code defines a React component called `OpenEditorButton` that renders a button using the `LemonButton` component from the `lemon-ui` library. The button, when clicked, navigates the user to a new insight page in the application, pre-populated with the data from the currently selected query node. The button is styled as a secondary button, displays a preview icon, and has a tooltip that reads \"Open as a new insight\". The destination URL is dynamically generated based on the `query` prop, which represents the current query node.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Open Query in Editor:** Allows users to open the current query in a dedicated editor.\n*   **New Insight Creation:** Facilitates the creation of new insights based on existing queries.\n*   **Pre-populated Editor:** Automatically populates the editor with the data from the selected query.\n*   **Visual Button Element:** Provides a clear and intuitive button for users to initiate the action.\n*   **Tooltip Explanation:** Offers a helpful tooltip to explain the button's functionality.\n"
    },
    {
        "path": "frontend/src/queries/nodes/Node",
        "summary": "The provided code snippets describe two React components, `EditHogQLButton` and `OpenEditorButton`, both designed to enhance the user experience when working with HogQL queries. These components provide users with intuitive ways to edit and explore queries by navigating them to a new insight page with the query pre-populated in the editor. Both components leverage the Lemon UI library for a consistent look and feel, incorporate visual cues like icons, and offer tooltips for clarity.\n\nHere's a consolidated list of high-level product features:\n\n*   **HogQL Query Editing:** Enables direct modification of HogQL queries.\n*   **Insight Creation from Query:** Streamlines the process of creating new insights based on existing queries.\n*   **Pre-populated Query Editor:** Automatically loads the selected query into the editor for immediate use.\n*   **Intuitive UI Buttons:** Provides clear and accessible buttons for initiating query editing and insight creation.\n*   **Contextual Tooltips:** Offers helpful explanations of button functionality.\n"
    },
    {
        "path": "frontend/src/queries/nodes/WebVitals/WebVitalsProgressBar.tsx",
        "summary": "This code defines a `WebVitalsProgressBar` component that visually represents a web vitals metric's value within predefined performance bands (good, needs improvement, poor). The component uses color-coded segments to indicate the range of each band and displays a vertical indicator line to pinpoint the exact value within its corresponding band. The `IndicatorLine` component is only rendered if the current value falls within the band being rendered by the parent `WebVitalsProgressBar` component.\n\nHere's a list of high-level product features:\n\n*   **Visual Representation of Web Vitals:** Displays web vitals metrics using a progress bar.\n*   **Color-Coded Performance Bands:** Uses green, yellow, and red segments to represent \"good,\" \"needs improvement,\" and \"poor\" performance bands, respectively.\n*   **Dynamic Indicator Line:** Shows a vertical line indicating the exact value of the metric within its band.\n*   **Metric-Specific Thresholds:** Uses predefined thresholds for each web vitals metric to determine band ranges.\n*   **Conditional Rendering:** Only renders the indicator line if the value falls within the current band.\n"
    },
    {
        "path": "frontend/src/queries/nodes/WebVitals/WebVitalsTab.tsx",
        "summary": "The `WebVitalsTab` component displays key web performance metrics (WebVitals) in a tab format. It shows the metric's value, unit, and a progress bar indicating its performance level. The component also includes a tooltip with a description of the metric. It highlights the active tab with a distinct border and adapts its layout for different screen sizes, providing a compact view on smaller screens and a more detailed view on larger screens.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Displays Web Vitals Metrics:** Shows key web performance metrics like First Input Delay (FID), Largest Contentful Paint (LCP), etc.\n*   **Visual Performance Indication:** Uses color-coding and a progress bar to visually represent the performance level of each metric.\n*   **Metric Descriptions:** Provides tooltips with descriptions for each metric to help users understand their significance.\n*   **Active Tab Highlighting:** Clearly indicates the currently selected metric tab.\n*   **Responsive Layout:** Adapts the layout for different screen sizes to ensure optimal viewing on various devices.\n*   **Loading State:** Displays a skeleton loader when the metric value is not yet available.\n"
    },
    {
        "path": "frontend/src/queries/nodes/WebVitals/WebVitals.tsx",
        "summary": "This code defines a `WebVitals` component that displays web performance metrics (INP, LCP, FCP, CLS) fetched using a query. It uses tabs to allow users to select a specific metric, displaying the value for the last day in the selected time range. The component also includes a `WebVitalsContent` component (not defined in this snippet) and a `Query` component that displays the underlying query used to fetch the data. Finally, it provides a button to open the query as a new Insight in the product analytics section.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Web Vitals Dashboard:** Displays key web performance metrics (INP, LCP, FCP, CLS).\n*   **Metric Selection Tabs:** Allows users to select and view individual web vital metrics.\n*   **Data Visualization:** Displays the selected metric's value.\n*   **Query Display:** Shows the underlying query used to fetch the web vitals data.\n*   **Insight Creation:** Enables users to create a new insight based on the web vitals query.\n*   **Documentation Link:** Provides a link to the documentation for more information on web vitals."
    },
    {
        "path": "frontend/src/queries/nodes/WebVitals/WebVitalsPathBreakdown.tsx",
        "summary": "This code defines a React component, `WebVitalsPathBreakdown`, that visualizes website performance metrics (web vitals) broken down by URL path. It categorizes paths into three bands: \"Good,\" \"Needs Improvements,\" and \"Poor,\" based on predefined performance thresholds for the selected web vital metric.  For each band, it displays a list of paths and their corresponding performance values, along with a visual representation of the value's position within the band's range. Users can click on a path to filter events by that path.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **WebVitals Performance Breakdown:** Displays web vitals metrics categorized into performance bands (Good, Needs Improvements, Poor).\n*   **Path-Based Analysis:** Breaks down web vitals performance by URL path, allowing identification of problematic pages.\n*   **Visual Representation:** Provides a visual representation of each path's performance value within its respective band.\n*   **Interactive Filtering:** Enables users to filter events based on a selected URL path.\n*   **Dynamic Thresholds:** Adapts performance thresholds based on the selected web vitals metric.\n*   **Path Cleaning:** Allows for cleaning and simplifying URL paths for better readability.\n*   **Loading State:** Displays a loading indicator while data is being fetched.\n*   **Empty State Handling:** Shows a message when there are no scores in a particular band."
    },
    {
        "path": "frontend/src/queries/nodes/WebVitals/WebVitalsContent.tsx",
        "summary": "This React component, `WebVitalsContent`, displays web vitals metrics such as CLS, LCP, and FID, providing insights into website performance. It fetches data using the `webAnalyticsLogic` and `WebVitalsQueryResponse`, then calculates and presents a grade (Great, Needs Improvement, Poor) based on predefined thresholds. The component also displays a user-friendly interpretation of the metric value, including quantifiers and experience scores, along with a description of the metric. If the data is loading, a skeleton loader is displayed.\n\nHere's a list of high-level product features:\n\n*   **Web Vitals Metrics Display:** Shows key web vitals metrics (CLS, LCP, FID).\n*   **Performance Grading:** Assigns a grade (Great, Needs Improvement, Poor) to each metric based on predefined thresholds.\n*   **Threshold Visualization:** Displays the thresholds for each grade, allowing users to understand the performance benchmarks.\n*   **Metric Interpretation:** Provides a user-friendly interpretation of the metric value, including quantifiers (e.g., \"faster than\") and experience scores (e.g., \"good experience\").\n*   **Metric Descriptions:** Includes a description of each metric to help users understand its significance.\n*   **Loading State:** Displays a skeleton loader while the data is being fetched.\n*   **Percentile Selection:** Allows users to view web vital metrics at different percentiles.\n"
    },
    {
        "path": "frontend/src/queries/nodes/WebVitals/definitions.ts",
        "summary": "This code defines constants, types, and functions related to Web Vitals metrics (INP, LCP, FCP, CLS) used for measuring website performance. It includes definitions for metric names, descriptions, icons, grading, and thresholds for determining performance bands (good, needs improvement, poor). The code also provides functions to retrieve metric values, determine the performance band for a given value, format values with appropriate units, and compute the position of a value within its performance band for UI display purposes.\n\nHere's a list of high-level product features that can be derived from this code:\n\n*   **Web Vitals Performance Monitoring:** Track and display key web performance metrics (INP, LCP, FCP, CLS).\n*   **Performance Grading:** Categorize web vital metrics into performance bands (good, needs improvement, poor) based on predefined thresholds.\n*   **Visual Performance Indicators:** Use icons and colors to visually represent the performance band of each metric.\n*   **Percentile-Based Analysis:** Analyze web vital metrics based on different percentiles (e.g., 75%, 90%, 99%) to understand the performance experienced by different segments of users.\n*   **Detailed Metric Descriptions:** Provide detailed descriptions for each web vital metric to educate users about their significance.\n*   **Threshold-Based Evaluation:** Evaluate web vital metrics against predefined thresholds to identify areas for improvement.\n*   **Unit Conversion and Formatting:** Automatically convert and format web vital values with appropriate units (e.g., milliseconds, seconds) for easy readability.\n*   **Progress Visualization:** Display the position of a metric within its performance band using a progress bar or similar visual element."
    },
    {
        "path": "frontend/src/queries/nodes/WebVitals",
        "summary": "The provided code collectively implements a comprehensive Web Vitals monitoring and analysis tool. It allows users to track key performance metrics like LCP, FID, CLS, and INP, providing visual representations of performance levels through color-coded progress bars and performance bands. The tool offers detailed metric interpretations, descriptions, and grades, along with the ability to drill down into performance breakdowns by URL path and create insights based on the underlying queries.\n\nHere's a list of high-level product features:\n\n*   Web Vitals Dashboard: Displays key web performance metrics (INP, LCP, FCP, CLS).\n*   Performance Grading: Assigns a grade (Great, Needs Improvement, Poor) to each metric based on predefined thresholds.\n*   Visual Performance Indication: Uses color-coding and a progress bar to visually represent the performance level of each metric.\n*   Metric Descriptions: Provides tooltips with descriptions for each metric to help users understand their significance.\n*   Path-Based Analysis: Breaks down web vitals performance by URL path, allowing identification of problematic pages.\n*   Interactive Filtering: Enables users to filter events based on a selected URL path.\n*   Insight Creation: Enables users to create a new insight based on the web vitals query.\n*   Responsive Layout: Adapts the layout for different screen sizes to ensure optimal viewing on various devices.\n"
    },
    {
        "path": "frontend/src/queries/nodes/HogQLQuery/hogQLQueryEditorLogic.tsx",
        "summary": "This code defines the logic for a HogQL query editor in a PostHog application. It manages the state and actions related to editing, saving, and generating HogQL queries. The logic includes features for interacting with an AI assistant to draft queries from prompts, saving queries as reusable views, and integrating with the data warehouse functionality. It also handles updating the query input, managing prompts, and displaying errors.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **HogQL Query Editing:** Allows users to write and edit HogQL queries using a code editor.\n*   **AI-Assisted Query Generation:** Enables users to generate HogQL queries from natural language prompts using an AI assistant.\n*   **Query Saving:** Allows users to save HogQL queries for later use.\n*   **Save as View:** Enables users to save HogQL queries as reusable data warehouse views.\n*   **Real-time Query Input Updates:** Updates the query in the parent component as the user types.\n*   **Error Handling:** Displays errors related to AI prompt processing.\n*   **Variable Management:** Filters variables based on their presence in the query.\n"
    },
    {
        "path": "frontend/src/queries/nodes/HogQLQuery/HogQLQueryEditor.tsx",
        "summary": "The `HogQLQueryEditor` component provides a user interface for editing and executing HogQL queries. It features a Monaco-based code editor with syntax highlighting and error checking, integration with an AI assistant for query generation and refinement, and options to save or update queries and views. The component also handles error display, permission checks, and provides customizable footer actions.\n\nHere's a list of high-level product features:\n\n*   **HogQL Query Editing:** Provides a code editor for writing and modifying HogQL queries.\n*   **AI-Powered Query Generation:** Integrates with an AI assistant to generate or refine queries based on user prompts.\n*   **Syntax Highlighting and Error Checking:** Offers real-time syntax highlighting and error detection within the code editor.\n*   **Query Execution:** Allows users to execute HogQL queries and view the results.\n*   **Query Saving and Updating:** Enables users to save or update existing queries.\n*   **View Creation and Management:** Supports saving queries as reusable views and updating existing views.\n*   **Permission Management:** Enforces permission checks to control query modification access.\n*   **Customizable Editor Footer:** Allows for custom actions and information to be displayed in the editor footer.\n"
    },
    {
        "path": "frontend/src/queries/nodes/HogQLQuery",
        "summary": "The HogQL Query Editor provides a comprehensive interface for creating, editing, and managing HogQL queries within PostHog. It features a Monaco-based code editor with syntax highlighting and error checking, and integrates with an AI assistant to generate and refine queries from natural language prompts. Users can execute queries, save them for later use, or save them as reusable data warehouse views. The editor also manages permissions, handles errors, and provides a customizable footer for additional actions and information.\n\nHere's a list of high-level product features:\n\n*   HogQL Query Editing\n*   AI-Powered Query Generation\n*   Syntax Highlighting and Error Checking\n*   Query Execution\n*   Query Saving\n*   Save as View\n*   Real-time Query Input Updates\n*   Error Handling\n*   Variable Management\n*   Permission Management\n*   Customizable Editor Footer\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataTable/BackToSource.tsx",
        "summary": "This React component, `BackToSource`, provides a button that allows users to navigate back to the source insight query that generated the current data table. It utilizes `kea` for state management and `kea-router` for navigation. The button's tooltip displays a summary of the source query, generated using the `summarizeInsightQuery` function, and its label indicates the type of insight being navigated back to. The button is only rendered if a `backToSourceQuery` is available in the `dataNodeLogic`.\n\nHere's a list of high-level product features:\n\n*   **Navigation to Source Insight:** Allows users to easily navigate back to the original insight query that produced the current data table.\n*   **Insight Query Summarization:** Provides a tooltip that summarizes the source insight query, giving users context before navigating back.\n*   **Dynamic Button Label:** The button label dynamically reflects the type of insight being navigated back to (e.g., \"Back to Event\").\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataTable/insightActorsQueryOptionsLogic.ts",
        "summary": "This code defines a Kea logic module called `insightActorsQueryOptionsLogic` that fetches options for an Insight Actors query. It uses loaders to manage the asynchronous loading of `InsightActorsQueryOptions` based on a provided `InsightActorsQuery`. The logic triggers a data load on mount and whenever the `query` prop changes, ensuring the options are kept in sync with the query. The fetched options are stored in the `insightActorsQueryOptions` state variable.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dynamic Insight Actors Query Options:** Enables the dynamic fetching and updating of options for Insight Actors queries.\n*   **Query-Dependent Options:** Allows the available options to be dependent on the specific Insight Actors query being executed.\n*   **Asynchronous Data Loading:** Manages the asynchronous loading of query options, preventing UI blocking.\n*   **Automatic Updates:** Automatically updates the options when the underlying query changes.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataTable/DataTableOpenEditor.tsx",
        "summary": "This React component, `DataTableOpenEditor`, provides a button that allows users to open the current data table query as a new insight. It leverages the `dataTableLogic` to access the HogQL representation of the data table. If a HogQL query is available, the button includes a side action dropdown menu with an option to \"Open as direct SQL insight,\" which opens the query in a new insight using the HogQL representation directly. Otherwise, the button simply opens the current data table query as a new insight.\n\nHere's a list of high-level product features:\n\n*   **Open as New Insight:** Allows users to create a new insight based on the current data table query.\n*   **Open as Direct SQL Insight:** Provides an option to open the data table query as a direct SQL insight using the HogQL representation.\n*   **HogQL Integration:** Leverages HogQL to represent the data table query as SQL for use in insights.\n*   **Dropdown Menu:** Implements a dropdown menu for additional actions related to opening the data table as an insight.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataTable/SavedQueries.tsx",
        "summary": "This React component, `SavedQueries`, provides a dropdown menu of pre-defined event queries for a data table. It allows users to quickly select and apply common event queries to their data table view. The component retrieves the available queries based on the current team and highlights the currently selected query. If the current query is a custom one, it displays \"Custom query\". The component uses `LemonButtonWithDropdown` from the `lib/lemon-ui` library to render the dropdown menu.\n\nHere's a list of high-level product features:\n\n*   **Predefined Query Selection:** Allows users to select from a list of predefined event queries.\n*   **Team-Specific Queries:** Queries are tailored to the current team's context.\n*   **Custom Query Handling:** Indicates when a user is using a custom query.\n*   **Active Query Highlighting:** Visually indicates the currently selected query in the dropdown.\n*   **Date-Agnostic Matching:** Attempts to match queries even if date ranges differ.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataTable/utils.ts",
        "summary": "This code defines utility functions for managing columns in a data table component, particularly within a PostHog application. It provides default column sets for different data types (events, persons, groups) and logic for retrieving the appropriate columns based on the node kind and query features. The code also includes functions for extracting and removing comments from HogQL expressions, which are used to provide descriptions or annotations for the columns.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Default Column Configuration:** Automatically sets default columns for data tables based on the data type (events, persons, groups).\n*   **Customizable Columns:** Allows users to define custom columns for data tables, overriding the defaults.\n*   **Column Descriptions:** Supports adding comments to HogQL expressions to provide descriptions for columns in the data table.\n*   **Dynamic Column Selection:** Selects columns based on query features and user-defined configurations.\n*   **Data Presentation:** Facilitates the presentation of data in a structured and user-friendly format within data tables.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataTable/EventRowActions.tsx",
        "summary": "This code defines a React component, `EventRowActions`, which renders a \"More\" dropdown menu containing actions related to a specific event in a data table. These actions include creating a new action from the event, copying a direct link to the event, viewing a recording associated with the event (if available), navigating to the related issue in error tracking (if the event is an exception), and trying out the event in Insights. The component utilizes PostHog's UI library (`lemon-ui`) for buttons and icons, and leverages PostHog's internal APIs for creating actions, generating URLs, and accessing team-related data.\n\nHere's a list of the high-level product features implemented by this code:\n\n*   **Create Action from Event:** Allows users to quickly create a new action based on the properties of an existing event.\n*   **Copy Event Link:** Provides a direct, shareable link to a specific event.\n*   **View Recording:** Enables users to view a session recording associated with an event, facilitating debugging and understanding user behavior.\n*   **Error Tracking Integration:** For exception events, provides a direct link to the corresponding issue in the error tracking system.\n*   **Insights Integration:** Allows users to easily explore the event within the Insights tool for further analysis.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataTable/renderColumnMeta.tsx",
        "summary": "This code defines a function `renderColumnMeta` that dynamically generates metadata for columns in a data table or data visualization based on the provided key, query, and context. It determines the column title, width, and alignment, handling various cases such as HogQL queries, specific column names like \"timestamp\" or \"event\", properties, and context-provided column configurations. It also supports rendering custom titles via React components and displaying sorting indicators if sorting is enabled.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dynamic Column Title Generation:** Automatically generates column titles based on the data source, column key, and context.\n*   **Customizable Column Titles:** Allows overriding column titles via a `title` property in the query context.\n*   **Custom Column Rendering:** Supports rendering column titles using custom React components defined in the query context.\n*   **Property Key Information Display:** Renders property keys with associated type information (event or person properties).\n*   **Column Width Configuration:** Enables setting column widths through the query context.\n*   **Column Alignment Configuration:** Enables setting column alignment through the query context.\n*   **Sorting Indicators:** Displays sorting indicators in column headers when sorting is enabled.\n*   **HogQL Query Support:** Handles column title generation specifically for HogQL queries.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataTable/ColumnConfigurator/columnConfiguratorLogic.tsx",
        "summary": "This code defines a Kea logic module named `columnConfiguratorLogic` that manages the configuration of columns in a data table. It provides functionality for showing and hiding a modal, selecting and unselecting columns, reordering columns, and saving the column configuration. The logic supports both temporary (local) column configurations and persistent configurations that can be saved as default settings, either for a specific event definition or team-wide. The logic interacts with the PostHog API to persist these default column settings.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Column Selection:** Allows users to select which columns are displayed in a data table.\n*   **Column Reordering:** Enables users to change the order of columns in a data table.\n*   **Modal Interface:** Provides a modal window for configuring column visibility and order.\n*   **Temporary Column Configuration:** Supports temporary column configurations that are not persisted.\n*   **Persistent Column Configuration:** Allows users to save column configurations as default settings.\n*   **Event-Specific Default Columns:** Enables saving default column configurations for specific events.\n*   **Team-Wide Default Columns:** Supports setting default column configurations for the entire team.\n*   **API Integration:** Interacts with the PostHog API to persist default column settings.\n*   **Toast Notifications:** Provides user feedback through toast notifications upon successful or failed save operations.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataTable/defaultEventsQuery.ts",
        "summary": "This code defines functions to generate default event queries for a team in PostHog, handling both legacy and new HogQL-based column definitions. It provides a way to clean and transform live event columns, retrieve a default events query based on team settings, and construct a set of predefined event queries, including a project default (if configured), a PostHog default, and an event counts view. The queries are structured to retrieve event data, potentially with custom columns, time ranges, and ordering.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Customizable Event Data Views:** Allows teams to define and use custom columns for viewing event data, supporting both legacy and HogQL-based configurations.\n*   **Default Event Query Configuration:** Enables setting a default event query at the project level, providing a consistent starting point for event exploration.\n*   **Predefined Event Queries:** Offers a set of pre-configured event queries (PostHog default, event counts) for common use cases, simplifying data access.\n*   **HogQL Support:** Integrates with HogQL for flexible and powerful data querying, including column selection and transformation.\n*   **Time-Based Filtering:** Provides options to filter event data based on time ranges (e.g., the last 24 hours).\n*   **Data Ordering:** Supports ordering event data based on selected columns, such as timestamp or event count.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataTable/ColumnConfigurator/ColumnConfigurator.tsx",
        "summary": "This code defines a React component, `ColumnConfigurator`, which allows users to customize the columns displayed in a data table. It provides a modal interface where users can reorder visible columns via drag and drop, add columns from a list of available properties (event properties, person properties, feature flags, and HogQL expressions), remove columns, and edit column expressions. The component persists column configurations and offers the option to save the current column configuration as the default for the project or a specific event type.\n\nHere's a list of high-level product features:\n\n*   **Column Reordering:** Users can change the order of columns in the data table by dragging and dropping them in the configuration modal.\n*   **Column Selection:** Users can add new columns to the data table from a list of available properties, including event properties, person properties, feature flags, and HogQL expressions.\n*   **Column Removal:** Users can remove existing columns from the data table.\n*   **Column Editing:** Users can edit the expressions used to define columns.\n*   **Persistent Column Configuration:** The component saves the column configuration, so it persists across sessions.\n*   **Default Column Configuration:** Users with admin access can save the current column configuration as the default for all project members or for a specific event type.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataTable/renderColumn.tsx",
        "summary": "This code defines a `renderColumn` function that dynamically renders columns in a data table based on the column key, value, record data, query type, and context. It handles various data types and scenarios, including loading/error states, JSON objects, timestamps, properties, person and group displays, and custom rendering via context. The function also supports linking to related entities (e.g., persons, groups) and copying values to the clipboard. It is used to provide a rich and interactive data table experience within the PostHog application.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dynamic Column Rendering:** Render columns with different components based on the data type and context.\n*   **JSON Display:** Display JSON objects in a readable format with collapsible sections.\n*   **Timestamp Formatting:** Display timestamps in a user-friendly format with timezone information.\n*   **Property Filtering:** Enable filtering data table results by clicking on property values.\n*   **Person and Group Identification:** Display person and group information with links to their respective pages.\n*   **Data Copying:** Allow users to easily copy values to the clipboard.\n*   **Custom Column Rendering:** Allow custom components to render specific columns.\n*   **Error and Loading States:** Display appropriate indicators for loading and error states.\n*   **Deletion of Persons:** Allow deletion of persons directly from the data table.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataTable/DataTable.examples.ts",
        "summary": "This code defines several example configurations for a DataTable component within a data analysis or visualization application. These configurations showcase different features and customization options for displaying data, including selecting columns, filtering data based on properties, showing/hiding various UI tools (export, reload, column configuration), and displaying data from different sources (Events or Persons). The examples cover scenarios from a minimalist table to a fully featured table with all tools and filters enabled.\n\nHere's a list of high-level product features demonstrated by these examples:\n\n*   **Data Table Display:** Ability to display data in a tabular format.\n*   **Column Selection:** Ability to select which columns to display in the table.\n*   **Data Filtering:** Ability to filter data based on event and property values.\n*   **UI Tools:**\n    *   **Data Export:** Ability to export the data from the table.\n    *   **Data Reload:** Ability to refresh the data in the table.\n    *   **Column Configuration:** Ability to configure the displayed columns.\n*   **Data Sources:** Support for different data sources (e.g., Events, Persons).\n*   **Search:** Ability to search within the data table.\n*   **Expandable Rows:** Ability to expand rows for more details.\n*   **Actions:** Ability to perform actions on rows.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataTable/dataTableLogic.ts",
        "summary": "This code defines a Kea logic module called `dataTableLogic` that manages the state and behavior of a data table component in a PostHog application. It handles fetching data, processing it into a tabular format, and providing various configuration options for the table's display and functionality. The logic connects to a data node logic to retrieve the underlying query results and provides selectors to derive computed values such as the data table rows, column definitions, and query configurations. It also manages features like sorting, filtering, and column visibility.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Data Table Display:** Renders query results in a tabular format.\n*   **Data Fetching and Processing:** Fetches data from a specified source query and transforms it into rows and columns suitable for display in a data table.\n*   **Column Management:** Allows users to configure which columns are displayed in the table.\n*   **Sorting:** Enables users to sort the data table by different columns.\n*   **Filtering:** Provides options to filter the data displayed in the table.\n*   **Date-Based Labeling:** Adds labels to rows based on date changes in the data.\n*   **Configuration Options:** Exposes various configuration options to control the table's appearance and behavior, such as showing/hiding filters, search, actions, date range, test account filters, export, reload, timings, column configurator, saved queries, and the HogQL editor.\n*   **Query Editor Integration:** Provides a button to open the query in an editor.\n*   **Persistent Column Configuration:** Allows users to save and persist column configurations.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataTable/queryFeatures.ts",
        "summary": "This code defines an enumeration `QueryFeature` representing various features that can be associated with different types of queries within the PostHog application. It also provides a function `getQueryFeatures` that takes a query node as input and returns a set of `QueryFeature` enums applicable to that specific query type. The function uses type guards to determine the query type and then adds the relevant features to the set. This allows the frontend to dynamically enable or disable certain UI elements or functionalities based on the type of query being executed.\n\nHere's a list of the high-level product features enabled by this code:\n\n*   **Date Range Picker:** Allows users to select a specific date range for their queries.\n*   **Columns in Response:** Displays the columns returned in the query response.\n*   **Event Actions Column:** Shows actions associated with events.\n*   **Event Name Filter:** Enables filtering events by name.\n*   **Event Property Filters:** Allows filtering events based on their properties.\n*   **Person Property Filters:** Enables filtering persons based on their properties.\n*   **Group Property Filters:** Allows filtering groups based on their properties.\n*   **Persons Search:** Enables searching for specific persons.\n*   **Groups Search:** Enables searching for specific groups.\n*   **Saved Events Queries:** Allows users to save and reuse event queries.\n*   **Column Configurator:** Enables users to configure which columns are displayed.\n*   **Result is Array of Arrays:** Indicates that the query result is structured as an array of arrays.\n*   **Select and Order By Columns:** Allows users to select and order columns in the query.\n*   **Display Response Error:** Displays any errors that occur during query execution.\n*   **Hide Load Next Button:** Hides the button for loading the next set of results.\n*   **Test Account Filters:** Allows filtering out test accounts from the query results.\n*   **Highlight Exception Event Rows:** Highlights rows in the results that represent exceptions.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataTable/ColumnConfigurator",
        "summary": "The provided code implements a column configuration feature for data tables, allowing users to customize the displayed columns and their order. Users can interact with a modal interface to select, reorder, remove, and edit columns, drawing from available properties like event properties, person properties, feature flags, and HogQL expressions. The configurations can be saved temporarily or persistently, with options to set default configurations at the project or event level, leveraging the PostHog API for storage and providing user feedback through toast notifications.\n\n**Features:**\n\n*   Column Selection: Add, remove, and reorder columns in a data table.\n*   Column Editing: Modify column expressions using HogQL.\n*   Property Integration: Access event properties, person properties, and feature flags as column data.\n*   Persistent Configuration: Save column configurations for future sessions.\n*   Default Configuration: Set default column configurations for the project or specific events.\n*   Drag and Drop Reordering: Intuitive reordering of columns within the modal.\n*   Modal Interface: User-friendly modal for managing column settings.\n*   API Integration: Persist settings via the PostHog API.\n*   Toast Notifications: Provide user feedback on save operations.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataTable/InsightActorsQueryOptions.tsx",
        "summary": "This React component, `InsightActorsQueryOptions`, dynamically renders a set of `LemonSelect` components based on the `insightActorsQueryOptions` derived from the `insightActorsQueryOptionsLogic`. These select components allow users to modify properties of an `InsightActorsQuery` object. The component receives an `InsightActorsQuery` object and a `setQuery` function as props, using the latter to update the query when a selection is made in any of the `LemonSelect` components. The options displayed in each `LemonSelect` are determined by the `cleanedInsightActorsQueryOptions` function, which processes the raw options.\n\n**Features:**\n\n*   **Dynamic Option Rendering:** Automatically generates select input components based on the structure of the `insightActorsQueryOptions`.\n*   **Query Modification:** Enables users to modify properties of an `InsightActorsQuery` object through interactive select inputs.\n*   **State Management:** Integrates with `kea` logic (`insightActorsQueryOptionsLogic`) to manage and derive the available options for each property.\n*   **Data Binding:** Connects the selected values in the `LemonSelect` components to the `InsightActorsQuery` object, allowing for real-time updates.\n*   **Customizable Select Options:** Uses the `cleanedInsightActorsQueryOptions` function to format and filter the options displayed in the `LemonSelect` components.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataTable/DataTableExport.tsx",
        "summary": "This code defines a `DataTableExport` component that provides users with options to export data from a data table in various formats. It supports exporting data as CSV or XLSX files, copying data to the clipboard as CSV or JSON, and saving the data as a static cohort (if applicable). The component dynamically adjusts the available export options based on the type of query being executed (Events, Persons, or HogQL) and the columns selected. It also handles filtering of disallowed columns and provides options to export either the currently displayed columns or all available columns.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Data Export to File:** Allows users to download data in CSV and XLSX formats.\n*   **Column Selection for Export:** Enables users to export either the currently selected columns or all available columns.\n*   **Clipboard Copy:** Provides options to copy data to the clipboard in CSV and JSON formats.\n*   **Static Cohort Creation:** Allows users to save the current data as a static cohort for further analysis.\n*   **Dynamic Export Options:** Adjusts export options based on the query type (Events, Persons, HogQL).\n*   **Column Filtering:** Automatically filters out disallowed columns during export.\n*   **Data Transformation:** Transforms data for specific query types (e.g., converting person data for display).\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataTable/DataTable.tsx",
        "summary": "This code defines a `DataTable` component that displays data retrieved from a PostHog query. It leverages various PostHog libraries and components to provide a rich user interface for exploring and manipulating the data. The component handles data loading, error display, column configuration, sorting, filtering, and exporting. It supports different query types, including Events, Persons, Groups, and HogQL queries, and offers features tailored to each type. The component also integrates with the PostHog editor, allowing users to modify the underlying query.\n\nHere's a list of high-level product features implemented by the code:\n\n*   **Data Visualization:** Displays query results in a tabular format using LemonTable.\n*   **Column Configuration:** Allows users to configure which columns are displayed and their order.\n*   **Sorting:** Enables sorting of data by column values.\n*   **Filtering:** Supports filtering data based on event properties, person properties, and group properties.\n*   **HogQL Editing:** Provides an interface for editing the underlying HogQL query.\n*   **Data Export:** Allows users to export the data in various formats.\n*   **Error Handling:** Displays error messages when queries fail.\n*   **Loading Indicators:** Shows loading indicators while data is being fetched.\n*   **Test Account Filtering:** Filters out test accounts from the results.\n*   **Date Range Selection:** Allows users to specify a date range for the query.\n*   **Event Details:** Provides detailed information about individual events.\n*   **Saved Queries:** Allows users to save and load queries.\n*   **Column Management:** Allows users to add, edit, and remove columns.\n*   **Back to Source:** Navigates back to the source query definition.\n*   **Person Deletion:** Provides functionality to delete persons (if applicable).\n*   **Search:** Allows searching for specific persons or groups.\n*   **Event Actions:** Provides actions that can be performed on individual events.\n*   **Elapsed Time:** Displays the time taken to execute the query.\n"
    },
    {
        "path": "frontend/src/queries/nodes/DataTable",
        "summary": "The provided code collectively implements a comprehensive data table feature within the PostHog application, enabling users to explore, analyze, and manipulate data retrieved from various query types. It offers a rich and interactive experience with dynamic column rendering, sorting, filtering, and configuration options. Users can easily navigate back to the source query, export data in multiple formats, and perform actions on individual data points. The system also supports custom column definitions, default query configurations, and integration with other PostHog features like session recordings, error tracking, and insights.\n\nHere's a list of high-level product features:\n\n*   **Data Table Display:** Renders query results in a tabular format with customizable columns, sorting, and filtering.\n*   **Dynamic Column Rendering:** Adapts column display based on data type and context, including JSON, timestamps, and properties.\n*   **Data Export:** Exports data in various formats (CSV, XLSX, JSON) with options for column selection.\n*   **Query Management:** Allows users to save, load, and edit queries, including default query configurations and HogQL support.\n*   **Navigation and Integration:** Provides navigation back to the source query and integration with other PostHog features like session recordings, error tracking, and insights.\n*   **Customization:** Enables users to define custom columns, configure column visibility, and set default configurations.\n*   **Data Manipulation:** Supports actions on individual data points, such as creating actions from events or deleting persons.\n*   **Search:** Allows users to search within the data table.\n*   **Insight Actors Query Options:** Enables the dynamic fetching and updating of options for Insight Actors queries.\n"
    },
    {
        "path": "frontend/src/queries/nodes/EventsNode/EventName.tsx",
        "summary": "This code defines a React component called `EventName` that allows users to select or input an event name within a query builder interface. It utilizes the `LemonEventName` component, likely a pre-built component with features like autocompletion or a dropdown of available events. The component takes a query object and a setter function as props, enabling it to both display the current event name and update it when the user makes a change. The `allEventsOption` prop is set to \"clear\", which likely adds an option to clear the selected event.\n\n**Features:**\n\n*   **Event Name Selection/Input:** Allows users to specify an event name as part of a query.\n*   **Integration with Query Builder:** Designed to be used within a query builder interface, updating the query object when the event name changes.\n*   **Event Autocompletion/Dropdown:** Leverages the `LemonEventName` component, which likely provides autocompletion or a dropdown list of available events.\n*   **Clear Event Option:** Provides an option to clear the selected event name.\n*   **Disable Input:** Disables the input field if no `setQuery` function is provided.\n"
    },
    {
        "path": "frontend/src/queries/nodes/EventsNode/EventPropertyFilters.tsx",
        "summary": "This component, `EventPropertyFilters`, renders a set of property filters for various query types including `EventsNode`, `EventsQuery`, `HogQLQuery`, `SessionAttributionExplorerQuery`, and `TracesQuery`. It dynamically adjusts the filter's behavior based on the query type, extracting existing properties and event names. It leverages the `PropertyFilters` component from the `lib` directory to display and manage the filters, allowing users to modify properties. The component also handles updating the query with the new property filters via a `setQuery` function. It supports various taxonomic filter group types, including event properties, person properties, feature flags, metadata, groups, cohorts, elements, and HogQL expressions.\n\nHere's a list of high-level product features:\n\n*   **Dynamic Property Filtering:** Adapts property filters based on the specific query type (Events, HogQL, Session Attribution, Traces).\n*   **Property Modification:** Allows users to modify and refine properties within the query.\n*   **Taxonomic Filter Group Support:** Supports a wide range of taxonomic filter groups, including event properties, person properties, feature flags, metadata, groups, cohorts, elements, and HogQL expressions.\n*   **Query Updating:** Updates the query object with the modified property filters.\n*   **Event Name Filtering:** Filters properties based on specific event names.\n"
    },
    {
        "path": "frontend/src/queries/nodes/EventsNode",
        "summary": "The provided code snippets describe two React components designed for a query builder interface. The `EventName` component allows users to select or input an event name, providing autocompletion or a dropdown of available events and an option to clear the selection. The `EventPropertyFilters` component dynamically renders and manages property filters based on the query type, supporting a wide range of taxonomic filter groups and updating the query object with the modified filters.\n\nHere's a list of high-level product features:\n\n*   Event Name Selection/Input with Autocompletion\n*   Dynamic Property Filtering based on Query Type\n*   Support for Various Taxonomic Filter Groups (Event, Person, Feature Flags, etc.)\n*   Query Updating with Modified Event Name and Property Filters\n*   Clear Event Name Option\n"
    },
    {
        "path": "frontend/src/queries/nodes/PersonsNode/DeletePersonButton.tsx",
        "summary": "This React component, `DeletePersonButton`, provides a button that, when clicked, triggers a modal to confirm the deletion of a specific person. Upon confirmation, the person is deleted, and the data is reloaded to reflect the change. The button uses a trash icon, is styled as a \"danger\" button, and includes a data attribute for testing.\n\n**Features:**\n\n*   **Person Deletion:** Allows users to delete a specific person.\n*   **Confirmation Modal:** Presents a modal to confirm the deletion action.\n*   **Data Reload:** Refreshes the data after a successful deletion.\n*   **Visual Indication:** Uses a trash icon and \"danger\" styling to indicate the destructive nature of the action.\n"
    },
    {
        "path": "frontend/src/queries/nodes/PersonsNode/PersonsSearch.tsx",
        "summary": "This code defines a `PersonsSearch` component that provides a search input field for filtering persons or groups based on a search term. It uses a debounced query hook to update the query object with the search term, preventing excessive API calls. The component dynamically adjusts its placeholder text and tooltip based on whether the query is for persons or groups, providing context-specific guidance to the user.\n\n**Features:**\n\n*   **Search Input:** Provides a text input field for users to enter search terms.\n*   **Debounced Query:** Implements debouncing to prevent excessive API calls while the user is typing.\n*   **Dynamic Placeholder:** Changes the placeholder text based on whether the search is for persons or groups.\n*   **Contextual Tooltip:** Displays a tooltip with a description of what can be searched for, tailored to persons or groups.\n*   **Disabling:** The search input can be disabled based on whether a `setQuery` function is provided.\n*   **Person/Group Search:** Supports searching for both persons and groups, adapting the search behavior accordingly.\n"
    },
    {
        "path": "frontend/src/queries/nodes/PersonsNode/PersonPropertyFilters.tsx",
        "summary": "This code defines a `PersonPropertyFilters` component that allows users to filter persons based on their properties. It utilizes the `PropertyFilters` component from the `lib/components` directory to manage and display the filters. The component receives a query object (either `PersonsNode` or `ActorsQuery`) and a `setQuery` function to update the query. It dynamically configures the `PropertyFilters` component based on the type of query, allowing filtering by person properties, cohorts, and HogQL expressions when the query is an `ActorsQuery`. It also handles a case where property groups are not supported, displaying an error message.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Filtering Persons by Properties:** Allows users to narrow down a selection of persons based on specific properties.\n*   **Cohort Filtering (ActorsQuery):** Enables filtering persons based on cohort membership when using an `ActorsQuery`.\n*   **HogQL Expression Filtering (ActorsQuery):** Supports filtering persons using custom HogQL expressions within an `ActorsQuery`.\n*   **Dynamic Filter Configuration:** Adapts the available filter options based on the type of query being used.\n*   **Property Management:** Provides a user interface for managing and modifying person property filters.\n"
    },
    {
        "path": "frontend/src/queries/nodes/PersonsNode",
        "summary": "The provided code snippets detail components for managing and filtering person data within a larger application. These components collectively enable users to search, filter, and delete person records, providing a comprehensive interface for managing individual profiles. The filtering capabilities are enhanced by dynamic configuration based on the query type, allowing for property-based filtering, cohort filtering, and even custom HogQL expressions.\n\nHere's a list of high-level product features:\n\n*   **Person Search:** Allows users to search for specific persons or groups using a text input field with debouncing.\n*   **Person Filtering:** Enables users to filter persons based on properties, cohort membership, or custom HogQL expressions.\n*   **Person Deletion:** Provides a mechanism for deleting individual person records with a confirmation step.\n*   **Dynamic UI Configuration:** Adapts the user interface based on the type of query being executed (e.g., PersonsNode vs. ActorsQuery).\n*   **Data Management:** Supports reloading data after a deletion to ensure the UI reflects the latest state.\n"
    },
    {
        "path": "frontend/src/queries/nodes",
        "summary": "The provided code collectively implements a comprehensive suite of features for data analysis, visualization, and management within PostHog. It empowers users to create, customize, and interact with insights derived from HogQL queries, offering a wide array of tools for data selection, chart configuration, conditional formatting, variable management, and display settings. The system supports various insight types, advanced filtering options, real-time updates, and integrates with other PostHog features like session recordings, error tracking, and feature flags.\n\nHere's a list of high-level product features:\n\n*   **Data Visualization:** Display query results in various formats (tables, charts, JSON).\n*   **Insight Creation & Configuration:** Creation and customization of various insight types (Trends, Funnels, Retention, Paths, Stickiness, Lifecycle) with a wide range of configurable options.\n*   **HogQL Query Editing & Management:** A comprehensive interface for creating, editing, and managing HogQL queries, including AI-powered query generation, syntax highlighting, and error checking.\n*   **Advanced Filtering:** Enables complex filtering with collapsible filter groups, AND/OR logic, property filters, test account filtering, and global filters.\n*   **Data Table Display & Manipulation:** Renders query results in a tabular format with customizable columns, sorting, filtering, and data export.\n*   **Web Vitals Monitoring:** Tracks key web performance metrics (INP, LCP, FCP, CLS) with visual performance indication and path-based analysis.\n*   **Person & Group Management:** Provides tools for searching, filtering, and managing person and group records.\n*   **Data Loading & Management:** Efficient data fetching, caching, refreshing, and prioritization for various query types.\n*   **User Interaction & Contextual UI:** Provides intuitive UI elements, informative tooltips, and adapts the UI based on the insight type and available features.\n*   **Integration & Extensibility:** Integrates with other PostHog features like session recordings, error tracking, feature flags, and supports custom column definitions.\n"
    },
    {
        "path": "frontend/src/queries/schema/index.ts",
        "summary": "This file acts as a central export point for schema definitions used by both the frontend and backend, ensuring type consistency across the application. It aggregates exports from several schema definition files related to general schema elements, assistant queries, assistant messages, and assistant replay functionality. Note that enums should be imported from their specific schema files instead of this index file due to tooling limitations.\n\nHere's a list of high-level product features based on the schema files included:\n\n*   **General Schema Definitions:** Provides core data structures and types used throughout the application.\n*   **Assistant Query Management:** Defines the schema for creating, storing, and managing queries used by an assistant.\n*   **Assistant Message Handling:** Defines the schema for messages exchanged with an assistant, including content and metadata.\n*   **Assistant Replay Functionality:** Defines the schema for replaying assistant interactions, likely for debugging or analysis purposes.\n"
    },
    {
        "path": "frontend/src/queries/schema/type-utils.ts",
        "summary": "This code defines two custom type aliases for use in JSON schema generation. The `integer` type alias is defined as a number but is intended to be represented as an integer in the JSON schema. Similarly, the `numerical_key` type alias is also a number but should be represented as a string in the JSON schema, accommodating JSON's requirement for string-based keys. These type aliases provide a way to enforce specific data types and formats when generating JSON schemas from TypeScript code.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **JSON Schema Generation with Type Enforcement:** Allows generating JSON schemas from TypeScript code while enforcing specific data types (integer) and formats (string for numerical keys).\n*   **Data Type Conversion for JSON Compatibility:** Enables the conversion of numerical keys to strings in the JSON schema, ensuring compatibility with JSON's string-based key requirement.\n*   **Customizable Data Type Representation:** Provides a mechanism to customize how TypeScript types are represented in the generated JSON schema.\n"
    },
    {
        "path": "frontend/src/queries/schema/schema-assistant-replay.ts",
        "summary": "This code defines TypeScript interfaces and types to represent a simplified set of filters applicable to recordings, intended for use with an AI assistant. It focuses on a subset of universal filters, making them more manageable for AI processing. The filters include date ranges, duration, test account filtering, and complex nested logical groupings of event, person, session, and recording properties.\n\nHere's a list of high-level product features that can be derived from this code:\n\n*   **Recording Filtering:** Allows users to filter recordings based on various criteria.\n*   **Date Range Filtering:** Enables filtering recordings by date ranges (from/to).\n*   **Duration Filtering:** Supports filtering recordings based on their duration.\n*   **Test Account Filtering:** Provides the ability to exclude or include recordings from test accounts.\n*   **Property-Based Filtering:** Allows filtering recordings based on properties of events, persons, sessions, and the recordings themselves.\n*   **Logical Filtering:** Supports complex filtering logic using AND/OR operators to combine multiple filter conditions.\n*   **AI Assistant Integration:** Designed to be used with an AI assistant to simplify the filtering process.\n*   **Ordering Recordings:** Allows users to specify the order in which recordings are displayed.\n"
    },
    {
        "path": "frontend/src/queries/schema/schema-assistant-messages.ts",
        "summary": "This code defines the schema for messages used in an AI assistant, likely for a product analytics platform. It specifies different message types, including human input, assistant responses, reasoning steps, visualizations (with associated queries and plans), tool calls, and failure messages. It also defines the structure for tool calls, including arguments and UI payloads, and includes types for assistant events and generation statuses.\n\nHere's a list of high-level product features that can be inferred from this schema:\n\n*   **AI Assistant for Data Analysis:** The core feature is an AI assistant that helps users analyze data.\n*   **Natural Language Input:** Users can interact with the assistant using natural language.\n*   **Reasoning and Explanation:** The assistant provides reasoning steps to explain its analysis.\n*   **Data Visualization:** The assistant can generate visualizations based on user queries.\n*   **Tool Calls:** The assistant can use external tools to perform specific tasks.\n*   **Contextual Tooling:** The assistant can use contextual tools, such as searching session recordings.\n*   **Error Handling:** The assistant provides failure messages when errors occur.\n*   **Form-based Interactions:** The assistant can present forms with options to guide user input.\n"
    },
    {
        "path": "frontend/src/queries/types.ts",
        "summary": "This code defines interfaces and types related to query contexts in a frontend application, likely for data exploration and visualization. It allows passing custom metadata to queries, customizing the behavior and appearance of data tables and visualizations. The code provides flexibility in defining column templates, overriding query editor settings, adding help, customizing empty states, handling data point clicks, and controlling refresh behavior.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Customizable Data Table Columns:** Define custom columns with specific titles, rendering logic, alignment, and width.\n*   **Query Editor Customization:** Show/hide the query editor, override values, and add help/examples.\n*   **Insight Integration:** Pass insight-specific properties to queries.\n*   **Empty State Customization:** Customize the empty state message and appearance.\n*   **Row Properties Customization:** Customize the properties of each row in the data table.\n*   **Group Type Label Customization:** Customize the label for group types in insight tooltips.\n*   **Data Point Click Handling:** Define custom behavior when a data point is clicked in a visualization.\n*   **Query Refresh Control:** Control the refresh behavior of queries.\n*   **Extra Data Table Query Features:** Add extra source features for data tables.\n"
    },
    {
        "path": "frontend/src/queries/examples.ts",
        "summary": "This code defines a comprehensive set of example queries and data visualizations for a product analytics platform. It covers a wide range of data analysis techniques, including event tracking, user behavior analysis, funnel analysis, retention analysis, path analysis, stickiness analysis, lifecycle analysis, web vitals monitoring, and custom HogQL queries. These examples are used in the storybook and the query interface to demonstrate the platform's capabilities and provide users with starting points for their own analyses.\n\nHere's a list of high-level product features that can be inferred from the code:\n\n*   **Event Tracking and Analysis:** Ability to track and analyze user events, including filtering by event properties and performing aggregations.\n*   **User Segmentation:** Ability to segment users based on properties and behaviors.\n*   **Funnel Analysis:** Ability to define and analyze user funnels to identify drop-off points.\n*   **Retention Analysis:** Ability to analyze user retention rates over time.\n*   **Path Analysis:** Ability to visualize user paths through the application.\n*   **Stickiness Analysis:** Ability to measure how often users return to the application.\n*   **Lifecycle Analysis:** Ability to track users through different stages of their lifecycle.\n*   **Web Vitals Monitoring:** Ability to monitor web vitals metrics such as INP, LCP, CLS, and FCP.\n*   **Custom Queries (HogQL):** Ability to write custom queries using a SQL-like language (HogQL).\n*   **Data Visualization:** Ability to visualize data in various formats, including tables, charts, and world maps.\n*   **Web Analytics:** Ability to analyze web traffic data, including referrer domains, page views, and browser usage.\n*   **Data Tables:** Ability to display query results in data tables.\n*   **Property Formulas:** Ability to create custom formulas based on event and user properties.\n"
    },
    {
        "path": "frontend/src/queries/schema/schema-general.ts",
        "summary": "This code defines the schema for PostHog queries, acting as the single source of truth for both the frontend (TypeScript) and backend (Python) representations. It encompasses various query types, including data nodes for events, actions, persons, and HogQL queries, as well as interface nodes for data tables, visualizations, and saved insights. The schema also includes definitions for web analytics, web vitals, experiment-related queries, database metadata, and AI-powered queries. It specifies the structure of requests and responses for different query types, including filters, modifiers, metadata, and autocomplete suggestions.\n\nHere's a list of high-level product features that can be inferred from the schema:\n\n*   **Data Querying:** Ability to query events, actions, persons, and groups using various filters and modifiers.\n*   **HogQL Support:** Enables querying data using HogQL, a custom query language, with features like autocomplete, metadata validation, and variable substitution.\n*   **Session Recording Analysis:** Functionality to query and analyze session recordings based on various criteria.\n*   **Web Analytics and Vitals:** Provides queries for web overview, stats, external clicks, goals, and web vitals.\n*   **Experimentation:** Supports experiment-related queries for metrics, exposure, and funnel analysis.\n*   **AI-Powered Insights:** Includes queries for suggested questions, team taxonomy, event taxonomy, and actor property taxonomy.\n*   **Error Tracking:** Enables querying and analyzing errors.\n*   **Data Visualization:** Supports data visualization through interface nodes.\n*   **Database Schema Exploration:** Allows querying the database schema.\n*   **Traces and Vector Search:** Supports querying traces and performing vector searches."
    },
    {
        "path": "frontend/src/queries/utils.ts",
        "summary": "This code defines a suite of utility functions for working with different types of query nodes in a PostHog application. These functions primarily focus on identifying the type of a given query node and extracting specific properties from it, such as date ranges, intervals, display types, formulas, series, breakdowns, and other filter-related configurations. The code supports a wide range of query types, including Trends, Funnels, Retention, Paths, Stickiness, Lifecycle, HogQL, and various web analytics queries. These utilities are essential for dynamically handling and processing different query types within the PostHog frontend.\n\nHere's a list of high-level product features that can be inferred from the code:\n\n*   **Query Type Identification:** Determine the specific type of a query node (e.g., Trends, Funnels, Retention).\n*   **Data Source Handling:** Identify and manage different data sources for queries (Events, Actions, Persons, HogQL).\n*   **Insight Visualization Configuration:** Extract and manage visualization settings for insights, such as display type, legend visibility, and axis scaling.\n*   **Filter Management:** Extract and manage filter configurations for different query types, including breakdowns, comparisons, and date ranges.\n*   **Asynchronous Query Handling:** Determine if a query should be executed asynchronously.\n*   **HogQL Query Support:** Identify and handle HogQL queries, including AST and metadata.\n*   **Web Analytics Query Support:** Support for various web analytics queries, such as Web Overview, Web Stats, and Web Vitals.\n*   **Result Customization:** Extract and manage result customization options, such as goal lines and series labels.\n*   **Percent Stack View Support:** Determine if a query supports percent stack view and manage its visibility.\n*   **Data Warehouse Integration:** Support for querying data from data warehouses.\n*   **Error Tracking Query Support:** Support for querying error tracking data.\n"
    },
    {
        "path": "frontend/src/queries/schema/schema-assistant-queries.ts",
        "summary": "This code defines the data structures and interfaces used for querying insights within PostHog, specifically tailored for an \"Assistant\" feature. It includes definitions for date ranges, property filters (for events, people, sessions, features, and groups), and query structures for Trends and Funnels insights. The code focuses on providing a structured way to define and customize queries, including specifying events, actions, breakdowns, date ranges, and various display options. The structures are designed to be used with a planning system, referencing properties and other values from a predefined plan.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Trends Insights:** Allows users to visualize trends in event and action data over time, with options for breakdowns, comparisons, and various display types (line graph, bar chart, etc.).\n*   **Funnels Insights:** Enables users to analyze conversion rates through a sequence of steps (events or actions), with options for defining funnel order, visualization type (steps, time to convert, trends), and exclusion events.\n*   **Property Filtering:** Provides a flexible system for filtering data based on event, person, session, feature, and group properties, with support for various operators (exact match, contains, regex, etc.).\n*   **Date Range Selection:** Allows users to specify date ranges for their queries, either as absolute dates or as durations relative to the present.\n*   **Data Sampling:** Enables users to sample data to improve query performance.\n*   **Test Account Filtering:** Provides an option to exclude internal and test user data from queries.\n*   **Breakdowns:** Supports breaking down data by various properties to gain deeper insights.\n*   **Customizable Display Options:** Offers a range of options for customizing the display of insights, including legend visibility, axis formatting, and value display.\n"
    },
    {
        "path": "frontend/src/queries/schema",
        "summary": "This collection of code files defines a comprehensive schema for data querying and analysis within a product analytics platform, with a strong emphasis on AI-powered assistance. The schema covers various aspects, including general data querying, specific query types for trends and funnels, filtering options, data visualization, and interactions with an AI assistant. The schema ensures type consistency between the frontend and backend, enabling features like natural language querying, automated insights generation, and interactive data exploration.\n\nHere's a list of high-level product features:\n\n*   Data Querying: Query events, actions, persons, and groups using filters and modifiers.\n*   HogQL Support: Query data using HogQL with autocomplete and metadata validation.\n*   Session Recording Analysis: Query and analyze session recordings based on various criteria.\n*   Web Analytics and Vitals: Queries for web overview, stats, external clicks, goals, and web vitals.\n*   Experimentation: Support experiment-related queries for metrics, exposure, and funnel analysis.\n*   AI-Powered Insights: Queries for suggested questions, team taxonomy, event taxonomy, and actor property taxonomy.\n*   Error Tracking: Query and analyze errors.\n*   Data Visualization: Support data visualization through interface nodes.\n*   Database Schema Exploration: Query the database schema.\n*   Traces and Vector Search: Query traces and perform vector searches.\n*   AI Assistant for Data Analysis: An AI assistant that helps users analyze data using natural language.\n*   Trends Insights: Visualize trends in event and action data over time.\n*   Funnels Insights: Analyze conversion rates through a sequence of steps.\n*   Property Filtering: Filter data based on event, person, session, feature, and group properties.\n*   Recording Filtering: Filter recordings based on date ranges, duration, test accounts, and properties.\n*   Tool Calls: The assistant can use external tools to perform specific tasks.\n*   Contextual Tooling: The assistant can use contextual tools, such as searching session recordings.\n"
    },
    {
        "path": "frontend/src/queries/QueryEditor/queryEditorLogic.ts",
        "summary": "This code defines the logic for a query editor component using the Kea framework. It manages the state of the query input, parses the JSON query, and handles saving the query. The logic includes actions for setting the query input and saving the query, reducers for managing the query input state, and selectors for deriving parsed query data, JSON query, error messages, and whether the input has changed. It also includes a listener that triggers when the save query action is called, displaying an error toast if the JSON is invalid or saving the query if it is valid. The query is formatted with pretty JSON for readability.\n\nHere's a list of high-level product features:\n\n*   **Query Input:** Allows users to input and edit queries in a text area.\n*   **JSON Parsing:** Parses the query input as JSON and displays any errors.\n*   **Error Handling:** Displays error messages for invalid JSON syntax.\n*   **Query Formatting:** Automatically formats the JSON query for readability (pretty JSON).\n*   **Save Query:** Saves the formatted query.\n*   **Change Detection:** Detects changes between the original query and the input.\n"
    },
    {
        "path": "frontend/src/queries/QueryEditor/QueryEditor.tsx",
        "summary": "The `QueryEditor` component provides a code editor interface for users to view and modify insight configurations as JSON code. It leverages Monaco's `CodeEditor` for syntax highlighting and schema validation against a predefined schema. The component includes features such as error handling for invalid JSON, a link to debug the query, and a button to save and run the updated query. It also dynamically adjusts the editor's height using `AutoSizer` and disables the save button based on permissions, errors, and whether the input has changed.\n\nHere's a list of high-level product features:\n\n*   **JSON Code Editor:** Allows users to view and edit insight configurations as JSON code.\n*   **Syntax Highlighting:** Provides syntax highlighting for JSON code to improve readability.\n*   **Schema Validation:** Validates the JSON code against a predefined schema to ensure correctness.\n*   **Error Handling:** Displays error messages for invalid JSON code.\n*   **Debug Link:** Provides a link to debug the query.\n*   **Save and Run:** Allows users to save and run the updated query.\n*   **Dynamic Height Adjustment:** Adjusts the editor's height dynamically to fit the available space.\n*   **Permission Control:** Disables the save button based on user permissions.\n*   **Change Detection:** Disables the save button if no changes have been made to the query.\n"
    },
    {
        "path": "frontend/src/queries/QueryEditor",
        "summary": "The Query Editor provides a user-friendly interface for viewing and modifying insight configurations as JSON code. It features syntax highlighting, schema validation, and error handling to ensure code correctness. Users can save and run updated queries, with the editor dynamically adjusting its height to fit the available space. The component also manages query input state, parses JSON, and formats the query for readability, while controlling save functionality based on user permissions and change detection.\n\nHere's a consolidated list of high-level product features:\n\n*   JSON Code Editor\n*   Syntax Highlighting\n*   Schema Validation\n*   Error Handling\n*   Debug Link\n*   Save and Run\n*   Dynamic Height Adjustment\n*   Permission Control\n*   Change Detection\n*   Query Input\n*   JSON Parsing\n*   Query Formatting (Pretty JSON)\n"
    },
    {
        "path": "frontend/src/queries/hooks/useDebouncedQuery.ts",
        "summary": "This code defines a `useDebouncedQuery` hook in React that allows for debouncing updates to a query object. It takes a query object, a setter function for the query, functions to extract a value from the query and modify the query with a new value, and a timeout in milliseconds. The hook returns the current value (which can be different from the query's value due to debouncing) and an `onChange` function that updates the local value and sets a timeout to update the query with the new value. This prevents rapid updates to the query, improving performance.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Debounced Query Updates:** Prevents excessive updates to a query object when a value changes rapidly.\n*   **Local Value State:** Maintains a local state for the value being debounced, allowing for immediate UI updates without waiting for the query to update.\n*   **Customizable Query Modification:** Allows for flexible modification of the query object based on the new value.\n*   **Configurable Timeout:** Provides control over the debounce delay.\n*   **React Hook Interface:** Easy integration into React components.\n"
    },
    {
        "path": "frontend/src/queries/hooks",
        "summary": "The `useDebouncedQuery` hook provides a mechanism to debounce updates to a query object in a React application. It manages a local state for a value derived from the query, allowing for immediate UI updates while delaying the actual update to the query itself. This is achieved through a configurable timeout and custom functions for extracting and modifying the query, preventing excessive updates and improving performance. The hook simplifies integration into React components by providing a standard React hook interface.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Debounced Query Updates:** Prevents excessive updates to a query object when a value changes rapidly.\n*   **Local Value State:** Maintains a local state for the value being debounced, allowing for immediate UI updates without waiting for the query to update.\n*   **Customizable Query Modification:** Allows for flexible modification of the query object based on the new value.\n*   **Configurable Timeout:** Provides control over the debounce delay.\n*   **React Hook Interface:** Easy integration into React components.\n"
    },
    {
        "path": "frontend/src/queries/schema-guards.ts",
        "summary": "This code defines schema validation functions using the Ajv library to ensure data conforms to predefined schemas. It imports a JSON schema and creates Ajv validators for `AnyPropertyFilter`, `WebAnalyticsPropertyFilters`, and `SessionPropertyFilter` types. The functions `isAnyPropertyFilters`, `isWebAnalyticsPropertyFilters`, and `isSessionPropertyFilters` validate whether given data conforms to the respective schema definitions. These functions are used to ensure type safety and data integrity when working with property filters in the application.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Data Validation:** Ensures that data related to property filters adheres to a predefined schema, preventing errors and inconsistencies.\n*   **Type Safety:** Provides type guards to verify the structure and content of property filter objects, improving code reliability.\n*   **Schema Enforcement:** Enforces a contract for property filter data, making the application more robust and maintainable.\n*   **Web Analytics Support:** Validates data specific to web analytics property filters.\n*   **Session Property Filtering:** Validates data related to session property filters.\n*   **Generic Property Filtering:** Validates data related to generic property filters.\n"
    },
    {
        "path": "frontend/src/queries/Query/Query.tsx",
        "summary": "This code defines a `Query` component in React that renders different data visualization and exploration tools based on the provided query type. It acts as a central hub, taking a query object and dynamically rendering the appropriate component to display and interact with the data, including tables, visualizations, insights, and debugging tools. The component handles query updates, read-only modes, embedding, and overrides for filters and variables, providing a flexible and configurable way to present data insights.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Dynamic Query Rendering:** Renders different UI components based on the query type (DataTable, DataVisualization, InsightViz, WebOverview, WebVitals, HogDebug, DataNode).\n*   **Data Table Visualization:** Displays data in a tabular format with customizable columns.\n*   **Data Visualization:** Renders various data visualizations based on the query.\n*   **Insight Visualization:** Displays saved insights and allows interaction with them.\n*   **Web Analytics Overview:** Provides an overview of web analytics data.\n*   **Web Vitals Monitoring:** Displays web vitals metrics.\n*   **HogQL Debugging:** Provides a tool for debugging HogQL queries.\n*   **Query Editor:** Allows users to edit the underlying query through a JSON editor.\n*   **Read-Only Mode:** Disables query modifications for shared or embedded contexts.\n*   **Dashboard Integration:** Supports overriding query filters and variables from a dashboard.\n*   **Error Handling:** Uses an ErrorBoundary to catch and display errors during rendering.\n"
    },
    {
        "path": "frontend/src/queries/query.ts",
        "summary": "This code defines a query execution framework for a data analysis platform, focusing on asynchronous query handling, polling for results, and optimized data streaming. It supports various query types, including HogQL queries and person-based queries, and provides mechanisms for refreshing data, overriding filters and variables, and exporting query contexts. The framework also includes error handling, logging, and integration with PostHog for tracking query performance.\n\nHere's a list of high-level product features based on the code:\n\n*   **Asynchronous Query Execution:** Allows long-running queries to execute in the background, improving user experience by not blocking the UI.\n*   **Query Status Polling:** Provides a mechanism to check the status of asynchronous queries and retrieve results when they are complete.\n*   **Optimized Data Streaming:** Uses server-sent events (SSE) for efficient streaming of query results, enabling real-time updates and reduced latency.\n*   **Query Result Caching:** Supports caching of query results to improve performance and reduce load on the data warehouse.\n*   **Query Exporting:** Enables users to export query results in various formats for further analysis or sharing.\n*   **HogQL Query Support:** Allows users to execute custom HogQL queries for advanced data analysis.\n*   **Person-Based Queries:** Provides specialized queries for retrieving and analyzing data related to individual users or persons.\n*   **Dashboard Integration:** Supports overriding filters and variables for queries embedded in dashboards, enabling dynamic data exploration.\n*   **Error Handling and Logging:** Includes robust error handling and logging mechanisms to identify and resolve query issues.\n*   **Performance Monitoring:** Integrates with PostHog to track query performance and identify areas for optimization."
    },
    {
        "path": "frontend/src/queries/Query",
        "summary": "The `Query` component serves as a dynamic rendering engine for various data exploration and visualization tools within the application. Based on the query type, it intelligently selects and renders the appropriate UI component, such as data tables, visualizations, insights, or debugging tools. It supports features like read-only mode for embedding, dashboard integration through filter and variable overrides, and robust error handling, providing a flexible and configurable way to present data insights to users.\n\nHere's a list of high-level product features enabled by this component:\n\n*   Dynamic Query Rendering\n*   Data Table Visualization\n*   Data Visualization\n*   Insight Visualization\n*   Web Analytics Overview\n*   Web Vitals Monitoring\n*   HogQL Debugging\n*   Query Editor\n*   Read-Only Mode\n*   Dashboard Integration\n*   Error Handling\n"
    },
    {
        "path": "frontend/src/queries",
        "summary": "The codebase collectively provides a comprehensive suite of features for data analysis, visualization, and management within a product analytics platform. It empowers users to create, customize, and interact with insights derived from various query types, including HogQL, trends, funnels, retention, and web analytics, offering a wide array of tools for data selection, chart configuration, conditional formatting, variable management, and display settings. The system supports advanced filtering options, real-time updates, and integrates with other platform features like session recordings, error tracking, and feature flags, while also providing AI-powered assistance for query generation and insights discovery.\n\nHere's a list of high-level product features:\n\n*   Data Visualization (charts, tables, JSON)\n*   Insight Creation & Configuration (Trends, Funnels, Retention, Paths, Stickiness, Lifecycle)\n*   HogQL Query Editing & Management (AI-powered, syntax highlighting, error checking)\n*   Advanced Filtering (collapsible groups, AND/OR logic, property filters)\n*   Data Table Display & Manipulation (customizable columns, sorting, filtering, export)\n*   Web Vitals Monitoring (INP, LCP, FCP, CLS)\n*   Person & Group Management (search, filter, manage)\n*   AI Assistant for Data Analysis (natural language querying, automated insights)\n*   Asynchronous Query Execution & Polling\n*   Debounced Query Updates\n*   Data Validation & Schema Enforcement\n*   Dashboard Integration (filter & variable overrides)\n*   JSON Code Editor with Syntax Highlighting & Validation\n*   Session Recording Analysis\n"
    },
    {
        "path": "frontend/src/models/insightsModel.tsx",
        "summary": "The `insightsModel` kea logic defines actions and listeners for managing insights, specifically focusing on renaming and duplicating insights. It provides functionality to rename an insight via a dialog prompting for a new name, updating the insight via the insights API, and displaying a success toast. It also allows duplicating an insight via the insights API and displaying a success toast. The logic is connected to the `teamLogic` kea store.\n\nHere's a list of high-level product features:\n\n*   **Rename Insight:** Allows users to change the name of an existing insight.\n*   **Duplicate Insight:** Enables users to create a copy of an existing insight.\n*   **Success Notifications:** Provides visual feedback (toast messages) upon successful renaming or duplication of insights.\n*   **Input Validation:** Ensures that a name is provided when renaming an insight.\n"
    },
    {
        "path": "frontend/src/models/tagsModel.ts",
        "summary": "This code defines a Kea logic model called `tagsModel` responsible for managing and loading tags. It connects to the `organizationLogic` to determine if tagging is enabled for the organization. If tagging is enabled, it fetches the list of tags from the API. The model uses Kea-loaders to handle the asynchronous loading of tags and stores them in the `tags` state variable. The `loadTags` action is triggered after the component mounts to initiate the tag loading process.\n\nHere's a list of high-level product features based on the code:\n\n*   **Tag Management:** Enables the management of tags within the application.\n*   **Tag Loading:** Asynchronously loads tags from the backend API.\n*   **Organization-Specific Tagging:** Respects organization-level settings for enabling or disabling tagging functionality.\n*   **Data Fetching:** Fetches tag data from the API endpoint.\n"
    },
    {
        "path": "frontend/src/models/groupPropertiesModel.ts",
        "summary": "The `groupPropertiesModel` Kea logic module manages the retrieval and storage of group properties for a PostHog project. It fetches group properties from the PostHog API, specifically for the current project and only if groups are enabled. The module provides selectors to access group properties for specific group types (0-4) and triggers the loading of all group properties after the component mounts.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Fetch Group Properties:** Retrieves group properties definitions from the PostHog API.\n*   **Store Group Properties:** Stores the fetched group properties in the Kea store.\n*   **Access Group Properties by Type:** Provides selectors to access group properties based on group type index (0-4).\n*   **Conditional Loading:** Only loads group properties if groups are enabled for the project.\n*   **Automatic Loading:** Automatically loads group properties when the component mounts.\n"
    },
    {
        "path": "frontend/src/models/actionsModel.ts",
        "summary": "This code defines a Kea logic model called `actionsModel` responsible for managing a list of actions fetched from an API. It provides functionality to load, update, pin, and unpin actions. The model also includes selectors to group, sort, and index actions by ID, and it automatically loads actions after the component mounts, provided the user is authenticated.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Action Listing:** Fetches and displays a list of actions from the API.\n*   **Action Updating:** Updates an existing action via the API.\n*   **Action Pinning:** Allows users to pin actions, likely for prioritization or easy access.\n*   **Action Unpinning:** Allows users to unpin actions.\n*   **Action Grouping:** Groups actions, likely for display in a select dropdown.\n*   **Action Sorting:** Sorts actions, prioritizing pinned actions.\n*   **Action Indexing:** Provides a way to quickly access actions by their ID.\n"
    },
    {
        "path": "frontend/src/models/notebooksModel.ts",
        "summary": "This code defines a Kea model named `notebooksModel` that manages the state and logic for notebooks within a PostHog application. It handles creating, deleting, updating, and loading notebooks, as well as managing notebook templates. The model interacts with the PostHog API to persist notebook data and provides functionality for creating notebooks from dashboards, automatically converting dashboard insights into notebook queries. It also manages a scratchpad notebook for quick note-taking.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Notebook Creation:** Allows users to create new notebooks with a title and initial content.\n*   **Notebook Deletion:** Enables users to delete notebooks, with undo functionality.\n*   **Notebook Updating:** Supports updating notebook metadata (e.g., title).\n*   **Notebook Loading:** Fetches and displays a list of available notebooks.\n*   **Scratchpad:** Provides a dedicated scratchpad notebook for quick note-taking.\n*   **Notebook Templates:** Offers pre-built notebook templates to streamline the creation process.\n*   **Dashboard to Notebook Conversion:** Converts existing dashboards into notebooks, automatically importing insights as queries.\n*   **Notebook Navigation:** Manages navigation to specific notebooks within the application.\n"
    },
    {
        "path": "frontend/src/models/cohortsModel.ts",
        "summary": "This code defines a Kea logic model named `cohortsModel` that manages the state and behavior related to cohorts. It handles fetching, updating, creating, and deleting cohorts, as well as managing filters and pagination for cohort lists. The model also includes functionality for exporting cohort data and polling for cohort calculation status. It interacts with the API to persist changes and uses URL parameters to maintain filter state.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Cohort Listing and Management:** Allows users to view a paginated list of cohorts, including searching and filtering.\n*   **Cohort Creation and Editing:** Enables users to create new cohorts and modify existing ones.\n*   **Cohort Deletion:** Provides the ability to delete cohorts with an undo option.\n*   **Cohort Data Export:** Supports exporting cohort member data in CSV format.\n*   **Real-time Cohort Calculation Status:** Polls the API to update the status of cohorts that are currently being calculated.\n*   **URL-based Filter Persistence:** Maintains cohort list filters (search, page) in the URL, allowing for shareable links and consistent navigation.\n"
    },
    {
        "path": "frontend/src/models/annotationsModel.ts",
        "summary": "This code defines a Kea logic model for managing annotations within a PostHog application. It handles fetching, creating, updating, and deleting annotations via the PostHog API, while also managing pagination and timezone conversions. The model stores annotations in a local state, provides selectors for accessing and transforming the data, and includes actions for triggering API calls and state updates. It also incorporates undo functionality for deletions and ensures annotations are only loaded when the user is authenticated within a team.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Annotation Creation:** Allows users to create annotations with a date marker, scope, and content, optionally linking them to a dashboard item.\n*   **Annotation Display:** Fetches and displays annotations, converting date and time information to the user's timezone.\n*   **Annotation Editing:** Enables users to update the content, date marker, and scope of existing annotations.\n*   **Annotation Deletion:** Provides a mechanism for deleting annotations with an undo option.\n*   **Pagination:** Supports loading annotations in batches with \"load more\" functionality.\n*   **Real-time Updates:** Updates the annotation list when new annotations are created, updated, or deleted.\n*   **Team-Based Annotations:** Ensures annotations are only loaded and managed within the context of an authenticated team.\n"
    },
    {
        "path": "frontend/src/models/groupsModel.ts",
        "summary": "This code defines a Kea logic model called `groupsModel` responsible for managing group types within a PostHog project. It fetches, updates, and provides access to group type metadata, including names and indices. The model also handles the creation of detail dashboards for specific group types and provides selectors for accessing and transforming group type data, such as generating taxonomic filter types and aggregation labels. It connects to other logic models like `projectLogic` and `groupsAccessLogic` to determine the current project and group access status.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Fetch Group Types:** Retrieve a list of group types associated with a project.\n*   **Update Group Type Metadata:** Modify the metadata (e.g., names) of existing group types.\n*   **Create Detail Dashboards:** Generate a dedicated dashboard for a specific group type.\n*   **Taxonomic Filtering for Groups:** Enable filtering data based on group types within the PostHog UI.\n*   **Dynamic Aggregation Labels:** Provide customizable labels for groups in charts and reports (e.g., \"person\" vs. \"user\").\n*   **Conditional Loading of Group Types:** Load group types only when the groups feature is enabled.\n"
    },
    {
        "path": "frontend/src/models/dashboardsModel.tsx",
        "summary": "This code defines the `dashboardsModel` using Kea, a state management library. It handles fetching, updating, creating, deleting, pinning, unpinning, and duplicating dashboards. The model manages a paginated list of dashboards, tracks loading states, and provides selectors for sorted and filtered dashboard lists. It also includes listeners for success actions that trigger toasts and navigation updates. The model interacts with the PostHog API to persist changes and reports usage events.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Dashboard Management:** Create, read, update, and delete dashboards.\n*   **Dashboard Listing and Sorting:** Display a list of dashboards, sorted by name and pin status.\n*   **Dashboard Pinning:** Pin dashboards for easy access.\n*   **Dashboard Duplication:** Duplicate existing dashboards.\n*   **Dashboard Restoration:** Restore deleted dashboards.\n*   **Dashboard Tagging:** Supports tagging dashboards.\n*   **Undo Functionality:** Provides undo options for dashboard updates and deletions.\n*   **Real-time Updates:** Updates the dashboard list in real-time.\n*   **Anonymous Dashboard Viewing:** Supports viewing shared dashboards without logging in.\n*   **Event Tracking:** Tracks user interactions with dashboards (e.g., pinning, updating).\n*   **Onboarding Integration:** Integrates with the onboarding flow to mark dashboard creation as a completed task.\n*   **Toast Notifications:** Provides user feedback through toast notifications for successful actions."
    },
    {
        "path": "frontend/src/models/propertyDefinitionsModel.ts",
        "summary": "This code defines a Kea logic model named `propertyDefinitionsModel` responsible for managing and caching property definitions and their possible values within a PostHog application. It fetches property definitions from the backend API, caches them locally, and provides methods for retrieving and updating these definitions. The model also handles fetching possible values for properties, including handling local options and constructing API endpoints for value retrieval. It optimizes API calls by debouncing requests and limiting the number of properties fetched in a single request.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Property Definition Management:** Fetches, caches, and updates property definitions (metadata about event, person, group, and session properties) from the backend.\n*   **Property Value Suggestion:** Provides suggestions for property values based on the property type and available data.\n*   **Optimized API Calls:** Debounces requests for property definitions and limits the number of properties fetched in a single API call to avoid performance issues.\n*   **Local Property Definitions:** Supports local property definitions that are calculated on the backend and do not exist on events.\n*   **Property Type Handling:** Differentiates between event, person, group, and session properties and fetches data accordingly.\n*   **Group Property Support:** Handles property definitions and values for different group types.\n*   **Loading State Management:** Tracks the loading state of property values and definitions.\n*   **Custom Value Support:** Allows custom values for properties where applicable."
    },
    {
        "path": "frontend/src/models",
        "summary": "This collection of code snippets outlines several Kea logic models that collectively manage various aspects of a PostHog application's functionality. These models handle data fetching, state management, and API interactions for features such as notebooks, cohorts, property definitions, actions, dashboards, tags, group properties, annotations, groups, and insights. They provide the foundation for a rich user experience by enabling users to create, manage, and analyze data within the PostHog platform.\n\nHere's a list of high-level product features enabled by these models:\n\n*   Notebook Management (creation, deletion, updating, templates, scratchpad, dashboard conversion)\n*   Cohort Management (creation, editing, deletion, listing, filtering, exporting)\n*   Property Definition Management (fetching, caching, value suggestion)\n*   Action Management (listing, updating, pinning, sorting)\n*   Dashboard Management (creation, deletion, updating, pinning, duplication, tagging)\n*   Tag Management (loading, organization-specific settings)\n*   Group Property Management (fetching, storing, access by type)\n*   Annotation Management (creation, display, editing, deletion, pagination)\n*   Group Management (fetching group types, updating metadata, creating detail dashboards, taxonomic filtering)\n*   Insight Management (renaming, duplicating, success notifications)\n"
    },
    {
        "path": "frontend/src/styles/index.tsx",
        "summary": "The provided code imports a global stylesheet file named `global.scss`. This file likely contains the main styling configurations for the PostHog frontend application, setting the overall look and feel of the user interface.\n\n**Features:**\n\n*   **Global Styling:** Provides a consistent and unified visual appearance across the entire application.\n*   **Customizable Theme:** The `global.scss` file likely allows for customization of the application's theme through variables and styles.\n*   **PostHog Branding:** The styling configurations likely incorporate PostHog's branding elements, such as colors, fonts, and logos.\n"
    },
    {
        "path": "frontend/src/types.ts",
        "summary": "This code defines various TypeScript types and enums used throughout the PostHog frontend. It covers user-related information, organization and team structures, feature flags, available product features, billing plans, and access control mechanisms. The code also includes types for experiments, surveys, session replays, data warehouses, and other PostHog products, providing a comprehensive set of data structures for managing and displaying information within the application.\n\nHere's a list of high-level product features represented by the types and enums:\n\n*   **User Management:** User profiles, authentication, roles, permissions, and notification settings.\n*   **Organization and Team Management:** Structure for managing multiple projects and users within an organization.\n*   **Feature Flags:** Management of feature flags, multivariate flags, and release conditions.\n*   **Experimentation:** A/B testing, funnel experiments, and statistical analysis.\n*   **Surveys:** Creation, targeting, and analysis of user surveys.\n*   **Session Replay:** Recording and playback of user sessions for debugging and analysis.\n*   **Data Warehouse:** Integration with data warehouses for advanced querying and analysis.\n*   **Product Analytics:** Tracking and analysis of user behavior, including events, funnels, and retention.\n*   **Integrations:** Support for integrations with other platforms like Slack, Microsoft Teams, and Zapier.\n*   **Access Control:** Mechanisms for controlling access to different features and data based on user roles and permissions.\n*   **Billing and Plans:** Definition of different billing plans and available features based on the plan.\n*   **Alerts:** Ability to set up alerts based on specific events or metrics.\n*   **Data Pipelines:** Ability to transform and route data to different destinations."
    },
    {
        "path": "frontend/src/styles",
        "summary": "The frontend styling configuration imports a global stylesheet (`global.scss`) to establish a consistent and branded visual appearance for the PostHog application. This global stylesheet likely defines the overall theme, incorporating customizable variables and PostHog's branding elements to ensure a unified user interface.\n\n**Features:**\n\n*   Global Styling\n*   Customizable Theme\n*   PostHog Branding\n"
    },
    {
        "path": "frontend/src/custom.d.ts",
        "summary": "This code defines TypeScript module declarations to handle imports of various file types, specifically SVG, PNG, MP3, and Lottie files. These declarations tell the TypeScript compiler that when a file with one of these extensions is imported, it should be treated as a module that exports a variable named `content` of type `any`. This prevents TypeScript from throwing errors when these file types are imported into TypeScript modules.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **SVG Support:** Allows importing and using SVG files within the application.\n*   **PNG Support:** Enables importing and using PNG image files.\n*   **MP3 Support:** Permits importing and using MP3 audio files.\n*   **Lottie Animation Support:** Facilitates importing and using Lottie animation files.\n"
    },
    {
        "path": "frontend/src/lib/ui/IconWrapper/IconWrapper.tsx",
        "summary": "The `IconWrapper` component is a flexible React component designed to wrap icons and provide consistent styling. It utilizes `class-variance-authority` to manage different size and intent variants, allowing for easy customization of icon appearance. The component accepts `size` and `intent` props to control the icon's dimensions and color, respectively, and forwards refs to the underlying div element. It also accepts custom class names for further styling.\n\nHere's a list of high-level product features:\n\n*   **Icon Size Customization:** Allows users to specify the size of the icon using predefined sizes (xs, sm, md, lg).\n*   **Icon Intent/Color Customization:** Enables users to set the color of the icon based on predefined intents (default, primary, secondary, tertiary).\n*   **CSS Class Overrides:** Supports custom CSS classes for overriding or extending the default styles.\n*   **Ref Forwarding:** Forwards refs to the underlying div element, allowing access to the DOM node.\n*   **Aspect Ratio Maintained:** Ensures the icon maintains a square aspect ratio.\n"
    },
    {
        "path": "frontend/src/lib/colors.ts",
        "summary": "This code defines a color palette and utility functions for managing colors within the PostHog frontend, focusing on data visualization and UI elements. It provides a set of predefined data colors, functions to retrieve these colors based on index or theme, and specific color schemes for charts, graphs, and lifecycle status indicators. The code also includes error handling for missing color variables and defines a set of tag colors for UI elements.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Data Visualization Color Management:** Consistent and customizable color schemes for charts and graphs.\n*   **Series Color Assignment:** Automatic assignment of distinct colors to data series in visualizations.\n*   **Lifecycle Status Color Coding:** Visual representation of lifecycle stages using specific colors.\n*   **Theming Support:** Adapting colors based on the current theme (light or dark).\n*   **UI Element Styling:** Predefined color options for tags and other UI components.\n*   **Error Handling:** Graceful fallback for missing color variables.\n"
    },
    {
        "path": "frontend/src/lib/ui/IconWrapper",
        "summary": "The `IconWrapper` component is a versatile React component that provides a consistent and customizable way to display icons. It leverages `class-variance-authority` to manage styling variations based on size and intent, offering a flexible solution for different icon appearances. The component supports size and color customization through props, allows for custom CSS class overrides, and forwards refs to the underlying div element for advanced use cases.\n\nHere's a list of high-level product features:\n\n*   **Icon Size Customization:** Allows users to specify the size of the icon using predefined sizes (xs, sm, md, lg).\n*   **Icon Intent/Color Customization:** Enables users to set the color of the icon based on predefined intents (default, primary, secondary, tertiary).\n*   **CSS Class Overrides:** Supports custom CSS classes for overriding or extending the default styles.\n*   **Ref Forwarding:** Forwards refs to the underlying div element, allowing access to the DOM node.\n*   **Aspect Ratio Maintained:** Ensures the icon maintains a square aspect ratio.\n"
    },
    {
        "path": "frontend/src/lib/ui/DropdownMenu/DropdownMenu.tsx",
        "summary": "This code defines a reusable Dropdown Menu component using Radix UI primitives, styled with custom CSS classes and PostHog icons. It provides various sub-components for creating a fully functional dropdown menu, including triggers, content areas, menu items, submenus, checkboxes, radio buttons, labels, and separators. The component is designed to be accessible, customizable, and visually consistent with the PostHog design system.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Dropdown Menu:** Core functionality for displaying a list of options in a dropdown format.\n*   **Trigger:** Component to open/close the dropdown menu.\n*   **Submenus:** Ability to create nested menus for hierarchical options.\n*   **Checkbox Items:** Menu items with checkbox functionality for selecting multiple options.\n*   **Radio Items:** Menu items with radio button functionality for selecting a single option from a group.\n*   **Labels:** Displaying descriptive labels within the menu.\n*   **Separators:** Visually dividing menu items into logical groups.\n*   **Keyboard Navigation:** Implied through the use of Radix UI primitives, enabling keyboard accessibility.\n*   **Customizable Styling:** CSS classes allow for flexible styling and integration with the PostHog design system.\n*   **Shortcuts:** Display keyboard shortcuts next to menu items."
    },
    {
        "path": "frontend/src/lib/ui/DropdownMenu",
        "summary": "This code defines a highly customizable and accessible Dropdown Menu component built with Radix UI and styled for the PostHog design system. It offers a range of sub-components to create versatile dropdown menus, including triggers, submenus, checkbox and radio items, labels, and separators, ensuring a consistent and user-friendly experience. The component supports keyboard navigation, customizable styling, and the display of shortcuts.\n\nHere's a list of high-level product features:\n\n*   Dropdown Menu\n*   Trigger\n*   Submenus\n*   Checkbox Items\n*   Radio Items\n*   Labels\n*   Separators\n*   Keyboard Navigation\n*   Customizable Styling\n*   Shortcuts\n"
    },
    {
        "path": "frontend/src/lib/ui/ListBox/ListBox.tsx",
        "summary": "This code defines a `ListBox` component and a `ListBox.Item` component in React. The `ListBox` component provides keyboard navigation (arrow keys, Home, End, Enter) for its children, which are expected to be `ListBox.Item` components. It manages focus and selection states for the items within the listbox, ensuring accessibility and a consistent user experience. The `ListBox.Item` component renders a list item with appropriate ARIA attributes and handles focus and click events to manage selection and visual states. It also supports the `asChild` prop, allowing it to render its children directly with the necessary props applied.\n\nHere's a list of high-level product features:\n\n*   **Keyboard Navigation:** Enables users to navigate list items using arrow keys (up/down), Home, and End keys.\n*   **Focus Management:** Manages focus state within the listbox, highlighting the currently focused item.\n*   **Selection Management:** Allows users to select list items, visually indicating the selected item.\n*   **ARIA Attributes:** Provides appropriate ARIA attributes for accessibility, making the listbox usable by screen readers.\n*   **Customizable Rendering:** Supports rendering list items as children using the `asChild` prop, allowing for flexible styling and component composition.\n*   **Click Handling:** Handles click events on list items, triggering actions and updating selection state.\n*   **Focus Highlighting:** Visually highlights the focused list item.\n*   **Dynamic Updates:** Recalculates focusable elements when the listbox's children change.\n"
    },
    {
        "path": "frontend/src/lib/ui/ListBox",
        "summary": "The code implements a React-based `ListBox` component with associated `ListBox.Item` components, designed to provide an accessible and user-friendly list selection experience. It offers robust keyboard navigation, focus management, and selection handling, ensuring users can easily interact with the list using both mouse and keyboard. The component also leverages ARIA attributes for enhanced accessibility and supports customizable rendering through the `asChild` prop, allowing developers to integrate the listbox seamlessly into various UI designs.\n\nHere's a list of high-level product features:\n\n*   Keyboard Navigation (arrow keys, Home, End, Enter)\n*   Focus Management and Highlighting\n*   Selection Management with visual indication\n*   ARIA Attributes for accessibility\n*   Customizable Rendering with `asChild` prop\n*   Click Handling for item selection\n*   Dynamic Updates for list changes\n"
    },
    {
        "path": "frontend/src/lib/ui/ContextMenu/ContextMenu.tsx",
        "summary": "This code defines a React component library for creating context menus using Radix UI primitives. It provides a set of styled components like `ContextMenu`, `ContextMenuItem`, `ContextMenuSub`, and others, that are built on top of Radix UI's headless components. These components offer features like submenus, checkbox items, radio items, separators, and keyboard shortcuts, with a consistent look and feel, including styling for hover states, disabled states, and accessibility.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Context Menu Display:** Renders a context menu on right-click or other trigger events.\n*   **Submenus:** Allows nesting of menu items within submenus for hierarchical organization.\n*   **Checkbox Items:** Provides menu items with checkbox functionality for toggling options.\n*   **Radio Items:** Implements radio button groups within the context menu for selecting one option from a list.\n*   **Menu Item Separators:** Adds visual separators to group related menu items.\n*   **Keyboard Shortcuts:** Supports displaying keyboard shortcuts for menu items.\n*   **Customizable Styling:** Offers a consistent style with customizable CSS classes for different states (hover, disabled, etc.).\n*   **Accessibility:** Built with accessibility in mind, leveraging Radix UI primitives.\n*   **Portal Support:** Renders the context menu within a portal for proper layering and positioning.\n"
    },
    {
        "path": "frontend/src/lib/ui/ContextMenu",
        "summary": "This React component library provides a comprehensive solution for creating accessible and customizable context menus. Built on Radix UI primitives, it offers a consistent look and feel with features like submenus, checkbox items, radio items, separators, and keyboard shortcut display. The library prioritizes accessibility and provides customizable styling options for various states, ensuring a seamless user experience.\n\nHere's a list of high-level product features:\n\n*   Context Menu Display\n*   Submenus\n*   Checkbox Items\n*   Radio Items\n*   Menu Item Separators\n*   Keyboard Shortcuts\n*   Customizable Styling\n*   Accessibility\n*   Portal Support\n"
    },
    {
        "path": "frontend/src/lib/ui",
        "summary": "The provided code snippets describe several React components designed to enhance user interface functionality and accessibility. These components offer a range of features including customizable icons, dropdown menus, listboxes, and context menus, all built with accessibility and flexibility in mind. They leverage libraries like Radix UI and class-variance-authority to provide consistent styling, keyboard navigation, and customizable rendering options.\n\nHere's a list of high-level product features:\n\n*   **Icon Management:** Customizable icon display with size and color options.\n*   **Dropdown Menus:** Versatile dropdown menus with submenus, checkbox/radio items, labels, and separators.\n*   **Listboxes:** Accessible list selection with keyboard navigation, focus management, and customizable rendering.\n*   **Context Menus:** Customizable context menus with submenus, checkbox/radio items, separators, and keyboard shortcuts.\n*   **Accessibility:** ARIA attributes and keyboard navigation for enhanced accessibility across all components.\n*   **Customizable Styling:** Options to override or extend default styles using CSS classes.\n*   **Ref Forwarding:** Access to underlying DOM nodes for advanced use cases.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSegmentedSelect/index.ts",
        "summary": "The code exports the `LemonSegmentedSelect` component, making it available for use in other parts of the application. This component likely provides a segmented control or button group style selection interface.\n\n**Features:**\n\n*   Provides a segmented select component for user input.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSegmentedSelect/LemonSegmentedSelect.tsx",
        "summary": "The `LemonSegmentedSelect` component dynamically switches between a segmented button group and a standard select dropdown based on screen size or the number of options. It uses the `useWindowSize` hook to track the window width and a `shrinkOn` prop to determine when to switch to the `LemonSelect` component. If the screen width is too small to display all segmented buttons or the number of options exceeds the `shrinkOn` threshold, it renders a `LemonSelect` component; otherwise, it renders a `LemonSegmentedButton` component.\n\n**Features:**\n\n*   **Dynamic UI Switching:** Automatically switches between a segmented button and a select dropdown based on screen size.\n*   **Responsive Design:** Adapts to different screen sizes to provide an optimal user experience.\n*   **Configurable Threshold:** Allows specifying a `shrinkOn` value to control when the component switches to the select dropdown.\n*   **Option Handling:** Manages a list of options for both the segmented button and select dropdown components.\n*   **Leverages Existing Components:** Uses `LemonSegmentedButton` and `LemonSelect` components for rendering.\n"
    },
    {
        "path": "frontend/src/lib/taxonomy.tsx",
        "summary": "This code defines a taxonomy of event properties and filters used within the PostHog platform. It includes definitions for core filters related to events, elements, metadata, and event properties, providing labels, descriptions, and examples for each. The code also defines lists of common campaign properties, person properties adapted from events, and session properties, which are used for filtering and analysis within the platform. This taxonomy helps users understand and effectively utilize the available data for tracking and analyzing user behavior.\n\nHere's a list of high-level product features that can be inferred from the code:\n\n*   **Event Tracking and Analysis:** Capturing and analyzing various user events like pageviews, clicks, and form submissions.\n*   **Autocapture:** Automatically capturing user interactions on a website or application.\n*   **Heatmaps:** Visualizing user interaction patterns on a webpage.\n*   **Session Recording:** Recording user sessions to understand their behavior.\n*   **Feature Flagging:** Tracking usage and impact of feature flags.\n*   **Mobile Analytics:** Tracking events and properties specific to mobile applications.\n*   **AI Model Tracking:** Tracking calls, traces, spans, embeddings, metrics, and feedback related to generative AI models (LLMs).\n*   **User Identification and Profiling:** Identifying and associating users with specific properties.\n*   **Group Analytics:** Identifying and associating groups with specific properties.\n*   **Campaign Attribution:** Tracking the source of user acquisition through campaign parameters.\n*   **Error Tracking:** Capturing and analyzing exceptions and errors in the application.\n*   **Web Vitals Tracking:** Automatically capturing and analyzing web performance metrics.\n*   **Filtering and Segmentation:** Allowing users to filter and segment data based on various properties and events.\n*   **SDK Debugging:** Providing tools and properties for debugging SDK integrations.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSegmentedSelect",
        "summary": "The `LemonSegmentedSelect` component offers a dynamic and responsive selection interface that adapts based on screen size and the number of options. It intelligently switches between a visually appealing segmented button group (`LemonSegmentedButton`) and a standard select dropdown (`LemonSelect`) to optimize the user experience across different devices. The `shrinkOn` prop allows developers to configure the threshold at which the component transitions to the dropdown, providing flexibility in design and usability.\n\n**Features:**\n\n*   Dynamic UI Switching: Adapts between segmented buttons and a dropdown based on screen size and option count.\n*   Responsive Design: Ensures optimal usability across various screen sizes.\n*   Configurable Threshold: Allows setting a `shrinkOn` value to control the switch to the dropdown.\n*   Option Handling: Manages options for both segmented buttons and the dropdown.\n*   Segmented Select Component: Provides a ready-to-use segmented select component for user input.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTextArea/index.ts",
        "summary": "The code exports a `LemonTextArea` component, its associated props type `LemonTextAreaProps`, and a `LemonTextAreaMarkdown` component, likely providing a text area with Markdown support. These components are part of the Lemon UI library.\n\nHere's a list of high-level product features:\n\n*   **LemonTextArea Component:** A standard text area input field.\n*   **LemonTextAreaProps:** Defines the properties and customization options for the `LemonTextArea` component.\n*   **LemonTextAreaMarkdown Component:** A text area input field that supports Markdown formatting.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTextArea/LemonTextArea.tsx",
        "summary": "The `LemonTextArea` component is a multi-line text input field built using `react-textarea-autosize`. It provides features such as automatic resizing based on content, handling of `Enter` key presses (with or without `Cmd/Ctrl` modifiers) via callbacks, and standard textarea attributes like `placeholder`, `disabled`, `maxLength`, `onFocus`, `onBlur`, and `onChange`. It also allows for control over event propagation and setting minimum and maximum rows.\n\nHere's a list of high-level product features:\n\n*   **Auto-resizing Text Area:** The text area automatically adjusts its height to fit the content.\n*   **Enter Key Handling:** Customizable behavior for `Enter` key presses, with separate callbacks for `Enter` and `Cmd/Ctrl + Enter`.\n*   **Standard Text Area Attributes:** Supports standard HTML textarea attributes such as `placeholder`, `disabled`, `maxLength`, `onFocus`, `onBlur`, `onChange`, etc.\n*   **Event Propagation Control:** Option to stop event propagation from the input field.\n*   **Row Limits:** Configurable minimum and maximum number of rows.\n*   **Customizable Styling:** Supports custom CSS classes for styling.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTextArea/LemonTextAreaMarkdown.tsx",
        "summary": "This code defines a `LemonTextAreaMarkdown` component, which is a rich text editor built on top of a standard text area. It provides a tabbed interface for writing and previewing Markdown content. The component supports image uploads via drag and drop if object storage is available, otherwise, it guides users to use Markdown image links. It leverages other Lemon UI components like `LemonTabs`, `LemonTextArea`, `LemonFileInput`, and `Tooltip` for its functionality and styling.\n\nHere's a list of high-level product features:\n\n*   **Markdown Editing:** Allows users to write and format text using Markdown syntax.\n*   **Live Preview:** Provides a real-time preview of the rendered Markdown content.\n*   **Image Upload:** Enables users to upload images directly into the text area (requires object storage).\n*   **Drag and Drop Image Support:** Supports drag-and-drop functionality for uploading images.\n*   **Markdown Image Link Support:** Guides users on how to add images using Markdown links when object storage is unavailable.\n*   **Error Handling:** Displays error messages for failed image uploads.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTextArea",
        "summary": "The LemonTextArea component suite provides versatile text input solutions with a focus on enhanced user experience and Markdown support. The core `LemonTextArea` offers auto-resizing, customizable Enter key behavior, and standard textarea attributes. Building upon this, the `LemonTextAreaMarkdown` component delivers a rich Markdown editing experience with live preview, image upload capabilities (including drag-and-drop), and guidance for Markdown image links when object storage is unavailable.\n\nHere's a list of high-level product features:\n\n*   Auto-resizing Text Area\n*   Enter Key Handling (with and without modifiers)\n*   Standard Text Area Attributes Support\n*   Event Propagation Control\n*   Configurable Row Limits\n*   Customizable Styling\n*   Markdown Editing\n*   Live Preview\n*   Image Upload (with drag and drop)\n*   Markdown Image Link Support\n*   Error Handling for Image Uploads\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonColor/index.ts",
        "summary": "The code exports two components related to color selection within the Lemon UI library: `LemonColorButton` and `LemonColorGlyph`. These components likely provide users with ways to choose and display colors within the user interface.\n\n**Features:**\n\n*   **Color Selection Button:** A button component that allows users to select a color, potentially opening a color picker or displaying a palette of available colors.\n*   **Color Glyph:** A visual representation of a color, possibly used as an indicator or to display a selected color.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonColor/LemonColorGlyph.tsx",
        "summary": "The `LemonColorGlyph` component is a UI element that displays a color glyph based on either a provided hex color or a color token. It supports different sizes and handles cases where the color is unset or the theme is still loading. The glyph's appearance adapts to the current theme (dark or light mode) by adjusting the background color.\n\nHere's a list of high-level product features:\n\n*   **Color Display:** Renders a visual representation of a color, either from a hex code or a color token.\n*   **Color Token Support:** Resolves and displays colors based on predefined color tokens, allowing for theme-based color management.\n*   **Theme Awareness:** Adapts its appearance (background color) based on the current theme (dark or light mode).\n*   **Unset Color Handling:** Provides a visual representation for unset colors, indicating the absence of a selected color.\n*   **Loading State:** Displays a placeholder glyph while the theme is loading, providing visual feedback to the user.\n*   **Size Variation:** Supports different sizes (e.g., small) to accommodate various UI contexts.\n*   **Custom Styling:** Allows for additional class names to be applied for custom styling."
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonColor/LemonColorList.tsx",
        "summary": "The `LemonColorList` component provides a flexible way to display a list of colors or color tokens, allowing users to select one. It dynamically renders either a list of `LemonColorButton` components based on a provided array of color strings or an array of `DataColorToken` objects. The component handles the selection state, highlighting the currently selected color or token, and triggers a callback function when a color or token is selected.\n\nHere's a list of high-level product features:\n\n*   **Color Selection:** Allows users to select a color from a predefined list of color strings.\n*   **Color Token Selection:** Enables users to choose from a list of color tokens, which are more complex color definitions.\n*   **Visual Indication of Selection:** Highlights the currently selected color or color token for clear user feedback.\n*   **Customizable Selection Handling:** Provides callback functions to handle color or color token selection events.\n*   **Dynamic Rendering:** Adapts its rendering based on whether color strings or color tokens are provided.\n*   **Theming Support:** Supports theming through the `themeId` prop, potentially affecting the appearance of the color buttons.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonColor/LemonColorButton.tsx",
        "summary": "The `LemonColorButton` component is a specialized button that displays a color glyph and optionally a color description in a tooltip. It leverages the `LemonButton` component and extends it with color-specific functionality. The component can accept either a direct color value or a color token referencing a color defined in a data theme. It dynamically derives the color from the token if provided, and generates a tooltip with the color description unless explicitly hidden.\n\nHere's a list of high-level product features:\n\n*   **Color Display:** Renders a visual representation of a color using a `LemonColorGlyph`.\n*   **Color Token Support:** Accepts color tokens to dynamically fetch colors from a data theme.\n*   **Direct Color Support:** Accepts direct color values for static color display.\n*   **Tooltip with Color Description:** Provides a tooltip that displays a description of the color.\n*   **Customizable Button Styling:** Inherits styling options from the base `LemonButton` component (type, size, className, etc.).\n*   **Conditional Tooltip Display:** Allows hiding the color description in the tooltip.\n*   **Data Theme Integration:** Integrates with a data theme logic to retrieve color values based on tokens.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonColor/LemonColorPicker.tsx",
        "summary": "The `LemonColorPicker` component provides a user interface for selecting colors, either from a predefined list of colors or by specifying a custom hexadecimal color code. It utilizes a popover to display the color selection options and includes features for managing preset colors, custom color input with validation, and integration with color tokens. The component supports both selecting a specific color string or a `DataColorToken` object, providing flexibility for different use cases.\n\n**Features:**\n\n*   **Preset Color Selection:** Allows users to choose from a predefined list of colors.\n*   **Custom Color Input:** Enables users to enter a custom hexadecimal color code.\n*   **Color Validation:** Validates the custom color code entered by the user.\n*   **Color Token Support:** Supports the selection of colors based on `DataColorToken` objects, potentially linked to a theme.\n*   **Popover Interface:** Uses a popover to display the color selection options, providing a clean and non-intrusive user experience.\n*   **Dropdown Hiding:** Allows hiding the dropdown indicator on the color button.\n*   **Event Handling:** Prevents popover from closing on certain events.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonColor/utils.ts",
        "summary": "This code defines a utility for identifying and describing colors based on a predefined set of reference HTML5 colors. It includes a comprehensive list of named colors, grouped by color families (e.g., Pink, Purple, Red). The `nearestColor` function calculates the Euclidean distance between a given color (in hex format) and each reference color in RGB space, returning the closest match. The `colorDescription` function then uses this nearest color to generate a user-friendly description, optionally including the color group if the group name isn't already part of the color name.\n\nHere's a list of high-level product features that can be derived from this code:\n\n*   **Color Identification:** Identifies the closest named HTML5 color for any given hex color code.\n*   **Color Grouping:** Categorizes colors into logical groups (e.g., Red, Blue, Green).\n*   **Color Description Generation:** Creates human-readable descriptions for colors, including the color name and group.\n*   **Color Distance Calculation:** Calculates the color distance between a given color and a set of reference colors.\n*   **Comprehensive Color Palette:** Provides a wide range of predefined HTML5 colors for reference.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonColor",
        "summary": "The Lemon UI Color components provide a comprehensive suite of tools for color selection and display within a user interface. These components offer a range of features, from displaying color glyphs and buttons to enabling users to select colors from predefined lists or custom hex codes. The system supports color tokens for dynamic theming, provides color validation, and generates user-friendly color descriptions.\n\nHere's a list of high-level product features:\n\n*   **Color Selection:** Allows users to select colors from a predefined list, custom hex codes, or color tokens.\n*   **Color Display:** Renders visual representations of colors using glyphs and buttons.\n*   **Color Token Support:** Integrates with color tokens for dynamic theming and color management.\n*   **Color Validation:** Validates custom hex codes entered by users.\n*   **Color Description:** Generates human-readable descriptions for colors.\n*   **Theme Awareness:** Adapts appearance based on the current theme (dark/light mode).\n*   **Customization:** Offers various customization options for styling and behavior.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonToast/index.ts",
        "summary": "This code exports the `lemonToast` function from the `./LemonToast` module, making it available for use in other parts of the application. This suggests the existence of a toast notification system within the Lemon UI library.\n\n**Features:**\n\n*   Provides a `lemonToast` function to trigger toast notifications.\n*   Offers a standardized way to display temporary messages to the user.\n*   Part of the Lemon UI library, ensuring consistent styling and behavior.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonToast/LemonToast.tsx",
        "summary": "The `LemonToast` component provides a consistent and customizable way to display toast notifications within the PostHog application. It leverages the `react-toastify` library and offers predefined toast types (info, success, warning, error) with associated icons and styling. The component supports custom messages (strings or JSX elements), optional buttons with associated actions, and promise-based toasts for asynchronous operations. It also includes error tracking via PostHog's event capture.\n\nHere's a list of high-level product features:\n\n*   **Toast Notifications:** Display non-intrusive, temporary messages to the user.\n*   **Multiple Toast Types:** Support for info, success, warning, and error toast types, each with a distinct visual representation.\n*   **Customizable Content:** Ability to display custom messages (text or JSX) within the toast.\n*   **Actionable Buttons:** Option to include buttons within toasts that trigger specific actions.\n*   **Promise-Based Toasts:** Support for displaying toasts during asynchronous operations (pending, success, error states).\n*   **Automatic Dismissal:** Toasts automatically disappear after a set time.\n*   **Manual Dismissal:** Users can manually dismiss toasts using a close button.\n*   **Error Tracking:** Capture error and warning toast events using PostHog for monitoring and debugging.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonToast",
        "summary": "The `LemonToast` component and its associated `lemonToast` function provide a comprehensive toast notification system within the PostHog application, offering a standardized and customizable way to display temporary messages to the user. It leverages the `react-toastify` library and offers predefined toast types with associated icons and styling. The component supports custom messages, optional buttons with associated actions, and promise-based toasts for asynchronous operations. It also includes error tracking via PostHog's event capture.\n\nHere's a list of high-level product features:\n\n*   Toast Notifications: Display non-intrusive, temporary messages to the user.\n*   Multiple Toast Types: Support for info, success, warning, and error toast types, each with a distinct visual representation.\n*   Customizable Content: Ability to display custom messages (text or JSX) within the toast.\n*   Actionable Buttons: Option to include buttons within toasts that trigger specific actions.\n*   Promise-Based Toasts: Support for displaying toasts during asynchronous operations (pending, success, error states).\n*   Automatic Dismissal: Toasts automatically disappear after a set time.\n*   Manual Dismissal: Users can manually dismiss toasts using a close button.\n*   Error Tracking: Capture error and warning toast events using PostHog for monitoring and debugging.\n*   Standardized UI: Part of the Lemon UI library, ensuring consistent styling and behavior.\n*   `lemonToast` Function: Provides a simple function to trigger toast notifications.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonFileInput/index.ts",
        "summary": "The code defines and exports a React component called `LemonFileInput` along with its props interface `LemonFileInputProps`. This component likely provides a styled or enhanced file input element for user interaction within a larger application.\n\n**Features:**\n\n*   Provides a file input component.\n*   Offers a props interface for customization.\n*   Can be integrated into React applications.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonFileInput/LemonFileInput.tsx",
        "summary": "The `LemonFileInput` component provides a user-friendly way to upload files, supporting both click-to-upload and drag-and-drop functionality. It allows for single or multiple file selection, accepts specific file types, and displays the names of uploaded files as tags. The component also handles loading states, disabled states, and provides flexibility in styling the drop target. It uses a ref to manage the drag and drop target, and can optionally use an alternative ref for a custom drop target.\n\nHere's a list of high-level product features:\n\n*   **File Upload:** Enables users to upload files through click or drag-and-drop.\n*   **Multiple File Selection:** Supports uploading single or multiple files.\n*   **File Type Restriction:** Allows specifying accepted file types (e.g., images, JSON files).\n*   **Visual Feedback:** Displays uploaded file names as tags.\n*   **Loading State:** Indicates when files are being uploaded with a spinner icon.\n*   **Disabled State:** Disables the input field to prevent uploads.\n*   **Customizable Call to Action:** Allows customizing the text displayed to the user.\n*   **Drag and Drop Highlighting:** Highlights the drop target area when a file is dragged over it.\n*   **Alternative Drop Target:** Supports using an alternative HTML element as a drop target.\n*   **Display Uploaded Files:** Option to show or hide the list of uploaded files."
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonFileInput",
        "summary": "The `LemonFileInput` component offers a versatile solution for file uploads within React applications, providing both click-to-upload and drag-and-drop functionalities. It supports single or multiple file selection, allows for file type restrictions, and offers visual feedback through file name tags. The component also manages loading and disabled states, provides customizable call-to-action text, and highlights the drop target during drag-and-drop operations. Furthermore, it allows for the use of an alternative drop target and offers the option to display or hide the list of uploaded files.\n\nHere's a list of high-level product features:\n\n*   File Upload (Click and Drag-and-Drop)\n*   Multiple File Selection\n*   File Type Restriction\n*   Visual Feedback (File Name Tags)\n*   Loading State Indicator\n*   Disabled State\n*   Customizable Call to Action Text\n*   Drag and Drop Highlighting\n*   Alternative Drop Target Support\n*   Display Uploaded Files (Toggle Visibility)\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonInput/index.ts",
        "summary": "The code defines and exports a React component called `LemonInput` along with its associated type definitions for different input types (text, number, and generic). This allows developers to use a pre-built input component with consistent styling and behavior within the Lemon UI library.\n\nHere's a list of high-level product features:\n\n*   **LemonInput Component:** A reusable React input component.\n*   **Text Input Support:** Specific type definitions and handling for text-based input.\n*   **Number Input Support:** Specific type definitions and handling for numerical input.\n*   **Props Definition:** Exposes type definitions (`LemonInputProps`, `LemonInputPropsNumber`, `LemonInputPropsText`) for customizing the component's behavior and appearance through props.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonInput/RawInputAutosize.tsx",
        "summary": "The `RawInputAutosize` component is a React component that renders an input field that automatically adjusts its width based on the content entered by the user or the placeholder text. It uses hidden divs to measure the width of the text and dynamically sets the input's width. The component utilizes refs and layout effects to manage the sizing and styling of the input.\n\nHere's a list of high-level product features:\n\n*   **Autosizing Input Field:** The input field automatically adjusts its width to fit the content.\n*   **Placeholder Support:** The input field adjusts its size based on the placeholder text when no value is present.\n*   **Dynamic Width Adjustment:** The input width is dynamically updated as the user types or the placeholder is displayed/hidden.\n*   **Style Preservation:** The input field preserves the font-related styles (font size, family, weight, style, letter spacing, and text transform) to ensure accurate width calculation.\n*   **Ref Forwarding:** Supports forwarding refs to the underlying input element.\n*   **Customizable Wrapper:** Allows for custom styling of the input's wrapper element.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonInput/LemonInput.tsx",
        "summary": "The `LemonInput` component provides a flexible and customizable input field with various features and styling options. It supports different input types (text, number, email, password, search, etc.), sizes, and statuses (default, danger). It allows for prefix and suffix elements, clearable inputs, full-width or auto-width sizing, and password visibility toggling. The component handles focus states, event propagation, and provides callbacks for common input events like `onChange`, `onFocus`, `onBlur`, and `onPressEnter`.\n\nHere's a list of high-level product features:\n\n*   **Multiple Input Types:** Supports text, number, email, password, search, URL, and time input types.\n*   **Status Indication:** Displays input validation status (e.g., \"danger\" for invalid input).\n*   **Clearable Input:** Provides an option to clear the input field with a clear icon.\n*   **Prefix and Suffix Elements:** Allows adding custom elements before and after the input field.\n*   **Password Visibility Toggle:** Offers a button to show or hide password content.\n*   **Flexible Sizing:** Supports different sizes (xsmall, small, medium, large) and width options (full-width, auto-width).\n*   **Focus Management:** Manages focus state and styling.\n*   **Event Handling:** Provides callbacks for common input events (onChange, onFocus, onBlur, onPressEnter).\n*   **Transparent Background:** Option for a transparent background style.\n*   **Accessibility:** Supports aria attributes for accessibility.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonInput",
        "summary": "The LemonInput component suite provides a versatile set of input field components with a focus on customization and user experience. These components offer features such as automatic width adjustment based on content, support for various input types and validation statuses, and the ability to add prefixes, suffixes, and clear buttons. The suite also includes a password visibility toggle, flexible sizing options, and comprehensive event handling, all while maintaining accessibility and a consistent style within the Lemon UI library.\n\nHere's a list of high-level product features:\n\n*   Multiple Input Types (text, number, email, password, search, URL, time)\n*   Autosizing Input Field\n*   Status Indication (e.g., \"danger\" for invalid input)\n*   Clearable Input\n*   Prefix and Suffix Elements\n*   Password Visibility Toggle\n*   Flexible Sizing (xsmall, small, medium, large, full-width, auto-width)\n*   Event Handling (onChange, onFocus, onBlur, onPressEnter)\n*   Placeholder Support\n*   Dynamic Width Adjustment\n*   Transparent Background Option\n*   Accessibility Support (aria attributes)\n*   Ref Forwarding\n*   Customizable Wrapper\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/Tooltip/index.ts",
        "summary": "This code exports the `Tooltip` component and its associated `TooltipProps` type from the `./Tooltip` file. This allows other parts of the application to easily import and use the Tooltip component with type safety.\n\nHere's a list of high-level product features related to this code:\n\n*   **Tooltip Display:** Provides a way to display contextual information on hover or focus.\n*   **Customizable Content:** Allows developers to specify the content displayed within the tooltip.\n*   **Type Safety:** Ensures that the Tooltip component is used correctly by providing a `TooltipProps` type definition.\n*   **Easy Integration:** Simplifies the process of adding tooltips to various UI elements.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/Tooltip/Tooltip.tsx",
        "summary": "The `Tooltip` component provides a way to display contextual information on hover or focus of a trigger element. It leverages the `@floating-ui/react` library to handle positioning, interactions, and accessibility. The tooltip can be controlled or uncontrolled in terms of visibility, supports custom styling, placement, delays, and interactivity, and includes an optional arrow. It renders the provided children as the trigger element and displays the tooltip content in a floating portal when active.\n\nHere's a list of high-level product features:\n\n*   **Display contextual information:** Shows a tooltip with a title (string, React node, or function) when the trigger element is hovered or focused.\n*   **Flexible content:** The tooltip title can be a simple string, a React node for more complex content, or a function that returns a string for dynamic content.\n*   **Customizable placement:** Allows specifying the placement of the tooltip relative to the trigger element (e.g., top, bottom, left, right).\n*   **Delay control:** Configurable delay before the tooltip appears and disappears.\n*   **Interactive tooltips:** Option to keep the tooltip open when the user hovers over it.\n*   **Custom styling:** Supports custom CSS classes for styling the tooltip.\n*   **Arrow support:** Includes an optional arrow pointing to the trigger element.\n*   **Controlled/Uncontrolled visibility:** Can be controlled by a `visible` prop or managed internally based on hover and focus.\n*   **Accessibility:** Implements ARIA roles and attributes for accessibility.\n*   **Offset control:** Allows adjusting the distance between the trigger element and the tooltip.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/Tooltip",
        "summary": "The `Tooltip` component provides a versatile way to display contextual information on hover or focus events, enhancing user experience by offering helpful hints and descriptions. It supports customizable content, placement, delays, and styling, including an optional arrow for visual clarity. The component can be controlled or uncontrolled in terms of visibility and is designed with accessibility in mind, ensuring it's usable by everyone.\n\nHere's a list of high-level product features:\n\n*   Display contextual information on hover or focus.\n*   Flexible tooltip content (string, React node, or function).\n*   Customizable tooltip placement relative to the trigger element.\n*   Configurable delay for tooltip appearance and disappearance.\n*   Interactive tooltips that remain open on hover.\n*   Custom CSS styling for the tooltip.\n*   Optional arrow pointing to the trigger element.\n*   Controlled/Uncontrolled visibility via prop or internal state.\n*   Accessibility support with ARIA roles and attributes.\n*   Offset control for adjusting tooltip distance.\n*   Type safety through `TooltipProps` type definition.\n*   Easy integration into various UI elements.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonField/index.ts",
        "summary": "The code exports the `LemonField` component along with its associated type definitions (`LemonFieldProps` and `LemonPureFieldProps`). This suggests the existence of a reusable form field component within the Lemon UI library.\n\n**Features:**\n\n*   **Reusable Form Field Component:** Provides a pre-built, customizable form field element for use in various forms and input scenarios.\n*   **Props for Customization:** Offers properties (`LemonFieldProps`) to control the appearance, behavior, and validation of the form field.\n*   **Pure Field Variant:** Includes a \"pure\" variant (`LemonPureFieldProps`), potentially offering a more basic or unstyled version of the field for greater customization control.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonField/LemonField.tsx",
        "summary": "The `LemonField` component provides a styled form field with labels, help text, and error messages. It supports integration with Kea forms for state management and also offers a standalone version (`LemonField.Pure`) for use outside of Kea forms. The component allows customization of the label, error display, and layout, and includes features like optional labels, explanation links, and info tooltips.\n\nHere's a list of high-level product features:\n\n*   **Styled Form Field:** Provides a consistent and visually appealing form field component.\n*   **Label Management:** Supports displaying labels with optional indicators, explanation links, and info tooltips.\n*   **Error Handling:** Displays error messages with a consistent style, including an error icon.\n*   **Help Text:** Allows displaying help text beneath the input field.\n*   **Layout Customization:** Supports inline (row) or column-based layouts.\n*   **Kea Forms Integration:** Integrates seamlessly with Kea forms for state management.\n*   **Standalone Usage:** Can be used independently of Kea forms with the `LemonField.Pure` variant.\n*   **Customizable Error Rendering:** Allows custom rendering of error messages.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonField",
        "summary": "The LemonField component offers a styled and customizable form field solution for React applications, providing features for label management, error handling, and help text display. It supports both integration with Kea forms for state management and standalone usage, offering flexibility in different form implementation scenarios. The component allows for layout customization and custom error rendering, ensuring a consistent and visually appealing user experience across various form designs.\n\nHere's a list of high-level product features:\n\n*   Styled Form Field: Provides a consistent and visually appealing form field component.\n*   Label Management: Supports displaying labels with optional indicators, explanation links, and info tooltips.\n*   Error Handling: Displays error messages with a consistent style, including an error icon.\n*   Help Text: Allows displaying help text beneath the input field.\n*   Layout Customization: Supports inline (row) or column-based layouts.\n*   Kea Forms Integration: Integrates seamlessly with Kea forms for state management.\n*   Standalone Usage: Can be used independently of Kea forms with the `LemonField.Pure` variant.\n*   Customizable Error Rendering: Allows custom rendering of error messages.\n*   Reusable Form Field Component: Provides a pre-built, customizable form field element for use in various forms and input scenarios.\n*   Props for Customization: Offers properties (`LemonFieldProps`) to control the appearance, behavior, and validation of the form field.\n*   Pure Field Variant: Includes a \"pure\" variant (`LemonPureFieldProps`), potentially offering a more basic or unstyled version of the field for greater customization control.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSlider/index.ts",
        "summary": "The code defines and exports a `LemonSlider` component along with its associated type definition `LemonSliderProps`. This allows other parts of the application to import and use the slider component.\n\n**Features:**\n\n*   **LemonSlider Component:** A slider component for selecting a value within a specified range.\n*   **LemonSliderProps Type:** Defines the properties and configuration options available for the LemonSlider component.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSlider/LemonSlider.tsx",
        "summary": "The `LemonSlider` component provides a customizable slider input for React applications. It supports mouse, touch, and keyboard interactions for adjusting the slider value. The slider's appearance can be customized with CSS classes, and it includes features like stepping, value constraints (min/max), and accessibility attributes. The component uses internal state and refs to manage dragging behavior and value updates.\n\nHere's a list of high-level product features:\n\n*   **Controllable Value:** The slider's value can be controlled via the `value` prop and updated using the `onChange` callback.\n*   **Min/Max Constraints:** The slider enforces minimum and maximum value limits.\n*   **Stepping:** The slider supports discrete value increments via the `step` prop.\n*   **Mouse Interaction:** Users can drag the slider handle or click on the track to change the value.\n*   **Touch Interaction:** The slider supports touch-based dragging on mobile devices.\n*   **Keyboard Interaction:** Users can use arrow keys, Home, End, Page Up, and Page Down keys to adjust the value. Holding shift increases the step size.\n*   **Customizable Appearance:** The slider's appearance can be customized using CSS classes.\n*   **Accessibility:** The slider includes ARIA attributes for accessibility.\n*   **Dragging State:** Visual feedback is provided to indicate when the slider is being dragged.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSlider",
        "summary": "The `LemonSlider` component offers a versatile and customizable slider input for React applications, enabling users to select values within a defined range through mouse, touch, and keyboard interactions. It provides features such as value constraints, stepping, and customizable appearance via CSS classes, while also ensuring accessibility through ARIA attributes. The component's value can be controlled and updated, and visual feedback is provided during dragging.\n\nHere's a list of high-level product features:\n\n*   Controllable Value: The slider's value can be controlled via the `value` prop and updated using the `onChange` callback.\n*   Min/Max Constraints: The slider enforces minimum and maximum value limits.\n*   Stepping: The slider supports discrete value increments via the `step` prop.\n*   Mouse Interaction: Users can drag the slider handle or click on the track to change the value.\n*   Touch Interaction: The slider supports touch-based dragging on mobile devices.\n*   Keyboard Interaction: Users can use arrow keys, Home, End, Page Up, and Page Down keys to adjust the value. Holding shift increases the step size.\n*   Customizable Appearance: The slider's appearance can be customized using CSS classes.\n*   Accessibility: The slider includes ARIA attributes for accessibility.\n*   Dragging State: Visual feedback is provided to indicate when the slider is being dragged.\n*   LemonSlider Component: A slider component for selecting a value within a specified range.\n*   LemonSliderProps Type: Defines the properties and configuration options available for the LemonSlider component.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonCalendarRange/index.ts",
        "summary": "The code exports two components related to date range selection: `LemonCalendarRange` and `LemonCalendarRangeInline`. These components likely provide users with the ability to select a start and end date, potentially with different display options, one being a standard component and the other being an inline version.\n\nHere's a list of high-level product features:\n\n*   **Date Range Selection:** Allows users to select a range of dates (start and end date).\n*   **Calendar Interface:** Provides a calendar-based user interface for selecting dates.\n*   **Standard Calendar Range Component:** A regular, likely pop-up or modal-based, date range picker.\n*   **Inline Calendar Range Component:** A date range picker that is displayed directly within the page layout.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonCalendarRange/LemonCalendarRange.tsx",
        "summary": "The `LemonCalendarRange` component provides a user interface for selecting a date range using an inline calendar. It allows users to pick a start and end date, displaying the selected range in a human-readable format. The component includes \"Cancel\" and \"Apply\" buttons to either discard the selection or confirm and propagate the chosen date range to a parent component via a callback function. It also supports an optional close button and configurable number of months to display in the inline calendar.\n\nHere's a list of high-level product features:\n\n*   **Date Range Selection:** Allows users to select a start and end date from a calendar interface.\n*   **Inline Calendar Display:** Presents a calendar directly within the component for date selection.\n*   **Date Range Formatting:** Displays the selected date range in a user-friendly format.\n*   **Apply and Cancel Actions:** Provides buttons to confirm or discard the selected date range.\n*   **Callback on Change:** Notifies the parent component when a date range is selected.\n*   **Customizable Number of Months:** Allows configuring the number of months displayed in the calendar.\n*   **Close Button:** Option to include a close button for dismissing the calendar range selector.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonCalendarRange/LemonCalendarRangeInline.tsx",
        "summary": "The `LemonCalendarRangeInline` component provides an inline date range picker using the `LemonCalendar` component. It allows users to select a start and end date, displaying a range of dates across multiple months (up to two, responsive to screen size). The component manages the selected date range, updates the parent component via the `onChange` prop, and ensures the selected range is always visible by adjusting the displayed months. It also provides visual cues for the selected range, highlighting the start, end, and intermediate dates.\n\nHere's a list of high-level product features:\n\n*   **Inline Date Range Selection:** Allows users to select a date range directly within the page.\n*   **Responsive Calendar Display:** Adapts the number of displayed months (1 or 2) based on screen size.\n*   **Date Range Highlighting:** Visually highlights the selected start date, end date, and all dates in between.\n*   **Dynamic Month Navigation:** Automatically adjusts the displayed months to keep the selected date range in view.\n*   **Controlled Component:**  Accepts a `value` prop for the selected date range and an `onChange` prop to notify the parent component of changes.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonCalendarRange",
        "summary": "The LemonCalendarRange library provides flexible date range selection capabilities with two main components: `LemonCalendarRange` and `LemonCalendarRangeInline`. These components offer users an intuitive calendar interface to select start and end dates, with options for inline or modal display, responsive design, date range highlighting, and customizable features like the number of displayed months and the inclusion of apply/cancel buttons. The selected date range is formatted for easy readability, and changes are communicated to parent components through callbacks.\n\nHere's a list of high-level product features:\n\n*   Date Range Selection: Allows users to select a start and end date from a calendar interface.\n*   Inline and Modal Calendar Display: Offers both inline and modal calendar display options.\n*   Responsive Calendar: Adapts the calendar display based on screen size.\n*   Date Range Highlighting: Visually highlights the selected date range.\n*   Customizable Calendar: Allows configuring the number of months displayed.\n*   Apply and Cancel Actions: Provides buttons to confirm or discard the selected date range.\n*   Callback on Change: Notifies the parent component when a date range is selected.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonMenu/index.ts",
        "summary": "The code defines and exports the types `LemonMenuItem`, `LemonMenuItems`, and `LemonMenuSection`, along with the `LemonMenu` component itself. These exports suggest a menu component with support for individual menu items, collections of menu items, and the ability to organize menu items into sections.\n\n**Features:**\n\n*   **LemonMenu Component:** A reusable menu component for user interfaces.\n*   **LemonMenuItem Type:** Defines the structure for individual items within the menu.\n*   **LemonMenuItems Type:** Defines the structure for a collection of menu items.\n*   **LemonMenuSection Type:** Defines the structure for organizing menu items into logical sections within the menu.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonMenu/useKeyboardNavigation.ts",
        "summary": "This code defines a React hook, `useKeyboardNavigation`, designed to enhance the accessibility and usability of menu-like components by enabling keyboard navigation. It manages focus state and provides refs for the container and individual menu items. The hook listens for `ArrowUp` and `ArrowDown` key presses to move focus between menu items, preventing default scrolling behavior. It returns refs that should be attached to the menu container and menu items.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Keyboard Navigation:** Enables users to navigate menu items using the `ArrowUp` and `ArrowDown` keys.\n*   **Focus Management:** Manages the focus state of menu items, ensuring only one item is focused at a time.\n*   **Accessibility:** Improves accessibility for users who rely on keyboard navigation.\n*   **Scroll Prevention:** Prevents the page from scrolling when navigating the menu with arrow keys.\n*   **React Hook:** Provides a reusable React hook for easy integration into menu components.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonMenu/LemonMenu.tsx",
        "summary": "The `LemonMenu` component provides a flexible and customizable menu system built on top of Lemon UI primitives. It supports nested menus, sections with titles and footers, keyboard navigation, and various styling options. Menu items can be buttons with labels, icons, keyboard shortcuts, and tags, or custom React elements. The component handles the layout and interaction logic for displaying menu items in a dropdown format, including keyboard navigation and accessibility features.\n\nHere's a list of high-level product features:\n\n*   **Nested Menus:** Allows creating hierarchical menus with submenus.\n*   **Menu Sections:** Organizes menu items into logical groups with optional titles and footers.\n*   **Customizable Menu Items:** Supports various item types, including buttons with icons, labels, keyboard shortcuts, and tags, as well as custom React elements.\n*   **Keyboard Navigation:** Enables users to navigate the menu using the keyboard.\n*   **Accessibility:** Provides accessibility features such as ARIA roles and keyboard support.\n*   **Styling Options:** Offers various styling options through props, including button size, tooltip placement, and custom CSS classes.\n*   **Dropdown Integration:** Integrates with the `LemonDropdown` component to display the menu in a dropdown format.\n*   **Automatic Item Normalization:** Handles different menu structures, including sections and individual items, and normalizes them for consistent rendering.\n*   **Active Item Highlighting:** Highlights the active (selected) menu item.\n*   **Client-Side Routing Support:** Supports client-side routing for menu items that are links.\n*   **Tag Support:** Allows adding tags (alpha, beta, new) to menu items.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonMenu",
        "summary": "The `LemonMenu` component provides a versatile and accessible menu system, enhanced by the `useKeyboardNavigation` hook, offering a range of features for building user-friendly interfaces. It supports nested menus, sectioning with titles and footers, and customizable menu items with icons, labels, shortcuts, and tags. Keyboard navigation is a core feature, improving accessibility and usability. The component integrates seamlessly with dropdowns and offers styling options for customization.\n\nHere's a list of high-level product features:\n\n*   Nested Menus: Create hierarchical menus with submenus.\n*   Menu Sections: Organize menu items into logical groups with optional titles and footers.\n*   Customizable Menu Items: Support various item types, including buttons with icons, labels, keyboard shortcuts, and tags, as well as custom React elements.\n*   Keyboard Navigation: Enable users to navigate the menu using the keyboard (ArrowUp and ArrowDown keys).\n*   Accessibility: Improve accessibility for users who rely on keyboard navigation, including ARIA roles.\n*   Styling Options: Offer various styling options through props, including button size, tooltip placement, and custom CSS classes.\n*   Dropdown Integration: Integrate with the `LemonDropdown` component to display the menu in a dropdown format.\n*   Automatic Item Normalization: Handle different menu structures, including sections and individual items, and normalize them for consistent rendering.\n*   Active Item Highlighting: Highlight the active (selected) menu item.\n*   Client-Side Routing Support: Support client-side routing for menu items that are links.\n*   Tag Support: Allow adding tags (alpha, beta, new) to menu items.\n*   Focus Management: Manages the focus state of menu items, ensuring only one item is focused at a time.\n*   Scroll Prevention: Prevents the page from scrolling when navigating the menu with arrow keys.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonLabel/index.ts",
        "summary": "The code defines and exports a LemonLabel component and its associated props type from the LemonLabel module. This allows other parts of the application to easily import and use the LemonLabel component with type safety.\n\nHere's a list of high-level product features related to this code:\n\n*   **Label Display:** Provides a UI component for displaying labels.\n*   **Customizable Label Properties:** Exposes props for customizing the appearance and behavior of the label.\n*   **Type Safety:** Includes TypeScript definitions for the component's props, ensuring type safety when using the component.\n*   **Reusability:** Designed as a reusable component for consistent label presentation throughout the application.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonLabel/LemonLabel.tsx",
        "summary": "The `LemonLabel` component is a styled label element with optional features for displaying extra information. It can render an \"(optional)\" tag, a \"(what is this?)\" link that triggers a callback, and an info icon with a tooltip. The info icon can also be a link to an external resource. The component accepts standard label attributes like `htmlFor`, `id`, and `className` for customization.\n\nHere's a list of high-level product features:\n\n*   **Basic Label Rendering:** Displays a standard HTML label with custom styling.\n*   **Optional Field Indicator:** Shows an \"(optional)\" tag next to the label text.\n*   **Explanation Link:** Provides a \"(what is this?)\" link that triggers a user-defined callback function.\n*   **Informational Tooltip:** Displays an info icon that shows a tooltip with additional information on hover.\n*   **Informational Link:** The info icon can be a link to an external resource.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonLabel",
        "summary": "The `LemonLabel` component is a versatile UI element designed for displaying labels with enhanced features. It offers standard label rendering with customizable styling options, along with the ability to indicate optional fields, provide explanations via a link, and display informational tooltips or links through an info icon. The component is built with TypeScript, ensuring type safety and reusability across the application.\n\nHere's a list of high-level product features:\n\n*   Basic Label Rendering: Displays a standard HTML label with custom styling.\n*   Optional Field Indicator: Shows an \"(optional)\" tag next to the label text.\n*   Explanation Link: Provides a \"(what is this?)\" link that triggers a user-defined callback function.\n*   Informational Tooltip: Displays an info icon that shows a tooltip with additional information on hover.\n*   Informational Link: The info icon can be a link to an external resource.\n*   Customizable Label Properties: Exposes props for customizing the appearance and behavior of the label.\n*   Type Safety: Includes TypeScript definitions for the component's props, ensuring type safety when using the component.\n*   Reusability: Designed as a reusable component for consistent label presentation throughout the application.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSnack/index.ts",
        "summary": "The code defines and exports a `LemonSnack` component and its associated props type `LemonSnackProps` from the `./LemonSnack` file. This suggests the existence of a UI component named `LemonSnack` intended to display snackbar-like notifications or messages within the application.\n\nHere's a list of high-level product features based on this code:\n\n*   **Snackbar/Notification Display:** Provides a UI element for displaying short, temporary messages to the user.\n*   **Customizable Properties:** Exposes properties (defined in `LemonSnackProps`) to control the appearance and behavior of the snackbar.\n*   **Reusable Component:** Designed as a reusable UI component for consistent snackbar presentation throughout the application.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSnack/LemonSnack.tsx",
        "summary": "The `LemonSnack` component is a versatile UI element for displaying short, non-intrusive messages or notifications. It offers two styles: \"regular\" (rectangular) and \"pill\" (rounded). It supports click actions, close buttons, and customizable content. The component is built using Tailwind CSS for styling and provides options for text wrapping and custom class names.\n\nHere's a list of high-level features:\n\n*   **Two Style Options:** Regular (rectangular) and Pill (rounded) styles.\n*   **Clickable Snack:** Supports an `onClick` handler to make the snack interactive.\n*   **Closeable Snack:**  Optional close button with an `onClose` handler.\n*   **Customizable Content:** Accepts any React node as content.\n*   **Text Wrapping:** Option to control text wrapping behavior.\n*   **Customizable Styling:** Accepts custom class names for styling.\n*   **Title Attribute:**  Supports a title attribute for accessibility and tooltips.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSnack",
        "summary": "The `LemonSnack` component is a flexible UI element designed for displaying concise, non-intrusive notifications or messages. It offers both rectangular and rounded \"pill\" styles, supports click actions and optional close buttons, and allows for fully customizable content. Built with Tailwind CSS, it provides options for text wrapping, custom styling via class names, and a title attribute for enhanced accessibility. The component is designed for reusability and consistent presentation of snackbar-like notifications throughout the application.\n\nHere's a list of high-level product features:\n\n*   Snackbar/Notification Display\n*   Two Style Options: Regular (rectangular) and Pill (rounded)\n*   Clickable Snack\n*   Closeable Snack\n*   Customizable Content\n*   Text Wrapping Control\n*   Customizable Styling\n*   Title Attribute for Accessibility\n*   Reusable Component\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSegmentedButton/index.ts",
        "summary": "The code exports the `LemonSegmentedButton` component, making it available for use in other parts of the application. This suggests the existence of a UI component that functions as a segmented button.\n\nHere's a list of high-level product features based on this information:\n\n*   **Segmented Button UI Component:** Provides a user interface element that allows users to select one option from a set of mutually exclusive options, visually represented as segments within a button group.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSegmentedButton/LemonSegmentedButton.tsx",
        "summary": "The `LemonSegmentedButton` component provides a button-radio hybrid, allowing users to select a single option from a set of predefined choices. It utilizes a slider to visually indicate the selected option and supports labels, icons, disabled states, tooltips, and custom data attributes for each option. The component is customizable in terms of size, width, and styling, and it triggers an `onChange` event when a new option is selected.\n\nHere's a list of high-level product features:\n\n*   **Single Option Selection:** Allows users to select only one option from a group of buttons.\n*   **Visual Slider Indicator:** Provides a visual cue (slider) to highlight the currently selected option.\n*   **Label and Icon Support:** Each option can display either a text label or an icon, or both.\n*   **Disabled State:** Options can be disabled with an optional reason displayed as a tooltip.\n*   **Customizable Size and Width:** The component's size and width can be adjusted to fit different layouts.\n*   **Theming and Styling:** Supports custom class names for styling and theming.\n*   **Event Handling:** Triggers an `onChange` event when the selected option changes.\n*   **Tooltip Support:** Options can have tooltips to provide additional information.\n*   **Data Attributes:** Supports custom data attributes for each option."
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSegmentedButton",
        "summary": "The `LemonSegmentedButton` component offers a user-friendly way to select a single option from a set of predefined choices, combining the functionality of a button and a radio input. It enhances the user experience with a visual slider to indicate the selected option and supports labels, icons, disabled states with tooltips, and custom data attributes for each option. The component is highly customizable in terms of size, width, and styling, and it triggers an `onChange` event when a new option is selected, making it a versatile tool for various selection scenarios.\n\nHere's a list of high-level product features:\n\n*   Single Option Selection\n*   Visual Slider Indicator\n*   Label and Icon Support\n*   Disabled State with Tooltip\n*   Customizable Size and Width\n*   Theming and Styling\n*   Event Handling (`onChange`)\n*   Custom Data Attributes\n*   Segmented Button UI Component\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonProgressCircle/index.tsx",
        "summary": "The code exports the LemonProgressCircle component, making it available for use in other parts of the application. This suggests the existence of a visual component designed to display progress in a circular format.\n\n**Features:**\n\n*   **Progress Visualization:** Displays progress to the user in a circular format.\n*   **Component Export:** Provides a reusable LemonProgressCircle component for easy integration.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonProgressCircle/LemonProgressCircle.tsx",
        "summary": "The `LemonProgressCircle` component is a customizable circular progress indicator built using SVG. It allows users to visualize progress with configurable stroke thickness, background stroke opacity, and size. The component accepts a progress value (0-1) to dynamically update the progress indication. It also supports displaying content within the circle, providing flexibility for adding labels or icons. The component is styled using SCSS and utilizes `clsx` for conditional class name application.\n\nHere's a list of high-level product features:\n\n*   **Circular Progress Visualization:** Displays progress in a circular format.\n*   **Customizable Size:** Allows users to define the size of the progress circle.\n*   **Configurable Stroke:** Enables customization of the stroke thickness for both the progress indicator and its background.\n*   **Adjustable Background Opacity:** Provides control over the opacity of the background circle.\n*   **Dynamic Progress Update:** Updates the progress indication based on a provided progress value.\n*   **Content Support:** Allows embedding content (e.g., text, icons) within the progress circle.\n*   **Stylable with CSS Classes:** Supports custom styling through CSS class names.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonProgressCircle",
        "summary": "The LemonProgressCircle component is a versatile and visually appealing way to represent progress in a circular format. Built with SVG for scalability and customization, it allows developers to easily integrate a progress indicator into their applications. The component offers a range of configurable options, including size, stroke thickness, background opacity, and the ability to display content within the circle, making it adaptable to various design requirements.\n\n**Features:**\n\n*   Circular Progress Visualization: Displays progress in a circular format.\n*   Customizable Size: Allows users to define the size of the progress circle.\n*   Configurable Stroke: Enables customization of the stroke thickness for both the progress indicator and its background.\n*   Adjustable Background Opacity: Provides control over the opacity of the background circle.\n*   Dynamic Progress Update: Updates the progress indication based on a provided progress value.\n*   Content Support: Allows embedding content (e.g., text, icons) within the progress circle.\n*   Stylable with CSS Classes: Supports custom styling through CSS class names.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/Splotch/index.ts",
        "summary": "The code exports the `Splotch` component from the `./Splotch` file, making it available for use in other parts of the application. This suggests the existence of a visual component named `Splotch` within the Lemon UI library.\n\n**Features:**\n\n*   **Splotch Component:** A reusable UI element, likely a visual element such as a colored shape or marker.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/Splotch/Splotch.tsx",
        "summary": "The `Splotch` component is a small, icon-sized blob that visually represents a specific color. It's designed to be used in contexts like color selection menus, potentially as an icon within a `LemonButton` component. The component accepts a `color` prop, which determines the color of the splotch, and renders a `div` element with CSS classes to style the splotch and its \"paint\" area.\n\nHere's a list of high-level features:\n\n*   **Color Representation:** Displays a visual representation of a color.\n*   **Configurable Color:** Accepts a `color` prop to dynamically change the displayed color.\n*   **Predefined Color Palette:** Supports a predefined set of colors (Purple, Blue, Green, Black, White) through the `SplotchColor` enum.\n*   **Styling:** Uses CSS classes for styling the splotch appearance.\n*   **Icon-Sized:** Designed to be small and suitable for use as an icon.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/Splotch",
        "summary": "The `Splotch` component is a reusable UI element designed to visually represent a specific color, making it suitable for color selection menus or as an icon within other components. It accepts a `color` prop to dynamically change the displayed color and supports a predefined set of colors. The component is styled using CSS classes and is designed to be small and icon-sized.\n\nHere's a list of high-level product features:\n\n*   Color Representation: Displays a visual representation of a color.\n*   Configurable Color: Accepts a `color` prop to dynamically change the displayed color.\n*   Predefined Color Palette: Supports a predefined set of colors.\n*   Styling: Uses CSS classes for styling the splotch appearance.\n*   Icon-Sized: Designed to be small and suitable for use as an icon.\n*   Reusable UI Element: Can be imported and used in other parts of the application.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonWidget/index.ts",
        "summary": "The code defines and exports a `LemonWidget` component and its associated props type `LemonWidgetProps` from the `./LemonWidget` file. This suggests the existence of a reusable UI component named `LemonWidget` within the Lemon UI library.\n\n**Features:**\n\n*   **LemonWidget Component:** A reusable UI component.\n*   **LemonWidgetProps:** Defines the properties/configuration options for the `LemonWidget` component.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonWidget/LemonWidget.tsx",
        "summary": "The `LemonWidget` component is a reusable UI element that provides a structured container for displaying content. It features a header with a title, optional actions, and a close button. The main content area is separated from the header by a border. The component is designed to be flexible and customizable through props such as `title`, `onClose`, `actions`, `children`, and `className`.\n\nHere's a list of high-level product features:\n\n*   **Title Display:** Displays a title in the widget header.\n*   **Close Functionality:** Provides an optional close button with a configurable `onClose` handler.\n*   **Custom Actions:** Supports adding custom action elements to the header.\n*   **Content Area:** Provides a dedicated content area for displaying the main content.\n*   **Custom Styling:** Allows for custom styling through the `className` prop.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonWidget",
        "summary": "The `LemonWidget` component is a versatile UI container designed for displaying content in a structured manner. It offers a customizable header with a title, optional actions, and a close button, along with a dedicated content area separated by a border. The component is designed to be reusable and easily styled, making it a valuable building block for creating consistent and visually appealing user interfaces.\n\nHere's a list of high-level product features:\n\n*   **Title Display:** Displays a title in the widget header.\n*   **Close Functionality:** Provides an optional close button with a configurable `onClose` handler.\n*   **Custom Actions:** Supports adding custom action elements to the header.\n*   **Content Area:** Provides a dedicated content area for displaying the main content.\n*   **Custom Styling:** Allows for custom styling through the `className` prop.\n*   **LemonWidget Component:** A reusable UI component.\n*   **LemonWidgetProps:** Defines the properties/configuration options for the `LemonWidget` component.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/PaginationControl/index.ts",
        "summary": "The code defines and exports components and utilities for implementing pagination controls in a user interface. It includes a `PaginationControl` component, related types for defining pagination properties and state (`PaginationControlProps`, `PaginationAuto`, `PaginationManual`, `PaginationState`), and a `usePagination` hook for managing pagination logic.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **UI Pagination Control:** Provides a ready-to-use UI component for navigating through paginated data.\n*   **Automatic Pagination:** Supports automatic calculation of pagination based on total items and items per page.\n*   **Manual Pagination:** Allows manual control over pagination state for more complex scenarios.\n*   **Pagination State Management:** Offers a centralized way to manage and update the current pagination state (current page, total pages, etc.).\n*   **Customizable Pagination Logic:** Exposes a hook (`usePagination`) to implement custom pagination logic and integrate it with other components.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/PaginationControl/usePagination.ts",
        "summary": "The `usePagination` hook provides pagination functionality for data displayed in a UI. It supports both automatic and manual pagination modes. It uses the `kea-router` library to manage the current page via URL search parameters, allowing for bookmarkable and shareable pagination states. The hook calculates and returns the current page, total page count, start and end indices of the current page's data, and a subset of the data source corresponding to the current page. It also provides a function to set the current page, updating the URL accordingly.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Automatic Data Pagination:** Automatically splits a data source into pages based on a specified page size.\n*   **Manual Pagination Control:** Allows external control of the current page and total entry count.\n*   **URL-Based Page Persistence:** Stores the current page in the URL, enabling bookmarking and sharing of specific pages.\n*   **Page Navigation:** Provides a function to easily navigate between pages.\n*   **Data Slicing:** Extracts the relevant subset of data for the current page.\n*   **Index Tracking:** Calculates and provides the start and end indices of the data displayed on the current page.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/PaginationControl/types.ts",
        "summary": "The code defines the types and interfaces for a pagination control component in a Lemon UI frontend. It supports both automatic and manual pagination modes. Automatic pagination calculates the number of pages based on the page size. Manual pagination requires the current page, total entry count, and navigation handlers to be provided. The code also defines a `PaginationState` type that encapsulates the state of the pagination control, including the current page, start and end indices, data source page, page count, and entry count.\n\nHere's a list of high-level product features based on the code:\n\n*   **Automatic Pagination:** Automatically calculates and displays pagination based on page size.\n*   **Manual Pagination:** Allows for complete control over pagination, including current page, total entry count, and navigation.\n*   **Page Size Configuration:** Allows setting the number of items displayed per page.\n*   **Current Page Tracking:** Keeps track of the current page being viewed.\n*   **Navigation Handling:** Provides handlers for navigating to the next and previous pages.\n*   **Entry Count Display:** Shows the total number of entries, providing context for the pagination.\n*   **Conditional Display:** Option to hide pagination when there is only one page.\n*   **Data Source Page:** Manages and provides the data for the current page.\n*   **Start and End Index Tracking:** Keeps track of the start and end indices of the current page within the entire dataset.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/PaginationControl/PaginationControl.tsx",
        "summary": "The `PaginationControl` component provides a user interface for navigating through paginated data. It displays the current range of items being viewed, along with buttons to move to the previous and next pages. The component handles both controlled and uncontrolled pagination scenarios, allowing for flexibility in how pagination state is managed. It also supports customization of the displayed nouns (e.g., \"entry\" and \"entries\") and offers an option to add a border for visual styling. The component intelligently hides itself when pagination is unnecessary, such as when there's only a single page of data.\n\nHere's a list of high-level product features:\n\n*   **Display of Current Item Range:** Shows the user which items are currently being viewed (e.g., \"1-10 of 100 entries\").\n*   **Previous/Next Page Navigation:** Provides buttons to navigate to the previous and next pages of data.\n*   **Controlled and Uncontrolled Pagination:** Supports both controlled pagination (where the parent component manages the current page) and uncontrolled pagination (where the component manages the current page internally).\n*   **Customizable Nouns:** Allows developers to customize the nouns used to describe the items being paginated (e.g., \"entry,\" \"entries,\" \"item,\" \"items\").\n*   **Conditional Rendering:** Hides the pagination control when there is only one page of data (optional).\n*   **Bordered Styling:** Offers an option to add a border to the pagination control for visual styling.\n*   **Disabled State for Navigation Buttons:** Disables the previous/next buttons when the user is on the first/last page, respectively.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/PaginationControl",
        "summary": "The Lemon UI Pagination Control provides a comprehensive solution for paginating data in user interfaces, offering both automatic and manual pagination modes. It includes a ready-to-use UI component, a hook for managing pagination logic, and supports URL-based page persistence for bookmarking and sharing. The component is highly customizable, allowing developers to control the display of item ranges, navigation buttons, and even the nouns used to describe the paginated items.\n\nHere's a list of high-level product features:\n\n*   **Automatic Pagination:** Automatically calculates and displays pagination based on page size and total items.\n*   **Manual Pagination:** Allows for complete control over pagination state and navigation.\n*   **UI Pagination Control Component:** Provides a pre-built UI component for navigating paginated data.\n*   **Pagination Logic Hook:** Offers a hook for implementing custom pagination logic.\n*   **URL-Based Page Persistence:** Stores the current page in the URL for bookmarking and sharing.\n*   **Customizable Display:** Allows customization of item range display, nouns, and styling.\n*   **Conditional Rendering:** Option to hide pagination when there is only one page.\n*   **Navigation Handling:** Provides handlers and UI elements for navigating to the next and previous pages.\n*   **Data Slicing:** Extracts the relevant subset of data for the current page.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonInputSelect/index.ts",
        "summary": "The code exports the `LemonInputSelect` component, making it available for use in other parts of the application. This suggests the existence of a custom input select component within the Lemon UI library.\n\n**Features:**\n\n*   Provides a custom input select component (`LemonInputSelect`).\n*   Offers a reusable UI element for selecting options from a list within an input field.\n*   Part of the Lemon UI library, suggesting a suite of related UI components.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonInputSelect/LemonInputSelect.tsx",
        "summary": "The `LemonInputSelect` component provides a flexible input field with dropdown suggestions, supporting both single and multiple selection modes. It allows users to either select from a predefined list of options or, optionally, enter custom values. The component features filtering, customizable display, and handles keyboard navigation for enhanced usability. It also includes visual cues like loading states and selected value indicators.\n\nHere's a list of high-level product features:\n\n*   **Single and Multiple Selection Modes:** Supports both single-choice and multi-select scenarios.\n*   **Predefined Options:** Allows selection from a list of provided options.\n*   **Custom Value Input:** Enables users to enter values not present in the predefined options.\n*   **Filtering/Search:** Filters the options list based on user input using fuzzy search.\n*   **Keyboard Navigation:** Supports keyboard navigation for selecting options.\n*   **Visual Indicators:** Displays loading states, selected values, and highlights focused options.\n*   **Customizable Display:** Offers options for placeholders, titles, and custom components within options.\n*   **Value Editing:** Allows editing of selected values, especially in single-select mode with custom values.\n*   **Comma Separation:** Automatically splits and adds values when commas are entered (in multiple mode with custom values enabled).\n*   **Snack-style Value Display:** Displays selected values as removable \"snacks\" or pills."
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonInputSelect",
        "summary": "The LemonInputSelect component is a versatile input field with dropdown suggestions, designed to enhance user experience through flexible selection options. It supports both single and multiple selection modes, allowing users to choose from predefined lists or enter custom values. Features include filtering, keyboard navigation, visual indicators for loading and selection states, and customizable display options. In multi-select mode with custom values enabled, the component automatically splits and adds values when commas are entered, displaying selected values as removable \"snacks\" or pills.\n\n**Features:**\n\n*   Single and Multiple Selection Modes\n*   Predefined Options with Filtering/Search\n*   Custom Value Input\n*   Keyboard Navigation\n*   Visual Indicators (loading, selection)\n*   Customizable Display\n*   Value Editing\n*   Comma Separation for Multiple Values\n*   Snack-style Value Display\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/Lettermark/index.ts",
        "summary": "The code defines and exports a `Lettermark` component and related types/enums for use in a UI library. Specifically, it exports the `Lettermark` component itself, a `LettermarkColor` enum (likely defining available colors for the lettermark), and the `LettermarkProps` type, which likely defines the properties that can be passed to the `Lettermark` component. This allows developers to easily incorporate a stylized letter or initial into their user interfaces with customizable colors.\n\nHere's a list of high-level product features:\n\n*   **Lettermark Component:** A reusable UI component for displaying a stylized letter or initial.\n*   **Color Customization:** Ability to change the color of the lettermark.\n*   **Configurable Properties:** Customizable properties to control the appearance and behavior of the lettermark.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/Lettermark/Lettermark.tsx",
        "summary": "The `Lettermark` component in `Lettermark.tsx` provides a customizable, icon-sized lettermark that can display the initial letter of a given name or a number (up to 99). It supports different sizes, colors (either specified directly or chosen based on an index), and styles (rounded or outlined). The component uses CSS classes for styling and provides a fallback representation (\"?\") when no name is provided.\n\nHere's a list of high-level product features:\n\n*   **Name/Value Representation:** Displays the initial letter of a string or a number (up to 99).\n*   **Color Customization:** Allows specifying a color directly or choosing a color variant based on an index.\n*   **Styling Options:** Supports rounded and outlined styles.\n*   **Size Variations:** Offers different size options (xsmall, small, medium, xlarge).\n*   **Fallback Representation:** Displays a default character (\"?\") when no name is provided.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/Lettermark",
        "summary": "The code defines a `Lettermark` component, a reusable UI element designed to display a stylized letter or number, typically representing the initials of a name or a numeric identifier. The component offers extensive customization options, including color selection (either direct specification or indexed variants), styling choices (rounded or outlined), and size variations. It also includes a fallback mechanism to display a default character when no input is provided, ensuring a consistent user experience.\n\nHere's a list of high-level product features:\n\n*   **Lettermark Component:** A reusable UI component for displaying a stylized letter or number.\n*   **Name/Value Representation:** Displays the initial letter of a string or a number (up to 99).\n*   **Color Customization:** Allows specifying a color directly or choosing a color variant based on an index.\n*   **Styling Options:** Supports rounded and outlined styles.\n*   **Size Variations:** Offers different size options.\n*   **Fallback Representation:** Displays a default character when no name is provided.\n*   **Configurable Properties:** Customizable properties to control the appearance and behavior of the lettermark.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/Spinner/index.ts",
        "summary": "The code exports the Spinner component from the `./Spinner` file, making it available for use in other parts of the application. This provides a visual indicator to the user that a process is ongoing, such as loading data or submitting a form.\n\nHere's a list of high-level product features related to this code:\n\n*   **Loading State Indication:** Provides a visual spinner to indicate when the application is in a loading state.\n*   **Reusable UI Component:** Offers a pre-built, reusable spinner component for consistent loading indicators throughout the application.\n*   **Easy Integration:** Simplifies the process of adding loading indicators to various parts of the application.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/Spinner/Spinner.tsx",
        "summary": "This code defines a `Spinner` component and a `SpinnerOverlay` component for use in a React application. The `Spinner` component is a smoothly animated loading indicator, while the `SpinnerOverlay` component is a wrapper that can display either the `Spinner` or an edit icon, along with an overlay. The `Spinner` component allows customization of color and animation speed, while the `SpinnerOverlay` allows customization of visibility, display mode (spinning or editing), and stacking level.\n\nHere's a list of high-level product features:\n\n*   **Animated Loading Indicator:** Displays a smooth animation to indicate that a process is ongoing.\n*   **Customizable Spinner:** Allows setting the color and animation speed of the spinner.\n*   **Overlay with Spinner or Edit Icon:** Provides a wrapper component that can display either a spinner or an edit icon.\n*   **Visibility Control:** Allows toggling the visibility of the spinner overlay.\n*   **Scene Level Stacking:** Provides an option to adjust the stacking level of the overlay.\n*   **Tailwind CSS Integration:** Uses Tailwind CSS for styling and customization.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/Spinner",
        "summary": "The provided code defines a reusable `Spinner` component and a `SpinnerOverlay` component, both designed to enhance user experience by providing clear visual feedback during loading or editing states. The `Spinner` offers customizable color and animation speed, while the `SpinnerOverlay` can display either the `Spinner` or an edit icon, with adjustable visibility and stacking level, all styled with Tailwind CSS for easy integration and customization.\n\nHere's a list of high-level product features:\n\n*   **Animated Loading Indicator:** Displays a smooth animation to indicate that a process is ongoing.\n*   **Customizable Spinner:** Allows setting the color and animation speed of the spinner.\n*   **Overlay with Spinner or Edit Icon:** Provides a wrapper component that can display either a spinner or an edit icon.\n*   **Visibility Control:** Allows toggling the visibility of the spinner overlay.\n*   **Scene Level Stacking:** Provides an option to adjust the stacking level of the overlay.\n*   **Tailwind CSS Integration:** Uses Tailwind CSS for styling and customization.\n*   **Loading State Indication:** Provides a visual spinner to indicate when the application is in a loading state.\n*   **Reusable UI Component:** Offers a pre-built, reusable spinner component for consistent loading indicators throughout the application.\n*   **Easy Integration:** Simplifies the process of adding loading indicators to various parts of the application.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonDivider/index.ts",
        "summary": "The code defines and exports a LemonDivider component and its associated props type. This allows developers to easily import and use the LemonDivider component in their projects, providing a visual separation between different sections of the user interface.\n\nHere's a list of high-level product features:\n\n*   **LemonDivider Component:** A UI component for visually separating content.\n*   **Props Definition:** Defines customizable properties for the LemonDivider component.\n*   **Export for Reusability:** Exports the component and its props for easy integration into other parts of the application.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonDivider/LemonDivider.tsx",
        "summary": "The `LemonDivider` component is a customizable line separator for React applications, offering horizontal or vertical orientation, adjustable thickness, and the option for a dashed line style. It provides default margins but allows for complete styling control through custom class names.  It can also display a label within the divider.\n\nHere's a list of high-level features:\n\n*   **Horizontal/Vertical Orientation:**  The divider can be displayed horizontally or vertically.\n*   **Adjustable Thickness:** The divider's thickness can be increased.\n*   **Dashed Line Style:** The divider can be rendered as a dashed line.\n*   **Customizable Styling:**  Users can override default styles with custom class names.\n*   **Label Support:**  The divider can display a label within the line.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonDivider",
        "summary": "The LemonDivider component provides a flexible way to visually separate content within a user interface. It offers customizable orientation (horizontal or vertical), adjustable thickness, and the option for a dashed line style. Users can further tailor the appearance with custom class names and display a label within the divider. The component and its associated properties are exported for easy reuse throughout the application.\n\nHere's a list of high-level product features:\n\n*   Horizontal/Vertical Orientation\n*   Adjustable Thickness\n*   Dashed Line Style\n*   Customizable Styling\n*   Label Support\n*   LemonDivider Component\n*   Props Definition\n*   Export for Reusability\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonRadio/index.ts",
        "summary": "The code exports the `LemonRadio` component, making it available for use in other parts of the application. This suggests the existence of a radio button component within the Lemon UI library.\n\nHere's a list of high-level product features:\n\n*   **Radio Button Component:** Provides a standard radio button input element for user selection.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonRadio/LemonRadio.tsx",
        "summary": "The `LemonRadio` component provides a customizable radio button group for single selection. It supports vertical and horizontal orientations, optional descriptions and disabled states for individual radio options, and tooltips to explain why an option is disabled. The component leverages `clsx` for dynamic class name generation and includes styling for different radio positions (center or top alignment).\n\nHere's a list of high-level product features:\n\n*   **Single Selection Radio Group:** Allows users to select one option from a list of choices.\n*   **Customizable Orientation:** Supports both vertical and horizontal layouts for the radio options.\n*   **Descriptive Labels:** Each radio option can have a label and an optional description for clarity.\n*   **Disabled States with Tooltips:** Individual radio options can be disabled, with a tooltip explaining the reason for the disabled state.\n*   **Flexible Radio Position:** Allows control over the vertical alignment of the radio button relative to its label (center or top).\n*   **Dynamic Styling:** Uses `clsx` for dynamic class name generation, enabling flexible styling and customization.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonRadio",
        "summary": "The LemonRadio component offers a customizable radio button group, enabling users to select a single option from a list. It provides flexibility in layout with vertical and horizontal orientations, supports descriptive labels and optional descriptions for each option, and allows individual options to be disabled with informative tooltips. The component also offers control over the radio button's vertical alignment and utilizes dynamic styling for enhanced customization.\n\nHere's a list of high-level product features:\n\n*   Single Selection Radio Group\n*   Customizable Orientation (Vertical/Horizontal)\n*   Descriptive Labels\n*   Disabled States with Tooltips\n*   Flexible Radio Position (Center/Top Alignment)\n*   Dynamic Styling\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSelect/index.ts",
        "summary": "The code exports the LemonSelect component, making it available for use in other parts of the application. This suggests the existence of a custom select component within the Lemon UI library.\n\n**Features:**\n\n*   Provides a custom select component (`LemonSelect`).\n*   Part of the Lemon UI library.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSelect/LemonSelect.tsx",
        "summary": "The `LemonSelect` component is a versatile React component that provides a customizable dropdown select menu. It leverages the `LemonMenu` and `LemonButton` components to create a user-friendly interface for selecting options. The component supports various configurations, including clearable selections, custom rendering of button content, and structured options with sections and nested nodes. It handles the selection logic, active state management, and rendering of options, providing a flexible and reusable select component for various applications.\n\nHere's a list of high-level product features:\n\n*   **Dropdown Select Menu:** Provides a standard dropdown select menu interface.\n*   **Clearable Selections:** Allows users to clear their selection if `allowClear` is enabled.\n*   **Customizable Button Content:** Enables developers to customize the content displayed within the select button.\n*   **Structured Options:** Supports options organized into sections and nested nodes for better organization.\n*   **Customizable Menu Items:** Supports custom menu items with custom controls.\n*   **Active State Management:** Manages the active state of selected options within the menu.\n*   **Placeholder Text:** Displays placeholder text when no option is selected.\n*   **Loading State:** Supports a loading state to indicate asynchronous operations.\n*   **Disabled State:** Supports a disabled state to prevent user interaction.\n*   **Tooltip Support:** Provides tooltip support for options.\n*   **Flexible Placement:** Allows customization of the dropdown placement.\n*   **Full Width Option:** Allows the select to take up the full width of its container.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSelect",
        "summary": "The `LemonSelect` component is a highly customizable dropdown select menu built using React and leveraging other Lemon UI components like `LemonMenu` and `LemonButton`. It offers a user-friendly interface with features such as clearable selections, customizable button content, structured options with sections and nested nodes, active state management, placeholder text, loading and disabled states, tooltip support, flexible placement, and a full-width option. The component is part of the Lemon UI library, providing a reusable and flexible select component for various applications.\n\nHere's a list of high-level product features:\n\n*   Dropdown Select Menu: Provides a standard dropdown select menu interface.\n*   Clearable Selections: Allows users to clear their selection if `allowClear` is enabled.\n*   Customizable Button Content: Enables developers to customize the content displayed within the select button.\n*   Structured Options: Supports options organized into sections and nested nodes for better organization.\n*   Customizable Menu Items: Supports custom menu items with custom controls.\n*   Active State Management: Manages the active state of selected options within the menu.\n*   Placeholder Text: Displays placeholder text when no option is selected.\n*   Loading State: Supports a loading state to indicate asynchronous operations.\n*   Disabled State: Supports a disabled state to prevent user interaction.\n*   Tooltip Support: Provides tooltip support for options.\n*   Flexible Placement: Allows customization of the dropdown placement.\n*   Full Width Option: Allows the select to take up the full width of its container.\n*   Part of Lemon UI Library:  Integrates as a component within the Lemon UI library.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonModal/index.ts",
        "summary": "The code exports the `LemonModal` component and its associated props type `LemonModalProps` from the `./LemonModal` file. This suggests the existence of a modal component within the Lemon UI library.\n\n**Features:**\n\n*   **LemonModal Component:** A reusable modal component for displaying content in a popup window.\n*   **LemonModalProps:** Defines the properties and configuration options available for the `LemonModal` component, allowing customization of its appearance and behavior.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonModal/LemonModal.tsx",
        "summary": "The `LemonModal` component provides a flexible and customizable modal dialog for React applications. It supports various features such as controlling the modal's size, appearance, and behavior, including handling unsaved input, full-screen mode, and custom styling. The modal can be rendered inline or as a traditional overlay, and it includes built-in header, content, and footer components for structuring the modal's content.\n\nHere's a list of high-level product features:\n\n*   **Modal Display:** Opens and closes a modal window with customizable open/close behavior.\n*   **Customizable Size:** Sets the width and maximum width of the modal.\n*   **Theming and Styling:** Supports inline styling, full-screen mode, and custom CSS classes.\n*   **Header, Content, and Footer Sections:** Provides dedicated components for structuring the modal's content.\n*   **Close Control:** Manages closing behavior, including handling unsaved input and disabling overlay clicks.\n*   **Keyboard Shortcuts:** Supports closing the modal with the Escape key.\n*   **Accessibility:** Includes aria-labels and other accessibility features.\n*   **Z-Index Control:** Allows fine-grained control over the modal's stacking order.\n*   **Tooltip on Close:** Displays a tooltip when the user attempts to close the modal with unsaved input.\n*   **Embedded Mode:** Renders the modal content without the standard modal overlay.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonModal",
        "summary": "The LemonModal component offers a versatile modal dialog solution for React applications, providing extensive customization options for appearance, behavior, and content structure. It includes features for managing size, theming, and close behavior, along with dedicated components for header, content, and footer sections. The modal also supports accessibility, keyboard shortcuts, and control over stacking order, ensuring a user-friendly and flexible modal experience.\n\nHere's a list of high-level product features:\n\n*   Modal Display: Opens and closes a modal window with customizable open/close behavior.\n*   Customizable Size: Sets the width and maximum width of the modal.\n*   Theming and Styling: Supports inline styling, full-screen mode, and custom CSS classes.\n*   Header, Content, and Footer Sections: Provides dedicated components for structuring the modal's content.\n*   Close Control: Manages closing behavior, including handling unsaved input and disabling overlay clicks.\n*   Keyboard Shortcuts: Supports closing the modal with the Escape key.\n*   Accessibility: Includes aria-labels and other accessibility features.\n*   Z-Index Control: Allows fine-grained control over the modal's stacking order.\n*   Tooltip on Close: Displays a tooltip when the user attempts to close the modal with unsaved input.\n*   Embedded Mode: Renders the modal content without the standard modal overlay.\n*   LemonModal Component: A reusable modal component for displaying content in a popup window.\n*   LemonModalProps: Defines the properties and configuration options available for the `LemonModal` component, allowing customization of its appearance and behavior.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/Popover/index.ts",
        "summary": "The code exports the `Popover` component from the `./Popover` file, making it available for use in other parts of the application. This suggests the existence of a Popover component within the Lemon UI library.\n\n**Features:**\n\n*   **Popover Component:** Provides a UI element for displaying content in a popup that is anchored to a specific element on the page.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/Popover/Popover.tsx",
        "summary": "The `Popover` component in `lemon-ui` provides a flexible way to display floating overlays, such as menus or tooltips, relative to a trigger element. It leverages the `floating-ui` library for precise positioning and handles various interactions like clicking outside to close, managing nested popovers, and automatically updating its position when the trigger element moves. The component supports features like arrow indicators, loading bars, width matching, and customizable styling, making it a versatile solution for creating interactive user interfaces.\n\nHere's a list of high-level features:\n\n*   **Positioning:** Dynamically positions the popover relative to a reference element using `floating-ui`, with configurable placement and fallback strategies.\n*   **Visibility Control:** Manages the popover's visibility state, including smooth transitions using `react-transition-group`.\n*   **Click Outside Handling:** Closes the popover when clicking outside of it, with support for nested popovers and exceptions for specific elements.\n*   **Nested Popover Management:** Handles interactions between nested popovers, preventing unintended closures.\n*   **Automatic Updates:** Automatically updates the popover's position when the reference element changes.\n*   **Customizable Styling:** Offers various styling options, including padding, width matching, maximum content width, and custom CSS classes.\n*   **Arrow Indicator:** Displays an arrow pointing to the reference element.\n*   **Loading Bar:** Shows a loading bar at the top of the popover.\n*   **Scrollable Content:** Provides a scrollable area for the popover's content with optional shadows.\n*   **Accessibility:** Includes accessibility features like keyboard navigation (Escape key to close) and ARIA attributes.\n*   **Delay:** Adds a delay before the floating overlay is shown."
    },
    {
        "path": "frontend/src/lib/lemon-ui/Popover",
        "summary": "The `Popover` component in the `lemon-ui` library offers a versatile solution for displaying floating overlays, such as menus or tooltips, relative to a trigger element. It uses `floating-ui` for precise positioning and handles interactions like closing on outside clicks, managing nested popovers, and automatically updating its position. The component supports features like arrow indicators, loading bars, width matching, customizable styling, scrollable content, and accessibility features, making it a comprehensive tool for creating interactive user interfaces. The component is exported to be used in other parts of the application.\n\nHere's a list of high-level product features:\n\n*   **Dynamic Positioning:** Precisely positions the popover relative to a reference element.\n*   **Visibility Management:** Controls the popover's visibility with smooth transitions.\n*   **Click Outside to Close:** Closes the popover when clicking outside, handling nested popovers.\n*   **Nested Popover Support:** Manages interactions between nested popovers.\n*   **Automatic Updates:** Updates the popover's position when the reference element changes.\n*   **Customizable Styling:** Offers various styling options for appearance.\n*   **Arrow Indicator:** Displays an arrow pointing to the reference element.\n*   **Loading Bar:** Shows a loading bar at the top of the popover.\n*   **Scrollable Content:** Provides a scrollable area for the popover's content.\n*   **Accessibility Features:** Includes keyboard navigation and ARIA attributes.\n*   **Delay:** Adds a delay before the floating overlay is shown.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonRow/index.ts",
        "summary": "The code defines and exports a React component called `LemonRow` along with its associated type definitions (`LemonRowProps` and `LemonRowPropsBase`). This component likely serves as a layout element, providing a row-based structure for arranging other UI elements within a Lemon UI framework.\n\n**Features:**\n\n*   **LemonRow Component:** A React component for creating row layouts.\n*   **Props Definition:** Defines the properties (`LemonRowProps`, `LemonRowPropsBase`) that can be passed to the `LemonRow` component for customization.\n*   **Layout Management:** Facilitates the arrangement of UI elements in a horizontal row.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonRow/LemonRow.tsx",
        "summary": "The `LemonRow` component is a versatile UI element designed to display content in a structured row format. It supports various customizations, including different sizes, status indicators, icons, and extended content areas. It can be rendered as different HTML tags and styled with different states such as loading, disabled, and outlined. The component also supports tooltips for providing additional information on hover.\n\nHere's a list of high-level product features:\n\n*   **Content Display:** Displays content in a row format.\n*   **HTML Tag Rendering:** Renders as different HTML tags (e.g., div, button).\n*   **Status Indicators:** Supports different status indicators (default, success, warning, danger, highlighted, muted).\n*   **Icon Support:** Displays an icon alongside the main content.\n*   **Extended Content:** Displays additional content below the main content.\n*   **Loading State:** Shows a loading spinner when in a loading state.\n*   **Tooltip Support:** Displays a tooltip on hover.\n*   **Size Variations:** Offers different size variations (small, medium, tall, large).\n*   **Full Width Option:** Allows the row to take up the full width of its parent.\n*   **Content Centering:** Centers the content within the row.\n*   **Outlined Style:** Adds an outline to the row.\n*   **Disabled State:** Disables the row, preventing interaction.\n*   **Side Icon Support:** Displays an icon on the side of the main content."
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonRow",
        "summary": "The `LemonRow` component is a flexible UI element that structures content in a row format, offering extensive customization options. It supports various HTML tag renderings, status indicators, icons, extended content areas, loading states, tooltips, and size variations. The component can also be styled with outlined or disabled states, and provides options for full-width display and content centering, making it a versatile layout tool for arranging UI elements horizontally within the Lemon UI framework.\n\n*   Content Display in a Row Format\n*   HTML Tag Rendering (div, button, etc.)\n*   Status Indicators (default, success, warning, danger, highlighted, muted)\n*   Icon Support (leading and side icons)\n*   Extended Content Area\n*   Loading State with Spinner\n*   Tooltip Support\n*   Size Variations (small, medium, tall, large)\n*   Full Width Option\n*   Content Centering\n*   Outlined Style\n*   Disabled State\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonDropdown/index.ts",
        "summary": "The code defines and exports a `LemonDropdown` component and its associated props type `LemonDropdownProps`. This suggests the existence of a dropdown component within the Lemon UI library.\n\n**Features:**\n\n*   **LemonDropdown Component:** A reusable dropdown component for selecting options from a list.\n*   **LemonDropdownProps:** A defined set of properties to configure and customize the behavior and appearance of the `LemonDropdown` component.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonDropdown/LemonDropdown.tsx",
        "summary": "The `LemonDropdown` component provides a flexible dropdown menu functionality built on top of the `Popover` component. It allows users to trigger the dropdown via click or hover and offers control over its visibility through props. The component handles click and mouse events, including closing the dropdown on outside clicks or based on the `closeOnClickInside` prop. It also manages event propagation to prevent parent popovers from closing when a dropdown item is clicked within them.\n\nHere's a list of high-level features:\n\n*   **Click or Hover Trigger:** Dropdown can be triggered by either a click or hover event.\n*   **Controlled Visibility:** Supports both controlled and uncontrolled visibility states.\n*   **Outside Click Handling:** Closes the dropdown when clicking outside the dropdown area.\n*   **Inside Click Handling:** Option to close the dropdown when clicking inside the dropdown content.\n*   **Event Propagation Control:** Prevents parent popovers from closing when clicking on dropdown items within them.\n*   **Customizable Content:** Accepts any React element as a child, allowing for flexible dropdown content.\n*   **Popover Integration:** Built on top of the `Popover` component, inheriting its styling and positioning capabilities.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonDropdown",
        "summary": "The LemonDropdown component is a versatile UI element that provides dropdown menu functionality, built upon the Popover component, with customizable triggers (click or hover) and controlled visibility. It intelligently handles click events both inside and outside the dropdown area, offering options to close the dropdown accordingly. Furthermore, it manages event propagation to prevent unintended closure of parent popovers when interacting with dropdown items.\n\n**Features:**\n\n*   Click or Hover Trigger\n*   Controlled Visibility\n*   Outside Click Handling\n*   Inside Click Handling\n*   Event Propagation Control\n*   Customizable Content\n*   Popover Integration\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/UploadedLogo/index.ts",
        "summary": "The code exports the `UploadedLogo` component from the `UploadedLogo.ts` file within the same directory. This suggests the existence of a UI component responsible for displaying an uploaded logo.\n\nHere's a list of high-level product features related to this component:\n\n*   **Logo Display:** Renders a logo that has been uploaded or otherwise provided.\n*   **Customizable Styling:** Allows for customization of the logo's appearance (size, shape, etc.).\n*   **Image Source Handling:** Manages the source of the logo image (e.g., URL, file path).\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/UploadedLogo/UploadedLogo.tsx",
        "summary": "The `UploadedLogo` component is a React component that displays a logo. It can display a logo from a media ID, or a lettermark if no media ID is provided. The lettermark is generated based on the entity ID and the name. The component also supports different sizes and an outlined lettermark variant. It uses a skeleton loader while the image is loading.\n\nHere's a list of high-level product features:\n\n*   **Logo Display:** Displays a logo based on a media ID.\n*   **Lettermark Generation:** Generates a lettermark logo based on the entity ID and name when no media ID is available.\n*   **Entity ID Handling:** Accepts either a number or a UUID string as an entity ID, extracting a numerical ID from the UUID.\n*   **Size Customization:** Supports different logo sizes (xsmall, small, medium, xlarge).\n*   **Outlined Lettermark:** Provides an option to display an outlined lettermark.\n*   **Loading State:** Displays a skeleton loader while the image is loading.\n*   **Error Handling:** Handles image loading errors.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/UploadedLogo",
        "summary": "The `UploadedLogo` component is a versatile React component designed to display logos in various ways. It can render a logo from a provided media ID, or dynamically generate a lettermark based on the entity ID and name when a media ID is not available. The component supports different sizes and an outlined lettermark variant, enhancing customization options. To provide a smooth user experience, it incorporates a skeleton loader during image loading and handles potential image loading errors gracefully.\n\nHere's a list of high-level product features:\n\n*   **Logo Display:** Renders a logo from a media ID.\n*   **Lettermark Generation:** Generates a lettermark logo based on entity ID and name when no media ID is available.\n*   **Entity ID Handling:** Accepts numerical or UUID string entity IDs.\n*   **Size Customization:** Supports different logo sizes (xsmall, small, medium, xlarge).\n*   **Outlined Lettermark:** Provides an option to display an outlined lettermark.\n*   **Loading State:** Displays a skeleton loader while the image is loading.\n*   **Error Handling:** Handles image loading errors.\n*   **Customizable Styling:** Allows for customization of the logo's appearance.\n*   **Image Source Handling:** Manages the source of the logo image (e.g., URL, file path).\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTabs/index.ts",
        "summary": "The code exports the `LemonTabs` component, making it available for use in other parts of the application. This suggests the existence of a tab component within the Lemon UI library.\n\nHere's a list of high-level product features:\n\n*   **Tabbed Interface:** Provides a way to organize content into separate views accessible through tabs.\n*   **Lemon UI Integration:** Seamlessly integrates with the Lemon UI library, ensuring a consistent look and feel.\n*   **Component Reusability:** The `LemonTabs` component can be easily reused throughout the application.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTabs/LemonTabs.tsx",
        "summary": "The `LemonTabs` component provides a flexible tabbed interface for displaying content. It supports both abstract tabs (where the content is rendered externally) and concrete tabs (where the component renders the content). The component handles tab selection, styling, and optional linking of tabs. It also includes features like tooltips for tab labels and a sliding indicator to highlight the active tab.\n\nHere's a list of high-level product features:\n\n*   **Tabbed Interface:** Provides a UI for organizing and navigating between different sections of content.\n*   **Abstract and Concrete Tabs:** Supports tabs with externally rendered content and tabs with content rendered by the component.\n*   **Active Tab Highlighting:** Visually indicates the currently selected tab.\n*   **Tab Linking:** Allows tabs to be associated with URLs for navigation.\n*   **Tooltip Support:** Displays tooltips on tab labels for additional information.\n*   **Customizable Styling:** Offers options for adjusting the size and appearance of the tabs.\n*   **Keyboard Navigation:** Supports keyboard navigation for accessibility.\n*   **Sliding Indicator:** A visual cue that slides to the active tab."
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTabs",
        "summary": "The `LemonTabs` component offers a versatile tabbed interface for organizing and navigating content, supporting both abstract and concrete tab implementations. It enhances user experience with features like active tab highlighting, optional tab linking, tooltips, customizable styling, keyboard navigation, and a sliding indicator. The component is designed for reusability and seamless integration within the Lemon UI library.\n\nHere's a list of high-level product features:\n\n*   Tabbed Interface: Organizes content into separate views accessible through tabs.\n*   Abstract and Concrete Tabs: Supports tabs with externally rendered content and tabs with content rendered by the component.\n*   Active Tab Highlighting: Visually indicates the currently selected tab.\n*   Tab Linking: Allows tabs to be associated with URLs for navigation.\n*   Tooltip Support: Displays tooltips on tab labels for additional information.\n*   Customizable Styling: Offers options for adjusting the size and appearance of the tabs.\n*   Keyboard Navigation: Supports keyboard navigation for accessibility.\n*   Sliding Indicator: A visual cue that slides to the active tab.\n*   Lemon UI Integration: Seamlessly integrates with the Lemon UI library, ensuring a consistent look and feel.\n*   Component Reusability: The `LemonTabs` component can be easily reused throughout the application.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/Link/index.ts",
        "summary": "This code defines and exports a `Link` component and its associated properties type `LinkProps` from the same file (`./Link`). This allows other parts of the application to easily import and use the `Link` component for creating hyperlinks within the user interface.\n\nHere's a list of high-level product features related to this code:\n\n*   **Hyperlink Creation:** Enables the creation of clickable hyperlinks within the application.\n*   **Customizable Link Properties:** Provides a way to customize the appearance and behavior of links through the `LinkProps` type.\n*   **Reusable Link Component:** Offers a reusable `Link` component for consistent hyperlink implementation across the application.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/Link/Link.tsx",
        "summary": "The `Link` component in `frontend/src/lib/lemon-ui/Link/Link.tsx` is a wrapper around the HTML `<a>` element, providing enhanced functionality for internal and external navigation within the PostHog application. It handles routing using `kea-router` for internal links, standard `href` navigation for external links, and special handling for PostHog documentation links, which can be opened in a side panel. The component also manages `target=\"_blank\"` attributes, adding appropriate `rel` attributes for security and optionally displaying an icon to indicate the link opens in a new tab or the side panel. It supports disabled states with tooltips explaining the reason for being disabled.\n\nHere's a list of high-level product features provided by the `Link` component:\n\n*   **Internal Routing:** Uses `kea-router` for client-side navigation within the application, providing a smoother user experience.\n*   **External Link Handling:** Supports standard `href` navigation for external links, including adding `rel=\"noopener noreferrer\"` for security.\n*   **Documentation Side Panel Integration:** Opens PostHog documentation links in a dedicated side panel, improving discoverability and context.\n*   **Target Blank Icon:** Displays an icon to indicate when a link opens in a new tab or the side panel.\n*   **Disabled State with Tooltip:** Visually disables links and provides a tooltip explaining why they are disabled.\n*   **Drag and Drop to Notebook:** Enables dragging links to a notebook feature.\n*   **Side Panel Awareness:** Adjusts link behavior based on whether it's rendered within a side panel.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/Link",
        "summary": "The `Link` component enhances navigation within the PostHog application by providing a consistent and feature-rich way to create hyperlinks. It intelligently handles internal routing using `kea-router`, external links with security considerations, and special integration for PostHog documentation, which can be opened in a side panel. The component also provides visual cues like icons for new tabs and disabled states with informative tooltips, improving the user experience and accessibility.\n\nHere's a list of high-level product features:\n\n*   Internal Routing: Enables smooth client-side navigation within the application.\n*   External Link Handling: Supports secure navigation to external websites.\n*   Documentation Side Panel Integration: Provides easy access to PostHog documentation within the application.\n*   Target Blank Icon: Visually indicates when a link opens in a new tab or side panel.\n*   Disabled State with Tooltip: Communicates why a link is disabled.\n*   Hyperlink Creation: Enables the creation of clickable hyperlinks within the application.\n*   Customizable Link Properties: Provides a way to customize the appearance and behavior of links.\n*   Reusable Link Component: Offers a reusable `Link` component for consistent hyperlink implementation.\n*   Drag and Drop to Notebook: Enables dragging links to a notebook feature.\n*   Side Panel Awareness: Adjusts link behavior based on whether it's rendered within a side panel.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTree/LemonTreeUtils.tsx",
        "summary": "This code defines utility functions and components for a LemonTree component, which appears to be a tree-like UI element with drag-and-drop functionality. It provides functions for determining the appropriate icon to display for each node (folder, file, or custom icon), and components for making tree nodes draggable and droppable using the `@dnd-kit/core` library. The code handles visual cues for drag and drop operations, such as highlighting droppable areas and changing the appearance of dragged items.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dynamic Icon Display:** Automatically displays appropriate icons for folders (open/closed state), files, or custom icons based on node type and state.\n*   **Drag and Drop Functionality:** Enables users to drag and drop tree nodes to reorder or move them within the tree structure.\n*   **Visual Feedback for Drag and Drop:** Provides visual cues during drag and drop operations, such as highlighting droppable areas and changing the opacity of dragged items.\n*   **Keyboard Navigation Support:** Excludes \"Enter\" key from drag listeners to prevent conflicts with other keyboard interactions.\n*   **Customizable Node Appearance:** Allows for custom styling and icons for individual tree nodes.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTree/LemonTree.tsx",
        "summary": "The `LemonTree.tsx` file defines a customizable tree component called `LemonTree` built using React and the `@dnd-kit/core` library for drag-and-drop functionality and Radix UI's Accordion primitive for expandable nodes. The component supports rendering hierarchical data with features like custom icons, side actions, context menus, and drag-and-drop functionality. It allows for item selection, focus, and expansion, with handlers for click events and drag-and-drop completion. The component also provides visual cues for active, loading, and unapplied states.\n\nHere's a list of high-level product features:\n\n*   **Hierarchical Data Display:** Renders tree-like structures from nested data.\n*   **Customizable Appearance:** Supports custom icons, display names, and rendering of individual items.\n*   **Interactive Elements:** Includes clickable nodes, expandable folders, side actions, and context menus.\n*   **Drag and Drop Support:** Enables reordering of tree items via drag and drop.\n*   **Selection and Focus Management:** Manages selected and focused items with visual highlighting.\n*   **Expand/Collapse Functionality:** Allows expanding and collapsing of folder nodes.\n*   **Loading and Status Indicators:** Displays loading spinners and unapplied icons for individual items.\n*   **Accessibility:** Uses ARIA attributes for accessibility.\n*   **Customizable Behavior:** Exposes handlers for click events, drag-and-drop completion, and context menu interactions.\n*   **Item Disabling:** Supports disabling individual items with a reason displayed.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTree",
        "summary": "The LemonTree component provides a flexible and interactive way to display hierarchical data in a tree-like structure. It offers a range of features including customizable icons and display names, interactive elements like clickable nodes and context menus, and drag-and-drop functionality for reordering items. The component also manages item selection, focus, and expansion states, providing visual cues for loading and unapplied states, and supports accessibility through ARIA attributes.\n\nHere's a list of high-level product features:\n\n*   Hierarchical Data Display\n*   Customizable Appearance (icons, display names, styling)\n*   Interactive Elements (clickable nodes, expandable folders, side actions, context menus)\n*   Drag and Drop Support\n*   Selection and Focus Management\n*   Expand/Collapse Functionality\n*   Loading and Status Indicators\n*   Accessibility\n*   Customizable Behavior (event handlers)\n*   Item Disabling\n*   Dynamic Icon Display\n*   Visual Feedback for Drag and Drop\n*   Keyboard Navigation Support\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonBadge/index.ts",
        "summary": "The code defines and exports a `LemonBadge` component and its associated props type `LemonBadgeProps` from the `./LemonBadge` file. This allows other parts of the application to easily import and use the `LemonBadge` component.\n\nHere's a list of high-level product features:\n\n*   **Badge Display:** Provides a visual badge component to highlight information.\n*   **Customizable Properties:** Offers customizable properties through `LemonBadgeProps` to control the badge's appearance and behavior.\n*   **Component Reusability:** Exports the component for easy integration and reuse throughout the application.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonBadge/LemonBadge.tsx",
        "summary": "The `LemonBadge` component provides a way to display small badges, either as simple status indicators or to show a count. It supports different sizes, positions, statuses, and can be conditionally rendered with a CSS transition. The `LemonBadge.Number` sub-component specifically handles displaying numerical counts, with options to truncate large numbers and display a plus sign to indicate more values are available.\n\nHere's a list of high-level product features:\n\n*   **Status Indicators:** Display badges with different status colors (primary, success, warning, danger, muted, data).\n*   **Positioning:** Control the badge's position relative to its parent element (top-left, top-right, bottom-left, bottom-right).\n*   **Sizing:** Offer different badge sizes (small, medium, large).\n*   **Conditional Visibility:** Show or hide the badge based on a boolean value, with a CSS transition for smooth appearance/disappearance.\n*   **Number Display:** Display numerical counts, with options to truncate large numbers (e.g., 9+) and show a plus sign to indicate more values are available.\n*   **Zero Handling:** Option to display the badge even when the count is zero.\n*   **Customizable Content:** Display custom text or JSX elements within the badge.\n*   **Accessibility:** Provides a `title` attribute for numerical badges, displaying the full number for screen readers.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonBadge",
        "summary": "The `LemonBadge` component offers a versatile way to display status indicators and numerical counts within an application. It provides customizable options for size, position, and status, along with conditional visibility using CSS transitions. The component also includes a specialized sub-component for displaying numerical counts, with features like truncation and a plus sign indicator for large numbers. The component is designed for easy integration and reuse throughout the application.\n\nHere's a list of high-level product features:\n\n*   Status Indicators with customizable colors (primary, success, warning, danger, muted, data).\n*   Flexible Positioning (top-left, top-right, bottom-left, bottom-right).\n*   Adjustable Sizing (small, medium, large).\n*   Conditional Visibility with smooth CSS transitions.\n*   Numerical Count Display with truncation and overflow indication.\n*   Zero Value Handling (option to display badge for zero counts).\n*   Customizable Content (text or JSX elements).\n*   Accessibility support for numerical badges (title attribute for screen readers).\n*   Easy integration and reuse throughout the application.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LoadingBar/index.ts",
        "summary": "The code exports the `LoadingBar` component from the `./LoadingBar` file, making it available for use in other parts of the application. This suggests the existence of a visual loading indicator component.\n\n**Features:**\n\n*   Provides a visual loading bar component.\n*   Offers a user-friendly way to indicate background processes or loading states.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LoadingBar/LoadingBar.tsx",
        "summary": "The `LoadingBar` component provides a visual indicator of a loading process. It features a smoothly animated progress bar that automatically increments, simulating progress even if the actual progress is unknown. The component accepts a `loadId` to manage and reset the progress, and a `setProgress` function to allow external control over the progress value. The progress bar's animation slows down as it approaches completion, providing a more realistic loading experience.\n\nHere's a list of high-level product features:\n\n*   **Visual Loading Indicator:** Displays a progress bar to indicate an ongoing loading process.\n*   **Automatic Progress Animation:** Animates the progress bar automatically, even without explicit progress updates.\n*   **Load ID Management:** Uses a unique `loadId` to manage and reset the progress bar when a new loading task begins.\n*   **External Progress Control:** Allows external components to set and control the progress of the loading bar via a `setProgress` function.\n*   **Slowdown Animation:** Decreases the animation speed as the progress bar nears completion for a more realistic feel.\n*   **Customizable Styling:** Supports custom CSS classes for flexible styling and integration into different UI themes.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LoadingBar",
        "summary": "The `LoadingBar` component offers a visually appealing and customizable way to indicate loading processes within an application. It features automatic progress animation, external progress control, and a slowdown effect as it nears completion, providing a realistic loading experience. The component is managed via a unique `loadId` and can be easily integrated into different UI themes through customizable styling.\n\nHere's a list of high-level product features:\n\n*   Visual Loading Indicator: Displays a progress bar to indicate an ongoing loading process.\n*   Automatic Progress Animation: Animates the progress bar automatically, even without explicit progress updates.\n*   Load ID Management: Uses a unique `loadId` to manage and reset the progress bar when a new loading task begins.\n*   External Progress Control: Allows external components to set and control the progress of the loading bar via a `setProgress` function.\n*   Slowdown Animation: Decreases the animation speed as the progress bar nears completion for a more realistic feel.\n*   Customizable Styling: Supports custom CSS classes for flexible styling and integration into different UI themes.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/icons/index.ts",
        "summary": "The code exports all members from the `./icons` module, effectively making all icons defined in that module available for use elsewhere in the application. This serves as a central point for importing and utilizing a collection of icons within the Lemon UI component library.\n\n**Features:**\n\n*   **Icon Library:** Provides a centralized collection of icons for use in the Lemon UI component library.\n*   **Icon Export:** Exports all icons from a dedicated module, simplifying icon imports throughout the application.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/icons/categories.ts",
        "summary": "This code defines a comprehensive set of icons categorized for use within the Lemon UI library. The icons are organized into logical groups such as Objects, Technology, Elements, and Teams & Companies, with further sub-categorization within each.  A list of unused icons is also provided. This structure allows developers to easily find and utilize relevant icons within the UI.\n\nHere's a list of high-level product features based on the icon categories:\n\n*   **Rich Icon Library:** A comprehensive collection of icons covering various categories.\n*   **Categorized Icons:** Icons organized into logical groups for easy discovery and use.\n*   **Objects Icons:** Icons representing common objects and concepts.\n*   **Technology Icons:** Icons related to technology, hardware, and software.\n*   **Elements Icons:** Icons for UI elements, actions, symbols, and shapes.\n*   **Teams & Companies Icons:** Icons relevant to business, analytics, and team collaboration.\n*   **Unused Icon List:** A list of icons that are currently not in use.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/icons/icons.tsx",
        "summary": "This code defines a set of React components for rendering icons, including the base `LemonIconBase` component and specialized icons like `IconTextSize`, `IconBranch`, `IconClipboardEdit`, `IconJavascript`, `IconNodeJS`, `IconPHP`, and `IconRuby`. It also provides components for adding badges and counts to icons, namely `IconWithBadge` and `IconWithCount`, which enhance the visual representation of icons with status indicators or numerical values. The icons are styled using a custom `icons.scss` file and leverage the `clsx` library for conditional class name application.\n\nHere's a list of high-level product features:\n\n*   **Base Icon Component:** Provides a foundation for creating custom icons with consistent styling and attributes.\n*   **Pre-built Icons:** Offers a collection of ready-to-use icons for common programming languages and actions.\n*   **Icon Badges:** Enables the addition of status indicators or labels to icons for conveying contextual information.\n*   **Icon Counts:** Allows displaying numerical values alongside icons to represent quantities or metrics.\n*   **Customizable Styling:** Supports customization of icon color, font size, and other CSS properties.\n*   **Badge Customization:** Supports customization of badge status and content.\n*   **Number Customization:** Supports customization of number status and visibility of zero values."
    },
    {
        "path": "frontend/src/lib/lemon-ui/icons",
        "summary": "The Lemon UI library provides a comprehensive and categorized set of icons for developers to easily integrate into their user interfaces. These icons are organized into logical groups like Objects, Technology, Elements, and Teams & Companies, and are implemented as React components with customizable styling. The library also offers features for enhancing icons with badges and counts to display status indicators or numerical values, and provides a centralized export for simplified icon imports throughout the application.\n\n**Features:**\n\n*   Rich Icon Library: A comprehensive collection of icons covering various categories.\n*   Categorized Icons: Icons organized into logical groups for easy discovery and use.\n*   Pre-built Icons: Offers a collection of ready-to-use icons for common programming languages and actions.\n*   Base Icon Component: Provides a foundation for creating custom icons with consistent styling and attributes.\n*   Icon Badges: Enables the addition of status indicators or labels to icons for conveying contextual information.\n*   Icon Counts: Allows displaying numerical values alongside icons to represent quantities or metrics.\n*   Customizable Styling: Supports customization of icon color, font size, and other CSS properties.\n*   Badge Customization: Supports customization of badge status and content.\n*   Number Customization: Supports customization of number status and visibility of zero values.\n*   Icon Library: Provides a centralized collection of icons for use in the Lemon UI component library.\n*   Icon Export: Exports all icons from a dedicated module, simplifying icon imports throughout the application.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonProgress/index.tsx",
        "summary": "The code exports the `LemonProgress` component, making it available for use in other parts of the application. This suggests the existence of a progress indicator component within the Lemon UI library.\n\nHere's a list of high-level product features:\n\n*   **Progress Indication:** Provides a visual representation of a process's progress.\n*   **Lemon UI Integration:** Seamlessly integrates with the Lemon UI design system.\n*   **Reusability:** Can be used across different parts of the application to display progress.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonProgress/LemonProgress.tsx",
        "summary": "The `LemonProgress` component is a customizable progress bar that visually represents a percentage value. It allows users to specify the size (medium or large), background color, stroke color, and percentage of completion. The component uses `clsx` for conditional styling and `forwardRef` to allow access to the underlying HTML div element. It renders a rounded progress bar with a track that fills based on the provided percentage, with options for custom children within the track.\n\nHere's a list of high-level product features:\n\n*   **Percentage Display:** Visually represents progress using a bar that fills according to a specified percentage.\n*   **Customizable Size:** Offers different size options (medium, large) to fit various UI layouts.\n*   **Theming:** Allows customization of background and stroke colors to match the application's theme.\n*   **Children Support:** Supports adding custom content within the progress bar track.\n*   **Ref Forwarding:** Forwards the ref to the underlying div element, enabling direct DOM manipulation if needed.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonProgress",
        "summary": "The LemonProgress component is a customizable and reusable progress bar designed for the Lemon UI library. It visually represents the completion percentage of a process, offering options for different sizes (medium, large) and theming through customizable background and stroke colors. The component also supports embedding custom content within the progress bar and forwards the ref to the underlying div element for advanced use cases.\n\nHere's a list of high-level product features:\n\n*   **Progress Indication:** Visually represents progress using a bar that fills according to a specified percentage.\n*   **Lemon UI Integration:** Seamlessly integrates with the Lemon UI design system.\n*   **Reusability:** Can be used across different parts of the application to display progress.\n*   **Customizable Size:** Offers different size options (medium, large) to fit various UI layouts.\n*   **Theming:** Allows customization of background and stroke colors to match the application's theme.\n*   **Children Support:** Supports adding custom content within the progress bar track.\n*   **Ref Forwarding:** Forwards the ref to the underlying div element, enabling direct DOM manipulation if needed.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonCard/index.ts",
        "summary": "The code defines and exports a `LemonCard` component and its associated props type, `LemonCardProps`, making it available for use in other parts of the application. This allows developers to easily create card-like UI elements with a consistent look and feel.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Card UI Element:** Provides a reusable card component for displaying information.\n*   **Customizable Card Appearance:** Exposes props (`LemonCardProps`) to allow customization of the card's content and styling.\n*   **Consistent UI:** Enforces a consistent look and feel for cards throughout the application.\n*   **Component Reusability:** Enables developers to easily reuse the card component in multiple locations.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonCard/LemonCard.tsx",
        "summary": "The `LemonCard` component is a versatile UI element that provides a container with customizable styling and interactive features. It supports hover effects, optional click handling, focus indication, and a closeable option with an associated close button. The component is built using SCSS for styling and leverages other Lemon UI components like `LemonButton` for the close button.\n\nHere's a list of high-level features:\n\n*   **Container with Styling:** Provides a styled container with rounded corners, padding, and background color.\n*   **Hover Effect:**  Offers an optional hover effect to indicate interactivity.\n*   **Click Handling:** Supports an `onClick` handler to trigger actions when the card is clicked.\n*   **Focus Indication:**  Visually indicates when the card is focused, using a border.\n*   **Closeable Option:**  Allows the card to be closed via a close button (an `IconX` wrapped in a `LemonButton`).\n*   **Customizable Styling:**  Accepts a `className` prop for applying custom CSS classes.\n*   **Data Attributes:** Supports arbitrary data attributes via spread props.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonCard",
        "summary": "The `LemonCard` component offers a flexible and reusable card-like UI element with customizable styling, interactive features, and a consistent look and feel. It supports hover effects, click handling, focus indication, and a closeable option, making it suitable for various display and interaction scenarios within an application. The component is designed to be easily integrated and reused, promoting a unified user interface.\n\nHere's a list of high-level product features:\n\n*   Reusable Card UI Element\n*   Customizable Appearance (styling and content)\n*   Hover Effect\n*   Click Handling\n*   Focus Indication\n*   Closeable Option\n*   Consistent UI\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonCalendar/index.ts",
        "summary": "The code exports two components from the Lemon UI library related to calendars: `LemonCalendar` and `LemonCalendarSelect`. This suggests the library provides at least a basic calendar display component and a component specifically designed for selecting dates or date ranges within a calendar interface.\n\nHere's a list of high-level product features:\n\n*   **Calendar Display:** Ability to display a calendar view (likely month view).\n*   **Date Selection:** Functionality to select dates from the calendar.\n*   **Date Range Selection:** A specialized component for selecting a range of dates.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonCalendar/LemonCalendar.tsx",
        "summary": "The `LemonCalendar` component is a flexible calendar UI built with Lemon UI components, allowing users to select dates and, optionally, times. It supports displaying multiple months, custom styling for dates and times via props, and configurable week starting day. The calendar can be set to different granularities such as day, hour, or minute. It utilizes `dayjs` for date manipulation and provides callbacks for date selection and month navigation.\n\nHere's a list of high-level product features:\n\n*   **Date Selection:** Allows users to select a specific date from the calendar.\n*   **Month Navigation:** Enables users to navigate between months using previous and next month buttons.\n*   **Multi-Month Display:** Supports displaying multiple months simultaneously.\n*   **Customizable Date Styling:** Provides options to customize the appearance of individual dates.\n*   **Configurable Week Start:** Allows setting the first day of the week (Sunday or Monday).\n*   **Time Granularity:** Supports selection of time in addition to date, with options for hour and minute granularity.\n*   **Customizable Time Styling:** Provides options to customize the appearance of time slots.\n*   **Today Highlighting:** Highlights the current day for easy identification.\n*   **Scrollable Time Selection:** Uses scrollable shadows for time selection."
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonCalendar/LemonCalendarSelect.tsx",
        "summary": "This code defines a `LemonCalendarSelect` component, which is a calendar interface for selecting dates and times, and a `LemonCalendarSelectInput` component, which is a button that triggers the calendar popover. The calendar allows users to select a date, and optionally a time, with constraints on past or future dates and a specified granularity (day, hour, or minute). It provides visual feedback on selected dates and times, and allows for clearing the selection. The input component integrates the calendar into a button, displaying the selected date or a placeholder, and offering a clear button when a date is selected.\n\nHere's a list of high-level product features:\n\n*   **Date and Time Selection:** Allows users to select a specific date and time.\n*   **Granularity Control:** Supports selection at different levels of granularity (day, hour, minute).\n*   **Date Range Restrictions:** Enables limiting date selection to past or future dates, with optional upper or lower bounds.\n*   **Visual Feedback:** Provides visual cues for selected dates and times.\n*   **Clear Selection:** Allows users to clear their current date selection.\n*   **Calendar Popover Integration:** Integrates the calendar into a popover triggered by a button.\n*   **Placeholder Text:** Displays placeholder text when no date is selected.\n*   **Time Toggle:** Allows users to toggle the time selection on or off.\n*   **Cancel and Apply Actions:** Provides cancel and apply buttons for the calendar selection.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonCalendar",
        "summary": "The Lemon UI Calendar library provides a comprehensive set of components for date and time selection, offering both a basic calendar display and a more specialized calendar select component. These components allow users to select dates with varying levels of granularity (day, hour, minute), restrict date ranges, and customize the appearance of the calendar. The library also supports features like multi-month display, configurable week start, and integration with popover elements for a seamless user experience.\n\nHere's a list of high-level product features:\n\n*   Calendar Display\n*   Date Selection\n*   Date Range Selection\n*   Date and Time Selection\n*   Granularity Control (Day, Hour, Minute)\n*   Date Range Restrictions\n*   Visual Feedback for Selections\n*   Clear Selection\n*   Calendar Popover Integration\n*   Placeholder Text\n*   Time Toggle\n*   Cancel and Apply Actions\n*   Month Navigation\n*   Multi-Month Display\n*   Customizable Date Styling\n*   Configurable Week Start\n*   Customizable Time Styling\n*   Today Highlighting\n*   Scrollable Time Selection\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonBanner/index.ts",
        "summary": "The code defines and exports a `LemonBanner` component and its associated props type `LemonBannerProps` from the `./LemonBanner` file. This allows other parts of the application to easily import and use the `LemonBanner` component.\n\nHere's a list of high-level product features:\n\n*   **Banner Display:** Provides a banner component for displaying important messages or announcements.\n*   **Customizable Properties:** Offers customizable properties (defined in `LemonBannerProps`) to control the banner's appearance and behavior.\n*   **Reusable Component:** Exposes the banner as a reusable component for easy integration into different parts of the application.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonBanner/lemonBannerLogic.ts",
        "summary": "This code defines a Kea logic module named `lemonBannerLogic` that manages the dismissed state of a banner component. It utilizes a `dismissKey` prop to uniquely identify and persist the dismissed state in the browser's local storage. The logic provides actions to dismiss the banner and reset the dismiss key, along with a reducer to manage the `isDismissed` boolean state, which is persisted across sessions.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dismissable Banner:** Allows users to dismiss a banner, hiding it from view.\n*   **Persistent Dismissal:** Remembers the dismissed state across browser sessions using local storage.\n*   **Unique Banner Identification:** Uses a `dismissKey` to differentiate between multiple banners and persist their dismissed states independently.\n*   **Reset Dismissal State:** Provides a mechanism to reset the dismissed state, potentially re-showing the banner.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonBanner/LemonBanner.tsx",
        "summary": "The `LemonBanner` component is a versatile alert message component that can be displayed at the top of a page or within a section. It supports different types of alerts (info, warning, error, success), allows for custom actions via buttons, and can be dismissed by the user, optionally persisting the dismissal state in local storage. The banner is responsive, adapting its layout for different screen sizes, and includes options to hide the icon and render with square corners.\n\nHere's a list of high-level product features:\n\n*   **Alert Display:** Displays alert messages with different types (info, warning, error, success).\n*   **Customizable Content:** Accepts arbitrary React nodes as children for flexible message content.\n*   **Actionable Buttons:** Supports an optional action button with customizable properties.\n*   **Dismissable Alerts:** Allows users to dismiss the banner, optionally persisting the dismissal in local storage.\n*   **Responsive Design:** Adapts its layout for different screen sizes.\n*   **Icon Visibility Control:** Option to hide the alert type icon.\n*   **Styling Options:** Supports custom CSS classes and a square corner style.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonBanner",
        "summary": "The LemonBanner component provides a flexible and customizable way to display alert messages and announcements within an application. It supports various alert types, customizable content, action buttons, and a dismissable option with persistent storage. The component is responsive, offers styling options, and can be easily integrated into different parts of the application.\n\nHere's a list of high-level product features:\n\n*   Alert Display: Displays alert messages with different types (info, warning, error, success).\n*   Customizable Content: Accepts arbitrary React nodes as children for flexible message content.\n*   Actionable Buttons: Supports an optional action button with customizable properties.\n*   Dismissable Alerts: Allows users to dismiss the banner, optionally persisting the dismissal in local storage.\n*   Persistent Dismissal: Remembers the dismissed state across browser sessions using local storage.\n*   Unique Banner Identification: Uses a `dismissKey` to differentiate between multiple banners and persist their dismissed states independently.\n*   Reset Dismissal State: Provides a mechanism to reset the dismissed state, potentially re-showing the banner.\n*   Responsive Design: Adapts its layout for different screen sizes.\n*   Icon Visibility Control: Option to hide the alert type icon.\n*   Styling Options: Supports custom CSS classes and a square corner style.\n*   Reusable Component: Exposes the banner as a reusable component for easy integration into different parts of the application.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonActionableTooltip/index.ts",
        "summary": "The code defines and exports a React component called `LemonActionableTooltip` along with its props interface `LemonActionableTooltipProps`. This component likely implements a tooltip that, in addition to displaying information, also allows the user to take actions.\n\nHere's a list of high-level product features that `LemonActionableTooltip` likely provides:\n\n*   **Informative Tooltips:** Displays helpful information on hover or click.\n*   **Actionable Items:** Provides interactive elements (buttons, links, etc.) within the tooltip.\n*   **Customizable Content:** Allows developers to customize the content displayed in the tooltip.\n*   **Configurable Positioning:** Enables control over the tooltip's placement relative to its target element.\n*   **Theming Support:** Integrates with a design system or theme for consistent styling.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonActionableTooltip/LemonActionableTooltip.tsx",
        "summary": "The `LemonActionableTooltip` component provides a customizable, interactive tooltip that can be attached to any element on the page. It supports a title, descriptive text, navigation for multi-step tooltips, and action buttons. The tooltip is built using a Popover component and includes features like placement control, visibility toggling, and an optional icon. It allows for both URL-based buttons that open in a new tab and action-based buttons that trigger a function.\n\nHere's a list of high-level features:\n\n*   **Interactive Tooltips:** Displays helpful information and guides users through multi-step processes.\n*   **Customizable Content:** Supports titles, descriptive text, and optional icons.\n*   **Multi-Step Navigation:** Allows users to navigate through a series of tooltips with \"previous\" and \"next\" buttons.\n*   **Actionable Buttons:** Includes buttons that can trigger custom actions or open URLs in a new tab.\n*   **Placement Control:** Offers flexible placement options relative to the target element.\n*   **Visibility Control:** Allows the tooltip to be shown or hidden based on application state.\n*   **Close Button:** Provides a button for users to dismiss the tooltip.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonActionableTooltip",
        "summary": "The `LemonActionableTooltip` component offers interactive and informative tooltips that can be attached to any element. It supports customizable content including titles, descriptive text, and optional icons, and allows for multi-step navigation with \"previous\" and \"next\" buttons. The tooltips can include actionable buttons that trigger custom functions or open URLs in a new tab, with flexible placement and visibility control. A close button is also provided for easy dismissal.\n\nHere's a list of high-level product features:\n\n*   Informative Tooltips: Displays helpful information on hover or click.\n*   Actionable Items: Provides interactive elements (buttons, links, etc.) within the tooltip.\n*   Customizable Content: Supports titles, descriptive text, and optional icons.\n*   Configurable Positioning: Enables control over the tooltip's placement relative to its target element.\n*   Theming Support: Integrates with a design system or theme for consistent styling.\n*   Multi-Step Navigation: Allows users to navigate through a series of tooltips with \"previous\" and \"next\" buttons.\n*   Actionable Buttons: Includes buttons that can trigger custom actions or open URLs in a new tab.\n*   Visibility Control: Allows the tooltip to be shown or hidden based on application state.\n*   Close Button: Provides a button for users to dismiss the tooltip.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTable/index.ts",
        "summary": "The code defines the public interface for a LemonTable component, including its props, associated types for sorting and expandable configurations, and column definitions (both individual columns and column groups). It exports the `LemonTable` component itself, along with related types to facilitate its usage and customization.\n\n**Features:**\n\n*   **LemonTable Component:** A React component for displaying tabular data.\n*   **Customizable Columns:** Allows defining table columns with specific configurations.\n*   **Column Grouping:** Supports grouping columns under a common header.\n*   **Sorting:** Provides functionality for sorting data within the table.\n*   **Expandable Rows:** Enables expanding rows to display additional information.\n*   **Type Safety:** Exports TypeScript types for props, sorting, column definitions, and expandable configurations.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTable/LemonTableLoader.tsx",
        "summary": "This React component, `LemonTableLoader`, provides a loading indicator for tables. It uses `react-transition-group` to animate the appearance and disappearance of a loader element (either a `div` or `th`) based on the `loading` prop. The loader can be positioned at the top or bottom of the table using the `placement` prop. The component leverages CSS transitions for smooth visual feedback during loading states.\n\nHere's a list of high-level product features:\n\n*   **Loading State Indication:** Visually indicates when a table is loading data.\n*   **Configurable Placement:** Allows positioning the loader at the top or bottom of the table.\n*   **Animated Transitions:** Uses CSS transitions for smooth appearance and disappearance of the loader.\n*   **Customizable Tag:** Supports using either a `div` or `th` element as the loader.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTable/columnUtils.tsx",
        "summary": "This code provides utility functions for generating pre-configured column definitions for the `LemonTable` component. These column definitions simplify the process of displaying common data types such as timestamps, user information, and status flags within the table. The functions handle formatting, sorting, and rendering specific data fields, reducing boilerplate code when creating tables.\n\nHere's a list of high-level features provided by the code:\n\n*   **Generic Column Definition:** Creates a base column definition with title, data index, rendering, alignment, and sorting capabilities.\n*   **Created At Column:** Generates a column specifically for displaying \"created\\_at\" timestamps, formatted with timezone information.\n*   **Updated At Column:** Generates a column specifically for displaying \"updated\\_at\" timestamps, formatted with timezone information.\n*   **Created By Column:** Generates a column for displaying user information (profile picture and name) associated with the \"created\\_by\" field.\n*   **Status Column:** Generates a column for displaying a boolean \"enabled\" status as an \"Enabled\" or \"Disabled\" tag.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTable/sorting.tsx",
        "summary": "This code defines the logic and UI for sorting functionality within a table component. It includes an interface for representing the sorting state (column key and order), a function to determine the next sorting state based on user interaction (getNextSorting), and a component (SortingIndicator) to visually indicate the current sorting order of a column using icons. The `getNextSorting` function handles cycling through ascending, descending, and no sorting states, while respecting a flag to disable sorting cancellation. The `SortingIndicator` component displays an up or down arrow based on the sorting order, or a generic sort icon when no sorting is applied.\n\n**Features:**\n\n*   **Sorting State Management:** Defines a data structure to represent the current sorting state of a table, including the column being sorted and the sort order (ascending or descending).\n*   **Sorting Logic:** Implements the logic to determine the next sorting state when a column header is clicked, cycling through ascending, descending, and unsorted states.\n*   **Sorting Indicator UI:** Provides a visual indicator (using icons) in the column header to show the current sorting order (ascending, descending, or unsorted).\n*   **Disable Sorting Cancellation:** Supports disabling the ability to return to an unsorted state, forcing users to cycle between ascending and descending order.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTable/LemonTableLink.tsx",
        "summary": "This code defines a `LemonTableLink` component, designed for use within tables. It's essentially a styled link that can display both a title and a description. The title is rendered with a bold font and the description, if provided, is rendered below the title in a smaller, tertiary color. The description can be either a string, which will be rendered as Markdown, or a JSX element for more complex content. The component leverages the `Link` and `LemonMarkdown` components from the same library.\n\nHere's a list of high-level features:\n\n*   **Styled Link for Tables:** Provides a visually distinct link style specifically tailored for table rows.\n*   **Title and Description Support:** Allows displaying both a title and a descriptive text within the link.\n*   **Markdown Rendering:** Renders the description as Markdown if it's a string, enabling formatted text.\n*   **Customizable Content:** Supports JSX elements for the description, allowing for rich content beyond plain text.\n*   **Standard Link Properties:** Accepts standard link properties like `to`, `onClick`, `target`, and `className` for navigation and styling.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTable/types.ts",
        "summary": "This code defines the type definitions for the LemonTable component, outlining the structure and properties of columns, including rendering, sorting, and styling options. It also includes configurations for expandable rows, allowing for dynamic content display within the table.\n\nHere's a list of high-level product features based on the code:\n\n*   **Column Definition:** Allows defining columns with titles, data indexing, and custom rendering logic.\n*   **Column Visibility Control:** Enables hiding specific columns from the table view.\n*   **Sorting:** Supports column sorting with custom sorting functions.\n*   **Column Customization:** Provides options for styling columns with CSS classes and styles, including dynamic styling based on data.\n*   **Column Alignment:** Allows specifying the alignment of content within columns (left, right, center).\n*   **Column Width Control:** Enables setting fixed widths for columns.\n*   **Expandable Rows:** Supports expandable rows with custom rendering and styling for expanded content.\n*   **Expandable Row Control:** Allows control over which rows are expandable and their expanded state.\n*   **Column Groups:** Supports grouping columns under a common title.\n*   **Column \"More\" Menu:** Enables adding a menu with extra options to each column.\n*   **Column Tooltips:** Supports adding tooltips to column titles.\n*   **Full Width Columns:** Allows columns to expand to fill the available width.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTable/TableRow.tsx",
        "summary": "This code defines a `TableRow` component for a LemonTable, which is responsible for rendering a single row of data within the table. The component handles row expansion/collapse, sticky first columns, custom row styles and classes, and rendering cell contents based on column configurations. It utilizes column groups to organize columns and allows for custom rendering of cell values. The component also supports expandable rows with custom content and callbacks for expand/collapse actions.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Data Display:** Renders data records in a tabular format.\n*   **Row Expansion/Collapse:** Allows rows to be expanded to show additional information.\n*   **Customizable Row Appearance:** Supports custom row class names, styles, and ribbon colors.\n*   **Sticky Columns:** Enables the first column to be fixed during horizontal scrolling.\n*   **Cell Content Rendering:** Provides flexible rendering of cell contents via column configurations.\n*   **Column Grouping:** Organizes columns into logical groups.\n*   **Event Handling:** Supports `onClick` events on rows.\n*   **Customizable Expanded Row Content:** Allows defining custom content for expanded rows.\n*   **Expand/Collapse Callbacks:** Provides callbacks for row expansion and collapse events.\n*   **Performance Optimization:** Uses `React.memo` to prevent unnecessary re-renders.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTable/LemonTable.tsx",
        "summary": "The `LemonTable` component is a flexible and customizable table component built with React and SCSS. It supports features like sorting, pagination, expandable rows, and various styling options. The component handles data display, loading states, and empty states, and allows for customization of row appearance and behavior. It also supports sticky columns and scrollable shadows for improved user experience.\n\nHere's a list of high-level product features:\n\n*   **Data Display:** Renders tabular data from a provided data source.\n*   **Column Configuration:** Allows defining columns with properties like title, data index, width, alignment, and custom renderers.\n*   **Sorting:** Enables sorting of data based on column values, with customizable sorting logic and visual indicators.\n*   **Pagination:** Supports automatic and manual pagination for large datasets.\n*   **Expandable Rows:** Provides the ability to expand rows to display additional information.\n*   **Loading State:** Displays a loading indicator while data is being fetched.\n*   **Empty State:** Shows a custom message or component when there is no data to display.\n*   **Styling Options:** Offers various styling options, including size, inset, embedded, stealth, and custom CSS classes.\n*   **Row Customization:** Allows customizing the appearance and behavior of individual rows.\n*   **Sticky Columns:** Supports fixing the first column to remain visible during horizontal scrolling.\n*   **Scrollable Shadows:** Adds visual cues to indicate horizontal scrolling.\n*   **Header Configuration:** Allows hiding the header, uppercasing header titles, and setting maximum header widths.\n*   **URL Syncing:** Persists sorting preferences in the URL."
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTable",
        "summary": "The LemonTable component is a highly customizable and feature-rich React component designed for displaying tabular data. It offers a wide array of functionalities including data rendering, sorting, pagination, expandable rows, and loading/empty state management. The component allows for extensive customization of column appearance and behavior, including custom renderers, styling options, and sticky column support. Furthermore, it provides utilities for generating pre-configured column definitions for common data types like timestamps, user information, and status flags, simplifying table creation and reducing boilerplate code.\n\nHere's a list of high-level product features:\n\n*   Data Display: Renders tabular data from a provided data source.\n*   Column Configuration: Allows defining columns with properties like title, data index, width, alignment, and custom renderers.\n*   Sorting: Enables sorting of data based on column values, with customizable sorting logic and visual indicators.\n*   Pagination: Supports automatic and manual pagination for large datasets.\n*   Expandable Rows: Provides the ability to expand rows to display additional information.\n*   Loading State: Displays a loading indicator while data is being fetched.\n*   Empty State: Shows a custom message or component when there is no data to display.\n*   Styling Options: Offers various styling options, including size, inset, embedded, stealth, and custom CSS classes.\n*   Row Customization: Allows customizing the appearance and behavior of individual rows.\n*   Sticky Columns: Supports fixing the first column to remain visible during horizontal scrolling.\n*   Scrollable Shadows: Adds visual cues to indicate horizontal scrolling.\n*   Header Configuration: Allows hiding the header, uppercasing header titles, and setting maximum header widths.\n*   URL Syncing: Persists sorting preferences in the URL.\n*   Pre-configured Column Definitions: Provides utility functions for generating column definitions for common data types (timestamps, user info, status).\n*   Markdown Rendering: Renders descriptions as Markdown if it's a string, enabling formatted text.\n*   Column Grouping: Supports grouping columns under a common title.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonDialog/index.ts",
        "summary": "The code defines and exports a `LemonDialog` component and its associated props type `LemonDialogProps` from the `./LemonDialog` file. This allows other parts of the application to easily import and use the dialog component.\n\n**Features:**\n\n*   **LemonDialog Component:** A reusable dialog component for displaying modal content.\n*   **LemonDialogProps Type:** A defined type for the properties that can be passed to the `LemonDialog` component, ensuring type safety and clear usage.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonDialog/lemonDialogLogic.ts",
        "summary": "This code defines a Kea logic module named `lemonDialogLogic` for handling form state and validation within a LemonDialog component. It utilizes the `kea` and `kea-forms` libraries to manage form defaults and dynamically generate error messages based on validation functions provided as props. The logic module is designed to be reusable and customizable through props, allowing developers to define specific validation rules for different form fields within the dialog.\n\nHere's a list of high-level product features:\n\n*   **Form State Management:** Manages the state of a form within a dialog.\n*   **Dynamic Form Validation:** Enables dynamic validation of form fields based on provided validation functions.\n*   **Customizable Error Messages:** Supports customizable error messages for form fields.\n*   **Reusable Logic Module:** Provides a reusable logic module for handling form state and validation in different dialogs.\n*   **Integration with Kea:** Leverages the Kea library for state management and logic composition.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonDialog/LemonDialog.tsx",
        "summary": "This code defines two React components, `LemonDialog` and `LemonFormDialog`, built on top of the `LemonModal` component. `LemonDialog` provides a customizable modal with configurable primary, secondary, and tertiary buttons, along with content and close handling. `LemonFormDialog` extends `LemonDialog` to provide a form-based modal, integrating with `kea-forms` for form management, validation, and submission. Both components can be opened programmatically using static `open` and `openForm` methods, which dynamically create and insert the dialog into the document body.\n\nHere's a list of high-level product features:\n\n*   **Customizable Dialogs:** Allows displaying modal dialogs with a title, description, and custom content.\n*   **Configurable Buttons:** Supports primary, secondary, and tertiary buttons with customizable properties (label, type, onClick handler, loading state).\n*   **Form Integration:** Provides a form-based dialog component with built-in form management, validation, and submission handling.\n*   **Asynchronous Submission Handling:** Supports asynchronous form submission with loading state management.\n*   **Programmatic Opening:** Enables opening dialogs programmatically using static methods.\n*   **Navigation Handling:** Can automatically close the dialog when the user navigates to a different page.\n*   **Dynamic Content:** Supports rendering content as a ReactNode or a function that receives a loading state.\n*   **Error Handling:** Displays form validation errors.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonDialog",
        "summary": "The LemonDialog component suite provides a flexible and reusable way to create modal dialogs within an application. It offers customizable dialogs with configurable buttons, form integration with state management and dynamic validation, asynchronous submission handling, programmatic opening, navigation handling, dynamic content rendering, and error handling. The suite includes a reusable Kea logic module for managing form state and validation, ensuring consistency and reducing boilerplate code across different dialog implementations.\n\n**Features:**\n\n*   Customizable Dialogs with configurable title, description, and content.\n*   Configurable Buttons (primary, secondary, tertiary) with customizable actions and loading states.\n*   Form Integration with state management, dynamic validation, and submission handling.\n*   Asynchronous Submission Handling with loading state management.\n*   Programmatic Opening of dialogs.\n*   Navigation Handling to automatically close dialogs on page navigation.\n*   Dynamic Content rendering with ReactNode or function-based content.\n*   Error Handling and display of form validation errors.\n*   Reusable Kea Logic Module for form state management and validation.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/ClampedText/ClampedText.tsx",
        "summary": "The `ClampedText` component is a React component that truncates text to a specified number of lines and provides a \"Show more\" link to expand the text. It uses CSS ellipsis to truncate the text and dynamically adjusts the number of lines displayed based on user interaction. The component determines if the ellipsis is applied by comparing the scroll height and client height of the text element.\n\nHere's a list of high-level product features:\n\n*   **Text Truncation:** Limits the display of text to a specified number of lines.\n*   **\"Show More/Less\" Link:** Provides a link to expand or collapse the truncated text.\n*   **Dynamic Line Adjustment:** Updates the number of displayed lines based on user interaction (expanding/collapsing).\n*   **CSS Ellipsis:** Uses CSS ellipsis to visually indicate truncated text.\n*   **Automatic \"Show More\" Detection:** Automatically determines if the \"Show More\" link should be displayed based on content length.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/ClampedText/index.ts",
        "summary": "The code exports the `ClampedText` component from the `./ClampedText` file, making it available for use in other parts of the application. This suggests the existence of a UI component that likely truncates text content and potentially provides a way to view the full text, such as a tooltip or expanding view.\n\n**Features:**\n\n*   **Text Truncation:** Automatically shortens text that exceeds a specified length or container size.\n*   **Visual Indication of Truncation:** Provides a visual cue (e.g., ellipsis) to indicate that the text has been truncated.\n*   **Full Text Display:** Offers a mechanism to view the complete, un-truncated text (e.g., tooltip on hover, expanding on click).\n*   **Customizable Clamping:** Allows configuration of the clamping behavior, such as the maximum number of lines or characters.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/ClampedText",
        "summary": "The `ClampedText` component is a React component designed to intelligently truncate text content within a specified container. It leverages CSS ellipsis to visually indicate truncation and provides a \"Show more/less\" link to toggle between the truncated and full text views. The component dynamically adjusts the number of displayed lines based on user interaction and automatically determines when to display the \"Show more\" link based on the content length, offering a seamless user experience for handling lengthy text within limited spaces.\n\nHere's a list of high-level product features:\n\n*   Text Truncation: Limits the display of text to a specified number of lines or characters.\n*   \"Show More/Less\" Link: Provides a user-friendly control to expand or collapse the truncated text.\n*   Dynamic Line Adjustment: Updates the number of displayed lines based on user interaction.\n*   CSS Ellipsis: Uses CSS ellipsis to visually indicate truncated text.\n*   Automatic \"Show More\" Detection: Automatically determines if the \"Show More\" link should be displayed based on content length.\n*   Visual Indication of Truncation: Provides a visual cue (e.g., ellipsis) to indicate that the text has been truncated.\n*   Customizable Clamping: Allows configuration of the clamping behavior, such as the maximum number of lines or characters.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonButton/index.ts",
        "summary": "The code defines and exports a LemonButton component and related types for a React-based UI library. It includes variations of the button, such as a standard button, a button with a dropdown menu, and buttons with or without side actions. The code exports the `LemonButton` and `LemonButtonWithDropdown` components, along with various type definitions to support different button configurations and properties.\n\nHere's a list of high-level product features:\n\n*   **Standard Button Component:** A basic button component for general use.\n*   **Dropdown Button Component:** A button component that triggers a dropdown menu when clicked.\n*   **Side Action Support:** Ability to add actions or elements to the side of the button.\n*   **Configurable Properties:** Customizable properties for styling and behavior.\n*   **TypeScript Support:** Type definitions for easy integration with TypeScript projects.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonButton/More.tsx",
        "summary": "This code defines a `More` component, which is a specialized button within the Lemon UI library. It's essentially a button with an ellipsis icon that, when clicked, reveals a popover menu. The component leverages the `LemonButtonWithDropdown` component and allows customization of the popover's content (`overlay`), placement, and other button properties. The button is disabled if no overlay content is provided.\n\nHere's a list of high-level features:\n\n*   **Ellipsis Icon Button:** A button displaying an ellipsis icon, commonly used to indicate additional options or actions.\n*   **Popover Menu:** Displays a popover menu when the button is clicked.\n*   **Customizable Popover Content:** Allows specifying the content to be displayed within the popover menu.\n*   **Popover Placement Control:** Enables control over the placement of the popover relative to the button.\n*   **Actionable Dropdown Items:** Supports interactive elements within the dropdown.\n*   **Disabled State:** Disables the button when no popover content is provided.\n*   **Small Size:** The button defaults to a small size.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonButton/LemonButton.tsx",
        "summary": "The `LemonButton` component provides a flexible and styled button with various customization options, including different types, statuses, sizes, icons, and loading states. It supports linking to URLs, opening in new tabs, and displaying tooltips for disabled states. The component can also include a side action, which can be another button or a dropdown menu. It handles accessibility concerns such as ARIA attributes for disabled buttons and tooltips. The `LemonButtonWithDropdown` component is a specialized button that integrates a dropdown menu, though it is recommended to use `LemonMenu` with a `LemonButton` child instead.\n\nHere's a list of high-level product features:\n\n*   **Styling Options:** Offers different button types (primary, secondary, tertiary), statuses (default, alt, danger), and sizes (xsmall, small, medium, large) for visual customization.\n*   **Icon Support:** Allows displaying icons on the left and right sides of the button.\n*   **Loading State:** Provides a loading indicator to show ongoing processes.\n*   **Tooltip Support:** Enables displaying tooltips on hover, especially for disabled buttons with a reason.\n*   **Link Functionality:** Supports linking to URLs with options for opening in new tabs and disabling client-side routing.\n*   **Accessibility:** Includes ARIA attributes for disabled states and tooltips for improved accessibility.\n*   **Side Actions:** Allows adding a clickable side action, which can be another button or a dropdown menu.\n*   **Dropdown Integration:** Offers a specialized button component (`LemonButtonWithDropdown`) for integrating dropdown menus (though `LemonMenu` is preferred).\n*   **Full Width Option:** Allows the button to take up the full width of its parent container.\n*   **Truncate Text:** Truncates the button's text if necessary."
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonButton",
        "summary": "The LemonButton component provides a versatile and customizable button solution for React applications, offering a range of styling options, icon support, loading states, and tooltip functionality. It supports linking to URLs, handles accessibility concerns, and allows for the inclusion of side actions or dropdown menus. Specialized variations like the `More` component provide pre-configured buttons with ellipsis icons that trigger popover menus, enhancing user interaction and providing access to additional options.\n\n**Features:**\n\n*   Styling Options: Button types, statuses, and sizes for visual customization.\n*   Icon Support: Display icons on the left and right sides of the button.\n*   Loading State: Visual indicator for ongoing processes.\n*   Tooltip Support: Display tooltips on hover, especially for disabled buttons.\n*   Link Functionality: Support for URLs with options for opening in new tabs.\n*   Accessibility: ARIA attributes for disabled states and tooltips.\n*   Side Actions: Add clickable elements to the side of the button.\n*   Dropdown Integration: Button component for triggering dropdown menus.\n*   Full Width Option: Button takes up the full width of its parent container.\n*   Truncate Text: Truncates the button's text if necessary.\n*   Popover Menu: Displays a popover menu when the button is clicked.\n*   Customizable Popover Content: Allows specifying the content to be displayed within the popover menu.\n*   Popover Placement Control: Enables control over the placement of the popover relative to the button.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonMarkdown/index.ts",
        "summary": "The code defines a LemonMarkdown component and exports it along with its props type. This component likely renders Markdown content.\n\n**Features:**\n\n*   **Markdown Rendering:** Renders Markdown formatted text into HTML.\n*   **Customizable Props:** Accepts props for customization (likely including styling, security settings, and potentially custom Markdown extensions).\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonMarkdown/LemonMarkdown.tsx",
        "summary": "The `LemonMarkdown` component provides a way to render Markdown content with custom styling and enhanced features. It leverages the `react-markdown` library to parse and render Markdown, while offering customization options such as low-key headings (using `<strong>` tags instead of heading tags), disabling documentation sidebar redirection, and custom link and code snippet rendering. The component also sanitizes the Markdown input by disallowing HTML to prevent security vulnerabilities.\n\nHere's a list of high-level product features:\n\n*   **Markdown Rendering:** Renders Markdown content into HTML.\n*   **Customizable Headings:** Allows headings to be rendered as `<strong>` tags for a less prominent appearance.\n*   **Customizable Links:** Renders links with custom styling and behavior, including opening in new tabs and disabling documentation sidebar redirection.\n*   **Code Snippet Highlighting:** Renders code blocks with syntax highlighting using the `CodeSnippet` component.\n*   **HTML Sanitization:** Disallows HTML in the Markdown input to prevent security vulnerabilities.\n*   **Customizable Styling:** Provides a `className` prop for applying custom CSS classes.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonMarkdown",
        "summary": "The `LemonMarkdown` component offers a secure and customizable way to render Markdown content within a React application. It leverages the `react-markdown` library while providing enhanced features such as customizable heading styles, custom link rendering with control over navigation behavior, syntax highlighting for code snippets, and HTML sanitization to prevent security vulnerabilities. The component also allows for custom styling through CSS classes.\n\nHere's a list of high-level product features:\n\n*   Markdown Rendering: Converts Markdown text into HTML for display.\n*   Customizable Headings: Allows rendering headings with alternative styles (e.g., using `<strong>` tags).\n*   Customizable Links: Provides control over link behavior, including opening in new tabs and disabling specific navigation features.\n*   Code Snippet Highlighting: Renders code blocks with syntax highlighting.\n*   HTML Sanitization: Prevents execution of arbitrary HTML within the Markdown content.\n*   Customizable Styling: Supports custom CSS classes for styling the rendered Markdown.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSkeleton/index.ts",
        "summary": "The code defines and exports a component named `LemonSkeleton` along with its associated properties type `LemonSkeletonProps`. This suggests the existence of a UI component designed to act as a placeholder or loading indicator, commonly known as a skeleton loader. It likely provides a visual representation of content that is still being fetched or processed, enhancing the user experience by providing immediate feedback.\n\nHere's a list of high-level product features based on this code:\n\n*   **Skeleton Loading UI Component:** Provides a pre-built UI element for displaying a skeleton loading state.\n*   **Configurable Properties:** Allows customization of the skeleton's appearance through props (e.g., size, shape, color).\n*   **Easy Integration:** Designed for simple integration into existing React applications.\n*   **Improved User Experience:** Enhances perceived performance by providing visual feedback during loading times.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSkeleton/LemonSkeleton.tsx",
        "summary": "The `LemonSkeleton` component provides a visual placeholder for content that is loading. It can be rendered as a basic block, repeated multiple times with optional fading, or styled as text, a row, a circle, or a button. The component uses CSS classes for styling and allows customization through props such as `className`, `repeat`, `fade`, and `active`.\n\nHere's a list of high-level product features:\n\n*   **Basic Skeleton Display:** Renders a simple rectangular skeleton placeholder.\n*   **Repeated Skeletons:** Allows rendering multiple skeleton placeholders in a sequence.\n*   **Progressive Fade Effect:** Provides an option to fade out repeated skeletons for a visual loading effect.\n*   **Static Skeleton Option:** Allows rendering a non-animated skeleton.\n*   **Text Skeleton Variant:** Offers a skeleton styled as a line of text.\n*   **Row Skeleton Variant:** Provides a skeleton styled as a row.\n*   **Circle Skeleton Variant:** Renders a circular skeleton placeholder, useful for avatars or icons.\n*   **Button Skeleton Variant:** Offers a skeleton styled as a button, with size options.\n*   **Customizable Styling:** Supports custom CSS classes for flexible styling.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSkeleton",
        "summary": "The `LemonSkeleton` component is a versatile UI element designed to provide visual feedback during content loading. It offers a range of customizable skeleton placeholders, including basic blocks, repeated sequences with optional fading, and specialized styles for text, rows, circles, and buttons. By allowing custom CSS classes and configurable properties, the component enables developers to seamlessly integrate loading indicators that match their application's design, ultimately improving the user experience by providing immediate feedback and a sense of progress.\n\nHere's a consolidated list of high-level product features:\n\n*   **Basic Skeleton Display:** Renders a simple rectangular skeleton placeholder.\n*   **Repeated Skeletons:** Allows rendering multiple skeleton placeholders in a sequence.\n*   **Progressive Fade Effect:** Provides an option to fade out repeated skeletons for a visual loading effect.\n*   **Static Skeleton Option:** Allows rendering a non-animated skeleton.\n*   **Text Skeleton Variant:** Offers a skeleton styled as a line of text.\n*   **Row Skeleton Variant:** Provides a skeleton styled as a row.\n*   **Circle Skeleton Variant:** Renders a circular skeleton placeholder, useful for avatars or icons.\n*   **Button Skeleton Variant:** Offers a skeleton styled as a button, with size options.\n*   **Customizable Styling:** Supports custom CSS classes for flexible styling.\n*   **Configurable Properties:** Allows customization of the skeleton's appearance through props (e.g., size, shape, color).\n*   **Easy Integration:** Designed for simple integration into existing React applications.\n*   **Improved User Experience:** Enhances perceived performance by providing visual feedback during loading times.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/ProfilePicture/index.ts",
        "summary": "The code defines and exports two components related to profile pictures: `ProfilePicture` and `ProfileBubbles`. It also exports their corresponding prop types, `ProfilePictureProps` and `ProfileBubblesProps`, respectively. These components likely provide different ways to display a user's profile image, with `ProfilePicture` being a standard display and `ProfileBubbles` potentially offering a more stylized or interactive representation.\n\nHere's a list of high-level product features:\n\n*   **Profile Picture Display:** Renders a user's profile picture.\n*   **Profile Bubbles Display:** Renders a user's profile picture in a stylized \"bubble\" format.\n*   **Customizable Profile Picture:** Allows customization of the appearance and behavior of the profile picture component via props.\n*   **Customizable Profile Bubbles:** Allows customization of the appearance and behavior of the profile bubbles component via props.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/ProfilePicture/ProfileBubbles.tsx",
        "summary": "The `ProfileBubbles` component provides a compact way to display a list of users, typically in collaborative contexts. It renders a series of profile pictures (using the `ProfilePicture` component) in a horizontal arrangement. When the number of users exceeds a specified limit, it displays a \"+n\" bubble indicating the number of additional users. Tooltips can be added to provide more information on hover.\n\nHere's a list of high-level features:\n\n*   **Displays a list of user profile pictures:** Renders profile pictures for a given list of users.\n*   **Limits the number of displayed profiles:** Configurable limit on the number of profile pictures shown.\n*   **Overflow indicator:** Shows a \"+n\" bubble when the number of users exceeds the limit.\n*   **Tooltip support:** Displays a tooltip with additional information when hovering over the component.\n*   **Customizable styling:** Accepts a className prop for custom styling.\n*   **Clickable:** Can be made clickable by passing an onClick handler.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/hooks.ts",
        "summary": "The `useSliderPositioning` hook provides dynamic slider positioning for horizontal single-choice components. It tracks the width and offset of the currently selected element within a container, enabling a smooth sliding effect when the selection changes. The hook utilizes `useResizeObserver` to react to container size changes and `useLayoutEffect` to update the slider position after rendering. It returns refs to the container and selected element, along with the slider's width, offset, and a boolean indicating whether a transition is in progress.\n\nHere's a list of high-level product features enabled by this hook:\n\n*   **Dynamic Slider Positioning:** Automatically adjusts the slider's position based on the selected element.\n*   **Smooth Transitions:** Provides a smooth sliding animation when the selected element changes.\n*   **Responsiveness:** Adapts to changes in the container's width, ensuring correct slider positioning on different screen sizes.\n*   **Horizontal Single-Choice Component Support:** Designed for components like segmented buttons or tabs where only one option can be selected at a time.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/ProfilePicture/ProfilePicture.tsx",
        "summary": "The `ProfilePicture` component is a versatile React component that displays a user's profile picture. It supports various sources for the picture, including Gravatar, a Hedgehog Buddy profile (if configured), a lettermark generated from the user's name, or a robot icon for bots. The component handles cases where a Gravatar fails to load and falls back to alternative representations. It also allows displaying the user's name alongside the picture and offers different size options.\n\nHere's a list of high-level features:\n\n*   **Profile Picture Display:** Renders a user's profile picture using different sources.\n*   **Gravatar Integration:** Fetches and displays Gravatar images based on user email.\n*   **Hedgehog Buddy Profile Support:** Displays a Hedgehog Buddy profile if configured for the user.\n*   **Lettermark Generation:** Generates a lettermark based on the user's name as a fallback.\n*   **Bot/System User Icons:** Displays a robot icon for bot users and allows styling for system users.\n*   **Size Customization:** Offers various size options for the profile picture (xs, sm, md, lg, xl, xxl).\n*   **Name Display:** Optionally displays the user's name alongside the profile picture.\n*   **Error Handling:** Handles Gravatar loading errors and falls back to alternative representations.\n*   **Title Attribute:** Sets the title attribute for accessibility and hover information.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/ProfilePicture",
        "summary": "The provided code implements two React components, `ProfilePicture` and `ProfileBubbles`, designed for displaying user profile information in different formats. `ProfilePicture` offers a versatile way to render a single user's profile image, supporting various sources like Gravatar, Hedgehog Buddy profiles, lettermarks, and bot icons, along with size customization and name display options. `ProfileBubbles`, on the other hand, provides a compact display of multiple user profiles, limiting the number of visible profiles and using an overflow indicator with tooltip support for larger groups.\n\nHere's a list of high-level product features:\n\n*   **Versatile Profile Picture Display:** Renders a single user's profile picture with support for multiple image sources (Gravatar, Hedgehog Buddy, lettermark, bot icon), size customization, and optional name display.\n*   **Compact Profile Bubbles Display:** Renders a list of user profile pictures in a space-saving horizontal arrangement, with a configurable limit on the number of displayed profiles and an overflow indicator for larger groups.\n*   **Gravatar Integration:** Fetches and displays user profile pictures from Gravatar based on email addresses.\n*   **Customizable Styling:** Allows customization of both `ProfilePicture` and `ProfileBubbles` components through props, including size, styling, and behavior.\n*   **Tooltip Support:** Provides tooltip functionality for `ProfileBubbles` to display additional information on hover.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonCollapse/index.ts",
        "summary": "The code exports the LemonCollapse component, making it available for use in other parts of the application. This suggests the existence of a collapsible UI element within the Lemon UI library.\n\nHere's a list of high-level product features based on this code:\n\n*   **Collapsible Panels:** Allows users to show and hide content sections within a panel.\n*   **Expand/Collapse Functionality:** Provides a mechanism for users to interact with the collapsible panels, typically through a header or trigger element.\n*   **UI Organization:** Enables developers to organize content in a structured and space-saving manner.\n*   **Lemon UI Integration:** Seamlessly integrates with other components within the Lemon UI library, maintaining a consistent look and feel.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonCollapse/LemonCollapse.tsx",
        "summary": "The `LemonCollapse` component provides a collapsible panel interface, allowing users to expand and collapse content sections. It supports both single and multiple active panels, controlled or uncontrolled modes, custom headers (either strings or `LemonButton` props), and optional transition animations. The component utilizes `react-transition-group` for smooth expand/collapse animations and `useResizeObserver` to dynamically adjust the height of the content area during transitions. It also supports embedded styling and custom class names for flexible integration into various layouts.\n\nHere's a list of high-level product features:\n\n*   **Collapsible Panels:** Allows users to organize content into expandable and collapsible sections.\n*   **Single/Multiple Panel Expansion:** Supports both single panel expansion (accordion style) and multiple panel expansion.\n*   **Controlled/Uncontrolled Modes:** Offers both controlled (active key(s) managed by parent) and uncontrolled (active key(s) managed internally) modes.\n*   **Customizable Headers:** Allows for custom headers using strings or `LemonButton` props, providing flexibility in styling and interaction.\n*   **Transition Animations:** Uses `react-transition-group` to provide smooth expand/collapse animations.\n*   **Dynamic Height Adjustment:** Adjusts the height of the content area dynamically during transitions using `useResizeObserver`.\n*   **Embedded Styling:** Supports an embedded style for seamless integration into different layouts.\n*   **Customizable Styling:** Allows for custom class names to be applied for further styling customization.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonCollapse",
        "summary": "The `LemonCollapse` component offers a versatile collapsible panel interface, enabling users to expand and collapse content sections for improved organization and space management. It supports single or multiple active panels, controlled and uncontrolled modes, customizable headers with strings or `LemonButton` props, smooth transition animations using `react-transition-group`, dynamic height adjustment during transitions with `useResizeObserver`, embedded styling, and custom class names for flexible integration within the Lemon UI library.\n\nHere's a list of high-level product features:\n\n*   Collapsible Panels: Organize content into expandable and collapsible sections.\n*   Single/Multiple Panel Expansion: Supports both single panel expansion (accordion style) and multiple panel expansion.\n*   Controlled/Uncontrolled Modes: Offers both controlled (active key(s) managed by parent) and uncontrolled (active key(s) managed internally) modes.\n*   Customizable Headers: Allows for custom headers using strings or `LemonButton` props.\n*   Transition Animations: Provides smooth expand/collapse animations.\n*   Dynamic Height Adjustment: Adjusts the height of the content area dynamically during transitions.\n*   Embedded Styling: Supports an embedded style for seamless integration.\n*   Customizable Styling: Allows for custom class names to be applied.\n*   UI Organization: Enables developers to organize content in a structured and space-saving manner.\n*   Lemon UI Integration: Seamlessly integrates with other components within the Lemon UI library.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTag/index.ts",
        "summary": "The code defines and exports a `LemonTag` component and its associated types (`LemonTagProps` and `LemonTagType`). This allows developers to use the `LemonTag` component in other parts of the application.\n\nHere's a list of high-level product features based on this code:\n\n*   **Tag Display:** The core feature is the ability to display tags, likely used for categorization, labeling, or highlighting information.\n*   **Customizable Tag Types:** The `LemonTagType` likely allows for different visual styles or behaviors of the tag based on its type (e.g., success, warning, error).\n*   **Configurable Properties:** The `LemonTagProps` likely define the properties that can be configured for the tag, such as its text, color, size, or icon.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTag/LemonTag.tsx",
        "summary": "The `LemonTag` component is a versatile UI element for displaying labels or categories. It supports various types (primary, option, highlight, etc.) to visually represent different meanings. The component can be customized with different sizes, weights, icons, and the ability to be closable. It also supports a popover menu via a dropdown button. The tag can be made clickable and can be disabled with a reason displayed as a tooltip.\n\nHere's a list of high-level features:\n\n*   **Styling Variants:** Supports different tag types (primary, option, highlight, etc.) with corresponding visual styles.\n*   **Size and Weight Customization:** Offers different sizes (small, medium) and font weights for visual emphasis.\n*   **Icon Support:** Allows displaying an icon within the tag.\n*   **Closable Tags:** Provides an option to make the tag closable with an \"X\" icon and an `onClose` handler.\n*   **Clickable Tags:** Supports click events with an `onClick` handler.\n*   **Popover Menu:** Integrates a dropdown menu (popover) using `LemonButtonWithDropdown`.\n*   **Disabled State:** Supports a disabled state with a tooltip explaining the reason for being disabled.\n*   **Customizable Class Names:** Allows adding custom CSS classes for further styling.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonTag",
        "summary": "The `LemonTag` component is a highly customizable UI element designed for displaying labels and categories. It offers a range of styling options, including different types, sizes, and weights, along with the ability to incorporate icons. The component supports interactive features such as being closable, clickable, and integrating a popover menu. It also provides a disabled state with informative tooltips and allows for custom CSS class names for further styling flexibility.\n\nHere's a list of high-level product features:\n\n*   Styling Variants (primary, option, highlight, etc.)\n*   Size and Weight Customization\n*   Icon Support\n*   Closable Tags with `onClose` handler\n*   Clickable Tags with `onClick` handler\n*   Popover Menu Integration\n*   Disabled State with Tooltip\n*   Customizable Class Names\n*   Tag Display\n*   Configurable Properties via `LemonTagProps`\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSwitch/index.ts",
        "summary": "The code defines and exports a React component called `LemonSwitch` along with its props type `LemonSwitchProps`. This component likely implements a toggle switch UI element, allowing users to switch between two states (on/off, true/false).\n\nHere's a list of high-level product features that `LemonSwitch` likely supports:\n\n*   **Toggle Functionality:** Allows users to switch between two states (e.g., on/off).\n*   **Customizable Appearance:**  (Implied) The component likely accepts props to customize its visual appearance (colors, sizes, labels, etc.).\n*   **Accessibility:** (Implied) The component is likely designed with accessibility in mind, providing proper ARIA attributes for screen reader users.\n*   **Integration with Forms:** (Implied) The component can likely be easily integrated into forms to capture user input.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSwitch/LemonSwitch.tsx",
        "summary": "The `LemonSwitch` component is a customizable switch control with various styling and functional options. It supports labels, tooltips (especially for disabled states), different sizes, and full-width display. The component uses `clsx` for conditional class names and `forwardRef` for ref forwarding. It also handles internal state for active styling and generates unique IDs for switches.\n\nHere's a list of high-level product features:\n\n*   **Toggle Functionality:** Basic on/off switch functionality with `checked` and `onChange` props.\n*   **Customizable Appearance:**\n    *   Different sizes (`xxsmall`, `xsmall`, `small`, `medium`).\n    *   Bordered style option.\n    *   Full-width display option.\n    *   Customizable slider colors for checked and unchecked states.\n    *   Customizable handle content.\n*   **Label Support:** Displays a label associated with the switch.\n*   **Tooltip Support:** Displays a tooltip on hover, especially useful for explaining why a switch is disabled.\n*   **Disabled State:** Disables the switch and optionally displays a reason for being disabled.\n*   **Accessibility:** Includes `aria-label` for accessibility.\n*   **Styling:** Supports custom class names for styling the switch and its label.\n*   **Ref Forwarding:** Allows access to the underlying HTML element via `ref`.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonSwitch",
        "summary": "The `LemonSwitch` component provides a versatile and customizable toggle switch for React applications. It offers a range of features including basic on/off functionality, customizable appearance options such as sizes, colors, and handle content, label and tooltip support for enhanced user experience, and a disabled state with optional explanations. The component is designed with accessibility in mind and supports integration with forms, making it a valuable UI element for various applications.\n\nHere's a list of high-level product features:\n\n*   Toggle Functionality: Enables users to switch between two states (on/off).\n*   Customizable Appearance: Offers options for adjusting sizes, colors, borders, and handle content.\n*   Label Support: Allows displaying a label associated with the switch.\n*   Tooltip Support: Provides tooltips for additional information, especially for disabled states.\n*   Disabled State: Disables the switch with optional explanations.\n*   Accessibility: Includes ARIA attributes for screen reader compatibility.\n*   Form Integration: Designed for easy integration into forms.\n*   Ref Forwarding: Allows access to the underlying HTML element via `ref`.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonCheckbox/index.ts",
        "summary": "The code defines and exports a `LemonCheckbox` component and its associated props type `LemonCheckboxProps` from the `./LemonCheckbox` file. This allows other parts of the application to easily import and use the checkbox component.\n\nHere's a list of high-level product features related to this code:\n\n*   **Checkbox Input:** Provides a standard checkbox input element for boolean selection.\n*   **Customizable Properties:** Exposes properties (via `LemonCheckboxProps`) to customize the appearance and behavior of the checkbox.\n*   **Reusable Component:** Offers a reusable checkbox component for consistent UI across the application.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonCheckbox/LemonCheckbox.tsx",
        "summary": "The `LemonCheckbox` component provides a customizable checkbox input with features like controlled and uncontrolled modes, indeterminate state, disabled state with tooltip explanation, various sizes, bordered style, and full-width option. It supports a label, custom ID, and styling via CSS classes. The component leverages a tooltip to display the reason for disabling the checkbox, enhancing user experience by providing context.\n\nHere's a list of high-level product features:\n\n*   **Checkbox with Label:** Displays a checkbox with an associated label.\n*   **Controlled and Uncontrolled Modes:** Operates as either a controlled component (value managed externally) or an uncontrolled component (value managed internally).\n*   **Indeterminate State:** Supports an indeterminate state for checkboxes, visually representing a mixed selection.\n*   **Disabled State with Tooltip:** Disables the checkbox and displays a tooltip explaining the reason for the disabled state.\n*   **Customizable Size:** Offers different size options (xsmall, small, medium) for the checkbox.\n*   **Bordered Style:** Provides an option to display the checkbox with a border.\n*   **Full-Width Option:** Allows the checkbox to occupy the full width of its container.\n*   **Customizable ID and Styling:** Supports custom IDs and styling through CSS classes.\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui/LemonCheckbox",
        "summary": "The `LemonCheckbox` component offers a versatile and customizable checkbox input for React applications. It supports both controlled and uncontrolled modes, an indeterminate state for representing mixed selections, and a disabled state accompanied by a tooltip explaining the reason for disablement. The component also provides options for adjusting the size, adding a border, and occupying the full width of its container, along with support for custom IDs and styling through CSS classes, ensuring flexibility and ease of integration into various UI designs.\n\nHere's a list of high-level product features:\n\n*   Checkbox with Label\n*   Controlled and Uncontrolled Modes\n*   Indeterminate State\n*   Disabled State with Tooltip Explanation\n*   Customizable Size\n*   Bordered Style\n*   Full-Width Option\n*   Customizable ID and Styling\n*   Reusable Component\n"
    },
    {
        "path": "frontend/src/lib/lemon-ui",
        "summary": "The Lemon UI library provides a comprehensive suite of React components designed to create consistent, accessible, and user-friendly interfaces. These components offer a wide range of features, from basic elements like buttons and inputs to more complex components like tables, calendars, and modals. The library emphasizes customization, theming, and responsiveness, ensuring that developers can easily integrate these components into their applications and tailor them to their specific needs. With a focus on accessibility and a consistent design language, Lemon UI aims to streamline the development process and enhance the overall user experience.\n\nHere's a list of high-level product features:\n\n*   **Basic UI Elements:** Buttons, inputs, labels, links, dividers, and icons.\n*   **Form Components:** Text areas, selects, checkboxes, radio buttons, file inputs, and form field wrappers.\n*   **Navigation and Organization:** Menus, tabs, dropdowns, pagination controls, and tree views.\n*   **Data Display:** Tables, cards, badges, and progress indicators.\n*   **Notifications and Feedback:** Toasts, snacks, banners, tooltips, and skeletons.\n*   **Modals and Overlays:** Modals, popovers, and actionable tooltips.\n*   **Date and Time Selection:** Calendars and date range pickers.\n*   **Layout and Structure:** Rows, widgets, and collapsible panels.\n*   **Customization and Theming:** Customizable styling, color tokens, and theme awareness.\n*   **Accessibility:** ARIA attributes, keyboard navigation, and screen reader compatibility.\n*   **State Management Integration:** Kea forms integration and URL syncing.\n*   **Utility Hooks:** Hooks for slider positioning and other dynamic UI behaviors.\n*   **Image Handling:** Profile picture display and logo rendering.\n*   **Markdown Support:** Markdown rendering with syntax highlighting and HTML sanitization.\n*   **Loading Indicators:** Spinners, loading bars, and skeleton loaders.\n*   **Data Visualization:** Progress circles and sliders.\n*   **Text Handling:** Clamped text and customizable text styles.\n*   **Code Highlighting:** Syntax highlighting for code snippets.\n*   **File Handling:** File upload functionality.\n*   **Color Selection:** Color selection tools and color display components.\n*   **Segmented Controls:** Segmented select and segmented button components.\n*   **Tag Management:** Tag display and management components.\n*   **Switch Components:** Toggle switch components.\n*   **Dynamic UI Switching:** Adapts between segmented buttons and a dropdown based on screen size and option count.\n*   **Lettermark Generation:** Generates a lettermark logo based on entity ID and name when no media ID is available.\n*   **Dynamic Slider Positioning:** Automatically adjusts the slider's position based on the selected element.\n*   **Snackbar/Notification Display:** Displays concise, non-intrusive notifications or messages.\n*   **Visual Loading Indicator:** Displays a progress bar to indicate an ongoing loading process.\n*   **Alert Display:** Displays alert messages with different types (info, warning, error, success).\n*   **Informative Tooltips:** Displays helpful information on hover or click.\n*   **Data Display:** Renders tabular data from a provided data source.\n*   **Customizable Dialogs:** Customizable dialogs with configurable title, description, and content.\n*   **Text Truncation:** Limits the display of text to a specified number of lines or characters.\n*   **Styling Options:** Button types, statuses, and sizes for visual customization.\n*   **Basic Skeleton Display:** Renders a simple rectangular skeleton placeholder.\n*   **Dynamic Slider Positioning:** Automatically adjusts the slider's position based on the selected element.\n*   **Versatile Profile Picture Display:** Renders a single user's profile picture with support for multiple image sources (Gravatar, Hedgehog Buddy, lettermark, bot icon), size customization, and optional name display.\n*   **Collapsible Panels:** Organize content into expandable and collapsible sections.\n*   **Styling Variants:** (primary, option, highlight, etc.)\n*   **Toggle Functionality:** Enables users to switch between two states (on/off).\n*   **Checkbox with Label:** Provides a checkbox input with an associated label.\n*   **Click or Hover Trigger:** Provides dropdown menu functionality, built upon the Popover component, with customizable triggers (click or hover) and controlled visibility.\n"
    },
    {
        "path": "frontend/src/lib/logic/userPreferencesLogic.ts",
        "summary": "This code defines a Kea logic module called `userPreferencesLogic` that manages user preferences stored in the browser. It provides actions to set preferences for hiding PostHog properties in tables and hiding null values. These preferences are persisted in the browser's local storage.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Hide PostHog Properties in Tables:** Allows users to toggle the visibility of PostHog-specific properties in data tables.\n*   **Hide Null Values:** Enables users to hide null values in data displays.\n*   **Persistent User Preferences:** User preferences are saved in the browser and persist across sessions.\n"
    },
    {
        "path": "frontend/src/lib/logic/featureFlagLogic.ts",
        "summary": "This code defines a Kea logic module called `featureFlagLogic` that manages feature flags within the application. It retrieves persisted feature flags from the application context, and uses a Proxy to intercept access to feature flags, notifying PostHog when a flag is accessed. This allows tracking of feature flag usage. The logic module also includes reducers to store the feature flags and a boolean indicating whether feature flags have been received. It listens for feature flag updates from PostHog and updates its state accordingly.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Feature Flag Management:** Allows enabling or disabling features remotely without code deployments.\n*   **Persisted Feature Flags:** Stores feature flag states, likely in local storage or cookies, so they persist across sessions.\n*   **Feature Flag Usage Tracking:** Tracks when and how often feature flags are accessed, providing insights into feature adoption.\n*   **Dynamic Feature Flag Updates:** Listens for updates from PostHog to dynamically change feature flag states.\n*   **Environment-Specific Feature Flags:** Handles different feature flag configurations based on the environment (e.g., development, production).\n"
    },
    {
        "path": "frontend/src/lib/logic/apiStatusLogic.ts",
        "summary": "The `apiStatusLogic` Kea logic module manages the application's state related to API responses, internet connectivity, and authentication status. It tracks whether there's an internet connection issue and whether time-sensitive authentication is required. It listens for API responses, and based on the response status and error messages, it updates the state accordingly. Specifically, it handles scenarios like failed fetch requests (indicating potential CORS or connectivity issues), 403 errors with a specific detail message (requiring recent authentication), and 401 errors (triggering a user logout if the user exists).\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Internet Connection Issue Detection:** Detects when the application is unable to connect to the backend server, likely due to network issues or CORS configuration problems.\n*   **Time-Sensitive Authentication Handling:** Prompts the user to re-authenticate if the backend requires recent authentication for certain actions.\n*   **Unauthorized Access Handling:** Automatically logs out the user if the application receives a 401 error, indicating that the user's session is no longer valid.\n*   **API Error Monitoring:** Provides a centralized mechanism for handling and reacting to different API error codes, improving the application's resilience and user experience.\n"
    },
    {
        "path": "frontend/src/lib/hog.ts",
        "summary": "This code defines a JavaScript library for executing HogQL (PostHog Query Language) code in a sandboxed environment, both synchronously and asynchronously. It provides functions `execHog` and `execHogAsync` that take HogQL code or a VM state as input and execute it with a set of external functions, including cryptographic functions, regular expression matching, and the ability to run other HogQL queries. The library also includes utilities for handling regular expression modifiers. The `execHogAsync` function allows for asynchronous operations like `sleep` and `run` (executing other HogQL queries), while disabling potentially unsafe operations like `fetch` and `posthogCapture` in the browser environment.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **HogQL Execution:** Enables the execution of HogQL code within a sandboxed JavaScript environment.\n*   **Synchronous and Asynchronous Execution:** Supports both synchronous and asynchronous execution of HogQL code.\n*   **Regular Expression Matching:** Provides regular expression matching capabilities within HogQL queries.\n*   **Querying from Queries:** Allows HogQL queries to execute other HogQL queries.\n*   **Sandboxed Environment:** Restricts access to potentially unsafe operations like network requests (`fetch`) and event capturing (`posthogCapture`) in the browser.\n*   **Asynchronous Functions:** Supports asynchronous functions like `sleep` within HogQL code.\n*   **Customizable Execution Options:** Allows for customization of execution options, including external functions.\n"
    },
    {
        "path": "frontend/src/lib/api.mock.ts",
        "summary": "This file defines mock data and a mock API for the PostHog frontend, primarily used for testing and development purposes. It includes mock objects representing various PostHog entities such as users, teams, organizations, projects, cohorts, plugins, and their configurations. The mock API allows frontend components to interact with a simulated backend, enabling isolated testing and development without relying on a live server.\n\nHere's a list of high-level product features that can be inferred from the mock data:\n\n*   **User Management:** User creation, authentication, roles, and permissions (including organization membership levels).\n*   **Organization Management:** Organization creation, settings (e.g., 2FA enforcement, member join emails), and plugin access control.\n*   **Project/Team Management:** Project/Team creation, settings (e.g., timezone, data attributes, test account filters, session recording settings).\n*   **Data Capture and Analysis:** Event ingestion, session recording, autocapture, heatmaps, performance monitoring, console log capture, and exception tracking.\n*   **Feature Flags:** Management and persistence of feature flags.\n*   **Cohorts:** Definition and management of user cohorts based on properties and behaviors.\n*   **Plugins:** Installation, configuration, and management of plugins to extend PostHog functionality.\n*   **Data Visualization:** Customizable color themes for data visualization.\n*   **Group Analytics:** Analysis of data based on groups (e.g., organizations, instances, projects).\n*   **Revenue Tracking:** Configuration for tracking revenue events and data warehouse tables.\n*   **Access Control:** Fine-grained control over access to features and data.\n*   **Onboarding:** Guided onboarding experience with tasks and progress tracking.\n*   **Live Events:** Real-time display of events with customizable columns.\n*   **User Interface Customization:** Theme settings for the user interface.\n*   **Personalization:** Display names for people based on properties.\n*   **Data Correlation:** Configuration to exclude certain events and properties from correlation analysis.\n"
    },
    {
        "path": "frontend/src/lib/logic",
        "summary": "The provided code snippets detail the implementation of several Kea logic modules that enhance the application's functionality and user experience. These modules manage API status, user preferences, and feature flags, contributing to a more robust and customizable application. The `apiStatusLogic` ensures the application gracefully handles API errors and authentication requirements, while `userPreferencesLogic` allows users to personalize their experience by controlling the visibility of data elements. Finally, `featureFlagLogic` enables dynamic feature management and usage tracking, providing valuable insights into feature adoption and allowing for remote configuration changes.\n\nHere's a list of high-level product features enabled by these modules:\n\n*   Internet Connection Issue Detection\n*   Time-Sensitive Authentication Handling\n*   Unauthorized Access Handling\n*   API Error Monitoring\n*   Hide PostHog Properties in Tables\n*   Hide Null Values\n*   Persistent User Preferences\n*   Feature Flag Management\n*   Persisted Feature Flags\n*   Feature Flag Usage Tracking\n*   Dynamic Feature Flag Updates\n*   Environment-Specific Feature Flags\n"
    },
    {
        "path": "frontend/src/lib/utils/regexp.ts",
        "summary": "The provided code defines a utility function `isValidRegexp` that checks if a given string is a valid regular expression. It attempts to create a new `RegExp` object from the input string. If the creation is successful, it returns `true`; otherwise, it catches the exception and returns `false`.\n\nHere's a list of high-level product features that can be derived from this code:\n\n*   **Regular Expression Validation:** Allows users to validate if a given string is a valid regular expression.\n*   **Error Handling:** Gracefully handles invalid regular expression strings without crashing the application.\n*   **Input Sanitization:** Can be used as part of input sanitization to prevent potential security vulnerabilities related to malformed regular expressions.\n"
    },
    {
        "path": "frontend/src/lib/utils/kea-logic-builders.ts",
        "summary": "This code defines a utility function `permanentlyMount` for the Kea framework. This function ensures that a Kea logic is mounted and remains mounted throughout the application's lifecycle, preventing it from being unmounted and re-mounted unnecessarily. This is achieved by using the `afterMount` lifecycle hook and a cache to track whether the logic has already been permanently mounted.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Persistent Logic Mounting:** Ensures that specific Kea logics remain mounted throughout the application's lifecycle.\n*   **Performance Optimization:** Prevents unnecessary mounting and unmounting of frequently used logics, improving application performance.\n*   **Simplified Logic Management:** Provides a convenient way to manage the lifecycle of critical Kea logics.\n"
    },
    {
        "path": "frontend/src/lib/utils/css-classes.ts",
        "summary": "This code defines a utility function `cn` that simplifies the process of combining and managing CSS class names in a React project. It leverages the `clsx` and `tailwind-merge` libraries to conditionally apply class names and resolve conflicts between Tailwind CSS classes, ensuring a clean and efficient way to style components.\n\nHere's a list of high-level product features enabled by this utility:\n\n*   **Conditional Class Application:** Allows developers to easily apply CSS classes based on component state or props.\n*   **Tailwind CSS Conflict Resolution:** Automatically resolves conflicts between Tailwind CSS classes, preventing unexpected styling issues.\n*   **Simplified Class Management:** Provides a single, consistent way to combine and manage CSS classes throughout the project.\n*   **Improved Code Readability:** Makes it easier to understand which CSS classes are being applied to a component.\n"
    },
    {
        "path": "frontend/src/lib/utils/wrapConsole.ts",
        "summary": "This code provides a utility function `wrapConsole` that allows intercepting and conditionally executing console log, warn, and error messages. It wraps the original console methods, executes a provided filter function `fn` with the console arguments, and only calls the original console method if the filter function returns true. This prevents infinite recursion by using a flag `inWrap`. The function returns another function that restores the original console method.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Conditional Logging:** Allows developers to selectively display console messages based on custom criteria.\n*   **Console Interception:** Provides a mechanism to intercept and modify console output before it's displayed.\n*   **Customizable Logging Filters:** Enables the creation of custom filters to control which console messages are displayed.\n*   **Safe Wrapping:** Prevents infinite recursion when intercepting console messages.\n*   **Console Restoration:** Provides a way to restore the original console methods after interception.\n"
    },
    {
        "path": "frontend/src/lib/utils/concurrencyController.ts",
        "summary": "The `ConcurrencyController` class manages the concurrent execution of asynchronous functions, limiting the number of functions running at any given time. It uses a priority queue to order the execution of functions, allowing higher priority functions to run before lower priority ones. The controller also supports aborting functions using `AbortController`, and dynamically adjusting the concurrency limit.\n\nHere's a list of high-level product features provided by the `ConcurrencyController`:\n\n*   **Concurrency Limiting:** Restricts the number of concurrently running asynchronous functions.\n*   **Priority Queueing:** Orders function execution based on assigned priority.\n*   **Abort Support:** Allows cancellation of queued or running functions via `AbortController`.\n*   **Dynamic Concurrency Limit Adjustment:** Enables modification of the concurrency limit at runtime.\n*   **Error Handling:** Catches and handles errors within the executed functions, preventing cascading failures.\n"
    },
    {
        "path": "frontend/src/lib/utils/file-utils.ts",
        "summary": "The `file-utils.ts` file provides utility functions for handling file interactions in a web application. It includes functionality to programmatically trigger a file selection dialog, allowing users to select one or more files of a specific content type. It also provides a function to read the content of a selected file as text.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **File Selection:** Allows users to select files from their local file system through a standard file selection dialog.\n*   **Content Type Filtering:** Restricts file selection to specific content types (e.g., images, text files).\n*   **Multiple File Selection:** Supports the selection of multiple files simultaneously.\n*   **Text File Reading:** Enables reading the content of a text file into a string format for further processing.\n"
    },
    {
        "path": "frontend/src/lib/utils/d3Utils.ts",
        "summary": "This code provides a set of utility functions for working with the D3.js library, specifically tailored for data visualization within a React application. It includes functions for efficiently creating or selecting existing DOM elements within a D3 container, animating D3 selections with configurable transitions, and wrapping text within a specified width to prevent overflow, enhancing the readability of labels in charts and graphs.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dynamic Element Management:** Efficiently manage and reuse D3 elements within a visualization.\n*   **Animated Transitions:** Animate changes in D3 visualizations for smoother user experience.\n*   **Text Wrapping:** Automatically wrap long text labels to fit within defined boundaries, improving readability.\n*   **Customizable Text Alignment:** Control the horizontal alignment of wrapped text.\n"
    },
    {
        "path": "frontend/src/lib/utils/event-property-utls.tsx",
        "summary": "This code provides utility functions and React components for extracting and displaying autocaptured images from a list of DOM elements. It includes a function to find an image element within a list of elements and extract its source, width, and height attributes. There are also React components to display the extracted image in different sizes and contexts, including a full-size preview and a smaller preview with a tooltip.\n\nHere's a list of high-level product features:\n\n*   **Autocaptured Image Extraction:** Extracts image source, width, and height from a list of DOM elements.\n*   **Full-Size Image Preview:** Displays the autocaptured image in a full-size preview component.\n*   **Tooltip Image Preview:** Displays a smaller version of the image with a tooltip showing the full-size image.\n*   **Image Display Component:** Reusable component for displaying images with configurable height and width.\n"
    },
    {
        "path": "frontend/src/lib/utils/deleteWithUndo.tsx",
        "summary": "This code provides two functions, `deleteWithUndo` and `deleteInsightWithUndo`, that implement a soft delete mechanism with an undo option for generic objects and query-based insights, respectively. Both functions update the `deleted` field of an object via an API call and display a toast notification to the user, indicating whether the object was deleted or restored. The toast includes an \"Undo\" button that allows the user to revert the deletion. The `deleteInsightWithUndo` function is specifically tailored for `QueryBasedInsightModel` objects.\n\nHere's a list of high-level product features:\n\n*   **Soft Delete:** Allows users to \"delete\" objects without permanently removing them from the database.\n*   **Undo Deletion:** Provides an option to restore deleted objects.\n*   **Toast Notifications:** Displays informative messages to the user upon deletion or restoration, including an undo option.\n*   **Generic Object Support:** The `deleteWithUndo` function can be used with various object types.\n*   **Insight-Specific Deletion:** The `deleteInsightWithUndo` function is specifically designed for query-based insights.\n"
    },
    {
        "path": "frontend/src/lib/utils/definitions.ts",
        "summary": "The code defines a utility function `isDefinitionStale` that determines if an event or property definition is considered stale based on its `last_seen_at` timestamp. It compares the difference between the current time and the `last_seen_at` time in seconds against a constant `STALE_EVENT_SECONDS`. If the difference exceeds this threshold, the function returns `true`, indicating that the definition is stale; otherwise, it returns `false`.\n\nHere's a list of high-level product features that could utilize this code:\n\n*   **Data Staleness Indicator:** Visually indicate in the UI when an event or property definition is considered stale, prompting users to review or update it.\n*   **Automated Definition Cleanup:** Automatically archive or delete stale event and property definitions to maintain data hygiene.\n*   **Stale Definition Alerting:** Notify users when event or property definitions become stale, ensuring data quality and relevance.\n*   **Definition Usage Tracking:** Track the usage of event and property definitions to identify and prioritize definitions that are actively used.\n"
    },
    {
        "path": "frontend/src/lib/utils/apiHost.ts",
        "summary": "This code defines two functions, `apiHostOrigin` and `liveEventsHostOrigin`, which determine the correct origin for API requests and live events, respectively, based on the application's origin. It handles specific cases for US and EU PostHog instances, as well as development environments, ensuring that API calls and live event streams are directed to the appropriate backend services. The `liveEventsHostOrigin` function also checks for a `livestream_host` value in the application context, falling back to a default localhost address if not found.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Regional Data Hosting:** Supports different API and live event origins based on the region (US, EU).\n*   **Development Environment Support:** Provides specific origins for development and Storybook environments.\n*   **Live Event Streaming:** Configures the origin for live event streams, allowing real-time data visualization.\n*   **Customizable Live Stream Host:** Allows overriding the default live stream host via application context.\n"
    },
    {
        "path": "frontend/src/lib/utils/permissioning.ts",
        "summary": "This code defines utility functions for managing user permissions and access levels within an organization and its teams. The primary function, `getReasonForAccessLevelChangeProhibition`, determines if a user is allowed to change another member's access level, returning a reason if the change is prohibited. It considers the current user's membership level, the target member's effective level, and the intended new level. The code also includes mappings and arrays for organization and team membership levels, facilitating the display and management of these levels in the user interface.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Role-Based Access Control (RBAC):** Defines and enforces different levels of access (member, admin, owner) within an organization and its teams.\n*   **Permission Management:** Allows administrators and owners to modify the access levels of other members.\n*   **Access Level Change Restrictions:** Implements rules to prevent unauthorized or illogical changes to access levels (e.g., preventing a user from changing their own level, or setting a level higher than their own).\n*   **User Interface Support:** Provides data structures (maps and arrays) to easily display and manage membership levels in the user interface.\n*   **Team-Specific Permissions:** Supports different membership levels and permissions within individual teams.\n"
    },
    {
        "path": "frontend/src/lib/utils/stringWithWBR.tsx",
        "summary": "This code defines a function `stringWithWBR` that takes a string as input and returns a JSX element. The function intelligently inserts `<wbr>` (word break opportunity) tags into the string to allow for line breaks at appropriate places, preventing long words or strings from overflowing their containers. It splits the string based on a character limit (`splitAt`) and also after specific characters like commas, periods, forward slashes, and backslashes. It also handles natural splits like spaces and hyphens, resetting the character count after these. If the input string is empty, it returns a JSX element displaying \"(empty string)\".\n\nHere's a list of high-level product features:\n\n*   **Automatic Word Break Insertion:** Inserts `<wbr>` tags into strings to enable line breaks within words or long strings.\n*   **Configurable Split Length:** Allows setting a maximum character length (`splitAt`) before inserting a `<wbr>` tag.\n*   **Character-Based Splitting:** Inserts `<wbr>` tags after specific characters (e.g., commas, periods, slashes).\n*   **Natural Split Handling:** Recognizes spaces and hyphens as natural split points and resets the character count.\n*   **Empty String Handling:** Displays a specific message when the input string is empty.\n"
    },
    {
        "path": "frontend/src/lib/utils/geography/currency.ts",
        "summary": "This code defines data structures for handling currency information, including mappings from currency codes to their full names and corresponding emoji flags. It also includes a list of disabled currencies with reasons for their disabled status. This information can be used to support features related to currency selection, display, and validation within an application.\n\nHere's a list of high-level product features that can be built using this code:\n\n*   **Currency Selection:** Allows users to select their preferred currency from a comprehensive list.\n*   **Currency Display:** Displays currency names and symbols (flags/emojis) in a user-friendly manner.\n*   **Currency Validation:** Ensures that only supported and enabled currencies are used in transactions or settings.\n*   **Regionalization:** Adapts the application's currency settings based on the user's geographic location.\n*   **Historical Currency Support:** Provides information about currencies that are no longer in use, along with the reasons for their discontinuation.\n*   **Cryptocurrency Support:** Includes support for cryptocurrencies like Bitcoin, allowing users to transact or view balances in these currencies.\n"
    },
    {
        "path": "frontend/src/lib/utils/router-utils.ts",
        "summary": "This code provides a set of utility functions for managing URL paths within a web application, specifically focusing on handling project IDs in the URL structure. It allows for adding, removing, and manipulating project IDs in paths, ensuring correct routing and navigation between different projects and resources. The code also handles special cases for certain paths, such as those related to settings or onboarding, where specific redirection or path preservation logic is applied when switching between projects.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Project-Specific Routing:** Enables navigation and access to resources within a specific project context.\n*   **Project Switching:** Facilitates seamless switching between different projects while maintaining context or redirecting to appropriate locations.\n*   **URL Management:** Provides tools to manipulate URLs by adding or removing project and flag IDs.\n*   **Contextual Navigation:** Adapts navigation behavior based on the current path and project context, ensuring a consistent user experience.\n*   **Consistent URL Structure:** Enforces a consistent URL structure across the application, improving maintainability and predictability."
    },
    {
        "path": "frontend/src/lib/utils/cssEscape.ts",
        "summary": "The `cssEscape` function is a utility that takes a string as input and returns a CSS-escaped version of that string. This is crucial for ensuring that strings used as CSS selectors or other CSS values do not cause parsing errors or unexpected behavior due to special characters. The function handles various edge cases, including null characters, control characters, characters that would be invalid as the first character of a CSS identifier, and characters outside the basic ASCII range. It essentially sanitizes strings for safe use within CSS.\n\nHere's a list of high-level features provided by the code:\n\n*   **CSS Identifier Escaping:** Escapes characters that are invalid or have special meaning in CSS identifiers, ensuring compatibility and preventing parsing errors.\n*   **Unicode Handling:** Correctly handles Unicode characters, including those outside the basic ASCII range, by either including them directly or escaping them as needed.\n*   **Null Character Replacement:** Replaces null characters (U+0000) with the Unicode replacement character (U+FFFD).\n*   **Control Character Escaping:** Escapes control characters (U+0001 to U+001F) and the delete character (U+007F).\n*   **First Character Validation:** Applies special escaping rules to the first and second characters of the string, particularly when they are digits or a hyphen.\n"
    },
    {
        "path": "frontend/src/lib/utils/elements-chain.ts",
        "summary": "This code defines a function `chainToElements` that parses a string representation of an element chain into an array of structured `ElementType` objects. The function splits the chain string into individual element strings, then extracts the tag name, classes, and attributes from each element string. It populates an `ElementType` object with this information, including handling specific attributes like `href`, `nth-child`, `nth-of-type`, `text`, and `attr_id`. The function also includes error handling, with an option to throw errors or silently fail.\n\nHere's a list of high-level features provided by the code:\n\n*   **Element Chain Parsing:** Converts a string representation of an element chain into a structured array of element objects.\n*   **Tag Name Extraction:** Identifies and extracts the tag name from each element string.\n*   **Class Extraction:** Extracts CSS classes associated with each element.\n*   **Attribute Parsing:** Parses attributes from the element string, including standard HTML attributes and custom attributes.\n*   **Specific Attribute Handling:** Handles specific attributes like `href`, `nth-child`, `nth-of-type`, `text`, and `attr_id` by assigning them to dedicated properties on the `ElementType` object.\n*   **Error Handling:** Provides an option to throw errors or silently fail during parsing.\n*   **Order Preservation:** Preserves the order of elements in the chain.\n"
    },
    {
        "path": "frontend/src/lib/utils/copyToClipboard.tsx",
        "summary": "This code provides a utility function `copyToClipboard` that copies a given string value to the user's clipboard. It first attempts to use the modern `navigator.clipboard` API, displaying a warning toast if the API is unavailable (e.g., not on HTTPS or localhost). If the API call succeeds, it displays a success toast with a copy icon. If the API fails, it falls back to an older method using a temporary textarea element. If both methods fail, it displays an error toast. The function returns a boolean indicating whether the copy operation was successful.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Copy to Clipboard Functionality:** Allows users to copy text or other data to their clipboard.\n*   **Clipboard API Support:** Leverages the modern `navigator.clipboard` API for copying.\n*   **HTTPS/Localhost Check:** Verifies that the clipboard API is available (HTTPS or localhost).\n*   **Fallback Mechanism:** Implements a fallback using a textarea element for environments where the clipboard API is not supported.\n*   **Success/Error Notifications:** Provides visual feedback to the user via toast notifications indicating whether the copy operation was successful or not.\n*   **Descriptive Copy Messages:** Displays a descriptive message in the toast notification indicating what was copied (e.g., \"Copied text to clipboard\").\n*   **Visual Copy Icon:** Includes a copy icon in the success toast notification.\n"
    },
    {
        "path": "frontend/src/lib/utils/semver.ts",
        "summary": "This code provides utilities for parsing, comparing, and manipulating semantic version strings. It includes functions to parse a version string into a structured `SemanticVersion` object, compare two versions to determine the type and magnitude of their difference, and find the lowest or highest version from a list. Additionally, it offers functions to check if two versions are equal, convert a `SemanticVersion` object back into a string, and create a version checker function that determines if a given version meets or exceeds a required version.\n\nHere's a list of high-level product features based on the code:\n\n*   **Semantic Version Parsing:** Converts a semantic version string (e.g., \"1.2.3\", \"v2.0\", \"3.1.0-beta\") into a structured object with major, minor, patch, and extra (prerelease) components.\n*   **Semantic Version Comparison:** Compares two semantic versions and determines the type (major, minor, patch, extra) and magnitude of the difference between them.\n*   **Version Ordering:** Determines the lowest and highest versions from a list of semantic versions.\n*   **Version Equality Check:** Checks if two semantic versions are equal.\n*   **Semantic Version String Conversion:** Converts a structured `SemanticVersion` object back into a string representation.\n*   **Version Checker:** Creates a function that checks if a given version meets or exceeds a required version.\n"
    },
    {
        "path": "frontend/src/lib/utils/geography/country.ts",
        "summary": "This code provides utility functions and data mappings for handling country and language codes. It includes functions to convert ISO 3166-1 alpha-2 country codes and ISO 639 language codes to their corresponding flag emojis. It also contains data structures mapping country codes to long names and language codes to their names, as well as a specific mapping for certain language codes to flag emojis when a direct country code conversion isn't suitable.\n\nHere's a list of high-level product features that could utilize this code:\n\n*   **Geolocation Support:** Determine a user's country based on their IP address or other location data and display the corresponding flag.\n*   **Language Selection:** Allow users to select their preferred language, displaying the appropriate flag alongside each language option.\n*   **Internationalization (i18n):**  Format dates, numbers, and currencies according to the user's locale, using the country and language data to ensure correct formatting.\n*   **Content Localization:**  Serve different content based on the user's country or language.\n*   **User Interface Localization:** Translate the user interface into the user's preferred language.\n*   **Data Visualization:** Display country flags in charts, maps, or other data visualizations.\n*   **Profile Settings:** Allow users to specify their country and language in their profile settings.\n*   **Form Validation:** Validate user-entered country and language codes.\n*   **Address Formatting:** Format addresses according to the conventions of the user's country.\n*   **Currency Conversion:** Convert currencies based on the user's location."
    },
    {
        "path": "frontend/src/lib/utils/product-intents.ts",
        "summary": "This code defines a system for tracking user intents within a product, particularly focusing on onboarding, feature discovery, and cross-selling between different product areas. It uses enums to define specific contexts in which a user might express intent (e.g., selecting a product during onboarding, creating an experiment, viewing recordings from an action). The code provides functions to record these intents, including metadata, and distinguishes between general product intents and cross-sell intents (where a user's action in one product area indicates interest in another). The recorded intents are sent to the backend via the `api.productIntents.update` call.\n\nHere's a list of high-level product features based on the code:\n\n*   **Product Intent Tracking:** Captures user actions and context to understand their goals and interests within the product.\n*   **Onboarding Guidance:** Tracks product selection during onboarding to tailor the user experience.\n*   **Cross-Sell Recommendations:** Identifies opportunities to suggest related product features based on user behavior.\n*   **Feature Discovery:** Tracks user interactions with specific features to understand adoption and identify areas for improvement.\n*   **Contextual Help & Empty State Guidance:** Provides relevant guidance and suggestions based on the user's current context (e.g., empty states in the SQL editor or taxonomic filter).\n*   **Experimentation Tracking:** Records the creation of experiments to understand user engagement with A/B testing.\n*   **Error Tracking Insights:** Tracks user interactions with error tracking features to understand adoption and identify areas for improvement.\n*   **Web Analytics Insights:** Tracks user interactions with web analytics features to understand adoption and identify areas for improvement.\n*   **Recording View Tracking:** Tracks when users view recordings from various contexts (actions, persons, feature flags, early access features).\n"
    },
    {
        "path": "frontend/src/lib/utils/geography",
        "summary": "The provided code defines data structures and utility functions for handling currency, country, and language information, including mappings to names and corresponding flag emojis. This enables a range of features focused on internationalization, localization, and user preference settings. The system supports currency selection and display, geolocation, language selection, and content localization, allowing for a user experience tailored to specific regions and languages.\n\nHere's a list of high-level product features:\n\n*   Currency Selection & Display\n*   Currency Validation\n*   Geolocation Support\n*   Language Selection\n*   Internationalization (i18n)\n*   Content Localization\n*   User Interface Localization\n*   Profile Settings (Country & Language)\n"
    },
    {
        "path": "frontend/src/lib/utils/getAppContext.ts",
        "summary": "This code defines utility functions to access application context information stored in the `window.POSTHOG_APP_CONTEXT` global variable. It provides functions to retrieve the entire application context, the default event name and label, the current team ID, and the current organization ID. These functions are crucial for accessing configuration and user-specific data within the frontend application, especially in scenarios where changes to team or organization IDs trigger full page reloads.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Access to Application Context:** Provides a centralized way to access application-wide configuration and data.\n*   **Default Event Tracking Configuration:** Allows setting a default event name (e.g., PageView, Screen) for tracking user activity.\n*   **Team and Organization Awareness:** Enables the application to identify the current team and organization the user is working within.\n*   **Error Handling:** Includes error handling to ensure that team and organization IDs are available when needed, providing informative error messages if they are missing.\n"
    },
    {
        "path": "frontend/src/lib/utils/eventUsageLogic.ts",
        "summary": "This code defines a Kea logic module named `eventUsageLogic` responsible for tracking user interactions and events within the PostHog application. It includes actions for reporting various user activities, such as viewing person details, creating and saving insights, interacting with dashboards, updating settings, and more. The logic connects to other Kea logics like `preflightLogic` and `userLogic` to access relevant data. The module also includes helper functions for sanitizing query data and extracting properties for experiment metrics. The tracked events are intended to provide insights into user behavior and product usage.\n\nHere's a list of high-level product features that are tracked by this logic:\n\n*   **Person Management:** Tracking viewing of person details and interactions with the persons modal.\n*   **Insight Creation and Management:** Reporting the creation, saving, viewing, and filtering of insights.\n*   **Funnel Analysis:** Tracking funnel calculations, step reordering, and correlation analysis.\n*   **Dashboard Interaction:** Monitoring dashboard views, mode toggling, refreshing, date range changes, pinning, sharing, and front-end updates.\n*   **Experiment Tracking:** Capturing data related to experiments, including metrics and parameters.\n*   **Account Settings:** Reporting updates to test account filters, timezone settings, and other account-level configurations.\n*   **Project Management:** Tracking project creation and dismissal of project notices.\n*   **Session Recording:** Tracking session recording usage.\n*   **General UI Interactions:** Reporting actions like opening the property select and toggling whitelabeling.\n*   **Time to See Data:** Reporting the time it takes for users to see data.\n*   **Property Management:** Tracking the addition, updating, and removal of person and group properties.\n"
    },
    {
        "path": "frontend/src/lib/utils",
        "summary": "This collection of code utilities enables a wide range of product features, from managing user permissions and tracking user intents to providing a seamless user experience through clipboard functionality, CSS management, and data visualization tools. The utilities also focus on internationalization, data staleness, and robust error handling, ensuring a reliable and user-friendly application. Furthermore, the code includes features for tracking user interactions and events, providing valuable insights into product usage and user behavior.\n\nHere's a list of high-level product features enabled by these utilities:\n\n*   **Role-Based Access Control (RBAC)**\n*   **Permission Management**\n*   **Product Intent Tracking**\n*   **Onboarding Guidance**\n*   **Cross-Sell Recommendations**\n*   **Feature Discovery**\n*   **Contextual Help & Empty State Guidance**\n*   **Experimentation Tracking**\n*   **Error Tracking Insights**\n*   **Web Analytics Insights**\n*   **Recording View Tracking**\n*   **Copy to Clipboard Functionality**\n*   **Conditional Class Application**\n*   **Tailwind CSS Conflict Resolution**\n*   **Autocaptured Image Extraction**\n*   **Regular Expression Validation**\n*   **Concurrency Limiting**\n*   **CSS Identifier Escaping**\n*   **Animated Transitions**\n*   **Text Wrapping**\n*   **Persistent Logic Mounting**\n*   **Regional Data Hosting**\n*   **Live Event Streaming**\n*   **File Selection**\n*   **Project-Specific Routing**\n*   **Data Staleness Indicator**\n*   **Element Chain Parsing**\n*   **Semantic Version Parsing**\n*   **Soft Delete**\n*   **Undo Deletion**\n*   **Conditional Logging**\n*   **Automatic Word Break Insertion**\n*   **Currency Selection & Display**\n*   **Geolocation Support**\n*   **Language Selection**\n*   **User Interaction Tracking**\n*   **Access to Application Context**\n*   **Team and Organization Awareness**\n"
    },
    {
        "path": "frontend/src/lib/integrations/linkedInAdsIntegrationLogic.ts",
        "summary": "This code defines a Kea logic module for integrating with LinkedIn Ads. It manages the loading and storage of LinkedIn Ads conversion rules and ad accounts, fetching them from the PostHog API based on a provided integration ID. The logic module provides actions to trigger the loading of these resources and stores the fetched data in its state.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Fetch LinkedIn Ads Conversion Rules:** Allows retrieving conversion rules associated with a specific LinkedIn Ads account.\n*   **Fetch LinkedIn Ads Accounts:** Enables fetching a list of LinkedIn Ads accounts associated with the integration.\n*   **Data Storage:** Stores the fetched conversion rules and ad accounts in the logic module's state for easy access.\n*   **API Integration:** Communicates with the PostHog API to retrieve LinkedIn Ads data.\n"
    },
    {
        "path": "frontend/src/lib/integrations/googleAdsIntegrationLogic.ts",
        "summary": "This code defines a Kea logic module named `googleAdsIntegrationLogic` responsible for fetching and managing data related to Google Ads integrations. It provides functionality to load Google Ads conversion actions and accessible accounts for a specific integration, identified by its ID. The logic uses API calls to retrieve this data and stores it in Kea loaders for easy access and management within the application.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Fetch Google Ads Conversion Actions:** Allows retrieving a list of conversion actions associated with a specific Google Ads customer and parent account.\n*   **Fetch Google Ads Accessible Accounts:** Enables fetching a list of Google Ads accounts accessible to the integration, including their IDs, levels, parent IDs, and names.\n*   **Data Management:** Provides a structured way to manage and access the fetched Google Ads data within the application using Kea loaders.\n"
    },
    {
        "path": "frontend/src/lib/integrations/IntegrationScopesWarning.tsx",
        "summary": "This component, `IntegrationScopesWarning`, displays a warning banner if an integration is missing required scopes. It compares the scopes configured for an integration against a schema defining the required scopes. If there are missing scopes, it renders a LemonBanner with an error message listing the missing scopes and a link to reconnect the integration. For HubSpot integrations, it also includes a note about potential feature limitations due to the HubSpot plan and a link to HubSpot's scopes documentation.\n\nHere's a list of high-level product features:\n\n*   **Scope Validation:** Checks if an integration has all the necessary scopes.\n*   **Warning Banner:** Displays an error banner when required scopes are missing.\n*   **Reconnect Link:** Provides a direct link to re-authorize the integration with the correct scopes.\n*   **HubSpot Specific Guidance:** Offers specific guidance and documentation links for HubSpot integrations regarding scopes and plan limitations.\n"
    },
    {
        "path": "frontend/src/lib/integrations/GoogleAdsIntegrationHelpers.tsx",
        "summary": "This code provides React components for selecting Google Ads Customer IDs and Conversion Actions within a PostHog integration. It uses LemonInputSelect components to display options fetched from the Google Ads API via the `googleAdsIntegrationLogic`. The components handle loading states, formatting of IDs, and passing selected values to a parent component through an `onChange` prop. The Customer ID picker fetches a list of accessible Google Ads accounts, while the Conversion Action picker fetches conversion actions based on a selected Customer ID.\n\nHere's a list of high-level product features:\n\n*   **Google Ads Customer ID Selection:** Allows users to select a Google Ads Customer ID from a list of accessible accounts.\n*   **Google Ads Conversion Action Selection:** Enables users to choose a specific Google Ads Conversion Action associated with a selected Customer ID.\n*   **Dynamic Option Loading:** Fetches Google Ads accounts and conversion actions from the Google Ads API on demand.\n*   **Loading State Management:** Displays loading indicators while fetching data from the Google Ads API.\n*   **ID Formatting:** Formats Google Ads Customer IDs for improved readability.\n*   **Integration with PostHog:** Designed to be used within a PostHog integration to configure Google Ads connections.\n"
    },
    {
        "path": "frontend/src/lib/integrations/IntegrationView.tsx",
        "summary": "The `IntegrationView` component in the PostHog frontend displays information about a connected integration. It shows the integration's icon, display name, and update information (user and timestamp). It also handles displaying errors related to the integration, such as authentication failures, and provides a \"Reconnect\" button to re-authorize the integration. Additionally, it renders a warning message related to integration scopes based on the integration's configuration and schema.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Integration Status Display:** Shows whether an integration is connected and functioning correctly.\n*   **Integration Identification:** Displays the integration's icon and display name for easy identification.\n*   **Update History:** Shows when and by whom the integration was last updated.\n*   **Error Handling:** Displays error messages related to the integration, such as authentication failures.\n*   **Reconnection Flow:** Provides a button to re-authorize the integration in case of errors.\n*   **Scope Warnings:** Displays warnings related to the integration's scopes and permissions.\n"
    },
    {
        "path": "frontend/src/lib/integrations/slackIntegrationLogic.ts",
        "summary": "This code defines a Kea logic module named `slackIntegrationLogic` responsible for managing and retrieving Slack channel information for a specific integration identified by its `id`. It fetches all available Slack channels and individual channels by ID from the PostHog API, stores them in the logic's state, and provides selectors to access and process this data. The logic also determines if PostHog is a member of a given Slack channel. It also connects to the preflight logic to check for site URL misconfigurations.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Fetch All Slack Channels:** Retrieves a list of all Slack channels associated with a specific integration.\n*   **Fetch Slack Channel by ID:** Retrieves details for a specific Slack channel using its ID.\n*   **Slack Channel Membership Check:** Determines if the PostHog integration is a member of a given Slack channel.\n*   **Data Management:** Stores and manages fetched Slack channel data in the logic's state.\n*   **Preflight Check Integration:** Checks for site URL misconfigurations that might affect the Slack integration.\n"
    },
    {
        "path": "frontend/src/lib/integrations/LinkedInIntegrationHelpers.tsx",
        "summary": "This code provides React components for selecting LinkedIn Ads accounts and conversion rules within a PostHog integration. It uses LemonInputSelect components from `@posthog/lemon-ui` and leverages `kea` for state management and actions. The components fetch and display options for LinkedIn Ads accounts and conversion rules, allowing users to select them. The `LinkedInAdsConversionRulePicker` component conditionally loads conversion rules based on a required field value, while the `LinkedInAdsAccountIdPicker` loads account data when the component is not disabled. Both components handle loading states and display appropriate placeholders or existing values.\n\nHere's a list of high-level product features:\n\n*   **LinkedIn Ads Account Selection:** Allows users to select a LinkedIn Ads account from a dropdown list.\n*   **LinkedIn Ads Conversion Rule Selection:** Enables users to choose a specific LinkedIn Ads conversion rule.\n*   **Dynamic Loading of Options:** Fetches LinkedIn Ads accounts and conversion rules dynamically from the LinkedIn Ads API.\n*   **Loading State Management:** Displays a loading indicator while fetching data from the LinkedIn Ads API.\n*   **Conditional Loading of Conversion Rules:** Loads conversion rules based on the value of another field.\n*   **Disabling Selection:** Allows disabling the selection components based on certain conditions.\n*   **Integration with PostHog:** Designed to be used within a PostHog integration context.\n*   **Display Account and Conversion Rule Information:** Displays the name and ID of each account and conversion rule in the dropdown options.\n"
    },
    {
        "path": "frontend/src/lib/integrations/integrationsLogic.ts",
        "summary": "This code defines the logic for managing integrations within the application. It handles fetching, creating, updating, and deleting integrations with various services like Slack, Salesforce, Google Cloud, and others. The logic also manages OAuth callbacks, handles Google Cloud key uploads, and provides selectors for filtering and checking the availability of specific integrations like Slack. It uses `kea` for state management, `kea-loaders` for asynchronous data loading, and `kea-router` for handling URL-based actions.\n\nHere's a list of high-level product features based on the code:\n\n*   **Integration Management:** Allows users to view, create, update, and delete integrations with third-party services.\n*   **OAuth Authentication:** Handles the OAuth flow for integrations, including callback processing and error handling.\n*   **Google Cloud Key Upload:** Enables users to upload Google Cloud keys for integrations requiring them.\n*   **Integration Status:** Displays the status and availability of different integrations.\n*   **Integration-Specific Configuration:** Allows users to configure integrations with specific settings.\n*   **Real-time Updates:** Updates the integration list and status in real-time after creation, deletion, or updates.\n*   **Error Handling:** Provides user-friendly error messages for integration failures.\n*   **Integration Filtering:** Allows users to filter integrations based on type (e.g., Slack).\n"
    },
    {
        "path": "frontend/src/lib/internalMetrics.ts",
        "summary": "This code defines functions for capturing and reporting telemetry data related to the time it takes for users to see data in the PostHog application. It includes functions to capture the time taken for dashboard and insight loading, as well as a wrapper around the `api.get` function to automatically track the time taken for API requests and report it as telemetry. The captured data includes information about the type of data being loaded, the context in which it's being loaded, the time taken, the status of the request, and the size of the API response. This data is sent to PostHog and Sentry for analysis and error tracking.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Performance Monitoring:** Tracks the time it takes for users to see data in different parts of the application (dashboards, insights, etc.).\n*   **Telemetry Reporting:** Sends performance data to PostHog for analysis and visualization.\n*   **Error Tracking:** Reports errors encountered during data loading to Sentry.\n*   **Session Tracking:** Includes session IDs in telemetry data for better user behavior analysis.\n*   **API Performance Analysis:** Measures the performance of API requests and includes response size in telemetry.\n*   **Data-driven Optimization:** Provides data to identify and address performance bottlenecks in the application.\n"
    },
    {
        "path": "frontend/src/lib/integrations/SlackIntegrationHelpers.tsx",
        "summary": "This code defines a React component, `SlackChannelPicker`, that allows users to select a Slack channel from a list of available channels for a given Slack integration. It fetches the list of channels using the `slackIntegrationLogic` Kea logic hook, displays them in a `LemonInputSelect` component, and handles cases where the channel list is not yet loaded or the user is not a member of the selected channel. It also provides a warning banner if the PostHog Slack App is not in the selected channel.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Slack Channel Selection:** Allows users to select a Slack channel from a list of available channels.\n*   **Dynamic Channel Loading:** Fetches and updates the list of available Slack channels dynamically.\n*   **Channel Membership Validation:** Checks if the PostHog Slack App is a member of the selected channel.\n*   **Warning Banner:** Displays a warning message if the PostHog Slack App is not in the selected channel.\n*   **Channel Name Display:** Displays the channel name with appropriate formatting (e.g., `#channel-name` for public channels, `🔒channel-name` for private channels).\n*   **External Channel Indication:** Indicates if a channel is externally shared with an icon.\n*   **Handles Channel ID Only:** Correctly displays the channel name even if only the channel ID is initially available.\n*   **Loading State:** Displays a loading indicator while fetching the list of Slack channels.\n*   **Empty State:** Displays a helpful message when no Slack channels are found, guiding the user to install the PostHog Slack App.\n"
    },
    {
        "path": "frontend/src/lib/api.ts",
        "summary": "This code defines a comprehensive API client for interacting with a PostHog instance. It provides a structured way to build API request URLs for various resources like organizations, projects, insights, plugins, actions, events, and more. The `ApiRequest` class acts as a builder, allowing developers to chain method calls to construct the desired endpoint URL. It also handles query parameters and CSRF token management. The code includes type definitions for API responses and request parameters, ensuring type safety when making API calls. It also defines error handling with the `ApiError` class.\n\nHere's a list of high-level product features that can be inferred from the API endpoints:\n\n*   **Organization Management:** Creating, retrieving, and managing organizations.\n*   **Project Management:** Creating, retrieving, and managing projects within an organization.\n*   **Environment Management:** Managing different environments (e.g., development, staging, production) for a project.\n*   **Insight Management:** Creating, retrieving, and managing insights (saved queries and visualizations).\n*   **File System:** Managing files and code snippets within a project.\n*   **Plugin Management:** Installing, configuring, and managing plugins to extend PostHog's functionality.\n*   **Action Management:** Defining and managing actions (user interactions) to track.\n*   **Comment Management:** Adding and managing comments on various resources.\n*   **Data Export:** Exporting data from PostHog.\n*   **Event Management:** Ingesting, retrieving, and managing events.\n*   **Event Definition Management:** Defining and managing event definitions.\n*   **Property Definition Management:** Defining and managing property definitions.\n*   **HogQL Function Management:** Creating, retrieving, and managing HogQL functions.\n*   **Feature Flag Management:** Managing feature flags to control feature releases.\n*   **Session Recording Management:** Managing session recordings for user behavior analysis.\n*   **Cohort Management:** Creating and managing cohorts of users based on specific criteria.\n*   **Data Warehouse Integration:** Connecting to and managing data warehouses.\n*   **Error Tracking:** Tracking and managing errors in the application.\n*   **Activity Log:** Viewing and managing activity logs for various resources.\n*   **Early Access Feature Management:** Managing early access features for organizations.\n*   **Notebooks:** Creating and managing notebooks for data analysis and collaboration.\n*   **Alerts:** Creating and managing alerts based on specific events or metrics.\n*   **Surveys:** Creating and managing surveys to collect user feedback.\n*   **Batch Exports:** Configuring and running batch exports of data.\n*   **Integrations:** Managing integrations with other services like Slack, Google Ads, and LinkedIn Ads.\n*   **User and Group Management:** Managing users, groups, and roles within an organization.\n*   **Personal API Keys:** Managing personal API keys for users.\n*   **Scheduled Changes:** Managing scheduled changes to feature flags and other configurations.\n*   **Sharing Configurations:** Managing sharing configurations for insights and other resources.\n*   **Subscriptions:** Managing subscriptions for users and organizations.\n"
    },
    {
        "path": "frontend/src/lib/integrations",
        "summary": "This collection of code snippets details the implementation of various integration features within the PostHog platform. These features enable users to connect PostHog with third-party services like Slack, Google Ads, and LinkedIn Ads, facilitating data sharing and workflow automation. The code includes components for selecting accounts, conversion actions, and channels, as well as logic for fetching data from external APIs, managing OAuth authentication, and displaying integration status and potential issues like missing scopes or authentication failures.\n\nHere's a list of high-level product features:\n\n*   **Third-Party Integrations:** Connect PostHog with services like Slack, Google Ads, LinkedIn Ads, and others.\n*   **Account and Channel Selection:** Allow users to select specific accounts, channels, and conversion actions within integrated services.\n*   **OAuth Authentication Management:** Handle the OAuth flow for authenticating and authorizing integrations.\n*   **Dynamic Data Loading:** Fetch data from external APIs on demand, such as Google Ads accounts and LinkedIn Ads conversion rules.\n*   **Integration Status Monitoring:** Display the status of integrations, including connection status, update history, and potential errors.\n*   **Scope Validation and Warnings:** Check if integrations have the necessary scopes and display warnings if scopes are missing.\n*   **Error Handling and Reconnection:** Provide error messages and a reconnection flow for failed integrations.\n*   **Integration Configuration:** Allow users to configure integrations with specific settings and options.\n"
    },
    {
        "path": "frontend/src/lib/components/HogQLEditor/HogQLEditor.tsx",
        "summary": "The `HogQLEditor` component provides an inline code editor for writing HogQL expressions. It features syntax highlighting, auto-focus, and the ability to execute the code with a keyboard shortcut (Cmd+Enter). The component also displays helpful placeholders and a link to the HogQL documentation. It includes a button to update the SQL expression and disables the button if no expression is entered.\n\nHere's a list of high-level product features:\n\n*   **Inline Code Editor:** Provides a space for users to write and edit HogQL expressions directly within the UI.\n*   **Syntax Highlighting:** Improves readability and helps identify errors in the HogQL code.\n*   **Auto-Focus:** Automatically focuses the editor on load for immediate input.\n*   **Keyboard Shortcut Execution:** Allows users to quickly execute the HogQL code using Cmd+Enter.\n*   **Dynamic Placeholders:** Displays context-aware examples and guidance for writing HogQL expressions.\n*   **HogQL Documentation Link:** Provides easy access to the HogQL documentation for learning and reference.\n*   **Update Button:** Allows users to save the entered HogQL expression.\n*   **Input Validation:** Disables the update button when no HogQL expression is entered.\n"
    },
    {
        "path": "frontend/src/lib/components/HogQLEditor",
        "summary": "The HogQLEditor component offers a user-friendly inline code editing experience for writing HogQL expressions directly within the application. It enhances productivity with features like syntax highlighting, auto-focus, and a keyboard shortcut for execution. To aid users in writing correct expressions, it provides dynamic placeholders and a direct link to the HogQL documentation. An update button allows saving the expression, with input validation ensuring that only valid expressions can be submitted.\n\nHere's a list of high-level product features:\n\n*   Inline Code Editor\n*   Syntax Highlighting\n*   Auto-Focus\n*   Keyboard Shortcut Execution\n*   Dynamic Placeholders\n*   HogQL Documentation Link\n*   Update Button\n*   Input Validation\n"
    },
    {
        "path": "frontend/src/lib/components/InsightLabel/index.tsx",
        "summary": "The `InsightLabel` component is a versatile React component designed to display information about insights, actions, and events in a user-friendly manner. It supports customization of colors, icons, and text formatting, and can display breakdown values, comparison values, and aggregation methods. The component leverages other components like `EntityFilterInfo`, `PropertyKeyInfo`, and `LemonTag` to present information clearly and concisely. It also includes logic for handling different aggregation types (total, unique, sum, etc.) and displaying them appropriately.\n\nHere's a list of high-level product features provided by the `InsightLabel` component:\n\n*   **Series Color Indication:** Displays a colored icon or letter to visually represent the series associated with the insight.\n*   **Action/Event Labeling:** Displays the name of the action or event being tracked, fetched from the backend.\n*   **Breakdown Value Display:** Shows the breakdown value used to segment the data.\n*   **Comparison Value Display:** Shows the value being compared against (e.g., previous period).\n*   **Aggregation Method Display:** Indicates the aggregation method used (e.g., total, unique, sum, average).\n*   **Customizable Icon Size and Style:** Allows customization of the size and style of the series color icon.\n*   **Text Wrapping:** Supports text wrapping for long labels, ensuring readability.\n*   **Clickable Label:** Provides an optional click handler for the inner label.\n*   **Pill-shaped Tags:** Displays breakdown and comparison values in pill-shaped tags.\n*   **Tooltip Support:** Provides tooltips for pill-shaped tags to display the full value when truncated.\n*   **Mid-ellipsis Text Truncation:** Truncates long text values in the middle to preserve context.\n*   **Customizable Pill Width:** Allows setting a maximum width for the pill-shaped tags.\n*   **HogQL Support:** Displays HogQL queries used for aggregation.\n*   **Unique Group Aggregation:** Displays unique group aggregations with proper pluralization.\n"
    },
    {
        "path": "frontend/src/lib/components/InsightLabel",
        "summary": "The `InsightLabel` component is a flexible React component that provides a clear and customizable way to display information about insights, actions, and events. It supports various features such as series color indication, action/event labeling, breakdown and comparison value display, and aggregation method indication. The component utilizes other components like `EntityFilterInfo`, `PropertyKeyInfo`, and `LemonTag` to present information concisely and offers customization options for icon size, style, text wrapping, and pill-shaped tag appearance, including tooltips and text truncation.\n\nHere's a list of high-level product features:\n\n*   Series Color Indication\n*   Action/Event Labeling\n*   Breakdown Value Display\n*   Comparison Value Display\n*   Aggregation Method Display\n*   Customizable Icon Size and Style\n*   Text Wrapping\n*   Clickable Label\n*   Pill-shaped Tags\n*   Tooltip Support\n*   Mid-ellipsis Text Truncation\n*   Customizable Pill Width\n*   HogQL Support\n*   Unique Group Aggregation\n"
    },
    {
        "path": "frontend/src/lib/components/PasswordStrength.tsx",
        "summary": "This code defines a React component called `PasswordStrength` that provides visual feedback on the strength of a user's password. It uses the `zxcvbn` library to estimate password strength and displays a progress bar with a color-coded indicator (red, yellow, green) based on the score. A tooltip provides a numerical score (out of 5) and suggestions for improving the password if it's weak. The `validatePassword` function encapsulates the password validation logic, including a custom check for minimum length.\n\nHere's a list of high-level product features:\n\n*   **Password Strength Estimation:** Uses the `zxcvbn` library to provide a score representing the password's strength.\n*   **Visual Strength Indicator:** Displays a color-coded progress bar to visually represent the password strength (red, yellow, green).\n*   **Numerical Strength Score:** Shows a numerical score (out of 5) to quantify the password's strength.\n*   **Password Improvement Suggestions:** Provides feedback and suggestions to the user on how to improve their password.\n*   **Minimum Length Enforcement:** Enforces a minimum password length of 8 characters.\n*   **Tooltip Display:** Displays detailed feedback and the score in a tooltip on hover.\n"
    },
    {
        "path": "frontend/src/lib/components/ScrollableShadows/ScrollableShadows.tsx",
        "summary": "The `ScrollableShadows` component is a React component that wraps its children in a scrollable container with visual cues (shadows) to indicate scrollability in a given direction (horizontal or vertical). It utilizes the `useScrollable` hook to determine when shadows should be displayed based on the scroll position. The component accepts props for customization, including class names for styling, a scroll reference, and accessibility attributes. It also supports styled scrollbars.\n\nHere's a list of high-level product features:\n\n*   **Scrollable Container:** Provides a container that enables scrolling of its content.\n*   **Directional Scrolling:** Supports both horizontal and vertical scrolling directions.\n*   **Scroll Indicator Shadows:** Displays shadows to visually indicate the presence of more content beyond the current view.\n*   **Dynamic Shadow Visibility:** Shadows appear and disappear based on the scroll position, indicating available scroll direction.\n*   **Customizable Styling:** Allows customization of the component's appearance through CSS class names.\n*   **Scroll Reference:** Provides a way to access the underlying scrollable element via a React ref.\n*   **Accessibility Support:** Includes accessibility attributes for improved usability.\n*   **Styled Scrollbars:** Offers the option to apply custom styling to the scrollbars.\n"
    },
    {
        "path": "frontend/src/lib/components/MemberSelect.tsx",
        "summary": "The `MemberSelect` component provides a user-friendly dropdown for selecting members, likely from an organization or team. It allows searching for members, excluding specific members from the selection, and displaying the selected member's name or a default label. The component utilizes Lemon UI components for styling and interactivity, and it integrates with the `membersLogic` to fetch and filter member data. It supports both UUID and ID as identifiers for members and handles cases where no member is selected.\n\nHere's a list of high-level features:\n\n*   **Member Selection:** Allows users to select a member from a dropdown list.\n*   **Searchable Member List:** Provides a search input to filter members by name.\n*   **Exclusion of Members:** Enables excluding specific members from the selectable list.\n*   **\"Any User\" Option:** Includes an option to select \"Any user\" or a similar default, representing no specific member.\n*   **Dynamic Display of Selected Member:** Displays the name of the selected member in the button or a custom display via children prop.\n*   **Loading State:** Shows a loading indicator while member data is being fetched.\n*   **No Results Display:** Displays a \"No matches\" or \"No users\" message when the search yields no results or no members are available.\n*   **Customizable Display:** Allows customization of the button's content via a `children` render prop.\n*   **Current User Identification:** Visually indicates the current user in the member list."
    },
    {
        "path": "frontend/src/lib/components/ScrollableShadows",
        "summary": "The `ScrollableShadows` React component enhances content presentation by providing a scrollable container with dynamic shadow indicators. These shadows appear and disappear based on the scroll position, visually signaling the availability of more content in either horizontal or vertical directions. The component is highly customizable through CSS class names, offers a scroll reference for direct access to the scrollable element, and includes accessibility attributes for improved usability. Furthermore, it supports styled scrollbars, allowing for a cohesive and visually appealing user experience.\n\nHere's a list of high-level product features:\n\n*   Scrollable Container\n*   Directional Scrolling (Horizontal and Vertical)\n*   Scroll Indicator Shadows\n*   Dynamic Shadow Visibility\n*   Customizable Styling (CSS Class Names)\n*   Scroll Reference\n*   Accessibility Support\n*   Styled Scrollbars\n"
    },
    {
        "path": "frontend/src/lib/components/BridgePage/BridgePage.tsx",
        "summary": "The `BridgePage` component provides a consistent layout for various pages within the application, offering flexibility through props that control the presence of a logo, a hedgehog graphic, a message associated with the hedgehog, and custom header/footer content. It uses CSS transitions to smoothly display the hedgehog message. The component adapts its layout based on whether it's displaying a side logo or not, and whether the content should be fixed width. It also conditionally renders a left container with either custom content or a hedgehog graphic, which varies based on the user's region (EU or non-EU).\n\nHere's a list of high-level product features provided by the `BridgePage` component:\n\n*   **Consistent Page Layout:** Provides a standardized structure for different pages.\n*   **Branding with Logo:** Displays a welcome logo, configurable for different views and mobile responsiveness.\n*   **Hedgehog Graphic:** Optionally displays a hedgehog graphic, with variations based on the user's region.\n*   **Informative Messages:** Supports displaying messages alongside the hedgehog graphic with CSS transitions.\n*   **Customizable Header and Footer:** Allows injection of custom header and footer content.\n*   **Flexible Content Width:** Offers a fixed-width or full-width layout option.\n*   **Left Container Customization:** Enables the addition of custom content to a left-side container.\n"
    },
    {
        "path": "frontend/src/lib/components/BridgePage",
        "summary": "The `BridgePage` component serves as a versatile layout template for various pages within the application, offering a consistent user experience while allowing for customization. It supports branding through a configurable logo, incorporates an optional hedgehog graphic with associated messages that transition smoothly, and enables the injection of custom header and footer content. The component adapts its layout based on the presence of a side logo and offers options for fixed or full-width content, along with a customizable left container that can display either custom content or a region-specific hedgehog graphic.\n\nHere's a list of high-level product features provided by the `BridgePage` component:\n\n*   Consistent Page Layout\n*   Branding with Logo\n*   Hedgehog Graphic (region-specific)\n*   Informative Messages (with transitions)\n*   Customizable Header and Footer\n*   Flexible Content Width\n*   Left Container Customization\n"
    },
    {
        "path": "frontend/src/lib/components/PropertiesTable/index.ts",
        "summary": "The code exports the `PropertiesTable` component, making it available for use in other parts of the application. This suggests the existence of a table component designed to display properties or attributes, likely in a structured and organized manner.\n\n**Features:**\n\n*   **Properties Display:** The component is designed to display properties or attributes.\n*   **Table Layout:** The component uses a table layout for structured data presentation.\n*   **Reusability:** The component is exported, implying it's designed to be reusable across different parts of the application.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertiesTable/PropertiesTable.tsx",
        "summary": "The `PropertiesTable` component in `PropertiesTable.tsx` provides a way to display and interact with a table of properties. It supports features like sorting, searching, filtering, and inline editing of property values. The component handles different data types, including nested objects and arrays, and allows users to hide PostHog-specific properties and null values. It also provides visual cues for type mismatches and allows users to navigate to property definitions.\n\nHere's a list of high-level product features:\n\n*   **Property Display:** Displays properties in a tabular format with key-value pairs.\n*   **Sorting:** Sorts properties alphabetically or based on promoted properties.\n*   **Searching:** Allows users to search for specific properties by key or value.\n*   **Filtering:** Filters properties based on user preferences (e.g., hiding PostHog properties, null values).\n*   **Inline Editing:** Enables inline editing of property values for certain data types.\n*   **Type Detection and Display:** Detects and displays the data type of property values, with visual cues for type mismatches.\n*   **Nested Property Support:** Handles nested objects and arrays as property values.\n*   **Customizable Appearance:** Offers options for embedded styling and custom CSS classes.\n*   **Property Deletion:** Allows users to delete properties (if `onDelete` callback is provided).\n*   **Property Highlighting:** Highlights specific properties based on provided keys."
    },
    {
        "path": "frontend/src/lib/components/PropertiesTable",
        "summary": "The `PropertiesTable` component offers a comprehensive solution for displaying and managing properties in a tabular format. It provides functionalities such as sorting, searching, and filtering to easily navigate and find specific properties. Inline editing allows for quick modifications of property values, while type detection and display, along with support for nested objects and arrays, ensure accurate representation of complex data structures. The component is designed to be reusable and customizable, offering options for embedded styling and custom CSS classes.\n\nHere's a list of high-level product features:\n\n*   **Property Display:** Displays properties in a tabular format with key-value pairs.\n*   **Sorting:** Sorts properties alphabetically or based on promoted properties.\n*   **Searching:** Allows users to search for specific properties by key or value.\n*   **Filtering:** Filters properties based on user preferences (e.g., hiding PostHog properties, null values).\n*   **Inline Editing:** Enables inline editing of property values for certain data types.\n*   **Type Detection and Display:** Detects and displays the data type of property values, with visual cues for type mismatches.\n*   **Nested Property Support:** Handles nested objects and arrays as property values.\n*   **Customizable Appearance:** Offers options for embedded styling and custom CSS classes.\n*   **Property Deletion:** Allows users to delete properties (if `onDelete` callback is provided).\n*   **Property Highlighting:** Highlights specific properties based on provided keys.\n*   **Table Layout:** The component uses a table layout for structured data presentation.\n*   **Reusability:** The component is exported, implying it's designed to be reusable across different parts of the application.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyIcon/types.ts",
        "summary": "This code defines the `PropertyIconProps` interface for a React component called `PropertyIcon`. This component is designed to display an icon representing a specific property, potentially along with its value. It accepts the property name, an optional value associated with the property, an optional CSS class name for styling, and an optional onClick handler.\n\nHere's a list of high-level features for the `PropertyIcon` component:\n\n*   **Property Representation:** Displays an icon associated with a given property name.\n*   **Value Display (Optional):**  Shows an optional value alongside the property icon.\n*   **Custom Styling:** Allows for custom styling through a `className` prop.\n*   **Click Handling:** Supports click events with an optional `onClick` handler.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyIcon/PropertyIcon.tsx",
        "summary": "This code defines a `PropertyIcon` component in React, composed of two sub-components: `PropertyIconStandalone` and `PropertyIconWithLabel`. It exports a map of property icons from `PropertyIconStandalone` and a type definition for the component's props. The `PropertyIcon` component is essentially a combination of the standalone icon and an icon with a label, providing flexibility in how the icon is displayed.\n\nHere's a list of high-level product features:\n\n*   **Property Icon Display:** Renders an icon representing a specific property.\n*   **Standalone Icon:** Displays the property icon without any associated label.\n*   **Icon with Label:** Displays the property icon along with a descriptive label.\n*   **Customizable Properties:** Allows customization of the icon's appearance and behavior through props.\n*   **Predefined Icon Set:** Provides a predefined set of property icons for common use cases.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyIcon/PropertyIconWithLabel.tsx",
        "summary": "The `PropertyIconWithLabel` component is a React functional component that displays a property icon alongside its corresponding value. It leverages the `PropertyIconStandalone` component to render the icon and then displays the value as text next to it. The component uses a flex layout to ensure the icon and value are aligned horizontally with a small gap between them. It accepts properties for the property type, value, and optional CSS class names, and it also supports forwarding refs to the underlying div element.\n\nHere's a list of high-level features:\n\n*   **Displays a property icon:** Renders an icon representing a specific property.\n*   **Displays a property value:** Shows the value associated with the property next to the icon.\n*   **Horizontal alignment:** Arranges the icon and value in a horizontal line.\n*   **Customizable styling:** Accepts CSS class names for styling.\n*   **Ref forwarding:** Supports forwarding refs to the root div element.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyIcon/PropertyIconStandalone.tsx",
        "summary": "This code defines a React component called `PropertyIconStandalone` that displays an icon based on a given property name and value. It uses a map (`PROPERTIES_ICON_MAP`) to associate property-value pairs with specific icons. The component handles properties like browser, device type, operating system, and country code, providing default icons when a specific value isn't found. For country codes, it displays the corresponding flag.\n\nHere's a list of high-level product features that can be derived from this code:\n\n*   **Property Icon Display:** Display icons associated with specific properties and their values.\n*   **Browser Icon Support:** Display icons for various browsers (Chrome, Firefox, Safari, Edge, etc.).\n*   **Device Type Icon Support:** Display icons for different device types (desktop, mobile, tablet, console, wearable).\n*   **Operating System Icon Support:** Display icons for various operating systems (macOS, Windows, Linux, Android, iOS).\n*   **Country Flag Display:** Display country flags based on the country code.\n*   **Customizable Icons:** Allow for the addition or modification of icons associated with properties and values.\n*   **Default Icon Handling:** Display a default icon when a specific property-value combination is not found.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyIcon",
        "summary": "The code defines a React component system for displaying icons associated with various properties and their values. This system includes standalone icons, icons with labels, and customizable styling options. It supports a predefined set of icons for common properties like browser, device type, operating system, and country, with the ability to handle default icons when specific values are not found. The system also allows for click handling and ref forwarding.\n\nHere's a list of high-level product features:\n\n*   Property Icon Display: Renders icons representing specific properties.\n*   Standalone Icon: Displays the property icon without any associated label.\n*   Icon with Label: Displays the property icon along with a descriptive label.\n*   Browser Icon Support: Display icons for various browsers (Chrome, Firefox, Safari, Edge, etc.).\n*   Device Type Icon Support: Display icons for different device types (desktop, mobile, tablet, console, wearable).\n*   Operating System Icon Support: Display icons for various operating systems (macOS, Windows, Linux, Android, iOS).\n*   Country Flag Display: Display country flags based on the country code.\n*   Customizable Icons: Allow for the addition or modification of icons associated with properties and values.\n*   Default Icon Handling: Display a default icon when a specific property-value combination is not found.\n*   Customizable Styling: Allows for custom styling through CSS class names.\n*   Click Handling: Supports click events with an optional `onClick` handler.\n*   Ref Forwarding: Supports forwarding refs to the root div element.\n"
    },
    {
        "path": "frontend/src/lib/components/FlaggedFeature.tsx",
        "summary": "The `FlaggedFeature` component in `frontend/src/lib/components/FlaggedFeature.tsx` is a React component that conditionally renders content based on the state of a feature flag. It uses the `featureFlagLogic` to access the current feature flag values and determines whether to render the `children` prop or the `fallback` prop based on whether the flag's value matches the specified `match` prop. If no `match` is provided, it renders the `children` if the flag is truthy.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Feature Flag Control:** Enables conditional rendering of UI elements or functionality based on the state of a feature flag.\n*   **Variant Matching:** Allows specifying a specific state or variant of a feature flag that must be active for the content to be rendered.\n*   **Fallback Content:** Provides a mechanism to display alternative content when the feature flag is not active or doesn't match the specified variant.\n*   **Dynamic Content Rendering:** Supports rendering children as a function, allowing dynamic content based on the feature flag's value.\n"
    },
    {
        "path": "frontend/src/lib/components/InternalSurvey/internalMultipleChoiceSurveyLogic.ts",
        "summary": "This code defines the logic for an internal multiple-choice survey component using the Kea framework. It manages the state of a survey, including the survey data, user's response, thank you message, and open-ended choice input. The logic fetches surveys, handles user responses, displays a thank you message upon submission, and tracks survey interactions using PostHog.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Displaying Surveys:** Fetches and displays multiple-choice surveys to users.\n*   **Capturing Survey Responses:** Allows users to select multiple choices and submit their responses.\n*   **Open-Ended Responses:** Supports open-ended text input as part of the survey response.\n*   **Customizable Thank You Message:** Shows a customizable thank you message after survey submission.\n*   **Survey Analytics:** Tracks survey views and submissions using PostHog for data analysis.\n*   **Timed Survey Display:** Controls the display duration of the thank you message.\n"
    },
    {
        "path": "frontend/src/lib/components/InternalSurvey/InternalMultipleChoiceSurvey.tsx",
        "summary": "The `InternalMultipleChoiceSurvey` component renders an interactive survey within a session recording. It dynamically displays survey questions, handles user responses for multiple-choice questions (including an optional open-ended text area for the last choice), and manages survey submission. The component uses Lemon UI components for buttons, checkboxes, and text areas. It also displays a thank you message upon successful submission. The component leverages kea-logic to manage the survey state and actions.\n\nHere's a list of high-level product features:\n\n*   **Dynamic Survey Display:** Renders survey questions and answer choices fetched from a backend.\n*   **Multiple Choice Questions:** Supports multiple choice questions with single or multiple selections.\n*   **Open-Ended Text Input:** Provides an optional open-ended text area for users to provide additional feedback.\n*   **Interactive Response Handling:** Captures and manages user responses to survey questions.\n*   **Submission Handling:** Submits the survey responses to the backend.\n*   **Thank You Message:** Displays a thank you message upon successful survey submission.\n*   **Disabled Submit Button:** Disables the submit button until a choice is selected or open choice text is entered.\n"
    },
    {
        "path": "frontend/src/lib/components/InternalSurvey",
        "summary": "The internal multiple-choice survey component provides a way to gather user feedback through interactive surveys displayed within a session recording. It dynamically renders survey questions with multiple-choice answers, including an option for open-ended text input. The component manages user responses, handles survey submission, and displays a thank you message upon completion. Survey interactions are tracked using PostHog for analytics.\n\nHere's a list of high-level product features:\n\n*   Dynamic Survey Display\n*   Multiple Choice Questions\n*   Open-Ended Text Input\n*   Interactive Response Handling\n*   Submission Handling\n*   Customizable Thank You Message\n*   Survey Analytics\n*   Timed Survey Display\n*   Disabled Submit Button\n"
    },
    {
        "path": "frontend/src/lib/components/TZLabel/index.tsx",
        "summary": "The `TZLabel` component is a React component that displays a user-friendly representation of a date and time, with timezone conversion capabilities. It leverages the Lemon UI library for styling and dropdown functionality. The component automatically updates to show a \"time ago\" format, and provides a popover that displays the time in the user's device timezone, the project's timezone (if configured), and UTC. The component is optimized to minimize re-renders and improve performance.\n\nHere's a list of high-level features:\n\n*   **Time Display:** Displays a human-friendly representation of a given date and time, including \"time ago\" functionality.\n*   **Timezone Conversion:** Provides a popover that shows the time in multiple timezones (user's device, project, and UTC).\n*   **Automatic Updates:** Automatically updates the displayed time to reflect the passage of time (e.g., \"a few seconds ago\", \"a minute ago\").\n*   **Customizable Formatting:** Allows customization of the date and time format.\n*   **Settings Link:** Includes a link to the project's date and time settings page.\n*   **Performance Optimization:** Memoized to reduce unnecessary re-renders and improve performance.\n*   **Optional Popover:** The timezone conversion popover can be enabled or disabled.\n*   **Styling Options:** Offers options to disable default styles and apply custom CSS classes.\n"
    },
    {
        "path": "frontend/src/lib/components/TZLabel",
        "summary": "The `TZLabel` React component offers a user-friendly way to display dates and times, enhanced with timezone conversion and automatic updates. It presents a human-readable time representation that dynamically updates (e.g., \"a minute ago\") and includes a popover displaying the time in the user's device timezone, the project's timezone (if available), and UTC. The component is designed for performance with memoization and provides customization options for formatting and styling, including a link to project settings.\n\nHere's a list of high-level product features:\n\n*   Human-readable time display with \"time ago\" functionality.\n*   Timezone conversion popover (user's device, project, and UTC).\n*   Automatic time updates.\n*   Customizable date and time formatting.\n*   Link to project date and time settings.\n*   Performance optimization (memoization).\n*   Optional timezone conversion popover.\n*   Customizable styling.\n"
    },
    {
        "path": "frontend/src/lib/components/DateDisplay/index.tsx",
        "summary": "The `DateDisplay` component is a React component that displays a date or date range in a standardized format, adapting to the specified interval (minute, hour, day, week, or month). It utilizes `dayjs` for date formatting and provides a highlighted portion of the date based on the interval. The component can also display a secondary date in parentheses and handles the display of week ranges, including calculating the end date of the week.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Dynamic Date Formatting:** Adapts the date format based on the specified interval (minute, hour, day, week, month).\n*   **Date Highlighting:** Highlights a portion of the date (e.g., day of the week) for emphasis.\n*   **Secondary Date Display:** Optionally displays a secondary date in parentheses for comparison or context.\n*   **Week Range Display:** Calculates and displays the end date of a week range when the interval is set to \"week\".\n*   **Customizable Week Range Hiding:** Allows hiding the week range display.\n"
    },
    {
        "path": "frontend/src/lib/components/DateDisplay",
        "summary": "The `DateDisplay` React component offers a flexible way to present dates and date ranges in a user-friendly format. It dynamically adjusts the date formatting based on the specified interval, such as minute, hour, day, week, or month, and highlights a portion of the date for emphasis. The component also supports displaying a secondary date for context and accurately calculates and displays week ranges, with the option to hide the range if needed.\n\nHere's a list of high-level product features:\n\n*   Dynamic Date Formatting\n*   Date Highlighting\n*   Secondary Date Display\n*   Week Range Display\n*   Customizable Week Range Hiding\n"
    },
    {
        "path": "frontend/src/lib/components/HTMLElementsDisplay/htmlElementsDisplayLogic.ts",
        "summary": "This code defines a Kea logic module named `htmlElementsDisplayLogic` that manages the display and selection of HTML elements. It takes a list of HTML elements, allows users to select elements using CSS selectors, and provides feedback on the uniqueness of the selected elements. The logic module also handles pre-selecting elements based on a starting selector and displaying a limited number of elements at a time, with the option to show more. It also includes a subscription that calls the `onChange` prop whenever the chosen selector changes.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **HTML Element Display:** Displays a chain of HTML elements for user selection.\n*   **CSS Selector Generation:** Generates a CSS selector string based on user selections.\n*   **Selector Uniqueness Check:** Checks the uniqueness of the generated CSS selector on the page.\n*   **Pre-selection:** Allows pre-selecting elements based on a starting CSS selector.\n*   **Progressive Element Display:** Displays a limited number of elements initially, with the option to show more.\n*   **Callback on Selector Change:** Notifies the parent component when the selected CSS selector changes, along with its uniqueness status.\n"
    },
    {
        "path": "frontend/src/lib/components/HTMLElementsDisplay/preselectWithCSS.ts",
        "summary": "This code provides functionality for parsing CSS selectors and matching them against a list of HTML elements. It includes functions to parse a CSS selector string into a structured object, convert a parsed selector back into a string, determine if an element matches a given selector, and preselect elements from a list based on a CSS selector. The `preselect` function is the core of the logic, iterating through elements and selectors, handling child combinators, and returning a map of element indices to their corresponding parsed CSS selectors.\n\nHere's a list of high-level product features that can be derived from this code:\n\n*   **CSS Selector Parsing:** Converts a CSS selector string into a structured object for easier manipulation and analysis.\n*   **CSS Selector String Generation:** Converts a structured CSS selector object back into a CSS selector string.\n*   **Element Matching:** Determines if a given HTML element matches a specified CSS selector.\n*   **Element Preselection:** Automatically selects a subset of HTML elements from a list based on a CSS selector, handling child combinators.\n"
    },
    {
        "path": "frontend/src/lib/components/HTMLElementsDisplay/SelectableElement.tsx",
        "summary": "The `SelectableElement` component provides a way to display HTML elements in a selectable and interactive format. It breaks down the element into its tag, ID, attributes, and text content, allowing users to select specific parts of the element's structure. The component highlights selected parts and provides visual cues for interaction, such as underlines on hover. It supports single and multiple selections for attributes, particularly for the `class` attribute, and highlights matching text within the element's content. The component is used to preselect elements with CSS.\n\nHere's a list of high-level product features:\n\n*   **Interactive HTML Element Display:** Renders HTML elements in a structured and interactive format.\n*   **Granular Selection:** Allows users to select specific parts of an HTML element, such as the tag name, ID, or individual attributes.\n*   **Visual Highlighting:** Highlights selected element parts for clear visual feedback.\n*   **Attribute Selection with Multi-Select Support:** Enables selection of attributes, with support for multiple selections for attributes like `class`.\n*   **Text Highlighting:** Highlights matching text within the element's content based on user selection.\n*   **Readonly Mode:** Supports a readonly mode where elements are displayed without interactivity.\n*   **CSS Preselection:** Used to preselect elements with CSS.\n"
    },
    {
        "path": "frontend/src/lib/components/HTMLElementsDisplay/HTMLElementsDisplay.tsx",
        "summary": "The `HTMLElementsDisplay` component is a React component that displays a chain of HTML elements, allowing users to visualize and interact with the structure of a webpage. It supports both read-only and editable modes, where in editable mode, users can modify CSS selectors for each element in the chain. The component also provides feedback on the uniqueness of the generated CSS selector, indicating how many elements on the page match the selector. It utilizes a Kea logic hook (`htmlElementsDisplayLogic`) to manage the state and actions related to selector parsing and element display.\n\nHere's a list of high-level product features:\n\n*   **HTML Element Chain Visualization:** Displays a hierarchical chain of HTML elements, representing the structure of a webpage.\n*   **Editable CSS Selectors:** Allows users to modify the CSS selector for each element in the chain (in editable mode).\n*   **Selector Uniqueness Feedback:** Provides real-time feedback on the uniqueness of the generated CSS selector, indicating the number of matching elements on the page.\n*   **Highlighting:** Highlights elements on the page based on the generated CSS selector or selected text.\n*   **Read-Only Mode:** Displays the HTML element chain without allowing modifications to the CSS selectors.\n*   **Customizable Size:** Offers different size options for the display, such as \"small\" and \"xsmall\".\n*   **Partial Element Chain Display:** Allows users to show or hide parts of the element chain for better readability.\n"
    },
    {
        "path": "frontend/src/lib/components/HTMLElementsDisplay",
        "summary": "The provided code collectively enables a product feature focused on interactive HTML element selection and CSS selector generation. It allows users to visualize a chain of HTML elements, interactively select parts of those elements (tag, ID, attributes, text), and generate CSS selectors that target those selections. The system provides feedback on the uniqueness of the generated selectors and supports pre-selection based on existing CSS selectors. The component can be used in read-only or editable modes, with progressive display of elements and callbacks for selector changes.\n\nHere's a list of high-level product features:\n\n*   Interactive HTML Element Display and Selection\n*   CSS Selector Generation and Editing\n*   CSS Selector Parsing and String Generation\n*   Selector Uniqueness Validation\n*   Visual Highlighting of Selected Elements and Text\n*   Pre-selection of Elements based on CSS Selectors\n*   Read-Only and Editable Modes\n*   Progressive Element Display\n*   Callback on Selector Change\n*   Customizable Display Size\n"
    },
    {
        "path": "frontend/src/lib/components/CopyToClipboard.tsx",
        "summary": "The `CopyToClipboardInline` component provides a convenient way to copy text to the clipboard. It renders either a string or JSX element alongside a copy icon, which, when clicked, copies the text to the clipboard. The component offers customization options such as selectable text, tooltip messages, icon styling, and icon position. It leverages LemonButton and Tooltip components from the Lemon UI library and the `copyToClipboard` utility function.\n\nHere's a list of high-level product features:\n\n*   **Copy Text to Clipboard:** Allows users to easily copy text to their clipboard with a single click.\n*   **Inline Display:** Renders the copy functionality inline with existing text or JSX elements.\n*   **Customizable Icon:** Provides options to customize the style, size, and position of the copy icon.\n*   **Selectable Text Option:** Allows users to select the text instead of automatically copying it on click.\n*   **Tooltip Support:** Displays a tooltip message on hover to indicate the copy functionality.\n*   **Value Sensitivity Handling:** Prevents sensitive values from being captured by analytics tools.\n"
    },
    {
        "path": "frontend/src/lib/components/Sharing/SharingModal.tsx",
        "summary": "The `SharingModal.tsx` component provides a modal or inline interface for sharing dashboards, insights, or recordings publicly. It allows users to enable or disable public sharing, copy a public link, and obtain embed code for embedding the content on external websites. The component also includes options to customize the embedded content, such as showing or hiding the title and description, PostHog branding, legend, detailed results, and inspector panel. It leverages various Lemon UI components for styling and interactivity, and integrates with other PostHog features like dashboard collaboration, access control, and feature flag management.\n\nHere's a list of high-level product features:\n\n*   **Public Sharing:** Enable/disable public access to dashboards, insights, and recordings.\n*   **Shareable Link Generation:** Generate a public link for easy sharing.\n*   **Embed Code Generation:** Generate HTML embed code for embedding content on external websites.\n*   **Customizable Embed Options:** Customize the appearance of embedded content (e.g., show/hide title, description, branding, legend, detailed results, inspector panel).\n*   **Dashboard Collaboration:** Manage collaborators for dashboards.\n*   **Access Control Integration:** Integrate with access control mechanisms for insights.\n*   **Preview Functionality:** Preview the embedded content before sharing.\n"
    },
    {
        "path": "frontend/src/lib/components/Sharing/sharingLogic.ts",
        "summary": "This code defines a Kea logic module named `sharingLogic` that manages the sharing configuration for dashboards, insights, and recordings. It handles fetching, updating, and displaying sharing links and embed codes. The logic includes features for toggling sharing, managing embed configuration options (like width, height, whitelabeling, and legend display), and generating shareable links and embeddable iframe code snippets. It also integrates with event tracking to report usage of sharing features.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Shareable Links:** Generate unique, publicly accessible links for dashboards, insights, and recordings.\n*   **Embeddable Insights/Dashboards:** Create embed codes (iframes) to embed insights and dashboards into external websites or applications.\n*   **Sharing Configuration Management:** Enable or disable sharing for specific dashboards, insights, or recordings.\n*   **Embed Configuration Options:** Customize the appearance of embedded content with options like width, height, whitelabeling, legend display, and header visibility.\n*   **Whitelabeling Support:** Allow users with the appropriate feature flag to remove PostHog branding from embedded content.\n*   **Usage Tracking:** Track user interactions with sharing features, such as toggling sharing and enabling whitelabeling.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyKeyInfo.tsx",
        "summary": "The `PropertyKeyInfo` component displays information about a property key, such as an event property or user property, within the PostHog application. It handles displaying the key's name, potentially with a PostHog or Langfuse icon to indicate its origin. If the key has a core definition (meaning it's a known property), it can display a popover with additional information like a description and examples. The component also handles cases where the key is an empty string and provides visual cues like ellipsis for long keys.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Property Key Display:** Displays the name of a property key.\n*   **Origin Identification:** Indicates the origin of the property key (e.g., PostHog, Langfuse) with an icon.\n*   **Core Definition Lookup:** Retrieves and displays additional information for known property keys (description, examples).\n*   **Popover Information Display:** Shows a popover with detailed information about a property key on hover.\n*   **Empty String Handling:** Displays a special indicator for empty string property keys.\n*   **Text Ellipsis:** Truncates long property keys with an ellipsis to prevent overflow.\n*   **Customizable Display:** Allows disabling the popover and icon, and customizing the display with CSS classes.\n"
    },
    {
        "path": "frontend/src/lib/components/Sharing",
        "summary": "The provided code implements a comprehensive sharing solution for dashboards, insights, and recordings within PostHog. It allows users to easily share their content publicly through shareable links and embeddable iframes, with granular control over the appearance of embedded content. The system also tracks usage of sharing features and integrates with PostHog's feature flag system to enable advanced options like whitelabeling.\n\nHere's a list of high-level product features:\n\n*   Public Sharing: Enable/disable public access to dashboards, insights, and recordings.\n*   Shareable Link Generation: Generate unique, publicly accessible links for easy sharing.\n*   Embed Code Generation: Generate HTML embed code for embedding content on external websites.\n*   Customizable Embed Options: Customize the appearance of embedded content (e.g., show/hide title, description, branding, legend, detailed results, inspector panel, width, height).\n*   Whitelabeling Support: Remove PostHog branding from embedded content (controlled by feature flag).\n*   Usage Tracking: Track user interactions with sharing features.\n*   Sharing Configuration Management: Manage sharing settings for specific dashboards, insights, or recordings.\n"
    },
    {
        "path": "frontend/src/lib/components/SignupRoleSelect.tsx",
        "summary": "This code defines a React component called `SignupRoleSelect` which is used to present a dropdown selection for a user's role within their organization during the signup process. It utilizes Lemon UI components (`LemonField` and `LemonSelect`) to create a styled and user-friendly form field. The component offers a predefined list of roles, including Engineering, Data, Product Management, Founder, Leadership, Marketing, Sales/Success, and Other.\n\nHere's a list of high-level product features:\n\n*   **Role Selection:** Allows users to specify their role within their organization during signup.\n*   **Predefined Role Options:** Offers a set of common role options for users to choose from.\n*   **\"Other\" Role Option:** Provides a fallback option for roles not explicitly listed.\n*   **UI Styling:** Uses Lemon UI components for consistent and visually appealing styling.\n*   **Full Width Display:** The select dropdown stretches to fill the available width.\n*   **Data Attribute:** Includes a data attribute for testing and analytics purposes.\n"
    },
    {
        "path": "frontend/src/lib/components/UnitPicker/CustomUnitModal.tsx",
        "summary": "The `CustomUnitModal.tsx` file defines a modal component that allows users to customize the prefix or postfix of units displayed in trends. The modal includes an input field for entering the custom prefix or postfix, a preview of how the value will be displayed, and save/cancel buttons. The modal's state is managed using React's `useState` and `useEffect` hooks to handle changes to the input field and update the preview accordingly. The modal is rendered conditionally based on the `formativeElement` prop.\n\nHere's a list of high-level product features:\n\n*   **Custom Unit Prefix:** Allows users to define a custom prefix to be displayed before numerical values in trends.\n*   **Custom Unit Postfix:** Allows users to define a custom postfix to be displayed after numerical values in trends.\n*   **Real-time Preview:** Provides a real-time preview of how the numerical value will be displayed with the custom prefix or postfix.\n*   **Modal Interface:** Presents the prefix/postfix customization options in a modal window for a focused user experience.\n*   **Persistence:** Saves the user-defined prefix/postfix for consistent display across the application (handled by `onSave` prop).\n"
    },
    {
        "path": "frontend/src/lib/components/UnitPicker/UnitPicker.tsx",
        "summary": "The `UnitPicker` component provides a user interface for customizing the display format of units on an insight's aggregation axis. It allows users to select predefined unit formats (like numeric, currency, etc.) or define custom prefixes and postfixes to be added to the displayed values. The component utilizes a dropdown menu to present the available options and a modal for defining custom units. It also tracks and reports usage events related to axis unit changes.\n\nHere's a list of high-level product features provided by the `UnitPicker` component:\n\n*   **Predefined Unit Selection:** Allows users to select from a list of predefined unit formats for the aggregation axis (e.g., numeric, currency, percentage).\n*   **Custom Unit Prefix:** Enables users to add a custom prefix to the displayed unit values.\n*   **Custom Unit Postfix:** Enables users to add a custom postfix to the displayed unit values.\n*   **Dropdown Menu Interface:** Provides a user-friendly dropdown menu for selecting unit formats and accessing custom unit options.\n*   **Custom Unit Modal:** Offers a modal interface for defining and saving custom unit prefixes and postfixes.\n*   **Usage Event Tracking:** Tracks and reports user interactions related to axis unit changes for analytics purposes.\n*   **Keyboard Shortcuts:** Supports keyboard shortcuts (Escape key) to close the custom unit modal and dropdown.\n"
    },
    {
        "path": "frontend/src/lib/components/UnitPicker",
        "summary": "The UnitPicker component and CustomUnitModal provide a comprehensive solution for customizing the display of units on an insight's aggregation axis. Users can select from predefined unit formats or define custom prefixes and postfixes to tailor the visualization to their specific needs. The system offers a user-friendly dropdown menu for selecting unit formats and a modal interface for defining custom units, complete with a real-time preview. User interactions are tracked for analytics purposes, and keyboard shortcuts are supported for enhanced accessibility.\n\nHere's a list of high-level product features:\n\n*   Predefined Unit Selection\n*   Custom Unit Prefix\n*   Custom Unit Postfix\n*   Dropdown Menu Interface\n*   Custom Unit Modal\n*   Real-time Preview\n*   Usage Event Tracking\n*   Keyboard Shortcuts\n"
    },
    {
        "path": "frontend/src/lib/components/ChartFilter/index.ts",
        "summary": "The code exports the `ChartFilter` component, making it available for use in other parts of the application. This suggests the existence of a UI element that allows users to filter or modify the data displayed in a chart.\n\nHere's a list of high-level product features based on this:\n\n*   **Chart Filtering:** Allows users to filter the data displayed in a chart based on various criteria.\n*   **Interactive Chart Controls:** Provides UI elements (likely within the `ChartFilter` component) for users to interact with and modify the chart's data.\n*   **Data Subset Visualization:** Enables users to focus on specific subsets of data within a chart for more detailed analysis.\n"
    },
    {
        "path": "frontend/src/lib/components/ChartFilter/ChartFilter.tsx",
        "summary": "The `ChartFilter` component provides a user interface for selecting the chart display type in PostHog insights. It uses a `LemonSelect` component to present a dropdown menu of available chart types, categorized into \"Time series\", \"Cumulative time series\", and \"Total value\". Each chart type has an icon, label, and description, and some options may be disabled based on the current insight's properties (e.g., whether it's a trends insight, has a single series, or uses formulas). When the user selects a chart type, the `updateInsightFilter` action is called to update the insight's display property.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Chart Type Selection:** Allows users to choose how their insight data is visualized.\n*   **Time Series Charts:** Offers line, area, and bar chart options for visualizing trends over time.\n*   **Cumulative Time Series Charts:** Provides a line chart option to visualize cumulative values over time.\n*   **Total Value Charts:** Includes number, pie chart, bar chart, table, and world map options for displaying total values.\n*   **Conditional Chart Availability:** Disables certain chart types based on the insight's properties, ensuring compatibility and relevance.\n*   **Informative Chart Descriptions:** Provides descriptions for each chart type to help users understand their purpose.\n*   **World Map Visualization:** Enables users to visualize data geographically on a world map.\n"
    },
    {
        "path": "frontend/src/lib/components/ChartFilter",
        "summary": "The `ChartFilter` component provides a user interface for selecting the chart display type in PostHog insights, offering a dropdown menu of available chart types categorized into \"Time series\", \"Cumulative time series\", and \"Total value\". The component uses a `LemonSelect` component to present the options, each with an icon, label, and description. Certain chart types are conditionally disabled based on the insight's properties, ensuring compatibility and relevance. When a user selects a chart type, the insight's display property is updated, allowing users to filter or modify the data displayed in a chart.\n\nHere's a list of high-level product features:\n\n*   Chart Type Selection: Allows users to choose how their insight data is visualized.\n*   Time Series Charts: Offers line, area, and bar chart options for visualizing trends over time.\n*   Cumulative Time Series Charts: Provides a line chart option to visualize cumulative values over time.\n*   Total Value Charts: Includes number, pie chart, bar chart, table, and world map options for displaying total values.\n*   Conditional Chart Availability: Disables certain chart types based on the insight's properties, ensuring compatibility and relevance.\n*   Informative Chart Descriptions: Provides descriptions for each chart type to help users understand their purpose.\n*   World Map Visualization: Enables users to visualize data geographically on a world map.\n*   Chart Filtering: Allows users to filter the data displayed in a chart based on various criteria.\n*   Interactive Chart Controls: Provides UI elements for users to interact with and modify the chart's data.\n*   Data Subset Visualization: Enables users to focus on specific subsets of data within a chart for more detailed analysis.\n"
    },
    {
        "path": "frontend/src/lib/components/VersionChecker/VersionCheckerBanner.tsx",
        "summary": "The `VersionCheckerBanner` component displays a banner notification to the user if their PostHog SDK version is outdated. It uses the `versionCheckerLogic` to determine if a version warning should be displayed based on the current team ID. The banner informs the user of the latest available SDK version and the version they are currently using, and provides a link to the PostHog documentation for updating the SDK. The banner's severity level (e.g., warning, error) is determined by the `versionWarning.level` property. The banner can be dismissed and will not reappear until the SDK versions change.\n\nHere's a list of high-level product features:\n\n*   **SDK Version Monitoring:** Automatically checks the current PostHog SDK version against the latest available version.\n*   **Version Update Notifications:** Displays a banner notification to users when their SDK version is outdated.\n*   **Actionable Update Link:** Provides a direct link to the PostHog documentation for updating the SDK.\n*   **Severity Levels:** Indicates the severity of the version discrepancy (e.g., warning, error).\n*   **Dismissable Notifications:** Allows users to dismiss the banner notification.\n*   **Team-Specific Version Checking:** Checks SDK versions on a per-team basis.\n"
    },
    {
        "path": "frontend/src/lib/components/VersionChecker/versionCheckerLogic.ts",
        "summary": "This code implements a version checker for the PostHog JavaScript SDK. It fetches the latest available SDK versions from the GitHub repository and the deprecation information from a raw GitHub file. It also queries the PostHog events to determine the versions of the SDK currently in use. The logic then compares the used versions with the latest available and deprecated versions to determine if a warning should be displayed to the user, indicating that they are using an outdated or deprecated version of the SDK. The component persists the last check timestamp and any version warnings to local storage.\n\nHere's a list of high-level product features:\n\n*   **SDK Version Detection:** Automatically detects the versions of the PostHog JavaScript SDK currently in use.\n*   **Latest Version Fetching:** Fetches the latest available SDK versions from the PostHog GitHub repository.\n*   **Deprecation Check:** Checks for deprecated SDK versions based on a deprecation configuration file.\n*   **Version Comparison:** Compares the used SDK versions with the latest available and deprecated versions.\n*   **User Warning System:** Displays a warning to the user if they are using an outdated or deprecated SDK version, including the severity level (info, warning, or error) and the number of versions behind.\n*   **Periodic Checks:** Periodically checks for new SDK versions and updates the warning status.\n*   **Persistence:** Persists the last check timestamp and version warnings to local storage.\n"
    },
    {
        "path": "frontend/src/lib/components/VersionChecker",
        "summary": "The PostHog SDK Version Checker provides users with real-time feedback on the status of their SDK integration, ensuring they are using the most up-to-date and secure version. It automatically detects the SDK version in use, compares it against the latest available and deprecated versions fetched from GitHub, and displays a dismissable banner notification with a severity level indicating the urgency of an update. The banner includes a direct link to the PostHog documentation for easy updating, and the system periodically checks for new versions, persisting the last check timestamp and any version warnings to local storage.\n\n*   SDK Version Detection: Automatically identifies the version of the PostHog SDK in use.\n*   Latest Version Monitoring: Fetches and compares against the latest available SDK versions from GitHub.\n*   Deprecation Warnings: Alerts users to deprecated SDK versions.\n*   Real-time Notifications: Displays a dismissable banner notification when an update is recommended or required.\n*   Actionable Guidance: Provides a direct link to the PostHog documentation for updating the SDK.\n*   Severity Levels: Indicates the urgency of the update with different warning levels.\n*   Periodic Checks: Regularly checks for new SDK versions and updates the warning status.\n*   Team-Specific Version Checking: Checks SDK versions on a per-team basis.\n"
    },
    {
        "path": "frontend/src/lib/components/DatabaseTableTree/TreeRow.tsx",
        "summary": "This code defines React components for rendering a tree-like structure representing database tables and their schemas. It includes components for displaying individual rows (TreeRow, TreeTableRow) and folders (TreeFolderRow) within the tree. The components handle user interactions like clicking to copy table names, selecting tables, and expanding/collapsing folders. The folder component also displays loading states, empty states, and status icons for materialized views.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Database Schema Visualization:** Displays database tables and their schemas in a hierarchical tree structure.\n*   **Table Selection:** Allows users to select a table from the tree.\n*   **Expandable/Collapsible Folders:** Enables users to expand and collapse folders to navigate the schema.\n*   **Loading State Indication:** Shows a loading spinner when fetching data for a folder.\n*   **Empty State Display:** Displays a message when a folder is empty.\n*   **Copy Table Name:** Allows users to copy the table name to the clipboard.\n*   **Materialized View Status:** Displays the status of materialized views (e.g., running, failed, completed) with corresponding icons and tooltips.\n*   **Context Menus:** Supports adding context menus to tree items for additional actions."
    },
    {
        "path": "frontend/src/lib/components/DatabaseTableTree/DatabaseTableTree.tsx",
        "summary": "The `DatabaseTableTree` component is a React component that renders a tree-like structure for displaying database schema information. It supports three types of tree items: folders (which can contain other items), table items (representing database tables), and leaf items (representing other data). The component allows for selection of rows, highlighting the selected row, and rendering custom dropdown overlays for folders. It uses recursion to handle nested folder structures and provides a consistent visual representation of the database schema.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Hierarchical Data Display:** Renders data in a tree-like structure, suitable for representing nested relationships like database schemas.\n*   **Folder Support:** Allows grouping of related items under expandable/collapsible folders.\n*   **Table Representation:** Specifically designed to display database tables within the tree.\n*   **Row Selection:** Enables users to select individual rows (tables) within the tree.\n*   **Selection Highlighting:** Visually indicates the currently selected row.\n*   **Customizable Folder Actions:** Supports custom dropdown menus/overlays for folder items.\n*   **Generic Leaf Nodes:** Supports generic leaf nodes with icons and menu items.\n*   **Loading State:** Supports displaying a loading state for folders.\n"
    },
    {
        "path": "frontend/src/lib/components/DatabaseTableTree",
        "summary": "The provided code implements a React component for visualizing and interacting with database schemas in a tree-like structure. This component allows users to navigate database tables and their schemas through expandable and collapsible folders, select tables for further actions, and copy table names. The component also provides visual cues for loading states, empty folders, and the status of materialized views, enhancing the user experience when exploring database structures.\n\nHere's a list of high-level product features:\n\n*   Database Schema Visualization: Displays database tables and schemas in a hierarchical tree structure.\n*   Table Selection: Allows users to select a table from the tree.\n*   Expandable/Collapsible Folders: Enables users to expand and collapse folders to navigate the schema.\n*   Loading State Indication: Shows a loading spinner when fetching data for a folder.\n*   Empty State Display: Displays a message when a folder is empty.\n*   Copy Table Name: Allows users to copy the table name to the clipboard.\n*   Materialized View Status: Displays the status of materialized views.\n*   Customizable Folder Actions: Supports custom dropdown menus/overlays for folder items.\n*   Generic Leaf Nodes: Supports generic leaf nodes with icons and menu items.\n"
    },
    {
        "path": "frontend/src/lib/components/UserSelectItem.tsx",
        "summary": "This code defines a `UserSelectItem` component and a `usersLemonSelectOptions` function. The `UserSelectItem` component is a React component that displays a user's profile picture, first name, and email address in a visually appealing format, suitable for use in selection lists. The `usersLemonSelectOptions` function takes an array of user objects and transforms them into an array of options suitable for use with a LemonInputSelect component, using the `UserSelectItem` component to render each option's label. This allows for a rich user selection experience with profile pictures and formatted names.\n\n**Features:**\n\n*   **User Display Component:** Renders a user's profile picture, first name, and email.\n*   **Lemon Select Integration:** Converts user data into options compatible with LemonInputSelect.\n*   **Customizable Key:** Allows specifying which user property to use as the key for select options (defaults to email).\n*   **Rich User Selection:** Provides a visually enhanced user selection experience with profile pictures.\n"
    },
    {
        "path": "frontend/src/lib/components/NotFound/index.tsx",
        "summary": "The `NotFound` component displays a user-friendly message when a specific object (e.g., dashboard, insight) is not found. It provides context-aware suggestions, such as prompting staff users to log in as a customer if the object belongs to a specific project. It also offers options to contact support or remove the object from a notebook, depending on the environment and context. The component leverages PostHog for event tracking and integrates with Lemon UI components for a consistent user experience.\n\nHere's a list of high-level product features:\n\n*   **Object Not Found Display:** Show a clear and informative message when a requested object is not found.\n*   **Contextual Suggestions:** Provide suggestions based on the user's role and the object's access permissions (e.g., \"Log in as customer\").\n*   **Staff User Impersonation:** Allow staff users to log in as specific customers to access project-specific content.\n*   **Support Contact Integration:** Offer a direct link to contact support for assistance.\n*   **Notebook Integration:** Enable users to remove missing objects from their notebooks.\n*   **Event Tracking:** Track instances of \"not found\" errors to identify potential issues.\n"
    },
    {
        "path": "frontend/src/lib/components/NotFound",
        "summary": "The NotFound component enhances the user experience by providing informative and context-aware messages when a requested object is not found. It offers tailored suggestions based on user roles and object permissions, such as prompting staff to impersonate customers for project-specific content. Furthermore, it integrates support contact options and notebook management features, while leveraging event tracking to monitor and address potential issues.\n\nHere's a list of high-level product features:\n\n*   Object Not Found Display\n*   Contextual Suggestions\n*   Staff User Impersonation\n*   Support Contact Integration\n*   Notebook Integration\n*   Event Tracking\n"
    },
    {
        "path": "frontend/src/lib/components/ConfirmUpgradeModal/ConfirmUpgradeModal.tsx",
        "summary": "The `ConfirmUpgradeModal` component is a modal that appears when a user is about to upgrade their PostHog plan. It displays the details of the new plan, including the price, billing frequency, and a list of included features. It also shows a proration amount if applicable, and confirms that the first payment will be charged immediately. The modal provides options to cancel or confirm the upgrade.\n\nHere's a list of high-level product features:\n\n*   **Displays Plan Details:** Shows the name, price, and billing frequency of the upgrade plan.\n*   **Proration Calculation:** Calculates and displays the prorated amount for the first payment, if applicable.\n*   **Feature List:** Lists the features included in the upgrade plan.\n*   **Confirmation and Cancellation:** Provides buttons to confirm or cancel the upgrade.\n*   **Immediate Charge Notification:** Notifies the user that the first payment will be charged immediately.\n"
    },
    {
        "path": "frontend/src/lib/components/ConfirmUpgradeModal/confirmUpgradeModalLogic.ts",
        "summary": "This code defines the logic for a confirmation modal that appears before a user upgrades their billing plan. It uses the Kea framework to manage the modal's state, including the target upgrade plan, confirmation callback, and cancellation callback. The logic includes actions to show and hide the modal, as well as to handle confirmation and cancellation events, triggering the appropriate callbacks and closing the modal.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Display Confirmation Modal:** Shows a modal to confirm the user's intent to upgrade their billing plan.\n*   **Upgrade Plan Selection:** Stores the details of the billing plan the user is upgrading to.\n*   **Confirmation Callback:** Executes a function when the user confirms the upgrade.\n*   **Cancellation Callback:** Executes a function when the user cancels the upgrade.\n*   **Modal Dismissal:** Hides the confirmation modal after confirmation or cancellation.\n"
    },
    {
        "path": "frontend/src/lib/components/ConfirmUpgradeModal",
        "summary": "The code implements a confirmation modal that appears before a user upgrades their PostHog billing plan. This modal manages the state of the upgrade process, including the target plan, confirmation and cancellation callbacks, and modal visibility. It displays detailed information about the new plan, such as price, billing frequency, included features, and any proration amounts, ensuring the user is fully informed before confirming the upgrade. The modal allows the user to either confirm the upgrade, triggering a specified callback, or cancel, triggering another callback and dismissing the modal.\n\nHere's a list of high-level product features:\n\n*   Display Confirmation Modal\n*   Upgrade Plan Selection\n*   Confirmation Callback\n*   Cancellation Callback\n*   Modal Dismissal\n*   Displays Plan Details\n*   Proration Calculation\n*   Feature List\n*   Confirmation and Cancellation\n*   Immediate Charge Notification\n"
    },
    {
        "path": "frontend/src/lib/components/FeedbackNotice.tsx",
        "summary": "The `FeedbackNotice` component displays a banner with a customizable text message. When the application is running in a cloud environment (determined by `preflight?.cloud`), it also shows two buttons: \"Report a bug\" and \"Give feedback\". Clicking these buttons opens a support form (via `supportLogic`) with the respective feedback type pre-selected. The component uses Lemon UI components for styling and icons.\n\nHere's a list of the high-level product features:\n\n*   **Informational Banner:** Displays a banner with customizable text.\n*   **Bug Reporting:** Allows users to report bugs directly from the interface.\n*   **Feedback Submission:** Enables users to provide general feedback.\n*   **Contextual Support Forms:** Opens pre-filled support forms based on the selected feedback type (bug or general feedback).\n*   **Cloud Environment Awareness:** Conditionally displays support options based on whether the application is running in a cloud environment.\n"
    },
    {
        "path": "frontend/src/lib/components/InsightLegend/utils.ts",
        "summary": "This code defines utility functions and constants related to the display of insight legends in a frontend application. It specifies chart display types that should not have a legend or detailed results, and provides a function to determine if a specific row in the legend should be highlighted based on the currently highlighted index and any hidden legend indexes.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Legend Display Control:** Ability to hide or show the legend based on the chart display type.\n*   **Detailed Results Control:** Ability to hide or show detailed results based on the chart display type.\n*   **Legend Highlighting:** Ability to highlight a specific row in the legend to draw user attention.\n*   **Series Visibility Control:** Ability to hide specific series from the legend and chart.\n"
    },
    {
        "path": "frontend/src/lib/components/InsightLegend/InsightLegendRow.tsx",
        "summary": "The `InsightLegendRow` component is a React component that renders a single row in the insight legend, providing controls for toggling the visibility of a series in a chart. It displays a checkbox with a label that represents the series, including its name, breakdown value, and comparison label (if applicable). The component also handles highlighting the row when the corresponding series is highlighted in the chart, and scrolling the highlighted row into view. Additionally, for pie charts, it displays the aggregated value for the series.\n\nHere's a list of high-level features provided by the `InsightLegendRow` component:\n\n*   **Series Visibility Toggle:** Allows users to show or hide individual series in a chart by toggling a checkbox.\n*   **Series Label Display:** Displays a formatted label for each series, including name, breakdown value, and comparison label.\n*   **Series Highlighting:** Highlights the legend row when the corresponding series is highlighted in the chart.\n*   **Automatic Scrolling:** Scrolls the highlighted legend row into view.\n*   **Aggregated Value Display (Pie Charts):** Shows the aggregated value for each series in pie charts.\n"
    },
    {
        "path": "frontend/src/lib/components/AccessControlledLemonButton.tsx",
        "summary": "This code defines a React component called `AccessControlledLemonButton` that extends the functionality of a standard `LemonButton` by incorporating access control. It leverages an `AccessControlAction` component to determine if the button should be disabled based on the user's access level, the minimum required access level, and the resource type being accessed. If the user's access level is insufficient, the button is disabled, and a reason for the disabled state is provided.\n\nHere's a list of high-level product features:\n\n*   **Access Control Integration:** Integrates with an access control system to manage user permissions.\n*   **Role-Based Button Enablement:** Enables or disables a button based on the user's role and required access level.\n*   **Resource-Specific Permissions:** Allows defining access control rules based on the type of resource being accessed.\n*   **Disabled State Indication:** Provides a reason for why a button is disabled due to insufficient permissions.\n*   **Extends LemonButton:** Leverages and extends the existing LemonButton component for consistent UI.\n"
    },
    {
        "path": "frontend/src/lib/components/InsightLegend/InsightLegend.tsx",
        "summary": "The `InsightLegend` component displays a legend for insights, particularly trends, in a PostHog application. It dynamically renders a list of `InsightLegendRow` components based on the data provided by the `trendsDataLogic` and `insightLogic`. The component's appearance is customizable with props for horizontal layout, read-only mode, and card view integration. It utilizes CSS classes for styling and conditional rendering based on the presence of a legend.\n\nHere's a list of high-level product features:\n\n*   **Dynamic Legend Generation:** Automatically generates a legend based on the data displayed in an insight.\n*   **Trend Visualization Support:** Specifically designed to work with trend visualizations.\n*   **Customizable Layout:** Offers horizontal and vertical layout options.\n*   **Read-Only Mode:** Allows displaying the legend in a read-only state, preventing user interaction.\n*   **Card View Integration:** Adapts its appearance for use within card-based layouts.\n*   **Interactive Legend Rows:** Each row in the legend represents a data series and can be interacted with (likely in the `InsightLegendRow` component, though not visible in this code).\n"
    },
    {
        "path": "frontend/src/lib/components/FullScreen.tsx",
        "summary": "The `FullScreen` component provides a way to display content in fullscreen mode. It hides elements with the class `layout-top-content` upon mounting, requests fullscreen for the document body, and adds a listener for the `fullscreenchange` event to call an optional `onExit` callback when exiting fullscreen. The component also dispatches `scroll` and `resize` events. On unmount, it restores the hidden elements, removes the event listener, exits fullscreen if active, and dispatches `scroll` and `resize` events again. The component handles potential errors in older browsers like IE11.\n\nHere's a list of high-level product features:\n\n*   **Fullscreen Mode:** Allows users to view content in fullscreen, maximizing screen real estate.\n*   **Content Hiding:** Temporarily hides specific layout elements (identified by the `.layout-top-content` selector) to provide a cleaner fullscreen experience.\n*   **Exit Callback:** Provides a mechanism to execute custom logic when the user exits fullscreen mode.\n*   **Event Dispatching:** Triggers `scroll` and `resize` events to ensure proper rendering and layout adjustments within the application.\n*   **Browser Compatibility:** Includes error handling to gracefully degrade functionality in older browsers like IE11.\n"
    },
    {
        "path": "frontend/src/lib/components/InsightLegend",
        "summary": "The code collectively implements a dynamic and interactive insight legend system for a frontend application, primarily focused on trend visualizations. The system provides fine-grained control over the display of data series, allowing users to toggle visibility, highlight specific series, and view aggregated values for pie charts. The legend's appearance and behavior are customizable, with options for horizontal layout, read-only mode, and card view integration.\n\n*   Dynamic Legend Generation\n*   Trend Visualization Support\n*   Customizable Layout (Horizontal/Vertical)\n*   Read-Only Mode\n*   Card View Integration\n*   Series Visibility Toggle\n*   Series Label Display (Name, Breakdown, Comparison)\n*   Series Highlighting\n*   Automatic Scrolling of Highlighted Row\n*   Aggregated Value Display (Pie Charts)\n*   Legend Display Control (Show/Hide)\n*   Detailed Results Control (Show/Hide)\n"
    },
    {
        "path": "frontend/src/lib/components/PathCleanFilters/PathCleanFilterAddItemButton.tsx",
        "summary": "This React component, `PathCleanFilterAddItemButton`, provides a user interface element for adding new path cleaning filters. It renders a button that, when clicked, opens a modal (`PathRegexModal`) allowing the user to define a new filter. Upon saving the filter in the modal, the `onAdd` prop function is called, which presumably updates the list of filters in the parent component. The button uses a plus icon and is styled as a secondary button.\n\n**Features:**\n\n*   **Add Path Cleaning Rule Button:** A button that triggers the creation of a new path cleaning filter.\n*   **Path Regex Modal:** A modal dialog for defining the properties of a new path cleaning filter, likely including a regular expression.\n*   **Filter Persistence:** The ability to save the defined filter and add it to a list of active filters.\n"
    },
    {
        "path": "frontend/src/lib/components/PathCleanFilters/PathCleanFilters.tsx",
        "summary": "The `PathCleanFilters` component provides a user interface for managing a list of path cleaning filters. Users can add, edit, remove, and reorder filters, which are used to modify file paths based on regular expressions. The component utilizes the `@dnd-kit` library to enable drag-and-drop sorting of the filters, providing a visual and intuitive way to prioritize the order in which filters are applied. The component maintains both a local state for immediate UI updates and calls a provided `setFilters` function to persist the changes externally.\n\nHere's a list of high-level product features:\n\n*   **Add Filter:** Allows users to add new path cleaning filters with an alias and a regular expression.\n*   **Edit Filter:** Enables users to modify existing path cleaning filters.\n*   **Remove Filter:** Provides the ability to delete path cleaning filters.\n*   **Sort Filters:** Allows users to reorder the filters using drag and drop, defining the order in which they are applied.\n*   **Real-time Updates:** Updates the filter list in real-time as changes are made.\n"
    },
    {
        "path": "frontend/src/lib/components/PathCleanFilters/PathRegexModal.tsx",
        "summary": "This React component, `PathRegexModal`, provides a modal interface for creating and editing path cleaning rules. It includes input fields for an alias and a regular expression, along with validation to ensure the regex is well-formed. The modal allows users to define rules to simplify and standardize URL paths by replacing dynamic parts with aliases. It also integrates with an AI Regex Helper to assist users in creating regular expressions.\n\nHere's a list of high-level product features:\n\n*   **Modal Interface:** Provides a modal for creating and editing path cleaning rules.\n*   **Alias Input:** Allows users to define an alias for the path cleaning rule.\n*   **Regex Input:** Allows users to define a regular expression for matching URL paths.\n*   **Regex Validation:** Validates the regular expression to ensure it is well-formed.\n*   **AI Regex Helper Integration:** Integrates with an AI Regex Helper to assist users in creating regular expressions.\n*   **Save and Cancel Actions:** Provides buttons to save or cancel the creation/editing of a path cleaning rule.\n*   **Dynamic Path Suggestion:** Suggests using `<id>` or `<slug>` to indicate dynamic parts of the path.\n*   **re2 Syntax Support:** Informs users that the regular expression syntax is based on re2.\n"
    },
    {
        "path": "frontend/src/lib/components/PathCleanFilters/PathCleanFilterItem.tsx",
        "summary": "This code defines a React component, `PathCleanFilterItem`, which is a visual representation of a path cleaning filter used for mapping URL paths based on regular expressions. It allows users to view, edit, and remove these filters. The component utilizes drag-and-drop functionality for reordering (though the reordering logic isn't contained within this component). It also includes a modal for editing the regex and alias of the filter, and displays an indicator if the regex is invalid. The `parseAliasToReadable` function formats the alias to highlight dynamic parts of the path.\n\nHere's a list of high-level product features related to this component:\n\n*   **Display Path Cleaning Filters:** Visually represents a path cleaning filter, showing the regex and its corresponding alias.\n*   **Edit Path Cleaning Filters:** Allows users to modify the regex and alias of a path cleaning filter via a modal.\n*   **Regex Validation:** Indicates whether the regex in a filter is valid or invalid.\n*   **Remove Path Cleaning Filters:** Provides a way to delete a path cleaning filter.\n*   **Dynamic Path Highlighting:** Highlights dynamic parts of the path alias for better readability.\n*   **Drag and Drop Reordering:** Supports drag and drop functionality for reordering the path cleaning filters (though the logic is external to this component).\n"
    },
    {
        "path": "frontend/src/lib/components/PathCleanFilters",
        "summary": "The path cleaning filters feature provides a comprehensive solution for managing and applying regular expression-based rules to modify file paths. Users can easily add, edit, remove, and reorder filters through an intuitive drag-and-drop interface. The system includes real-time updates, regex validation, dynamic path highlighting, and integration with an AI Regex Helper to assist in creating complex expressions. A modal interface facilitates the creation and modification of filters, ensuring a streamlined user experience.\n\nHere's a list of high-level product features:\n\n*   **Add Path Cleaning Rule:** Allows users to add new path cleaning filters with an alias and a regular expression.\n*   **Edit Path Cleaning Rule:** Enables users to modify existing path cleaning filters.\n*   **Remove Path Cleaning Rule:** Provides the ability to delete path cleaning filters.\n*   **Sort Path Cleaning Rules:** Allows users to reorder the filters using drag and drop, defining the order in which they are applied.\n*   **Real-time Updates:** Updates the filter list in real-time as changes are made.\n*   **Regex Validation:** Indicates whether the regex in a filter is valid or invalid.\n*   **Dynamic Path Highlighting:** Highlights dynamic parts of the path alias for better readability.\n*   **AI Regex Helper Integration:** Integrates with an AI Regex Helper to assist users in creating regular expressions.\n"
    },
    {
        "path": "frontend/src/lib/components/JSONViewer.tsx",
        "summary": "The `JSONViewer` component is a wrapper around the `react-json-view` library, providing a configurable JSON viewer with theming support based on the application's dark/light mode. It aims to reduce visual clutter by default, and it dynamically re-renders the underlying JSON viewer component when the theme changes to ensure proper styling.\n\nHere's a list of high-level product features:\n\n*   **JSON Visualization:** Renders JSON data in a human-readable format.\n*   **Theming:** Adapts its appearance based on the application's dark/light mode.\n*   **Customizable Display:** Allows toggling the display of data types and object sizes.\n*   **Root Node Labeling:** Supports customizing the root node label.\n"
    },
    {
        "path": "frontend/src/lib/components/SocialLoginButton/SocialLoginIcon.tsx",
        "summary": "This code defines a `SocialLoginIcon` component in React that renders a specific icon based on the provided social login provider. It uses icons from `@posthog/icons` and `lib/lemon-ui/icons` for Google, GitHub, GitLab, and SAML. The component takes a `provider` prop of type `SSOProvider` to determine which icon to display and a `className` prop for styling. If the provider doesn't match any of the supported types, it returns null.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Social Login:** Allows users to log in using their existing accounts from various providers.\n*   **Google Login:** Supports user authentication via Google accounts.\n*   **GitHub Login:** Supports user authentication via GitHub accounts.\n*   **GitLab Login:** Supports user authentication via GitLab accounts.\n*   **SAML Login:** Supports user authentication via SAML-based identity providers.\n*   **Customizable Styling:** Provides a `className` prop for applying custom styles to the icons.\n"
    },
    {
        "path": "frontend/src/lib/components/SocialLoginButton/SocialLoginButton.tsx",
        "summary": "This code provides React components for social login functionality, allowing users to authenticate using various SSO providers like Google or SAML. It dynamically renders buttons for available providers based on preflight checks and configurations. The components handle constructing the correct login URLs with necessary parameters, including redirect URLs and SAML-specific identifiers. The code also includes options for customizing the appearance and layout of the social login buttons, such as adding titles, captions, and dividers.\n\nHere's a list of high-level product features:\n\n*   **Dynamic SSO Provider Buttons:** Renders buttons for available social authentication providers based on server-side configuration.\n*   **SSO Login URL Generation:** Constructs the correct login URL for each provider, including necessary parameters like redirect URLs and SAML identifiers.\n*   **Customizable Button Appearance:** Allows customization of button appearance with icons, text, and styling options.\n*   **Layout Options:** Provides options for adding titles, captions, and dividers to the social login section.\n*   **Enforced SSO Login:** Supports a specific login flow where users are directed to a particular SSO provider based on their email address.\n*   **Preflight Check Integration:** Integrates with a preflight check to determine available SSO providers.\n"
    },
    {
        "path": "frontend/src/lib/components/SocialLoginButton",
        "summary": "The provided code implements social login functionality, enabling users to authenticate using various SSO providers. It dynamically renders buttons for available providers based on server-side configuration and preflight checks, constructing the correct login URLs with necessary parameters. The appearance and layout of the social login buttons are customizable with options for icons, text, titles, captions, and dividers.\n\nHere's a list of high-level product features:\n\n*   Social Login: Allows users to log in using their existing accounts from various providers.\n*   Google Login: Supports user authentication via Google accounts.\n*   GitHub Login: Supports user authentication via GitHub accounts.\n*   GitLab Login: Supports user authentication via GitLab accounts.\n*   SAML Login: Supports user authentication via SAML-based identity providers.\n*   Dynamic SSO Provider Buttons: Renders buttons for available social authentication providers based on server-side configuration.\n*   SSO Login URL Generation: Constructs the correct login URL for each provider, including necessary parameters like redirect URLs and SAML identifiers.\n*   Customizable Button Appearance: Allows customization of button appearance with icons, text, and styling options.\n*   Layout Options: Provides options for adding titles, captions, and dividers to the social login section.\n*   Enforced SSO Login: Supports a specific login flow where users are directed to a particular SSO provider based on their email address.\n*   Preflight Check Integration: Integrates with a preflight check to determine available SSO providers.\n*   Customizable Styling: Provides a `className` prop for applying custom styles to the icons.\n"
    },
    {
        "path": "frontend/src/lib/components/PageHeader.tsx",
        "summary": "The `PageHeader` component provides a consistent header structure for pages within the application. It supports a caption, buttons (which are rendered via a portal to a designated actions container), and a flag to indicate if the page uses tabs for secondary navigation. The buttons are rendered in the actions container unless the component is rendered within a side panel. A `Subtitle` component is also provided, allowing for a secondary heading with optional buttons aligned to the right.\n\nHere's a list of high-level product features provided by these components:\n\n*   **Page Caption:** Displays a primary title or description for the page.\n*   **Page Actions:** Renders buttons or interactive elements within the page header, providing quick access to common actions.\n*   **Tabbed Page Support:** Provides visual styling to indicate that the page uses tabs for navigation.\n*   **Subtitle:** Displays a secondary heading to provide more context or information.\n*   **Subtitle Actions:** Renders buttons or interactive elements alongside the subtitle.\n"
    },
    {
        "path": "frontend/src/lib/components/Cards/TextCard/textCardModalLogic.ts",
        "summary": "This code defines the logic for a modal that allows users to create or edit text cards on a dashboard. It uses Kea for state management and form handling. The modal allows users to input text, validates that the text field is not empty, and then updates the dashboard with the new or modified text tile. It also handles success and failure states, displaying error messages and closing the modal accordingly.\n\nHere's a list of high-level product features:\n\n*   **Text Card Creation:** Allows users to add new text cards to a dashboard.\n*   **Text Card Editing:** Allows users to modify the content of existing text cards on a dashboard.\n*   **Form Validation:** Ensures that the text card content is not empty before saving.\n*   **Dashboard Integration:** Seamlessly integrates with the dashboard to update the text card content.\n*   **Error Handling:** Displays informative error messages when saving the text card fails.\n*   **Modal Interface:** Provides a user-friendly modal interface for creating and editing text cards.\n"
    },
    {
        "path": "frontend/src/lib/components/Cards/handles.tsx",
        "summary": "This code defines React components for resize handles, specifically `ResizeHandle1D` and `ResizeHandle2D`. `ResizeHandle1D` creates a one-dimensional handle that can be oriented horizontally or vertically, while `ResizeHandle2D` creates a two-dimensional (corner) handle. Both components use SVG elements to render the handle's visual representation, including background, accent dots, and border.\n\nHere's a list of high-level product features based on the code:\n\n*   **One-Dimensional Resizing:** Allows resizing along a single axis (horizontal or vertical).\n*   **Two-Dimensional Resizing:** Enables resizing in both horizontal and vertical directions simultaneously (corner resizing).\n*   **Theming Support:** Uses CSS variables (`var(--bg-surface-primary)`, `var(--accent-primary)`, `var(--border-primary)`) for styling, allowing for easy customization and theming.\n*   **Visual Handles:** Provides visual cues (resize handles) for users to interact with and resize elements.\n"
    },
    {
        "path": "frontend/src/lib/components/Cards/TextCard/TextCard.tsx",
        "summary": "The `TextCard` component is a flexible and customizable card designed to display text content within a dashboard. It supports editing, duplication, deletion, and movement to other dashboards. The card utilizes LemonMarkdown for rendering text and includes resize handles for adjusting its dimensions. It also provides a \"more\" menu for additional actions, and allows for custom buttons to be added to this menu.\n\nHere's a list of high-level product features provided by the `TextCard` component:\n\n*   **Text Display:** Renders text content using LemonMarkdown for formatting.\n*   **Editing:** Allows users to edit the text content of the card.\n*   **Resizing:** Enables users to resize the card using drag handles.\n*   **Duplication:** Provides a function to duplicate the card.\n*   **Dashboard Movement:** Supports moving the card to other dashboards.\n*   **Deletion:** Allows users to remove the card from the current dashboard.\n*   **Custom Actions:** Offers a \"more\" menu for additional actions, with the ability to add custom buttons.\n*   **Customizable Styling:** Supports custom styling through CSS classes.\n"
    },
    {
        "path": "frontend/src/lib/components/Cards/TextCard/TextCardModal.tsx",
        "summary": "This code defines a modal component, `TextCardModal`, which allows users to create or edit text cards within a dashboard. It utilizes `kea` for state management and `kea-forms` for form handling. The modal includes a markdown-enabled text area for editing the card's content, along with \"Cancel\" and \"Save\" buttons. The \"Save\" button is disabled based on validation errors or submission status. The modal is opened and closed based on the `isOpen` prop and calls the `onClose` prop when closed.\n\nHere's a list of high-level product features:\n\n*   **Text Card Creation:** Allows users to create new text cards on a dashboard.\n*   **Text Card Editing:** Enables users to modify the content of existing text cards.\n*   **Markdown Support:** Provides a markdown-enabled text area for formatting text card content.\n*   **Form Validation:** Validates the text card content before submission, preventing saving with errors.\n*   **Loading State:** Displays a loading indicator during text card submission.\n*   **Cancellation:** Allows users to cancel the text card creation or editing process.\n*   **Modal Interface:** Presents the text card creation/editing interface within a modal window.\n"
    },
    {
        "path": "frontend/src/lib/components/Cards/CardMeta.tsx",
        "summary": "The `CardMeta` component is a versatile container for displaying information, controls, and details related to a card or insight within the PostHog application. It provides a structured layout with a primary section for core content and an expandable details section. The component supports visual cues like a ribbon color, controls for refreshing data and showing/hiding details, and a \"more\" menu for additional actions. It also handles responsiveness by adjusting the visibility of detail labels based on available width and uses transitions for smooth expansion/collapse of the details section.\n\nHere's a list of high-level product features provided by the `CardMeta` component:\n\n*   **Insight Display:** Presents key information and visualizations.\n*   **Ribbon Color:** Highlights the card with a color-coded ribbon.\n*   **Data Refresh:** Allows users to manually refresh the data displayed in the card.\n*   **Details Toggle:** Enables users to show or hide detailed information related to the card.\n*   **Additional Actions:** Provides a \"more\" menu for accessing additional actions or options.\n*   **Sampling Indication:** Displays a visual indicator when data is based on a sample.\n*   **Responsive Layout:** Adapts the layout and label visibility based on screen size.\n*   **Animated Transitions:** Uses smooth transitions for expanding and collapsing the details section.\n"
    },
    {
        "path": "frontend/src/lib/components/Cards/TextCard",
        "summary": "The provided code collectively implements a feature-rich text card component for dashboards. Users can create, edit, and delete text cards, format the content using Markdown, and resize and reposition the cards within the dashboard. The system includes form validation, error handling, and a modal interface for creating and editing cards. Furthermore, the text card supports duplication, movement to other dashboards, and custom actions via a \"more\" menu, enhancing its flexibility and integration within the dashboard environment.\n\n**Features:**\n\n*   Text Card Creation & Editing: Allows users to add new text cards and modify existing ones.\n*   Markdown Support: Enables rich text formatting within the cards.\n*   Resizing & Repositioning: Provides the ability to adjust the size and location of text cards on the dashboard.\n*   Duplication & Deletion: Supports duplicating and removing text cards.\n*   Dashboard Movement: Allows moving text cards between different dashboards.\n*   Custom Actions: Offers a \"more\" menu for additional actions, including custom button integration.\n*   Form Validation & Error Handling: Ensures data integrity and provides informative error messages.\n*   Modal Interface: Presents a user-friendly modal for creating and editing text cards.\n"
    },
    {
        "path": "frontend/src/lib/components/Cards/InsightCard/index.tsx",
        "summary": "The code exports the `InsightCard` component from the `InsightCard.tsx` file. This suggests the existence of a reusable card component designed to display insights or key information within the application.\n\n**Features:**\n\n*   **Insight Display:** The primary feature is to present insights or key information to the user.\n*   **Reusable Component:** The component is designed for reuse across different parts of the application.\n*   **Card-based Layout:** The component utilizes a card-based layout for visual organization.\n"
    },
    {
        "path": "frontend/src/lib/components/Cards/InsightCard/TopHeading.tsx",
        "summary": "The `TopHeading` component displays the insight type and date range for a given query. It determines the insight type based on the query's kind (e.g., Trends, Funnels, Retention) and extracts the date range from the query. It then formats the date range into a human-readable string. The component renders the insight type name and, if available, the formatted date range.\n\n**Features:**\n\n*   **Insight Type Display:** Shows the name of the insight type (e.g., Trends, Funnels).\n*   **Dynamic Insight Type Determination:** Determines the insight type based on the query node's kind.\n*   **Date Range Display:** Shows the date range associated with the insight.\n*   **Date Range Extraction:** Extracts the date range from the query node.\n*   **Date Range Formatting:** Formats the date range into a human-readable string.\n*   **Default Date Range:** Provides a default date range (\"Last 7 days\") when no specific date range is defined in the query.\n*   **Insight Type Description Tooltip:** Displays the description of the insight type as a tooltip.\n"
    },
    {
        "path": "frontend/src/lib/components/Cards/InsightCard/QueryCard.tsx",
        "summary": "The `QueryCard` component is a React component that displays a query and its results, similar to an `InsightCard` but specifically for unsaved queries. It renders the query using the `Query` component, along with a title, description, and metadata. The card includes a ribbon for highlighting, a toggle for showing details, and a menu with an option to open the query as a new insight. It also leverages `CardMeta` for consistent styling and layout of the card's elements.\n\nHere's a list of high-level features:\n\n*   **Query Visualization:** Displays the results of a query using the `Query` component.\n*   **Metadata Display:** Shows the title, description, and other metadata associated with the query.\n*   **Highlighting:** Allows highlighting of the card with a ribbon color.\n*   **Details Toggle:** Enables showing or hiding detailed information about the query.\n*   **\"Open as New Insight\" Action:** Provides a menu option to create a new insight based on the current query.\n*   **Consistent Styling:** Uses `CardMeta` for consistent styling and layout with other cards.\n*   **Error Handling:** Wraps the content in an `ErrorBoundary` to prevent crashes.\n"
    },
    {
        "path": "frontend/src/lib/components/Cards/InsightCard/InsightCard.tsx",
        "summary": "The `InsightCard` component is a React component designed to display insights, potentially within a dashboard context. It handles loading states, error boundaries, and visibility optimization to efficiently render insights. The component also provides editing controls, details controls, and resize handles when appropriate. It leverages various hooks and logic components to manage data fetching, feature flags, theme application, and user interactions such as refreshing, renaming, duplicating, and moving insights.\n\nHere's a list of high-level product features provided by the `InsightCard` component:\n\n*   **Insight Display:** Renders a visual representation of an insight using the `Query` component.\n*   **Dashboard Integration:** Supports display within a dashboard, including dashboard-specific actions and variables.\n*   **Loading and Error Handling:** Manages loading states and displays error messages when necessary.\n*   **Visibility Optimization:** Optimizes rendering based on page visibility and viewport intersection.\n*   **Editing Controls:** Provides controls for renaming, duplicating, deleting, and moving insights.\n*   **Resizing:** Allows resizing of the card within a grid layout.\n*   **Customization:** Supports ribbon colors and custom \"more\" menu buttons.\n*   **Details Display:** Allows toggling the display of additional insight details.\n*   **Theming:** Applies a theme to the card's appearance.\n*   **Data Refresh:** Enables refreshing the insight data.\n*   **Variable Overrides:** Supports overriding insight variables with dashboard-level variables."
    },
    {
        "path": "frontend/src/lib/components/Cards/InsightCard/InsightDetails.tsx",
        "summary": "The `InsightDetails.tsx` component provides a detailed summary of the queries used to generate insights within the PostHog platform. It dynamically renders information based on the type of insight query, including trends, funnels, retention, paths, and HogQL queries. The component displays the entities involved (events, actions, cohorts), the mathematical operations applied, and any filters used. It aims to provide a human-readable explanation of the underlying data and logic behind an insight.\n\nHere's a list of high-level product features implemented by the code:\n\n*   **Query Summarization:** Provides a human-readable summary of the query used to generate an insight.\n*   **Trends Query Display:** Shows the entities, math operations, and filters used in trends insights.\n*   **Funnels Query Display:** Indicates the entities involved in funnel analysis.\n*   **Retention Query Display:** Explains the target and returning entities, as well as the time periods used in retention analysis.\n*   **Paths Query Display:** Summarizes the event types, start points, and end points used in user path analysis.\n*   **HogQL Query Display:** Renders the raw HogQL query used to generate the insight.\n*   **Property Filter Display:** Shows the properties and operators used to filter data.\n*   **Entity Display:** Displays the name and type of entities (events, actions, cohorts) involved in the query.\n*   **Formula Display:** Shows the formula used in trends insights.\n"
    },
    {
        "path": "frontend/src/lib/components/Cards/InsightCard/InsightMeta.tsx",
        "summary": "This code defines the `InsightMeta` component, which is responsible for rendering the metadata and actions associated with an insight card in the PostHog application. It displays the insight's name, description, tags, and provides various actions such as viewing, refreshing, editing, renaming, duplicating, moving to a different dashboard, setting a color, exporting, removing from a dashboard, and deleting the insight. The component also handles loading states and displays appropriate messages. It leverages other components like `CardMeta`, `TopHeading`, `ExportButton`, `ObjectTags`, and Lemon UI components for styling and functionality.\n\nHere's a list of high-level product features provided by the `InsightMeta` component:\n\n*   **Insight Display:** Shows the insight's title, description, and tags.\n*   **Insight Actions:**\n    *   **View:** Navigates to the full insight view.\n    *   **Refresh:** Refreshes the insight data.\n    *   **Edit:** Navigates to the insight editing page.\n    *   **Rename:** Allows renaming the insight.\n    *   **Duplicate:** Creates a copy of the insight.\n    *   **Move to Dashboard:** Moves the insight to another dashboard.\n    *   **Set Color:** Sets a color for the insight card's ribbon.\n    *   **Export:** Exports the insight data in various formats (PNG, CSV, XLSX).\n    *   **Remove from Dashboard:** Removes the insight from the current dashboard.\n    *   **Delete:** Deletes the insight.\n*   **Loading State Handling:** Displays a loading indicator and appropriate messages when the insight data is being refreshed.\n*   **Access Control:** Enforces access control based on user privileges.\n"
    },
    {
        "path": "frontend/src/lib/components/Cards/InsightCard",
        "summary": "The `InsightCard` component and its related files provide a comprehensive solution for displaying and managing insights within the PostHog platform. It offers a reusable card-based layout for presenting key information, handling loading states and errors, and optimizing visibility. Users can interact with insights through various actions such as viewing, refreshing, editing, renaming, duplicating, moving, and deleting them. The component also provides detailed query summaries, metadata display, and customization options like ribbon colors and export functionality, enhancing the overall user experience and data exploration capabilities.\n\n**Features:**\n\n*   Insight Display: Rendering and visualization of various insight types (Trends, Funnels, Retention, Paths, HogQL) and unsaved queries.\n*   Dashboard Integration: Seamless integration within dashboards, including dashboard-specific actions and variable overrides.\n*   Interactive Actions: Providing users with actions such as viewing, refreshing, editing, renaming, duplicating, moving, deleting, and exporting insights.\n*   Query Summarization: Generating human-readable summaries of the queries used to create insights.\n*   Metadata Display: Showing insight titles, descriptions, tags, and other relevant metadata.\n*   Customization: Allowing users to customize the appearance of insight cards with ribbon colors and other styling options.\n*   Loading and Error Handling: Managing loading states and displaying error messages for a smooth user experience.\n*   Visibility Optimization: Optimizing rendering based on page visibility and viewport intersection for performance.\n*   Details Display: Enabling users to toggle the display of additional insight details.\n*   Theming: Applying a consistent theme to the card's appearance.\n"
    },
    {
        "path": "frontend/src/lib/components/Cards",
        "summary": "The provided code snippets detail the implementation of various card components within the PostHog application, each designed to present and manage different types of information and insights. These components share common features like theming support, interactive actions, and responsive layouts, while also offering specialized functionalities tailored to their specific content, such as text editing with Markdown support, insight visualization, and data refresh capabilities. The overall goal is to provide a flexible and user-friendly interface for displaying, interacting with, and managing data within the PostHog platform.\n\nHere's a list of high-level product features:\n\n*   **Insight Display & Management:** Rendering and managing various insight types (Trends, Funnels, Retention, Paths, HogQL) and unsaved queries.\n*   **Text Card Creation & Editing:** Allows users to add new text cards and modify existing ones with Markdown support.\n*   **Data Refresh & Details Toggle:** Enables users to manually refresh data and show/hide detailed information.\n*   **Interactive Actions:** Providing users with actions such as viewing, refreshing, editing, renaming, duplicating, moving, deleting, and exporting insights and cards.\n*   **Customization & Theming:** Allowing users to customize the appearance of cards with ribbon colors, styling options, and theming support.\n*   **Responsive Layout & Animated Transitions:** Adapting the layout based on screen size and using smooth transitions for expanding and collapsing sections.\n*   **Resizing & Repositioning:** Provides the ability to adjust the size and location of cards on the dashboard.\n*   **Query Summarization:** Generating human-readable summaries of the queries used to create insights.\n"
    },
    {
        "path": "frontend/src/lib/components/SceneDashboardChoice/SceneDashboardChoiceModal.tsx",
        "summary": "This code defines a modal component, `SceneDashboardChoiceModal`, which allows users to select a default dashboard for a specific scene within the application. The modal displays a list of available dashboards, allows users to search for dashboards, and indicates the currently selected default dashboard. Users can choose a new default dashboard from the list, which then updates the application's settings. The modal also handles loading states and provides a close button.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Dashboard Selection:** Allows users to choose a dashboard from a list of available dashboards.\n*   **Search Functionality:** Enables users to search for specific dashboards by name or description.\n*   **Default Dashboard Indication:** Clearly indicates which dashboard is currently set as the default for a given scene.\n*   **Loading State Handling:** Displays a loading indicator while the list of dashboards is being fetched.\n*   **Modal Presentation:** Presents the dashboard selection interface within a modal window.\n*   **Scene-Specific Configuration:** Allows users to configure default dashboards on a per-scene basis.\n"
    },
    {
        "path": "frontend/src/lib/components/TestAccountFiltersSwitch.tsx",
        "summary": "The `TestAccountFilterSwitch` component is a toggle switch that allows users to filter out internal and test users from their data. It leverages the `LemonSwitch` component from `@posthog/lemon-ui` and integrates with `teamLogic` to determine if test account filters are configured. If no filters are set, the switch is disabled with a corresponding message. Clicking the gear icon next to the label opens the settings panel to manage internal user filtering.\n\nHere's a list of high-level product features:\n\n*   **Toggle to Filter Test Accounts:** Provides a simple on/off switch to exclude data from internal and test users.\n*   **Configuration Link:** Offers a direct link to the settings panel for managing internal user filters.\n*   **Disabled State with Explanation:** Disables the switch and provides a clear message when no test account filters are configured.\n*   **Visual Indication:** Uses a LemonSwitch component to provide a clear visual indication of the filter's state.\n"
    },
    {
        "path": "frontend/src/lib/components/SceneDashboardChoice/SceneDashboardChoiceRequired.tsx",
        "summary": "This React component, `SceneDashboardChoiceRequired`, is displayed when a user navigates to a scene (like a project homepage) that requires a dashboard but one hasn't been selected yet. It presents a message indicating that no dashboard is set for the current scene, along with an icon representing the scene. For the project homepage scene, it provides additional context explaining the purpose of default dashboards. A primary button labeled \"Select a dashboard\" is provided, which triggers a function (`props.open`) to open a dashboard selection modal.\n\n**Features:**\n\n*   **Empty State Display:** Shows a clear message when a required dashboard is missing for a specific scene.\n*   **Scene-Specific Messaging:** Adapts the message based on the current scene, providing relevant context (e.g., explaining default dashboards for the project homepage).\n*   **Dashboard Selection Button:** Provides a button to initiate the process of selecting a dashboard for the current scene.\n*   **Scene Icon:** Displays an icon representing the current scene for visual clarity.\n"
    },
    {
        "path": "frontend/src/lib/components/SceneDashboardChoice/SceneIcon.tsx",
        "summary": "The `SceneIcon` component in `SceneIcon.tsx` is a React component that renders an icon based on the provided `scene` prop. It uses icons from `@posthog/icons` (specifically `IconHome` and `IconPerson`) and applies a size-dependent styling using `clsx`. The component displays a home icon for the `ProjectHomepage` scene and a person icon for both `Group` and `Person` scenes. It returns null for any other scene type.\n\nHere's a list of high-level product features associated with this component:\n\n*   **Scene Representation:** Visually represents different scenes (e.g., project homepage, group, person) using distinct icons.\n*   **Iconography:** Uses a library of icons (`@posthog/icons`) to provide a consistent and recognizable visual language.\n*   **Theming/Styling:** Applies consistent styling to icons, including size and color, based on predefined CSS classes.\n*   **Dashboard Integration:** Used within a dashboard context to represent different scene types, likely within a scene selection or navigation component.\n"
    },
    {
        "path": "frontend/src/lib/components/SceneDashboardChoice/sceneDashboardChoiceModalLogic.ts",
        "summary": "This code defines a Kea logic module named `sceneDashboardChoiceModalLogic` that manages the state and behavior of a modal for choosing a dashboard to associate with a specific scene (e.g., a person's page, a group's page, or the project homepage). It handles opening and closing the modal, searching for dashboards, selecting a dashboard for a scene, and persisting that choice either as the team's primary dashboard (for the project homepage) or as a user-specific scene personalization setting. The logic connects to other Kea logics like `eventUsageLogic`, `teamLogic`, `userLogic`, and `dashboardsModel` to access and update relevant data.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dashboard Association with Scenes:** Allows users to associate specific dashboards with different scenes within the application (e.g., person profiles, group pages, project homepage).\n*   **Modal Interface for Dashboard Selection:** Provides a modal interface for users to browse and select a dashboard to associate with a scene.\n*   **Dashboard Search:** Enables users to search for dashboards within the modal using keywords.\n*   **Personalized Scene Dashboards:** Supports user-specific dashboard preferences for scenes like person profiles and group pages.\n*   **Team-Level Project Homepage Dashboard:** Allows setting a primary dashboard for the project homepage, which applies to the entire team.\n*   **Event Tracking:** Tracks user interactions with the modal and dashboard selection process for analytics purposes.\n"
    },
    {
        "path": "frontend/src/lib/components/SceneDashboardChoice",
        "summary": "The provided code collectively implements a feature for associating dashboards with specific scenes within the application, allowing for both team-wide defaults and user-specific customizations. A modal interface enables users to browse, search, and select dashboards, with clear visual cues indicating the current selection and scene context. The system handles loading states, provides scene-specific messaging, and tracks user interactions for analytics.\n\n**Features:**\n\n*   Dashboard Selection: Allows users to choose a dashboard from a list of available dashboards.\n*   Search Functionality: Enables users to search for specific dashboards by name or description.\n*   Default Dashboard Indication: Clearly indicates which dashboard is currently set as the default for a given scene.\n*   Loading State Handling: Displays a loading indicator while the list of dashboards is being fetched.\n*   Modal Presentation: Presents the dashboard selection interface within a modal window.\n*   Scene-Specific Configuration: Allows users to configure default dashboards on a per-scene basis.\n*   Empty State Display: Shows a clear message when a required dashboard is missing for a specific scene.\n*   Scene-Specific Messaging: Adapts the message based on the current scene, providing relevant context.\n*   Scene Representation: Visually represents different scenes using distinct icons.\n*   Personalized Scene Dashboards: Supports user-specific dashboard preferences for scenes.\n*   Team-Level Project Homepage Dashboard: Allows setting a primary dashboard for the project homepage, which applies to the entire team.\n*   Event Tracking: Tracks user interactions with the dashboard selection process for analytics purposes.\n"
    },
    {
        "path": "frontend/src/lib/components/HogQLDropdown/HogQLDropdown.tsx",
        "summary": "The `HogQLDropdown` component provides a dropdown interface for editing HogQL queries. It utilizes the `LemonDropdown` and `HogQLEditor` components to present a user-friendly editor for modifying HogQL code. The component takes a `hogQLValue` and `tableName` as input, displaying the current HogQL value within a button. Clicking the button toggles the visibility of the dropdown, which contains the `HogQLEditor`. Changes made in the editor are propagated via the `onHogQLValueChange` callback, updating the `hogQLValue` and closing the dropdown.\n\nHere's a list of high-level product features:\n\n*   **HogQL Query Editing:** Allows users to edit HogQL queries within a dedicated editor.\n*   **Dropdown Interface:** Presents the editor within a dropdown for a cleaner UI.\n*   **Syntax Highlighting and Autocompletion:** (Implied by the use of `HogQLEditor`, though not explicitly stated in the provided code) Provides syntax highlighting and autocompletion for HogQL code.\n*   **Dynamic Table Context:** Provides context to the editor based on a specified table name.\n*   **Real-time Updates:** Updates the HogQL value as the user edits the query.\n*   **Toggle Visibility:** Allows users to easily show/hide the HogQL editor.\n"
    },
    {
        "path": "frontend/src/lib/components/HogQLDropdown",
        "summary": "The HogQLDropdown component offers a user-friendly interface for editing HogQL queries directly within the application. It leverages a dropdown to house a dedicated HogQL editor, providing a clean and efficient way to modify queries. The component dynamically updates the HogQL value as the user makes changes and provides context based on the specified table name.\n\nHere's a list of high-level product features:\n\n*   **HogQL Query Editing:** Enables users to modify HogQL queries using a specialized editor.\n*   **Dropdown Interface:** Presents the editor within a dropdown for a streamlined user experience.\n*   **Syntax Highlighting and Autocompletion:** Offers syntax highlighting and autocompletion for efficient HogQL coding.\n*   **Dynamic Table Context:** Provides context to the editor based on a specified table name.\n*   **Real-time Updates:** Reflects changes to the HogQL value as the user edits the query.\n*   **Toggle Visibility:** Allows users to easily show/hide the HogQL editor.\n"
    },
    {
        "path": "frontend/src/lib/components/ObjectTags/objectTagsLogic.ts",
        "summary": "This code defines a Kea logic module called `objectTagsLogic` for managing tags associated with an object. It handles setting, cleaning, and ensuring the uniqueness of tags. The logic also manages the editing state of the tags and calls an optional `onChange` callback with the cleaned and unique tags whenever they are updated.\n\nHere's a list of high-level features:\n\n*   **Tag Management:** Allows setting and updating tags associated with an object.\n*   **Tag Cleaning:** Cleans tags by trimming whitespace and converting them to lowercase.\n*   **Tag Uniqueness:** Ensures that only unique tags are stored.\n*   **Editing State:** Manages the editing state of the tags (whether they are currently being edited).\n*   **Change Notification:** Provides a callback function to notify parent components when the tags are updated.\n"
    },
    {
        "path": "frontend/src/lib/components/ObjectTags/ObjectTags.tsx",
        "summary": "The `ObjectTags` component provides a way to display and manage tags associated with an object. It supports both static display of tags and interactive editing, allowing users to add, remove, and modify tags. The component uses Lemon UI components for styling and interaction, and integrates with PostHog's feature flagging system to potentially restrict tag editing behind a paywall. It also handles placeholder display for empty tag lists and provides visual cues for different tag types based on predefined color overrides.\n\nHere's a list of high-level product features:\n\n*   **Tag Display:** Displays a list of tags associated with an object.\n*   **Static Tag Display:** Supports displaying tags in a non-editable format.\n*   **Tag Editing:** Allows users to add, remove, and modify tags.\n*   **Tag Autocompletion:** Provides a list of available tags for autocompletion during editing.\n*   **Custom Tag Creation:** Enables users to create custom tags if allowed.\n*   **Saving State Indication:** Indicates when tags are being saved.\n*   **Feature Flagging Integration:** Integrates with feature flags to control access to tag editing functionality.\n*   **Visual Tag Styling:** Styles tags with different colors based on their content or type.\n*   **Placeholder for Empty Tags:** Displays a placeholder when no tags are present.\n"
    },
    {
        "path": "frontend/src/lib/components/ObjectTags",
        "summary": "The ObjectTags component provides a user interface for displaying and managing tags associated with an object. It handles tag cleaning, ensures uniqueness, and manages the editing state, notifying parent components of changes via a callback. The component supports both static display and interactive editing of tags, integrating with feature flags to control access to editing functionality and providing visual styling cues for different tag types.\n\nHere's a list of high-level product features:\n\n*   Tag Display: Displays a list of tags associated with an object.\n*   Tag Editing: Allows users to add, remove, and modify tags.\n*   Tag Autocompletion: Provides a list of available tags for autocompletion during editing.\n*   Custom Tag Creation: Enables users to create custom tags if allowed.\n*   Feature Flagging Integration: Integrates with feature flags to control access to tag editing functionality.\n*   Visual Tag Styling: Styles tags with different colors based on their content or type.\n*   Tag Management: Allows setting, cleaning, and ensuring the uniqueness of tags.\n*   Change Notification: Provides a callback function to notify parent components when the tags are updated.\n"
    },
    {
        "path": "frontend/src/lib/components/UpgradeModal/UpgradeModal.tsx",
        "summary": "The `UpgradeModal` component is a modal that prompts users to upgrade their PostHog plan to access a specific feature. It leverages the `PayGateMini` component to display information about the feature, current usage, and grandfathered status. The modal is controlled by the `upgradeModalLogic` Kea logic, which manages the visibility of the modal and the feature being promoted. If the `upgradeModalFeatureKey` is present, the modal is displayed; otherwise, nothing is rendered.\n\nHere's a list of high-level product features:\n\n*   **Upgrade Prompt:** Displays a modal prompting users to upgrade their plan to access a specific feature.\n*   **Feature Information Display:** Shows information about the feature that requires an upgrade.\n*   **Usage Tracking:** Displays the user's current usage of the feature.\n*   **Grandfathered Status Indication:** Indicates whether the user is grandfathered into the feature.\n*   **Modal Management:** Controls the visibility of the upgrade modal.\n"
    },
    {
        "path": "frontend/src/lib/components/UpgradeModal/upgradeModalLogic.ts",
        "summary": "This code defines the logic for an upgrade modal in the PostHog frontend. It manages the state of the modal, including which feature triggered it, the current usage of that feature, and whether the user is grandfathered in. It also provides a function `guardAvailableFeature` that checks if a feature is available to the user based on their preflight status (cloud vs. self-hosted), feature flags, and usage. If the feature is not available, it triggers the upgrade modal. The logic also tracks when the upgrade modal is shown for usage reporting.\n\nHere's a list of high-level product features related to this code:\n\n*   **Upgrade Modal:** Displays a modal prompting the user to upgrade their plan to access a specific feature.\n*   **Feature Gating:** Controls access to features based on the user's plan and usage.\n*   **Usage Tracking:** Tracks the user's usage of specific features.\n*   **Plan Management:** Allows users to upgrade their plan to access more features or increase usage limits.\n*   **Cloud/Self-hosted Differentiation:** Handles feature availability differently based on whether the instance is cloud-hosted or self-hosted.\n*   **Grandfathered Status:** Accounts for users who may have access to features due to grandfathered plans.\n*   **Event Tracking:** Tracks when the upgrade modal is shown to understand feature gating effectiveness."
    },
    {
        "path": "frontend/src/lib/components/UpgradeModal",
        "summary": "The code implements an upgrade modal system within the PostHog frontend. This system aims to gate certain features based on a user's subscription plan and usage, prompting them to upgrade when necessary. The system tracks feature usage, determines feature availability based on hosting type (cloud vs. self-hosted), feature flags, and grandfathered status, and displays a modal with relevant information about the feature and upgrade options. The display of the modal is tracked for usage reporting and effectiveness analysis.\n\nHere's a list of high-level product features:\n\n*   **Upgrade Modal:** Displays a modal prompting users to upgrade their plan to access a specific feature.\n*   **Feature Gating:** Controls access to features based on the user's plan and usage.\n*   **Usage Tracking:** Tracks the user's usage of specific features.\n*   **Plan Management:** Allows users to upgrade their plan to access more features or increase usage limits.\n*   **Cloud/Self-hosted Differentiation:** Handles feature availability differently based on whether the instance is cloud-hosted or self-hosted.\n*   **Grandfathered Status:** Accounts for users who may have access to features due to grandfathered plans.\n*   **Event Tracking:** Tracks when the upgrade modal is shown to understand feature gating effectiveness.\n*   **Feature Information Display:** Shows information about the feature that requires an upgrade.\n*   **Modal Management:** Controls the visibility of the upgrade modal.\n"
    },
    {
        "path": "frontend/src/lib/components/EntityFilterInfo.tsx",
        "summary": "The `EntityFilterInfo` component is a React component that displays information about an entity filter, which can be either an `EntityFilter` or an `ActionFilter`. It handles displaying the name of the filter, taking into account custom names and whether to show the underlying event/action name in addition to the custom name. The component also handles cases where the filter represents \"All events\". The component truncates the text if `allowWrap` is false.\n\nHere's a list of high-level features provided by the `EntityFilterInfo` component:\n\n*   **Displays entity filter names:** Shows the name of an entity filter, handling both standard names and custom names.\n*   **Handles \"All events\" filter:** Specifically displays \"All events\" when the filter represents all events.\n*   **Displays underlying event/action name:** Optionally displays the underlying event or action name in addition to a custom name.\n*   **Text truncation:** Truncates the displayed text to prevent overflow, with control over whether wrapping is allowed.\n*   **Taxonomic Filter Group Type:** Retrieves the label from the core filter definition based on the filter group type.\n"
    },
    {
        "path": "frontend/src/lib/components/Fade/Fade.tsx",
        "summary": "The `Fade` component in `Fade.tsx` provides a simple fade-in/fade-out animation for its children based on a boolean `visible` prop. It uses CSS animations to control the fade effect and manages the rendering of its children based on the animation state, ensuring that the content is only rendered when visible or during the fade-out animation. The component accepts additional props for customization, including a `className` for custom styling and a `style` prop for inline styles.\n\nHere's a list of high-level features:\n\n*   **Conditional Visibility:** Renders content based on a boolean `visible` prop.\n*   **Fade-in Animation:** Animates the content to fade in when `visible` is true.\n*   **Fade-out Animation:** Animates the content to fade out when `visible` is false.\n*   **CSS Styling:** Uses CSS classes for styling the fade effect.\n*   **Customizable Styling:** Accepts `className` and `style` props for custom styling.\n*   **Animation State Management:** Manages the rendering of children based on the animation state.\n"
    },
    {
        "path": "frontend/src/lib/components/Fade",
        "summary": "The `Fade` component offers a straightforward way to animate the visibility of content using a fade-in/fade-out effect. It leverages a boolean `visible` prop to control the animation and rendering of its children, ensuring a smooth transition. The component is styled using CSS and provides customization options through `className` and `style` props, allowing developers to easily integrate it into various UI designs.\n\nHere's a list of high-level product features:\n\n*   Conditional Visibility with Fade Animation\n*   Fade-in Animation\n*   Fade-out Animation\n*   CSS Styling\n*   Customizable Styling\n*   Animation State Management\n"
    },
    {
        "path": "frontend/src/lib/components/Animation/Animation.tsx",
        "summary": "The `Animation` component is a React component that displays Lottie animations with a configurable delay, size, and animation type. It fetches animation data asynchronously, utilizing a cache to prevent redundant requests. A fallback spinner is displayed if the animation fails to load. The component includes a delay before showing the animation to avoid visual distractions and handles visibility with a fade-in effect. It also disables autoplay in Storybook test runner environments.\n\n**Features:**\n\n*   **Animation Display:** Renders Lottie animations based on a specified type.\n*   **Asynchronous Loading:** Fetches animation data asynchronously with caching.\n*   **Configurable Delay:** Introduces a delay before displaying the animation.\n*   **Fallback Spinner:** Shows a spinner if the animation fails to load.\n*   **Size Options:** Offers different size options for the animation (small, large).\n*   **Autoplay Control:** Disables autoplay in Storybook test runner environments.\n*   **CSS Styling:** Uses CSS classes for styling and appearance.\n"
    },
    {
        "path": "frontend/src/lib/components/Animation",
        "summary": "The `Animation` component is a React component designed to display Lottie animations with a focus on performance and user experience. It asynchronously fetches animation data, leveraging a cache to prevent unnecessary requests and improve loading times. To enhance the user experience, it incorporates a configurable delay before displaying the animation and provides a fallback spinner in case the animation fails to load. The component also offers size options and disables autoplay in Storybook environments to prevent issues with automated testing.\n\n**Features:**\n\n*   Display Lottie animations based on a specified type.\n*   Asynchronously fetch animation data with caching.\n*   Configurable delay before displaying the animation.\n*   Fallback spinner if the animation fails to load.\n*   Size options for the animation (small, large).\n*   Disable autoplay in Storybook test runner environments.\n*   CSS styling for appearance.\n"
    },
    {
        "path": "frontend/src/lib/components/MonacoDiffEditor.tsx",
        "summary": "The `MonacoDiffEditor` component provides a React wrapper around the Monaco Editor's diff editor functionality. It allows users to compare two versions of code or text side-by-side, highlighting the differences between them. The component supports customizable width, height, language, theme, and editor options. It also provides a callback function for detecting changes in the modified content. The component dynamically calculates the height of the editor based on the content if the height is set to 100%.\n\nHere's a list of high-level product features:\n\n*   **Side-by-Side Diff View:** Displays two versions of content (original and modified) for easy comparison.\n*   **Syntax Highlighting:** Supports syntax highlighting for various programming languages.\n*   **Customizable Appearance:** Allows customization of width, height, theme, and other editor options.\n*   **Dynamic Height Calculation:** Automatically adjusts the editor height based on content length.\n*   **Change Detection:** Provides a callback function to detect and respond to changes in the modified content.\n*   **Programmatic Access:** Exposes the underlying Monaco Editor instance via a React ref.\n*   **URI Support:** Allows specifying URIs for the original and modified models.\n"
    },
    {
        "path": "frontend/src/lib/components/EmptyMessage/EmptyMessage.tsx",
        "summary": "The `EmptyMessage` component is a reusable React component that displays a message when a section of the application is empty or has no data to show. It consists of a title, a description, and an optional button. The button can link to another page or trigger a custom action. The component is styled using SCSS and utilizes the `LemonButton` component from the `lemon-ui` library.\n\nHere's a list of high-level features:\n\n*   **Displays a title:** Shows a prominent title to indicate the empty state.\n*   **Provides a description:** Offers a descriptive message explaining why the section is empty.\n*   **Includes an optional button:** Allows users to navigate to another page or trigger an action to populate the empty section.\n*   **Customizable button text:** The button text can be customized to suit the specific context.\n*   **Supports navigation:** The button can link to a different part of the application.\n*   **Supports custom actions:** The button can trigger a custom function when clicked.\n*   **Styled for visual appeal:** The component is styled using SCSS to provide a visually appealing empty state message.\n"
    },
    {
        "path": "frontend/src/lib/components/EmptyMessage",
        "summary": "The `EmptyMessage` component is a versatile React component designed to inform users when a section of the application lacks data. It provides a clear title and descriptive message to explain the empty state, and it includes an optional, customizable button. This button can either navigate the user to another relevant page or trigger a specific action to help populate the empty section, enhancing the user experience by guiding them towards resolving the empty state.\n\nHere's a list of high-level features:\n\n*   Displays a title to indicate the empty state.\n*   Provides a description explaining why the section is empty.\n*   Includes an optional button for navigation or action triggering.\n*   Offers customizable button text.\n*   Supports navigation to other pages.\n*   Supports triggering custom actions.\n*   Styled for visual appeal.\n"
    },
    {
        "path": "frontend/src/lib/components/TitleWithIcon.tsx",
        "summary": "The `TitleWithIcon` component is a reusable React component that displays a title (which can be a string or another JSX element) alongside an icon. It uses flexbox to align the title and icon horizontally, with the icon positioned to the right of the title and a small margin separating them. The component accepts an icon (a JSX element), children (the title content), and an optional `data-attr` prop for adding custom data attributes to the container element.\n\n**Features:**\n\n*   Displays a title with an icon.\n*   Supports string or JSX element as the title.\n*   Uses flexbox for easy alignment of title and icon.\n*   Accepts an icon as a JSX element.\n*   Allows adding custom data attributes to the container.\n"
    },
    {
        "path": "frontend/src/lib/components/CompareFilter/CompareFilter.tsx",
        "summary": "The `CompareFilter` component provides a user interface for comparing data across different time periods. It allows users to select between no comparison, comparing to the previous period, or comparing to a custom rolling date range. The component utilizes a `LemonSelect` dropdown for the main selection and a `RollingDateRangeFilter` for specifying the custom date range. The selected comparison option and date range are then passed to an `updateCompareFilter` function to update the overall query. The component also dynamically adjusts its display based on screen size, showing abbreviated labels on smaller screens.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Time-based Data Comparison:** Enables users to compare data across different time periods.\n*   **No Comparison Option:** Allows users to disable data comparison.\n*   **Compare to Previous Period:** Provides a quick option to compare data to the immediately preceding time period.\n*   **Custom Rolling Date Range Comparison:** Enables users to define a specific rolling date range for comparison.\n*   **Dynamic Labeling:** Adjusts displayed labels based on screen size for improved usability.\n*   **Disabled State Handling:** Hides the component when disabled to prevent inconsistent states.\n"
    },
    {
        "path": "frontend/src/lib/components/hedgehogs.tsx",
        "summary": "This code defines a React component library for displaying various hedgehog-themed images. It imports a collection of hedgehog images from the `public/hedgehog` directory and exports them as individual React components. Each component renders an `img` element with a specific hedgehog image as its source, with some components enforcing a square aspect ratio (400x400) and others maintaining a fixed height of 400px while allowing variable width.\n\nHere's a list of high-level product features:\n\n*   **Hedgehog Image Library:** Provides a collection of pre-designed hedgehog images for use in other components or applications.\n*   **React Components:** Exposes each hedgehog image as a reusable React component.\n*   **Image Display:** Renders the hedgehog images within a defined area, maintaining aspect ratio or fixed height.\n*   **Customizable Properties:** Allows passing standard `img` element properties to customize the appearance and behavior of the hedgehog images.\n*   **Image Variants:** Offers a variety of hedgehog characters depicting different themes and activities.\n"
    },
    {
        "path": "frontend/src/lib/components/SeriesGlyph.tsx",
        "summary": "This code defines React components for rendering glyphs used to represent data series in charts or graphs. It provides a base `SeriesGlyph` component for general styling and layout, and specialized components `SeriesLetter` and `ExperimentVariantNumber` for displaying series identifiers as letters or numbers, respectively. The styling of these components adapts to the current theme (light or dark mode) and whether the series has a breakdown, using color manipulation functions to create visually distinct and accessible glyphs.\n\n**Features:**\n\n*   **Base Glyph Component:** Provides a foundational component for styling series glyphs with customizable classes, styles, and children.\n*   **Series Letter Glyph:** Displays a letter from the alphabet to represent a data series, with dynamic styling based on dark mode and breakdown status.\n*   **Experiment Variant Number Glyph:** Displays a number to represent an experiment variant, with styling consistent with secondary text and adapting to dark mode.\n*   **Dynamic Styling:** Adapts glyph styling based on the current theme (light/dark mode) for improved visual appearance.\n*   **Color Handling:** Utilizes color manipulation functions to generate appropriate background and border colors for glyphs.\n"
    },
    {
        "path": "frontend/src/lib/components/CompareFilter",
        "summary": "The `CompareFilter` component empowers users to analyze data trends by offering flexible time-based comparisons. Users can choose to disable comparison, compare data to the previous period, or define a custom rolling date range for comparison. The component adapts to different screen sizes by dynamically adjusting labels and manages its visibility based on its enabled state, ensuring a consistent user experience.\n\nHere's a list of high-level product features:\n\n*   Time-based Data Comparison\n*   No Comparison Option\n*   Compare to Previous Period\n*   Custom Rolling Date Range Comparison\n*   Dynamic Labeling\n*   Disabled State Handling\n"
    },
    {
        "path": "frontend/src/lib/components/PanelLayout/PanelLayout.tsx",
        "summary": "The code defines a `PanelLayout` component in React, designed to provide a structured layout for panels and their settings. It includes components for creating primary and secondary panel containers, individual panels with customizable styling, settings sections with titles and borders, and various types of settings controls like menus, toggles, and buttons. These components leverage Lemon UI components and offer flexibility in arranging and styling panel-based interfaces.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Panel Layout Structure:** Provides a consistent structure for arranging panels in primary and secondary layouts, including column-based layouts.\n*   **Customizable Panels:** Allows creation of individual panels with custom styling and content.\n*   **Settings Sections:** Enables grouping of settings within panels, with optional titles and borders.\n*   **Settings Menu:** Implements a dropdown menu for settings, with support for availability checks and highlighting active items.\n*   **Settings Toggle:** Creates toggle switches for boolean settings, with tooltips and disabled states.\n*   **Settings Button:** Offers a simple button for triggering settings-related actions.\n"
    },
    {
        "path": "frontend/src/lib/components/PanelLayout",
        "summary": "The `PanelLayout` component provides a structured and customizable layout for panels and their associated settings within a React application. It offers a way to organize panels into primary and secondary layouts, create individual panels with custom styling, and group settings into visually distinct sections. The component also includes pre-built settings controls such as menus, toggles, and buttons, enhancing the user experience for configuring panel-related options.\n\nHere's a list of high-level product features enabled by this code:\n\n*   Panel Layout Structure\n*   Customizable Panels\n*   Settings Sections\n*   Settings Menu\n*   Settings Toggle\n*   Settings Button\n"
    },
    {
        "path": "frontend/src/lib/components/AuthorizedUrlList/AuthorizedUrlForm.tsx",
        "summary": "This component provides a form for adding authorized URLs, specifically designed for actions or experiments. It allows users to input a URL, with support for wildcard subdomains if enabled. The form includes \"Save\" and \"Cancel\" buttons, with the \"Save\" button indicating a loading state during submission. The form leverages the `kea-forms` library for state management and form handling, and it's styled using Lemon UI components.\n\nHere's a list of high-level product features:\n\n*   **URL Input:** Allows users to enter a URL to be authorized.\n*   **Wildcard Subdomain Support:** Enables the use of wildcard characters in the URL input for broader authorization.\n*   **Form Submission:** Provides \"Save\" and \"Cancel\" buttons for submitting or discarding the entered URL.\n*   **Loading State:** Indicates when the form is submitting data.\n*   **Integration with Actions/Experiments:** Designed to be used in the context of actions or experiments.\n"
    },
    {
        "path": "frontend/src/lib/components/AuthorizedUrlList/EmptyState.tsx",
        "summary": "The `EmptyState` component in the `AuthorizedUrlList` module provides a user interface for when there are no authorized URLs or domains. It dynamically displays different messages and actions based on the type of authorization list (recording domains or general URLs), the presence of suggested URLs, and the visibility of the add URL form. It also provides a button to fetch URL suggestions based on recently received events.\n\nHere's a list of high-level product features related to this component:\n\n*   **Authorized URL/Domain Management:** Allows users to manage a list of authorized URLs or domains for use in PostHog features.\n*   **URL/Domain Suggestions:** Provides suggestions for URLs or domains to authorize based on recently received events.\n*   **Dynamic Empty State Messaging:** Displays context-aware messages when the authorized list is empty, guiding users on how to get started.\n*   **Refresh Suggestions:** Enables users to manually refresh the list of suggested URLs or domains.\n*   **Integration with PostHog Features:** Connects authorized URLs/domains to various PostHog features like recordings, web analytics, web experiments, and the toolbar.\n"
    },
    {
        "path": "frontend/src/lib/components/AuthorizedUrlList/AuthorizedUrlList.tsx",
        "summary": "This component, `AuthorizedUrlList`, manages a list of authorized URLs for actions or experiments, allowing users to add, edit, remove, and launch these URLs. It distinguishes between authorized URLs and suggested URLs, providing contextual actions for each type. The component also offers an empty state with suggestions when no authorized URLs exist and supports launching URLs with or without the PostHog toolbar, including a manual launch code option.\n\nHere's a list of high-level product features:\n\n*   **URL Authorization Management:** Allows users to manage a list of authorized URLs for actions or experiments.\n*   **URL Suggestion:** Provides suggestions for URLs based on event data.\n*   **Add URL:** Enables users to add new URLs to the authorized list.\n*   **Edit URL:** Allows users to modify existing authorized URLs.\n*   **Remove URL:** Enables users to remove URLs from the authorized list.\n*   **Launch URL:** Provides functionality to launch authorized URLs in a new tab.\n*   **Toolbar Launch:** Supports launching URLs with the PostHog toolbar for debugging.\n*   **Manual Launch Code:** Offers a manual launch code for the PostHog toolbar.\n*   **Empty State with Suggestions:** Displays an empty state with suggested URLs when no authorized URLs exist.\n*   **Wildcard Support:** Allows the use of wildcards in authorized URLs."
    },
    {
        "path": "frontend/src/lib/components/AuthorizedUrlList/authorizedUrlListLogic.ts",
        "summary": "This code defines a Kea logic module named `authorizedUrlListLogic` that manages a list of authorized URLs for a PostHog team. It handles adding, removing, updating, and validating URLs, as well as fetching suggested URLs based on recent pageview events. The logic also supports launching the PostHog toolbar at a specific URL and copying the launch code to the clipboard. It distinguishes between different types of authorized URLs, such as toolbar URLs, recording domains, web analytics, and web experiments. The logic interacts with the PostHog API to update the team's authorized URLs and retrieve toolbar parameters.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Authorized URL Management:** Allows users to manage a list of URLs or domains that are authorized for PostHog features like recording and the toolbar.\n*   **URL Validation:** Validates URLs entered by the user, ensuring they are in the correct format and adhere to specific rules (e.g., wildcard usage).\n*   **URL Suggestion:** Suggests URLs based on recent pageview events, making it easier for users to add frequently visited domains.\n*   **Toolbar Launch:** Enables users to launch the PostHog toolbar directly from the authorized URL list.\n*   **Launch Code Generation:** Generates code snippets for manually launching the PostHog toolbar on a specific URL.\n*   **Wildcard Support:** Supports the use of wildcards in URLs to authorize entire subdomains.\n*   **Different URL Types:** Manages different types of authorized URLs, such as recording domains and app URLs, separately.\n"
    },
    {
        "path": "frontend/src/lib/components/AuthorizedUrlList",
        "summary": "The authorized URL list feature allows users to manage and validate URLs or domains authorized for use with PostHog features like recordings, the toolbar, web analytics, and experiments. It provides suggestions based on recent pageview events, supports wildcard subdomains, and offers contextual actions for adding, editing, removing, and launching URLs. The feature includes an empty state with dynamic messaging to guide users when no URLs are authorized, and a form for adding new URLs with loading state indication.\n\nHere's a list of high-level product features:\n\n*   Authorized URL Management\n*   URL Validation\n*   URL Suggestion\n*   Toolbar Launch\n*   Launch Code Generation\n*   Wildcard Support\n*   Different URL Types\n*   Add URL\n*   Edit URL\n*   Remove URL\n*   Launch URL\n*   Manual Launch Code\n*   Empty State with Suggestions\n*   Dynamic Empty State Messaging\n*   Refresh Suggestions\n*   URL Input\n*   Form Submission\n*   Loading State\n*   Integration with Actions/Experiments\n"
    },
    {
        "path": "frontend/src/lib/components/Subscriptions/subscriptionsLogic.ts",
        "summary": "This code defines the `subscriptionsLogic` Kea logic hook, responsible for managing subscriptions related to either a specific insight or a dashboard. It fetches, stores, and allows deleting subscriptions. The logic hook uses API calls to load subscriptions associated with a dashboard or insight and provides functionality to delete subscriptions with an undo option.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Subscription Listing:** Fetches and displays a list of subscriptions associated with a specific insight or dashboard.\n*   **Subscription Deletion:** Allows users to delete existing subscriptions.\n*   **Undo Delete:** Provides an \"undo\" mechanism when deleting a subscription, allowing users to revert the deletion.\n*   **Contextual Subscriptions:** Loads subscriptions based on the context of either a dashboard or a specific insight.\n"
    },
    {
        "path": "frontend/src/lib/components/Subscriptions/views/ManageSubscriptions.tsx",
        "summary": "The `ManageSubscriptions` component provides a user interface for managing subscriptions associated with insights or dashboards. It displays a list of existing subscriptions, allows users to view subscription details, delete subscriptions, and create new ones. The component handles loading states and displays appropriate messages when no subscriptions exist. It integrates with a modal for a focused management experience and utilizes PostHog's Lemon UI components for a consistent look and feel.\n\nHere's a list of high-level product features:\n\n*   **Subscription Listing:** Displays a list of active subscriptions with their titles and summaries.\n*   **Subscription Details:** Allows users to view the details of a subscription (likely via the `onSelect` callback).\n*   **Subscription Creation:** Enables users to create new subscriptions.\n*   **Subscription Deletion:** Allows users to delete existing subscriptions.\n*   **Target Type Display:** Displays the target type of the subscription (email or Slack) with appropriate icons and profile bubbles for email targets.\n*   **Loading State:** Shows a loading indicator while subscriptions are being fetched.\n*   **Empty State:** Displays a message when no subscriptions exist, prompting the user to create one.\n*   **Modal Integration:** Presents the subscription management interface within a modal.\n"
    },
    {
        "path": "frontend/src/lib/components/JSSnippet.tsx",
        "summary": "This code defines React components, `JSSnippet` and `JSSnippetV2`, that generate and display the PostHog JavaScript snippet. The snippet is configured with options like `api_host`, `ui_host`, and `person_profiles`, which are dynamically set based on feature flags, proxy settings, and team configurations. The `useJsSnippet` hook constructs the snippet string, incorporating a core JavaScript function that defines the `posthog` object and its methods. The `JSSnippetV2` component uses a different array.js path.\n\nHere's a list of high-level product features related to this code:\n\n*   **JavaScript Snippet Generation:** Dynamically generate the PostHog JavaScript snippet for web integration.\n*   **Proxy Support:** Configure the snippet to work with reverse proxies, ensuring correct API and UI host settings.\n*   **Feature Flag Integration:** Enable or disable snippet options based on feature flags, such as disabling person profiles for anonymous users.\n*   **Team-Specific Configuration:** Customize the snippet with the team's API token.\n*   **Code Display:** Display the generated JavaScript snippet in a user-friendly code block with HTML syntax highlighting.\n"
    },
    {
        "path": "frontend/src/lib/components/Subscriptions/subscriptionLogic.ts",
        "summary": "This code defines the logic for managing a single subscription within a PostHog application. It handles loading, creating, updating, and validating subscription data. The logic uses Kea for state management, forms for handling user input, and loaders for managing API requests. It also integrates with the router to handle navigation to subscription-related URLs. The component supports subscriptions for insights or dashboards, allowing users to schedule reports to be sent via email, Slack, or webhook.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Subscription Creation:** Allows users to create new subscriptions for insights or dashboards.\n*   **Subscription Editing:** Enables users to modify existing subscription settings.\n*   **Subscription Scheduling:** Supports various scheduling frequencies (daily, weekly, etc.) with customizable intervals and delivery times.\n*   **Delivery Target Configuration:** Allows users to specify the delivery target (email, Slack channel, or webhook URL).\n*   **Input Validation:** Validates user inputs, such as email addresses and URLs, to ensure data integrity.\n*   **Real-time Updates:** Propagates subscription changes to other relevant parts of the application.\n*   **Unsaved Changes Warning:** Warns users about unsaved changes when navigating away from the subscription form.\n*   **URL-based Actions:** Handles actions based on the URL, such as loading a subscription based on its ID.\n"
    },
    {
        "path": "frontend/src/lib/components/Subscriptions/SubscriptionsModal.tsx",
        "summary": "This code defines a modal and a button component for managing subscriptions within the PostHog application. The `SubscriptionsModal` component displays either a view for managing existing subscriptions or a view for editing a specific subscription, depending on the provided `subscriptionId`. It leverages the `PayGateMini` component to handle feature availability and display relevant documentation. The `SubscribeButton` component provides a dropdown menu with options to create a new subscription or manage existing ones, navigating the user to the appropriate views within the modal.\n\nHere's a list of high-level product features:\n\n*   **Subscription Management Modal:** A modal window that allows users to manage and edit their subscriptions.\n*   **Subscription Creation:** Ability to create new subscriptions, likely for reports or dashboards.\n*   **Subscription Editing:** Ability to modify existing subscriptions.\n*   **Subscription Deletion:** Ability to remove existing subscriptions.\n*   **Subscription Listing/Management:** A view to list and manage all existing subscriptions.\n*   **PayGate Integration:** Integration with a payment gateway (PayGateMini) to handle subscription-related payments and feature availability.\n*   **Dashboard/Insight Association:** Subscriptions can be associated with specific dashboards or insights.\n*   **Navigation:** Seamless navigation between subscription management and editing views.\n*   **\"Subscribe\" Button:** A button that triggers the subscription management modal, offering options to create or manage subscriptions.\n"
    },
    {
        "path": "frontend/src/lib/components/Subscriptions/views/EditSubscription.tsx",
        "summary": "This code defines a React component, `EditSubscription`, which is a modal form for creating or editing subscriptions within PostHog. Subscriptions allow users to schedule reports or insights to be sent to various destinations like email, Slack, or webhooks. The form dynamically renders fields based on the selected destination type, offering options for specifying recipients, channels, or webhook URLs. It also handles recurrence settings, allowing users to define the frequency and timing of the subscriptions. The component leverages Kea logic for state management and form handling, and integrates with other PostHog services like user management, Slack integration, and email configuration.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Subscription Creation/Editing:** Allows users to create new subscriptions or modify existing ones.\n*   **Multi-Destination Support:** Enables sending subscriptions to email, Slack channels, or webhooks.\n*   **Email Subscription Management:** Manages email recipients, including integration with user selection and custom email input.\n*   **Slack Integration:** Facilitates sending subscriptions to Slack channels, with channel selection and integration authorization.\n*   **Webhook Support:** Allows sending subscriptions to custom webhook URLs.\n*   **Recurrence Scheduling:** Provides options to configure the frequency and timing of subscriptions.\n*   **User-Friendly Interface:** Offers a modal form with clear labels, help text, and validation.\n*   **Dynamic Form Rendering:** Adapts the form fields based on the selected destination type.\n*   **Error Handling and Notifications:** Displays banners for configuration issues (e.g., SITE_URL misconfiguration, email not configured).\n*   **User Activity Tracking:** Displays who created the subscription and when."
    },
    {
        "path": "frontend/src/lib/components/Subscriptions/views",
        "summary": "The provided code implements a comprehensive subscription management feature within PostHog, enabling users to schedule and deliver reports or insights to various destinations. Users can manage existing subscriptions, create new ones, and edit their configurations through a user-friendly modal interface. The system supports multiple destinations, including email, Slack channels, and webhooks, with dynamic form rendering adapting to the selected destination type. Recurrence scheduling allows users to define the frequency and timing of subscriptions, while error handling and notifications ensure a smooth user experience.\n\nHere's a list of high-level product features:\n\n*   Subscription Listing: Display and manage a list of active subscriptions.\n*   Subscription Creation/Editing: Create new subscriptions or modify existing ones.\n*   Multi-Destination Support: Send subscriptions to email, Slack channels, or webhooks.\n*   Email Subscription Management: Manage email recipients, including user selection and custom email input.\n*   Slack Integration: Send subscriptions to Slack channels with channel selection and integration authorization.\n*   Webhook Support: Send subscriptions to custom webhook URLs.\n*   Recurrence Scheduling: Configure the frequency and timing of subscriptions.\n*   Subscription Details: View the details of a subscription.\n*   Subscription Deletion: Delete existing subscriptions.\n*   Target Type Display: Display the target type of the subscription (email or Slack).\n*   Loading State: Show a loading indicator while subscriptions are being fetched.\n*   Empty State: Display a message when no subscriptions exist.\n*   User Activity Tracking: Displays who created the subscription and when.\n"
    },
    {
        "path": "frontend/src/lib/components/Subscriptions/utils.tsx",
        "summary": "This code defines utility functions and data structures for managing subscriptions within a PostHog application, specifically related to dashboards and insights. It provides functions for generating URLs to subscription management pages, and defines various options for configuring subscription parameters such as target type (email, Slack), frequency (daily, weekly, monthly), interval, weekday, and time. These options are presented as LemonSelectOptions, a format compatible with PostHog's Lemon UI component library.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Subscription Management:** Allows users to subscribe to receive updates or reports related to dashboards and insights.\n*   **Delivery Channels:** Supports sending subscriptions via email and Slack.\n*   **Customizable Frequency:** Enables users to define the frequency of subscriptions (daily, weekly, monthly).\n*   **Interval Configuration:** Allows users to set an interval for subscriptions (e.g., every 2 days, every 3 weeks).\n*   **Weekday Selection:** Enables users to specify the day of the week for weekly subscriptions.\n*   **Time Selection:** Allows users to choose the time of day for subscription delivery.\n*   **Monthly Subscription Options:** Supports configuration of monthly subscriptions, including selecting a specific day of the week or a specific day of the month.\n"
    },
    {
        "path": "frontend/src/lib/components/Subscriptions",
        "summary": "The provided code collectively implements a comprehensive subscription management feature within PostHog, allowing users to schedule and deliver reports or insights to various destinations like email, Slack channels, and webhooks. Users can create, edit, delete, and manage their subscriptions through a user-friendly modal interface, with options to customize the frequency, timing, and delivery target. The system integrates with a payment gateway to manage feature availability and provides real-time updates and input validation to ensure a smooth user experience.\n\nHere's a list of high-level product features:\n\n*   Subscription Creation: Allows users to create new subscriptions for insights or dashboards.\n*   Subscription Editing: Enables users to modify existing subscription settings.\n*   Subscription Deletion: Allows users to delete existing subscriptions with an undo option.\n*   Subscription Listing/Management: Provides a view to list and manage all existing subscriptions.\n*   Subscription Scheduling: Supports various scheduling frequencies (daily, weekly, etc.) with customizable intervals and delivery times.\n*   Delivery Target Configuration: Allows users to specify the delivery target (email, Slack channel, or webhook URL).\n*   Multi-Destination Support: Send subscriptions to email, Slack channels, or webhooks.\n*   Input Validation: Validates user inputs, such as email addresses and URLs, to ensure data integrity.\n*   PayGate Integration: Integration with a payment gateway to handle subscription-related payments and feature availability.\n*   Contextual Subscriptions: Loads subscriptions based on the context of either a dashboard or a specific insight.\n"
    },
    {
        "path": "frontend/src/lib/components/ExportButton/exporter.tsx",
        "summary": "This code defines functions for downloading exported assets from a server. It includes a utility function `downloadBlob` that takes a Blob object and a filename, creates a temporary anchor element, sets the `href` to a URL representing the Blob, sets the `download` attribute to the filename, triggers a click on the anchor to initiate the download, and then cleans up the temporary URL. The `downloadExportedAsset` function takes an `ExportedAssetType` object, determines the download URL from the API, fetches the data as a Blob, and then calls `downloadBlob` to trigger the download. Finally, it defines a type `TriggerExportProps` which is a subset of `ExportedAssetType` used to trigger an export.\n\nHere's a list of high-level product features:\n\n*   **Download Exported Assets:** Allows users to download assets (e.g., dashboards, insights) that have been exported from the application.\n*   **Determine Export URL:** Dynamically determines the correct URL for downloading an exported asset based on its ID.\n*   **Blob Handling:** Fetches exported data as a Blob object for efficient download management.\n*   **Filename Handling:** Preserves the original filename of the exported asset during download.\n*   **Trigger Export:** Defines the properties needed to trigger an export, such as export format, dashboard, insight, and export context.\n"
    },
    {
        "path": "frontend/src/lib/components/ExportButton/ExportButton.tsx",
        "summary": "The `ExportButton` component provides a user interface element that allows users to export data in various formats. It utilizes a dropdown menu to present different export options, each associated with a specific file format and context (e.g., dashboard, insight, or a custom path and body). When a user selects an export option, the component triggers an export process via the `exportsLogic`, capturing relevant data attributes for analytics purposes. The component is built using Lemon UI components for styling and interactivity.\n\nHere's a list of high-level product features provided by the code:\n\n*   **Data Export:** Enables users to export data from dashboards, insights, or custom contexts.\n*   **Multiple Export Formats:** Supports exporting data in various file formats (e.g., CSV, JSON, etc.).\n*   **Dropdown Menu for Export Options:** Presents available export formats in a user-friendly dropdown menu.\n*   **Customizable Export Context:** Allows specifying the context of the export, such as a specific dashboard or insight.\n*   **Analytics Tracking:** Captures data attributes related to the export process for analytics purposes.\n*   **UI Integration:** Integrates with Lemon UI components for consistent styling and user experience.\n"
    },
    {
        "path": "frontend/src/lib/components/ExportButton/exportsLogic.ts",
        "summary": "This code defines a Kea logic module named `exportsLogic` that manages the creation, polling, and retrieval of exported assets. It handles both local and server-side exports, providing functionality to trigger exports, check their status, and download them upon completion. The logic also includes features for creating static cohorts from queries and displaying notifications to the user about the export and cohort creation processes. It interacts with the PostHog API to track export success and failures.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Initiate Exports:** Allows users to trigger the export of data in various formats (e.g., CSV, PNG). Supports both local data exports and server-side processing.\n*   **Export Status Polling:** Continuously checks the status of server-side exports, providing real-time updates to the user.\n*   **Automatic Download:** Automatically downloads the exported asset once it's ready.\n*   **Export History:** Keeps track of recent exports and allows users to download them.\n*   **Notifications:** Provides user feedback through toast notifications for export status (pending, success, failure).\n*   **Static Cohort Creation:** Enables users to create static cohorts based on a given query.\n*   **Cohort Management Integration:** Integrates with the cohort management system, allowing users to view newly created cohorts.\n*   **Error Handling:** Gracefully handles export failures and network errors, providing informative error messages to the user.\n"
    },
    {
        "path": "frontend/src/lib/components/ExportButton",
        "summary": "The provided code collectively delivers a comprehensive data export solution within the application. It empowers users to export data from various contexts like dashboards and insights in multiple formats, providing a user-friendly interface with real-time status updates and notifications. The system handles both local and server-side exports, automatically downloading assets upon completion and offering options to create static cohorts from queries. Furthermore, it integrates with analytics tracking and cohort management systems, ensuring a seamless user experience with robust error handling.\n\nHere's a list of high-level product features:\n\n*   Data Export: Enables users to export data from dashboards, insights, or custom contexts in various formats (CSV, JSON, PNG, etc.).\n*   Export Management: Manages the export process, including triggering exports, polling status, and automatic downloads.\n*   User Notifications: Provides real-time feedback on export status through toast notifications.\n*   Static Cohort Creation: Allows users to create static cohorts based on queries.\n*   Analytics Tracking: Captures data attributes related to the export process for analytics purposes.\n*   Error Handling: Gracefully handles export failures and network errors.\n*   UI Integration: Integrates with Lemon UI components for consistent styling and user experience.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertySelect/PropertySelect.tsx",
        "summary": "The `PropertySelect` component provides a user interface for selecting and managing properties, likely for filtering or analysis purposes. It allows users to add properties from a taxonomic filter, display selected properties as removable \"snacks,\" and optionally reorder them via drag-and-drop. The component utilizes the `dnd-kit` library for drag-and-drop functionality and PostHog's Lemon UI components for styling and interaction.\n\nHere's a list of high-level product features provided by the component:\n\n*   **Property Selection:** Allows users to select properties from a predefined list (taxonomic filter).\n*   **Property Display:** Displays selected properties as removable items (LemonSnacks).\n*   **Property Removal:** Enables users to remove selected properties.\n*   **Drag and Drop Reordering (Optional):** Provides the ability to reorder selected properties via drag and drop, enabled by a `sortable` prop.\n*   **Customizable Add Text:** The text on the \"add property\" button can be customized.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertySelect",
        "summary": "The `PropertySelect` component empowers users to interactively select, display, and manage properties, enhancing filtering and analysis workflows. Selected properties are presented as easily removable \"snacks,\" and the component offers optional drag-and-drop reordering for customized arrangements. The \"add property\" button's text is also customizable, providing flexibility in user guidance.\n\nHere's a list of high-level product features:\n\n*   Property Selection from a predefined list.\n*   Display of selected properties as removable items.\n*   Property Removal.\n*   Optional Drag and Drop Reordering.\n*   Customizable \"Add Property\" button text.\n"
    },
    {
        "path": "frontend/src/lib/components/Alerts/alertsLogic.ts",
        "summary": "This code defines a Kea logic module called `alertsLogic` responsible for managing and displaying alerts in the frontend. It fetches alerts from an API endpoint, stores them in a state variable, and sorts them based on their state (firing, errored, snoozed, not firing, and disabled). The logic module also provides a selector for accessing the sorted alerts.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Alert Retrieval:** Fetches alerts from the backend API.\n*   **Alert Storage:** Stores the fetched alerts in the frontend state.\n*   **Alert Sorting:** Sorts alerts based on their state to prioritize important alerts.\n*   **Alert State Management:** Tracks the state of each alert (firing, errored, snoozed, not firing, disabled).\n*   **Alert Display:** Provides a selector to access the sorted alerts for display in the UI.\n"
    },
    {
        "path": "frontend/src/lib/components/Alerts/SnoozeButton.tsx",
        "summary": "The `SnoozeButton` component provides a user interface for setting a \"snooze until\" date. It leverages the `DateFilter` component to allow users to select a date and time, which is then passed to a callback function (`onChange`). The component offers predefined date options like \"Tomorrow\" and \"One week from now,\" as well as the ability to select a custom date. It formats the dates using `dayjs` and `formatDate` utilities.\n\nHere's a list of high-level product features:\n\n*   **Snooze Functionality:** Allows users to temporarily suppress alerts or notifications until a specified date and time.\n*   **Predefined Snooze Options:** Offers quick snooze options like \"Tomorrow\" and \"One week from now.\"\n*   **Custom Date Selection:** Enables users to choose a specific date and time for snoozing.\n*   **Date Formatting:** Displays dates in a user-friendly format (e.g., \"MMM D - HH:mm\").\n*   **Rolling Date Ranges:** Supports relative date ranges like days, weeks, months, and years.\n"
    },
    {
        "path": "frontend/src/lib/components/Alerts/alertLogic.ts",
        "summary": "This code defines a Kea logic module named `alertLogic` responsible for managing the state and loading of a single alert. It uses `kea-loaders` to handle the asynchronous loading of alert data from an API endpoint. The logic is keyed by the `alertId` prop, allowing for multiple instances of the logic to manage different alerts. If no `alertId` is provided, it defaults to 'new', suggesting it can also handle the creation of new alerts. The logic fetches alert data upon mounting.\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **Alert Management:** The system allows for the management of alerts.\n*   **Alert Retrieval:** The system can retrieve individual alerts based on their ID.\n*   **New Alert Creation:** The system supports the creation of new alerts.\n*   **Asynchronous Data Loading:** Alert data is loaded asynchronously from an API.\n"
    },
    {
        "path": "frontend/src/lib/components/Alerts/insightAlertsLogic.ts",
        "summary": "This code defines the `insightAlertsLogic` Kea logic for managing alerts associated with a specific insight in a product analytics platform. It handles loading, deleting, and displaying alerts, as well as determining whether alerts are supported for a given insight query. The logic connects to the insight visualization data logic to access and react to changes in the insight's query and threshold line visibility. It also manages a warning message that appears when alerts are present but not supported for the current insight query.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Alert Creation and Management:** Allows users to create, view, and delete alerts for insights.\n*   **Threshold-Based Alerting:** Supports alerts triggered when insight data crosses defined thresholds (upper and lower bounds).\n*   **Visual Alert Representation:** Displays alert thresholds as goal lines on the insight visualization.\n*   **Alert Support Detection:** Determines if alerts are supported for a given insight query type.\n*   **Alert Deletion Warning:** Warns users when deleting an insight with existing alerts that are no longer supported.\n"
    },
    {
        "path": "frontend/src/lib/components/Alerts/views/ManageAlertsModal.tsx",
        "summary": "This code defines a modal component, `ManageAlertsModal`, that allows users to view and manage alerts associated with a specific insight in PostHog. It fetches and displays a list of alerts, showing their status (firing, errored, snoozed, not firing), enabled state, threshold conditions, and subscribed users. Users can navigate to individual alert details or create new alerts for the insight. The modal also provides a link to view all alerts in the system.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Alert Listing:** Displays a list of alerts associated with a specific insight.\n*   **Alert Status Indication:** Shows the current status of each alert (firing, errored, snoozed, not firing).\n*   **Alert Threshold Display:** Shows the threshold conditions for each alert (e.g., high/low bounds).\n*   **Alert Enabled State Display:** Indicates whether an alert is currently enabled or disabled.\n*   **Subscribed Users Display:** Shows a list of users subscribed to receive notifications for an alert.\n*   **Alert Navigation:** Allows users to navigate to the details page of a specific alert.\n*   **Alert Creation:** Provides a button to create a new alert for the insight.\n*   **Global Alert View Link:** Provides a link to view all alerts in the system.\n"
    },
    {
        "path": "frontend/src/lib/components/Sparkline.tsx",
        "summary": "The `Sparkline` component is a versatile charting tool designed for concise data visualization. It supports both bar and line chart types, displaying data as a single series of numbers or multiple time series with customizable colors. The component features optional labels for the X-axis, a maximum value indicator, and a loading state with a skeleton UI. It also includes interactive tooltips that display detailed information about data points on hover, and allows for customization of the X and Y axis scales.\n\nHere's a list of high-level product features:\n\n*   **Chart Type Selection:** Supports both bar and line chart visualizations.\n*   **Data Series Handling:** Accepts single series of numerical data or multiple time series with names and colors.\n*   **Customizable Colors:** Allows specifying colors for data series and hover states.\n*   **X-Axis Labels:** Supports optional labels for the X-axis.\n*   **Maximum Value Indicator:** Option to display an indicator for the maximum value on the Y-axis.\n*   **Loading State:** Displays a skeleton UI during data loading.\n*   **Axis Scale Customization:** Provides hooks to customize the X and Y axis scales.\n*   **Interactive Tooltips:** Displays detailed information on data points when hovering.\n*   **Tooltip Label Rendering:** Allows custom rendering of labels in the tooltip.\n"
    },
    {
        "path": "frontend/src/lib/components/Alerts/types.ts",
        "summary": "This code defines the data structures and interfaces for managing alerts within the application. It includes types for alert configurations, alert conditions, thresholds, and states. It also defines the structure for representing alerts, including their properties, associated insights, subscribed users, and check history. The code differentiates between the read and write representations of alerts, as well as the data structures for alert checks.\n\nHere's a list of high-level product features that can be inferred from the code:\n\n*   **Alert Creation and Configuration:** Allows users to create and configure alerts based on specific conditions and thresholds.\n*   **Alert Subscription Management:** Enables users to subscribe to alerts and receive notifications.\n*   **Alert Snoozing:** Provides the ability to temporarily disable or snooze alerts.\n*   **Alert State Tracking:** Monitors and displays the current state of alerts (e.g., active, triggered, resolved).\n*   **Alert History and Checks:** Maintains a history of alert checks and notifications.\n*   **Insight Integration:** Integrates alerts with query-based insights for data-driven alerting.\n*   **User Management:** Manages users who create and subscribe to alerts.\n*   **Alert Scheduling:** Allows configuration of alert calculation intervals and skipping weekend checks.\n"
    },
    {
        "path": "frontend/src/lib/components/Alerts/views/Alerts.tsx",
        "summary": "This component, `Alerts.tsx`, displays a table of alerts fetched from the PostHog backend. It allows users to view alert details, status, last checked/notified times, associated insight, and enabled/disabled state. The table provides sorting and links to individual alert details and associated insights. When no alerts are present, a product introduction component is displayed, guiding users on how to create alerts. An `EditAlertModal` is also rendered when a specific alert is selected, enabling users to modify alert settings.\n\nHere's a list of high-level product features:\n\n*   **Alert Listing:** Displays a sortable table of alerts with key information.\n*   **Alert Details:** Provides links to individual alert detail pages.\n*   **Alert Status Indication:** Shows the current status (enabled/disabled) of each alert.\n*   **Last Checked/Notified Timestamps:** Displays the last time an alert was checked and/or triggered.\n*   **Insight Association:** Links alerts to their corresponding insights.\n*   **Alert Creation Guidance:** Provides a product introduction with instructions on creating alerts when no alerts exist.\n*   **Alert Editing:** Allows users to modify existing alert settings via a modal.\n"
    },
    {
        "path": "frontend/src/lib/components/Alerts/views/EditAlertModal.tsx",
        "summary": "This code defines the `EditAlertModal` component, a modal window that allows users to create or edit alerts for insights in PostHog. The modal includes a form for configuring alert conditions, such as the metric to monitor, the threshold for triggering the alert, and notification settings. It also displays the current status of the alert and a history of checks. The component leverages Lemon UI components for a consistent user interface and uses Kea logic for state management and form handling.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Alert Creation/Editing:** Allows users to define and modify alerts based on insight data.\n*   **Alert Configuration:** Provides a form to configure alert conditions, including metric selection, threshold values, and comparison operators (e.g., \"greater than,\" \"less than\").\n*   **Threshold Types:** Supports absolute value and relative change (increase/decrease) threshold types.\n*   **Alert Status Display:** Shows the current status of the alert (e.g., firing, snoozed) and a history of checks.\n*   **Notification Settings:** Enables users to specify who should be notified when an alert is triggered.\n*   **Alert Snoozing:** Allows users to temporarily disable alerts for a specified period.\n*   **Alert Enabling/Disabling:** Allows users to enable or disable the alert.\n*   **Breakdown Support:** Handles alerts for trends with breakdowns, firing if any breakdown value breaches the threshold.\n*   **Formula Support:** Handles alerts for trends using formulas, alerting on the formula value."
    },
    {
        "path": "frontend/src/lib/components/Alerts/alertFormLogic.ts",
        "summary": "This code defines a Kea logic module, `alertFormLogic`, responsible for managing the creation, updating, and deletion of alerts within the PostHog application. It handles the form state, validation, and API interactions for alert management, including setting alert thresholds based on insight goal lines, managing subscribed users, and configuring alert conditions and intervals. The logic also supports snoozing and clearing snoozes for existing alerts.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Alert Creation:** Allows users to create new alerts based on insights, defining conditions, thresholds, and notification settings.\n*   **Alert Editing:** Enables users to modify existing alerts, including their name, status, conditions, thresholds, and subscribed users.\n*   **Alert Deletion:** Provides the ability to remove alerts that are no longer needed.\n*   **Alert Snoozing:** Allows users to temporarily silence alerts until a specified time.\n*   **Alert Snooze Clearing:** Enables users to manually remove an active snooze from an alert.\n*   **Threshold Configuration:** Supports setting alert thresholds based on insight goal lines, allowing alerts to trigger when metrics cross defined boundaries.\n*   **User Subscription Management:** Allows users to subscribe or unsubscribe other users from receiving alert notifications.\n*   **Alert Condition Configuration:** Supports configuring different alert conditions, such as absolute value or relative increase.\n*   **Alert Interval Configuration:** Allows users to set the calculation interval for alerts (e.g., daily, hourly).\n*   **Weekend Skipping:** Provides an option to skip alert checks on weekends.\n*   **Ongoing Interval Checking:** Allows alerts to check for conditions that persist over an interval."
    },
    {
        "path": "frontend/src/lib/components/Alerts/views",
        "summary": "The provided code implements a comprehensive alert management system within PostHog, enabling users to create, edit, view, and manage alerts based on insight data. The system provides a user-friendly interface for configuring alert conditions, monitoring alert status, and managing notifications. Key features include the ability to define alerts based on various metrics and thresholds, view alert history and status, manage alert subscriptions, and receive notifications when alerts are triggered.\n\n*   **Alert Creation/Editing:** Define and modify alerts based on insight data with configurable conditions.\n*   **Alert Listing & Details:** View a sortable table of alerts with key information and links to individual alert detail pages.\n*   **Alert Status & History:** Display the current status of alerts (firing, snoozed, etc.) and a history of checks.\n*   **Notification Management:** Specify who should be notified when an alert is triggered and manage subscriptions.\n*   **Alert Snoozing/Enabling/Disabling:** Temporarily disable alerts or toggle their active state.\n*   **Insight Association:** Link alerts to their corresponding insights for easy management.\n*   **Threshold Configuration:** Set threshold values and comparison operators for triggering alerts.\n*   **Breakdown & Formula Support:** Handle alerts for trends with breakdowns or formulas.\n*   **Global Alert View:** Access a centralized view of all alerts in the system.\n"
    },
    {
        "path": "frontend/src/lib/components/Alerts/AlertDeletionWarning.tsx",
        "summary": "The `AlertDeletionWarning` component displays a warning banner using LemonBanner from the Lemon UI library when a user is about to save an insight with a chart type that doesn't support alerts. It checks if alerts are set up for the insight and if the current chart type supports them. If alerts exist but the chart type doesn't support them, the banner informs the user that saving will result in the deletion of those alerts. The component uses kea logic to determine whether the warning should be displayed, based on the insight's ID and properties.\n\nHere's a list of high-level product features:\n\n*   **Alerting on Insights:** Allows users to set up alerts for specific insights.\n*   **Chart Type Compatibility Check:** Determines if the selected chart type supports alerts.\n*   **Alert Deletion Warning:** Displays a warning message when saving an insight will result in the deletion of existing alerts due to chart type incompatibility.\n"
    },
    {
        "path": "frontend/src/lib/components/Alerts/AlertsButton.tsx",
        "summary": "This React component, `AlertsButton`, renders a button that navigates the user to the alerts management page for a specific insight. The button is only displayed if the `ALERTS` feature flag is enabled. It uses the `insightAlertsLogic` to fetch the number of alerts associated with the insight and displays this count as a badge on the bell icon. The button is disabled if alerts are not supported for the current insight type (currently only trends insights are supported).\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Alerts Management Navigation:** Provides a button to navigate to the alerts management page for a given insight.\n*   **Alerts Feature Flag Check:** Checks if the alerts feature is enabled before rendering the button.\n*   **Alert Count Display:** Displays the number of alerts associated with an insight on the button icon.\n*   **Insight Type Support Check:** Disables the button if alerts are not supported for the insight type.\n"
    },
    {
        "path": "frontend/src/lib/components/Alerts",
        "summary": "This collection of code files describes a comprehensive alerting system integrated within a product analytics platform, likely PostHog. The system enables users to create, manage, and monitor alerts based on insights derived from their data. Key functionalities include defining alert conditions and thresholds, managing user subscriptions to alerts, snoozing alerts, and receiving notifications when alerts are triggered. The system also ensures compatibility between alert configurations and insight types, warning users when changes might lead to alert deletion. The user interface provides tools for navigating to alert management pages, displaying alert counts, and visualizing alert thresholds on insight charts.\n\nHere's a list of high-level product features:\n\n*   Alert Creation and Configuration: Define alerts based on specific conditions, thresholds, and notification settings.\n*   Alert Management: Create, edit, delete, snooze, enable/disable, and manage existing alerts.\n*   Alert Monitoring: Track the status of alerts (firing, snoozed, etc.) and view alert history.\n*   Alert Notifications: Subscribe users to alerts and send notifications when alerts are triggered.\n*   Insight Integration: Associate alerts with specific insights and visualize alert thresholds on charts.\n*   Threshold-Based Alerting: Trigger alerts when insight data crosses defined thresholds.\n*   Alert Support Detection: Determine if alerts are supported for a given insight query type.\n*   Alert Deletion Warning: Warn users when deleting or modifying insights will result in the deletion of existing alerts.\n*   User Subscription Management: Allow users to subscribe or unsubscribe other users from receiving alert notifications.\n*   Alert Condition Configuration: Support configuring different alert conditions, such as absolute value or relative increase.\n*   Alert Interval Configuration: Allow users to set the calculation interval for alerts (e.g., daily, hourly).\n*   Weekend Skipping: Provide an option to skip alert checks on weekends.\n*   Ongoing Interval Checking: Allow alerts to check for conditions that persist over an interval.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertiesTimeline/index.ts",
        "summary": "The code exports the `PropertiesTimeline` component, making it available for use in other parts of the application. This suggests the existence of a visual component designed to display a timeline of property-related events or changes.\n\n**Features:**\n\n*   **Property Timeline Visualization:** Displays a chronological view of events or changes associated with a property.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertiesTimeline/propertiesTimelineLogic.ts",
        "summary": "This code defines the logic for a Properties Timeline component in a PostHog application. It fetches and processes data to display a timeline of property changes for a given actor (person), based on a specified filter. The logic handles data fetching, timezone conversions, and selection of specific points on the timeline. It also includes error handling for cases where the API returns unexpected results.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Display Property Timeline:** Visualizes how an actor's properties change over time.\n*   **Filter Property Timeline:** Allows users to filter the timeline based on specific criteria.\n*   **Select Timeline Points:** Enables users to select and inspect specific points on the timeline.\n*   **Show Crucial Properties:** Highlights the most important properties that changed during the selected period.\n*   **Timezone Conversion:** Converts timestamps to the user's timezone for accurate display.\n*   **Error Handling:** Captures and reports errors when the API returns unexpected data.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertiesTimeline/PropertiesTimeline.tsx",
        "summary": "The `PropertiesTimeline` component visualizes the evolution of an actor's (person or group) properties over time, focusing on properties relevant to a specific insight. It displays a timeline seekbar that highlights points where key properties change, allowing users to select a point in time and view the actor's properties at that moment. The component also indicates which properties are crucial to the insight's query definition, providing context for their importance. A properties table displays the properties for the selected point in time, highlighting the crucial properties.\n\nHere's a list of high-level features:\n\n*   **Timeline Visualization:** Displays a timeline representing changes in an actor's properties over time.\n*   **Key Property Highlighting:** Highlights properties that are relevant to the current insight's query definition.\n*   **Point-in-Time Property Inspection:** Allows users to select a specific point on the timeline and view the actor's properties at that time.\n*   **Properties Table:** Presents a table view of the actor's properties, with crucial properties highlighted.\n*   **Loading State:** Indicates when the property data is being loaded.\n*   **Contextual Tooltips:** Provides explanations about the relevance of key properties to the insight.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertiesTimeline",
        "summary": "The `PropertiesTimeline` component provides a visual representation of how an actor's properties evolve over time, focusing on those properties that are most relevant to a specific insight. Users can interact with the timeline to select specific points in time and inspect the actor's properties at that moment, with crucial properties highlighted for context. The component handles data fetching, timezone conversions, and error handling to ensure accurate and reliable display of property changes.\n\n**Features:**\n\n*   Timeline Visualization: Displays a timeline representing changes in an actor's properties over time.\n*   Key Property Highlighting: Highlights properties that are relevant to the current insight's query definition.\n*   Point-in-Time Property Inspection: Allows users to select a specific point on the timeline and view the actor's properties at that time.\n*   Properties Table: Presents a table view of the actor's properties, with crucial properties highlighted.\n*   Loading State: Indicates when the property data is being loaded.\n*   Contextual Tooltips: Provides explanations about the relevance of key properties to the insight.\n*   Filter Property Timeline: Allows users to filter the timeline based on specific criteria.\n*   Timezone Conversion: Converts timestamps to the user's timezone for accurate display.\n*   Error Handling: Captures and reports errors when the API returns unexpected data.\n"
    },
    {
        "path": "frontend/src/lib/components/Map/Map.tsx",
        "summary": "The `Map` component renders an interactive map using MapLibre GL JS, displaying geographical data sourced from a PMTiles archive. The map's appearance adapts to the user's selected theme (light or dark mode). The component conditionally renders the map only in cloud or development environments, displaying a message otherwise. It supports centering the map on specific coordinates and displaying markers at specified locations. The map dynamically resizes to fit its container.\n\nHere's a list of high-level product features:\n\n*   **Interactive Map Display:** Renders an interactive map using MapLibre GL JS.\n*   **PMTiles Data Source:** Fetches map data from a PMTiles archive hosted on AWS S3.\n*   **Theme Support:** Adapts the map's appearance based on the user's selected theme (light or dark mode).\n*   **Conditional Rendering:** Only displays the map in cloud or development environments.\n*   **Map Centering:** Allows centering the map on specified coordinates.\n*   **Marker Support:** Enables displaying markers at specified locations on the map.\n*   **Dynamic Resizing:** Automatically resizes the map to fit its container.\n"
    },
    {
        "path": "frontend/src/lib/components/BillingAlertsV2.tsx",
        "summary": "The `BillingAlertsV2` component displays billing-related alerts to the user via a LemonBanner component. The alerts are fetched from the `billingLogic` and can be dismissed, unless they are of type 'error'. The component tracks whether the alert has been shown and reports when the alert is displayed and when the action button is clicked. The alert's visibility is also dependent on the current URL, hiding if the current path doesn't match the alert's specified path. The banner includes a title, message, and an optional action button that navigates to the billing page, contacts support, or performs a custom action.\n\nHere's a list of high-level product features:\n\n*   **Display Billing Alerts:** Shows important billing notifications to users.\n*   **Alert Persistence:** Remembers if an alert has been dismissed (except for error alerts).\n*   **Contextual Alerts:** Displays alerts based on the current URL/route.\n*   **Actionable Alerts:** Provides buttons for users to take action, such as managing billing or contacting support.\n*   **Alert Reporting:** Tracks when alerts are shown and when actions are taken on them.\n*   **Customizable Alerts:** Allows for different alert types (status), titles, messages, and actions.\n"
    },
    {
        "path": "frontend/src/lib/components/Map",
        "summary": "The Map component provides an interactive map interface using MapLibre GL JS, sourcing geographical data from a PMTiles archive. It dynamically adjusts its appearance based on the user's theme preference and renders conditionally based on the environment. The map supports centering on specific coordinates, displaying markers, and automatically resizing to fit its container.\n\nHere's a list of high-level product features:\n\n*   Interactive Map Display\n*   PMTiles Data Source\n*   Theme Support (Light/Dark Mode)\n*   Conditional Rendering (Environment-based)\n*   Map Centering\n*   Marker Support\n*   Dynamic Resizing\n"
    },
    {
        "path": "frontend/src/lib/components/EventSelect/EventSelect.tsx",
        "summary": "The `EventSelect` component provides a user interface for selecting and managing events. It displays selected events as removable \"snacks\" and uses a popover with a `TaxonomicFilter` to allow users to add new events to the selection. The component supports custom filter group types and provides callbacks for handling changes to the selected events and items.\n\nHere's a list of high-level features:\n\n*   **Event Selection:** Allows users to select events from a predefined list or taxonomy.\n*   **Display of Selected Events:** Shows currently selected events in a visually clear manner (using LemonSnack components).\n*   **Removal of Selected Events:** Provides a mechanism to remove individual events from the selection.\n*   **Taxonomic Filtering:** Integrates with a `TaxonomicFilter` component to enable searching and filtering of events based on predefined categories or types.\n*   **Customizable Filter Groups:** Supports different types of event filtering via `filterGroupTypes`.\n*   **Popover Interface:** Uses a popover to display the event selection interface, keeping the main UI clean and uncluttered.\n*   **Callback Functions:** Exposes callback functions to notify parent components of changes to the selected events and items.\n"
    },
    {
        "path": "frontend/src/lib/components/EventSelect",
        "summary": "The `EventSelect` component offers a user-friendly interface for event selection and management. It displays selected events as easily removable \"snacks\" and utilizes a popover containing a `TaxonomicFilter` to facilitate the addition of new events. The component is designed to be flexible, supporting custom filter group types and providing callback functions to handle changes in selected events and items, ensuring seamless integration with parent components.\n\nHere's a list of high-level features:\n\n*   Event Selection from a predefined list or taxonomy.\n*   Visual display of selected events as removable \"snacks\".\n*   Taxonomic filtering for efficient event searching.\n*   Customizable filter groups for diverse event filtering options.\n*   Popover interface for a clean and uncluttered UI.\n*   Callback functions for event and item change notifications.\n"
    },
    {
        "path": "frontend/src/lib/components/ReverseProxyChecker/reverseProxyCheckerLogic.ts",
        "summary": "The `reverseProxyCheckerLogic` Kea logic component is designed to automatically detect if a reverse proxy is set up for a PostHog instance. It periodically queries the event stream for the presence of the `$lib_custom_api_host` property, indicating a custom API host configuration typically associated with reverse proxies. Upon successful detection, it marks the \"Set Up Reverse Proxy\" task as completed in the activation checklist. The logic uses loaders to manage the asynchronous API call and reducers to persist the last checked timestamp, ensuring checks are performed no more frequently than once per hour.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Automatic Reverse Proxy Detection:** Automatically determines if a reverse proxy is configured.\n*   **Activation Task Completion:** Marks the \"Set Up Reverse Proxy\" task as complete in the activation checklist upon successful detection.\n*   **Periodic Checks:** Checks for the reverse proxy configuration periodically (every hour) to account for changes.\n*   **Persistence:** Remembers the last check time to avoid excessive API calls.\n"
    },
    {
        "path": "frontend/src/lib/components/ReverseProxyChecker",
        "summary": "The `reverseProxyCheckerLogic` Kea logic component automates the detection of reverse proxy configurations in PostHog instances by periodically querying the event stream for the `$lib_custom_api_host` property. Upon detection, it automatically completes the \"Set Up Reverse Proxy\" task in the activation checklist. The component also implements rate limiting by persisting the last check timestamp, ensuring checks are performed no more than once per hour.\n\nHere's a list of high-level product features:\n\n*   Automatic Reverse Proxy Detection\n*   Activation Task Completion\n*   Periodic Checks for Configuration Changes\n*   Rate Limiting to Prevent Excessive API Calls\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/shortcutsLogic.ts",
        "summary": "This code defines a Kea logic module called `shortcutsLogic` that manages keyboard shortcuts for the command bar. It listens for the \"Escape\" key press and triggers the `hideCommandBar` action from the `commandBarLogic` to close the command bar. The logic registers and unregisters the keydown event listener on the window during the component's mount and unmount lifecycle, respectively.\n\n**Features:**\n\n*   **Escape Key Shortcut:** Closes the command bar when the \"Escape\" key is pressed.\n*   **Keyboard Event Handling:** Registers and unregisters a global keydown event listener.\n*   **Integration with Command Bar:** Connects to the `commandBarLogic` to trigger the command bar's hide action.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/utils.ts",
        "summary": "This code provides a utility function `getNameFromActionScope` that translates an action scope string into a more human-readable name. It uses a predefined mapping (`actionScopeToName`) to perform the translation. If the scope is found in the mapping, the corresponding name is returned; otherwise, the original scope string is returned.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Action Scope Naming:** Allows the application to display user-friendly names for different action scopes in the command bar.\n*   **Customizable Action Scope Labels:** Enables the customization of action scope labels through the `actionScopeToName` mapping.\n*   **Fallback Scope Display:** Provides a fallback mechanism to display the original scope string if a user-friendly name is not defined.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/SearchTabs.tsx",
        "summary": "The `SearchTabs` component displays a set of tabs within the command bar, grouped by category. It utilizes the `searchBarLogic` to retrieve the tabs and their grouping. The component iterates through the grouped tabs and renders a `SearchBarTab` component for each tab, passing the tab data and a reference to the input element. The tabs are displayed in a vertical column with optional group headers.\n\n**Features:**\n\n*   **Tabbed Search:** Organizes search options into distinct tabs for easier navigation.\n*   **Tab Grouping:** Groups related search tabs under category headings.\n*   **Dynamic Tab Display:** Uses data from `searchBarLogic` to dynamically render tabs.\n*   **Keyboard Navigation Support:** Passes input reference to individual tabs for keyboard navigation.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/ActionResult.tsx",
        "summary": "This React component, `ActionResult`, is responsible for rendering a single result within a command bar or palette. It displays the result's icon and display text, highlights the result when focused, and provides visual feedback (a border) to indicate executability. Clicking on an executable result triggers its execution via the `actionBarLogic`. The component also ensures the focused result is visible by scrolling it into view.\n\nHere's a list of high-level product features associated with this component:\n\n*   **Display Command Results:** Renders individual command results with an icon and display text.\n*   **Focus Highlighting:** Visually highlights the currently focused command result.\n*   **Executability Indication:** Indicates whether a command result is executable.\n*   **Command Execution:** Executes a command when its result is clicked.\n*   **Scroll Into View:** Automatically scrolls the focused command result into the visible area.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/ActionBar.tsx",
        "summary": "The `ActionBar` component is a core part of the command bar interface. It dynamically renders either an `ActionInput` component or displays `ActionResults` based on the state of the `activeFlow` within the `actionBarLogic`. The component uses a flexbox layout to arrange its children vertically, occupying the full height of its container.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Action Input:** Provides a user interface element for accepting user input to initiate actions or commands.\n*   **Dynamic UI Rendering:** Switches between displaying the action input and the action results based on the current state of the active flow.\n*   **Action Results Display:** Presents the results or output of executed actions or commands to the user.\n*   **Command Flow Management:** Integrates with a command flow management system (`actionBarLogic`) to guide the user through a series of steps or instructions.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/ActionResults.tsx",
        "summary": "This code defines the `ActionResults` component, which is responsible for displaying the results of commands in a command bar. It groups the results by scope (category) and renders each result using the `ActionResult` component. The component uses the `actionBarLogic` to access the search results and the currently active result index, highlighting the focused result. The `ResultsGroup` component displays the scope name as a header for each group of results.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Command Result Display:** Shows the results of commands entered in the command bar.\n*   **Result Grouping:** Groups command results by scope or category.\n*   **Active Result Highlighting:** Highlights the currently selected or focused command result.\n*   **Scrolling:** Allows users to scroll through a long list of command results.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/SearchResultPreview.tsx",
        "summary": "The `SearchResultPreview` component displays a preview of the currently selected search result in the command bar. It shows the type of result, its name, the URL, and a description. It also includes a button to open the selected result, with a keyboard shortcut hint. The component uses data from the `searchBarLogic` Kea logic to access the search results and open them.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Search Result Preview:** Displays a preview of the selected search result.\n*   **Result Type Indication:** Shows the category or type of the search result.\n*   **Result Name Display:** Presents the name or title of the search result.\n*   **URL Display:** Shows the URL associated with the search result.\n*   **Result Description:** Provides a brief description of the search result.\n*   **Open Result Action:** Allows the user to open the selected search result.\n*   **Keyboard Shortcut Support:** Displays and supports a keyboard shortcut for opening the result.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/commandBarLogic.ts",
        "summary": "This code defines the logic for a command bar component using the Kea framework. It manages the command bar's visibility and state (hidden, search, actions, shortcuts), handles keyboard shortcuts to toggle different command bar modes (search, actions, shortcut overview), and tracks command bar usage via event reporting. The logic also manages an initial query that can be set when the command bar is opened.\n\nHere's a list of high-level product features:\n\n*   **Toggleable Command Bar:** Allows users to show or hide the command bar.\n*   **Search Functionality:** Provides a search interface within the command bar.\n*   **Actions Menu:** Presents a menu of available actions within the command bar.\n*   **Shortcut Overview:** Displays a list of available keyboard shortcuts.\n*   **Keyboard Shortcut Support:** Enables users to trigger command bar functions using keyboard shortcuts (e.g., Ctrl/Cmd+K for search, Ctrl/Cmd+Shift+K for actions, Shift+? for shortcut overview).\n*   **Initial Query Support:** Allows pre-populating the search bar with an initial query when the command bar is opened.\n*   **Usage Tracking:** Reports command bar status changes for usage analysis.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/SearchInput.tsx",
        "summary": "This code defines a search input component for a command bar in a web application. It utilizes the LemonInput component from `@posthog/lemon-ui` and manages the search query state using `kea` logic. The input field dynamically sets its placeholder text based on the current team's name and includes a keyboard shortcut hint for escaping the search. The component is wrapped in `forwardRef` to allow access to the underlying input element's ref.\n\n**Features:**\n\n*   **Search Input Field:** Provides a text input field for users to enter search queries.\n*   **Dynamic Placeholder:** The placeholder text adapts to display the current team's name, guiding the user on the scope of the search.\n*   **Keyboard Shortcut Hint:** Displays a keyboard shortcut (Escape key) to exit the search input.\n*   **State Management:** Uses `kea` logic to manage and update the search query state.\n*   **Auto Focus:** Automatically focuses on the input field when the component is rendered.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/ActionInput.tsx",
        "summary": "This code defines the `ActionInput` component, which is a key part of a command bar interface. It utilizes the `LemonInput` component from Lemon UI and integrates with the `actionBarLogic` using Kea for state management. The input field dynamically adapts its prefix icon and placeholder text based on the currently active command flow. It also displays a keyboard shortcut for escaping the input. The component renders a full-width input field with a prefix icon (either a flow-specific icon or a default pencil icon) and a suffix displaying the escape keyboard shortcut.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Command Input:** Provides a text input field for users to enter commands.\n*   **Dynamic Placeholder:** The placeholder text changes based on the active command flow, providing context-sensitive instructions.\n*   **Dynamic Prefix Icon:** The icon displayed before the input field changes based on the active command flow, visually indicating the current context.\n*   **Keyboard Shortcut Display:** Shows the keyboard shortcut for escaping the input field.\n*   **Focus on Load:** Automatically focuses the input field when the component is rendered.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/SearchBar.tsx",
        "summary": "The `SearchBar` component is the main entry point for the search functionality within the application. It's structured as a grid layout, dividing the space into two main sections: `SearchTabs` and a container for the `SearchInput` and `SearchResults`. The `SearchTabs` component likely handles different search categories or filters, while the `SearchInput` allows users to enter their search query. The `SearchResults` component displays the results based on the input and selected tab. The component uses `useMountedLogic` to load initial results and a ref to focus the input after tab changes.\n\nHere's a list of high-level product features:\n\n*   **Tabbed Search:** Allows users to filter search results by category.\n*   **Search Input:** Provides a text input field for users to enter their search queries.\n*   **Search Results Display:** Shows the search results based on the user's input and selected tab.\n*   **Initial Results Loading:** Loads initial search results when the component is mounted.\n*   **Input Focus Management:** Automatically focuses the search input field after a tab change.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/types.ts",
        "summary": "This code defines the types and enums used by a command bar component in a frontend application. It specifies the possible states of the command bar (hidden, showing search, showing actions, showing shortcuts), the types of results that can be displayed in the command bar (searchable entities, people, groups), and the structure of the data for person and group search results, including their type, ID, extra fields, and rank. It also defines a general `SearchResult` type that encompasses all possible search result types.\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **Command Bar:** A user interface element for quickly accessing features and information.\n*   **Search Functionality:** The command bar allows users to search for various entities within the application.\n*   **Search Results:** The command bar displays search results, including different types of entities like people and groups.\n*   **Actions Menu:** The command bar provides a menu of available actions.\n*   **Shortcuts Menu:** The command bar provides a menu of available shortcuts.\n*   **People Search:** Users can search for people within the application.\n*   **Group Search:** Users can search for groups within the application.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/actionBarLogic.ts",
        "summary": "This code defines the logic for an action bar component, likely part of a command palette or similar interface. It manages the state and behavior of the action bar, including handling user input, displaying search results, executing commands, and managing keyboard shortcuts for navigation and command execution. It connects to other logic files for command palette functionality, event tracking, and managing the overall command bar state.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Command Search and Execution:** Allows users to search for and execute commands via a text-based interface.\n*   **Keyboard Navigation:** Enables users to navigate search results and execute commands using the keyboard (arrow keys, Enter, Escape, Backspace).\n*   **Command History/Flow Management:** Supports navigating back through command flows or clearing input.\n*   **Integration with Command Palette:** Integrates with a command palette component to display and manage available commands.\n*   **Event Tracking:** Tracks user interactions with the command bar, such as searches and command executions.\n*   **URL Query Integration:** Sets the default query from the URL.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/CommandBar.tsx",
        "summary": "The `CommandBar` component provides a dynamic overlay that presents different interfaces based on its internal `barStatus`. It leverages kea logic for state management and actions, and a custom hook to detect clicks outside the command bar to hide it. The component renders a search bar, action bar, or shortcuts interface within the overlay, depending on the current status. The overlay is visually styled with a rounded border and background, and positioned as a fixed element on the screen.\n\nHere's a list of high-level product features:\n\n*   **Search Bar:** Allows users to search for specific items or functionalities.\n*   **Action Bar:** Provides a list of available actions that users can quickly execute.\n*   **Shortcuts:** Displays a list of keyboard shortcuts for efficient navigation and operation.\n*   **Overlay Interface:** Presents a modal-like interface on top of the existing content.\n*   **Outside Click Detection:** Automatically closes the command bar when the user clicks outside of it.\n*   **Dynamic Content:** Switches between search, actions, and shortcuts based on the current state.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/Shortcuts.tsx",
        "summary": "This React component, `Shortcuts`, displays a list of keyboard shortcuts available in the application. It utilizes the `shortcutsLogic` (likely for managing or retrieving shortcut data) and the `KeyboardShortcut` component for rendering individual shortcuts. The component presents site-wide shortcuts for opening search (Cmd+K) and the command palette (Cmd+Shift+K).\n\n**Features:**\n\n*   **Displays Keyboard Shortcuts:** Shows a list of available keyboard shortcuts to the user.\n*   **Site-Wide Shortcuts:** Specifically highlights shortcuts that are applicable across the entire application.\n*   **Search Shortcut:** Provides a shortcut (Cmd+K) to open the search functionality.\n*   **Command Palette Shortcut:** Offers a shortcut (Cmd+Shift+K) to open the command palette.\n*   **Uses `KeyboardShortcut` Component:** Leverages a dedicated component for consistent and clear presentation of individual shortcuts.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/SearchResult.tsx",
        "summary": "This code defines the `SearchResult` component, which is responsible for rendering individual search results within a command bar. It displays the type of result, such as insight, feature flag, or notebook, along with its name or a summarized version if it's an insight. The component handles highlighting the focused result, navigating to the selected result, and displaying a skeleton loading state. It also includes logic for displaying group names and notebook content.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Search Result Display:** Renders individual search results with relevant information.\n*   **Result Highlighting:** Visually highlights the currently focused search result.\n*   **Result Navigation:** Enables navigation to the selected search result upon click or selection.\n*   **Mobile Layout Support:** Adapts the component's behavior for mobile layouts, including hiding the navigation bar when a result is selected.\n*   **Skeleton Loading:** Provides a skeleton loading state for search results while data is being fetched.\n*   **Insight Summarization:** Summarizes insights to display a concise representation in search results.\n*   **Group Display:** Displays group names based on group key and properties.\n*   **Notebook Preview:** Renders a preview of notebook content within the search result.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/SearchBarTab.tsx",
        "summary": "This React component, `SearchBarTab`, renders a tab within a search bar, allowing users to filter search results by category. It uses the `kea` library for state management and displays the tab's name, optionally with a count of results and a loading spinner. Clicking a tab activates it, focuses the search input, and updates the displayed results. The component dynamically generates tab labels based on the `aggregationLabel` function when the tab is not a predefined type.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Tabbed Search Filtering:** Allows users to filter search results by category using tabs.\n*   **Dynamic Tab Labels:** Generates tab labels dynamically based on aggregation data.\n*   **Active Tab Highlighting:** Visually indicates the currently active tab.\n*   **Result Count Display:** Shows the number of results associated with each tab.\n*   **Loading State Indicator:** Displays a spinner to indicate when results are loading for a tab.\n*   **Focus on Activation:** Automatically focuses the search input when a tab is activated.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/constants.ts",
        "summary": "This code defines constants and enums related to a command bar feature, likely used for quick navigation and actions within the PostHog application. It specifies different scopes (global, insights), tab groups (all, event data, PostHog), and individual tabs representing various PostHog entities like actions, cohorts, dashboards, events, experiments, feature flags, insights, notebooks, persons, groups, and surveys. It also includes mappings to translate these enum values into human-readable names for display in the UI.\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **Global Command Bar:** A command bar accessible globally within the application.\n*   **Insights-Specific Command Bar:** A command bar with actions and navigation tailored to the \"Insights\" section.\n*   **Tabbed Navigation:** The command bar utilizes tabs to categorize and filter available actions and navigation options.\n*   **Entity-Specific Actions:** The command bar provides access to actions related to specific PostHog entities (e.g., creating a new cohort, navigating to a specific dashboard).\n*   **Event Data Exploration:** A dedicated tab group for exploring and managing event data.\n*   **PostHog Feature Access:** A tab group providing access to core PostHog features.\n*   **ClickHouse Data Access:** Special handling for tabs related to Person and Group data, likely stored in ClickHouse.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/SearchResults.tsx",
        "summary": "The `SearchResults` component displays search results within the command bar. It fetches search results and loading state from the `searchBarLogic` using `kea's useValues` hook. When loading, it shows skeleton results. If no results are found, it displays a \"No results\" message with a detective hedgehog image. Otherwise, it presents the search results in a two-column layout (on medium screens and larger). The left column lists the search results using the `SearchResult` component, highlighting the active result. The right column, visible on larger screens, displays a preview of the selected search result using the `SearchResultPreview` component.\n\nHere's a list of high-level product features:\n\n*   **Displays Search Results:** Shows a list of search results based on user input.\n*   **Loading State:** Indicates when search results are being fetched with skeleton loading.\n*   **No Results Message:** Informs the user when no search results are found.\n*   **Result Highlighting:** Highlights the currently selected search result.\n*   **Search Result Preview:** Shows a preview of the selected search result (on larger screens).\n*   **Responsive Layout:** Adapts the layout to different screen sizes, showing a two-column layout on larger screens and a single-column layout on smaller screens.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar/searchBarLogic.ts",
        "summary": "This code defines the logic for a search bar component in a web application, likely for a product analytics platform. It uses the Kea framework for state management and data fetching. The search bar allows users to search across different entities like events, actions, persons, groups, insights, dashboards, and more. It fetches data from the backend API based on the search query and the selected tab, debouncing the search requests to avoid excessive API calls. The search results are then combined, ranked, and displayed to the user. The logic also handles tab selection, keyboard navigation through the search results, and reporting of search usage.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Unified Search:** Allows users to search across various entities within the application from a single search bar.\n*   **Tabbed Search:** Enables users to filter search results by entity type (e.g., events, actions, persons, insights).\n*   **Real-time Search Suggestions:** Provides search results as the user types, with a debounce to optimize performance.\n*   **Group Search:** Supports searching for groups based on different group types.\n*   **Keyboard Navigation:** Allows users to navigate search results using the arrow keys.\n*   **Usage Reporting:** Tracks search bar usage for analytics and product improvement.\n*   **Ranking of Search Results:** Ranks search results based on the length of the matching query.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandBar",
        "summary": "The provided code implements a comprehensive command bar feature, offering users a centralized interface for searching, executing actions, and discovering keyboard shortcuts within the application. The command bar dynamically adapts its content based on the current context, providing a streamlined and efficient user experience. It includes features such as tabbed search, real-time search suggestions, action execution, keyboard navigation, and result previews, all designed to enhance user productivity and discoverability of application features.\n\nHere's a list of high-level product features:\n\n*   **Command Bar:** A central interface for search, actions, and shortcuts.\n*   **Search Functionality:** Enables searching across various entities and data within the application.\n*   **Action Execution:** Allows users to quickly execute commands and actions.\n*   **Keyboard Navigation:** Provides keyboard shortcuts and navigation for efficient interaction.\n*   **Tabbed Search:** Organizes search results into categories for easier filtering.\n*   **Real-time Search Suggestions:** Offers suggestions as the user types.\n*   **Search Result Preview:** Displays a preview of the selected search result.\n*   **Dynamic Content:** Adapts the displayed content based on the current context.\n*   **Shortcuts Display:** Shows available keyboard shortcuts for the application.\n*   **Action Scope Naming:** Displays user-friendly names for different action scopes.\n*   **Command Flow Management:** Guides the user through a series of steps or instructions for complex actions.\n*   **Usage Tracking:** Reports command bar status changes for usage analysis.\n"
    },
    {
        "path": "frontend/src/lib/components/Support/SupportModal.tsx",
        "summary": "The `SupportModal.tsx` file defines a modal component that allows users to submit support requests. The modal is only displayed for cloud or development environments and when the side panel is not available. It contains a form for the user to enter their support request and provides \"Cancel\" and \"Submit\" buttons. The modal is dynamically rendered using `react-dom/client` and appended to the document body when the `openSupportModal` function is called.\n\nHere's a list of high-level product features:\n\n*   **Support Request Submission:** Allows users to submit support requests directly from the application.\n*   **Modal Interface:** Presents the support form within a modal window for a focused user experience.\n*   **Conditional Display:** Only shows the support modal in specific environments (cloud or development) and when the side panel is unavailable.\n*   **Dynamic Rendering:** Dynamically renders the modal when needed and removes it from the DOM when closed.\n*   **Form Validation:** Tracks unsaved input to prevent accidental data loss.\n*   **Cancel and Submit Actions:** Provides standard actions for canceling or submitting the support request.\n"
    },
    {
        "path": "frontend/src/lib/components/Support/supportLogic.ts",
        "summary": "The code defines the logic for a support form within the PostHog application. It handles the state, actions, and form submission for creating support tickets, providing feedback, or reporting bugs. The logic connects to other parts of the application to retrieve user information, preflight checks, and side panel state. It also includes functions for generating helpful support snippets with links to relevant information like session replays, admin panels, and error tracking. The support form allows users to specify the type of issue, the affected product area, and the severity level.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Support Ticket Submission:** Allows users to submit support tickets directly from the application.\n*   **Feedback Submission:** Enables users to provide general feedback on the product.\n*   **Bug Reporting:** Provides a dedicated channel for users to report bugs they encounter.\n*   **Targeted Support:** Allows users to specify the product area their issue relates to.\n*   **Severity Level Selection:** Enables users to indicate the severity of their issue.\n*   **Automated Support Snippets:** Generates helpful snippets with links to session replays, admin panels, and error tracking to aid support staff.\n*   **Contextual Support:** Pre-fills form fields and suggests target areas based on the user's current location in the application.\n*   **Email Form Option:** Provides an alternative email form for support requests.\n"
    },
    {
        "path": "frontend/src/lib/components/Support/SupportForm.tsx",
        "summary": "The `SupportForm` component provides a user interface for submitting support requests, feedback, or bug reports to PostHog. It includes fields for the user's name and email (if not logged in), the type of message (question, feedback, or bug), the topic of the message, the message content itself, and the severity level. The form also supports file uploads for logged-in users with object storage available. The component leverages Lemon UI components for styling and Kea for state management.\n\nHere's a list of high-level product features:\n\n*   **Support Ticket Submission:** Allows users to submit support tickets directly from the application.\n*   **Feedback Submission:** Enables users to provide feedback on the product.\n*   **Bug Reporting:** Provides a mechanism for users to report bugs they encounter.\n*   **Message Type Selection:** Allows users to categorize their message as a question, feedback, or bug report.\n*   **Topic Selection:** Enables users to specify the topic of their message.\n*   **File Upload:** Supports uploading files (e.g., screenshots) to provide additional context.\n*   **Severity Level Selection:** Allows users to indicate the severity of their issue.\n*   **Dynamic Form Fields:** Shows/hides form fields based on user login status and selected options.\n*   **Error Tracking Topic Warning:** Displays a warning banner when the user selects the \"error\\_tracking\" topic.\n*   **Authentication Restriction:** Restricts topic selection for logged out users to authentication issues.\n"
    },
    {
        "path": "frontend/src/lib/components/AccessControlAction.tsx",
        "summary": "The `AccessControlAction` component in `AccessControlAction.tsx` provides a mechanism for controlling user access to specific features or resources within the application. It dynamically renders its children based on whether the current user's access level meets the minimum required access level for a given resource type. The component determines access levels based on resource type (Project, Organization, or others like FeatureFlag) and provides a disabled state and reason to the wrapped component if the user lacks sufficient permissions.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Role-Based Access Control (RBAC):** Defines and enforces different access levels (e.g., viewer, editor, member, admin) for various resources.\n*   **Dynamic UI Rendering:** Enables or disables UI elements based on the user's permissions, providing a context-aware user experience.\n*   **Permission Checks:** Verifies if a user has the necessary permissions to perform specific actions on a resource.\n*   **Informative Error Messages:** Displays clear and helpful messages to users when they lack the required permissions, explaining why an action is disabled.\n*   **Resource-Specific Access Levels:** Supports different access level hierarchies based on the resource type (e.g., different levels for projects vs. feature flags).\n"
    },
    {
        "path": "frontend/src/lib/components/Support",
        "summary": "The provided code implements a comprehensive support system within the PostHog application, enabling users to easily submit support requests, provide feedback, and report bugs. The system features a dynamic form with customizable fields, conditional display based on environment and user state, and automated generation of helpful support snippets to aid in issue resolution. Users can specify the type of issue, affected product area, severity level, and upload files for additional context.\n\nHere's a list of high-level product features:\n\n*   Support Ticket Submission\n*   Feedback Submission\n*   Bug Reporting\n*   Message Type Selection\n*   Topic Selection\n*   File Upload\n*   Severity Level Selection\n*   Dynamic Form Fields\n*   Modal Interface\n*   Conditional Display\n*   Dynamic Rendering\n*   Automated Support Snippets\n*   Contextual Support\n*   Email Form Option\n"
    },
    {
        "path": "frontend/src/lib/components/Resizer/Resizer.tsx",
        "summary": "The `Resizer` component provides a visual handle that allows users to resize elements on a webpage. It uses the `resizerLogic` to manage the resizing state and interactions. The component's appearance changes based on whether a resize is in progress and its placement relative to the element being resized. Users can initiate a resize by clicking and dragging the handle, and the component dynamically updates its style to reflect the resizing action.\n\nHere's a list of high-level product features:\n\n*   **Draggable Resizing:** Allows users to resize elements by dragging a handle.\n*   **Visual Feedback:** Provides visual cues to indicate when a resize is in progress.\n*   **Placement Flexibility:** Supports different placements of the resizer handle (e.g., left, right, top, bottom).\n*   **Orientation Support:** Handles both vertical and horizontal resizing.\n*   **Multiple Resizer Support:** Allows multiple resizers to function independently on the same page.\n"
    },
    {
        "path": "frontend/src/lib/components/Resizer/resizerLogic.ts",
        "summary": "This code defines a Kea logic module called `resizerLogic` that manages the resizing of a container element. It handles user interactions like mouse movements and clicks to dynamically adjust the size of the container, persisting the desired size if configured. The logic also includes features for detecting double clicks to reset the size and triggering callbacks when a close threshold is crossed. It tracks resizing state, desired size, and provides selectors to determine the orientation and starting position of the resizer.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Dynamic Resizing:** Allows users to interactively resize a container element by dragging a resizer handle.\n*   **Persistent Size:** Remembers the user's preferred size for the container across sessions (optional).\n*   **Orientation Support:** Handles both vertical (left/right) and horizontal (top/bottom) resizing.\n*   **Close Threshold:** Defines a size below which the container is considered \"closed,\" triggering a callback.\n*   **Double-Click Reset:** Enables users to quickly reset the container to its original size with a double-click.\n*   **Event Tracking:** Captures resize events using PostHog for analytics and debugging.\n*   **Resizing State Management:** Tracks whether a resize operation is in progress.\n"
    },
    {
        "path": "frontend/src/lib/components/Resizer",
        "summary": "The Resizer component and its associated logic provide a user-friendly and feature-rich way to dynamically resize elements on a webpage. It offers visual feedback during resizing, supports various placements and orientations, and can persist the user's preferred size across sessions. Additional features include a double-click reset, close threshold detection, and event tracking for analytics.\n\n*   Draggable Resizing\n*   Visual Feedback\n*   Placement Flexibility\n*   Orientation Support (Vertical/Horizontal)\n*   Persistent Size\n*   Close Threshold\n*   Double-Click Reset\n*   Event Tracking\n*   Resizing State Management\n*   Multiple Resizer Support\n"
    },
    {
        "path": "frontend/src/lib/components/ViewRecordingButton/sessionRecordingViewedLogic.ts",
        "summary": "This code defines a Kea logic module called `sessionRecordingViewedLogic` that manages the state of whether a session recording has been viewed by the current user and how many other viewers there are. It fetches this information from the PostHog API based on the session recording ID and the current team ID. The logic also provides a way to update the state optimistically when the user clicks through to view the recording.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Session Recording View Tracking:** Tracks whether a user has viewed a specific session recording.\n*   **Concurrent Viewer Count:** Displays the number of other users currently viewing the same session recording.\n*   **Real-time Updates:** Provides near real-time updates on the viewed status and viewer count.\n*   **API Integration:** Fetches session recording view data from the PostHog API.\n"
    },
    {
        "path": "frontend/src/lib/components/DebugNotice.tsx",
        "summary": "The `DebugNotice` component displays information about the current branch and revision in a PostHog instance running in debug mode. It fetches the branch and revision information from elements in the DOM and renders a notice that can be dismissed. When the navigation is collapsed, the notice is displayed as a `NavbarButton`. When the navigation is not collapsed, the notice is displayed as a banner with the branch and revision information, along with a warning and link to fix the port if the app is not running on port 8010.\n\nHere's a list of high-level product features:\n\n*   **Debug Mode Indication:** Displays a clear \"DEBUG mode\" notice to indicate the instance is running in debug mode.\n*   **Branch and Revision Display:** Shows the current branch and revision of the code.\n*   **Dismissable Notice:** Allows users to dismiss the debug notice.\n*   **Port Warning and Fix:** Warns users if they are not using the correct port (8010) and provides a link to fix it.\n*   **Responsive Display:** Adapts the display of the notice based on the navigation state (collapsed or not).\n"
    },
    {
        "path": "frontend/src/lib/components/ViewRecordingButton/ViewRecordingButton.tsx",
        "summary": "The `ViewRecordingButton` component provides a button that allows users to view session recordings, either by opening them in a modal or navigating to a dedicated replay page. It handles scenarios where the session ID might be missing and indicates whether a recording has been viewed, showing an \"Unwatched\" indicator if it hasn't. The button also supports opening the recording at a specific timestamp, particularly useful when triggered from an event timeline. Additionally, the component includes a utility function `mightHaveRecording` to determine if an event's properties suggest a session recording might exist.\n\nHere's a list of high-level product features:\n\n*   **Session Recording Playback:** Allows users to view session recordings associated with specific sessions.\n*   **Modal or Page Navigation:** Provides flexibility to open recordings either in a modal window or a separate replay page.\n*   **\"Unwatched\" Indicator:** Visually indicates whether a session recording has been previously viewed by the user.\n*   **Timestamped Playback:** Enables opening a recording at a specific timestamp, useful for event-driven access.\n*   **Session ID Validation:** Prevents the button from functioning if a session ID is not provided.\n*   **Recording Availability Check:** Determines if a recording might exist based on event properties.\n"
    },
    {
        "path": "frontend/src/lib/components/ViewRecordingButton",
        "summary": "The `ViewRecordingButton` component and its associated logic provide a comprehensive solution for viewing and managing session recordings within the application. It allows users to easily access recordings, indicates whether they have been previously viewed, and supports opening recordings at specific timestamps. The system also tracks and displays the number of concurrent viewers, providing a collaborative viewing experience.\n\n**Features:**\n\n*   Session Recording Playback: Allows users to view session recordings associated with specific sessions.\n*   Modal or Page Navigation: Provides flexibility to open recordings either in a modal window or a separate replay page.\n*   \"Unwatched\" Indicator: Visually indicates whether a session recording has been previously viewed by the user.\n*   Timestamped Playback: Enables opening a recording at a specific timestamp, useful for event-driven access.\n*   Session ID Validation: Prevents the button from functioning if a session ID is not provided.\n*   Recording Availability Check: Determines if a recording might exist based on event properties.\n*   Session Recording View Tracking: Tracks whether a user has viewed a specific session recording.\n*   Concurrent Viewer Count: Displays the number of other users currently viewing the same session recording.\n*   Real-time Updates: Provides near real-time updates on the viewed status and viewer count.\n*   API Integration: Fetches session recording view data from the PostHog API.\n"
    },
    {
        "path": "frontend/src/lib/components/DurationPicker/DurationPicker.tsx",
        "summary": "The `DurationPicker` component provides a user interface for selecting a duration in seconds, minutes, or hours. It consists of a numeric input field (`LemonInput`) for the time value and a dropdown (`LemonSelect`) to choose the unit of time. The component converts the input value to seconds and calls the `onChange` prop function to update the parent component with the selected duration in seconds. It also handles updating the local state when the `value` prop changes.\n\nHere's a list of high-level features:\n\n*   **Duration Selection:** Allows users to specify a duration using a numeric input and a unit selector.\n*   **Unit Options:** Supports seconds, minutes, and hours as units of time.\n*   **Value Conversion:** Converts the selected duration to seconds before passing it to the parent component.\n*   **Controlled Component:** Updates its local state based on the `value` prop, allowing for external control of the selected duration.\n*   **Input Validation:** Enforces a minimum value of 0 for the numeric input.\n*   **Auto Focus:** Provides an autoFocus prop to automatically focus on the input field when the component is rendered.\n"
    },
    {
        "path": "frontend/src/lib/components/DurationPicker",
        "summary": "The DurationPicker component offers a user-friendly interface for specifying a time duration. Users can input a numerical value representing the duration and select the unit of time (seconds, minutes, or hours) from a dropdown menu. The component then converts this input into seconds and communicates the total duration in seconds to the parent component via an onChange function. It also maintains its state based on the value prop, enabling external control, and includes input validation to ensure a minimum value of 0.\n\nHere's a list of high-level product features:\n\n*   Duration Selection with Numeric Input\n*   Unit Selection (Seconds, Minutes, Hours)\n*   Automatic Conversion to Seconds\n*   Controlled Component Behavior\n*   Input Validation (Minimum Value)\n*   Auto Focus on Input Field\n"
    },
    {
        "path": "frontend/src/lib/components/CustomerLogo.tsx",
        "summary": "The code defines a `CustomerLogo` component in React that renders a customer's logo within a list item. It takes an image source, alt text, and an optional CSS class name as props. The `Logo` sub-component handles the actual image rendering, applying default styling for background, width, padding, and height, while also allowing for custom class names to be passed down. The `CustomerLogo` component is responsible for wrapping the `Logo` component in a list item with flexbox styling for centering the logo.\n\nHere's a list of high-level product features based on the code:\n\n*   **Customer Logo Display:** Enables displaying customer logos on the frontend.\n*   **Image Source Configuration:** Allows specifying the image source URL for each customer logo.\n*   **Alt Text Support:** Provides alt text for accessibility and SEO purposes.\n*   **Custom CSS Styling:** Supports custom CSS class names for flexible styling and integration with existing themes.\n*   **Responsive Design:** The logo is rendered with `w-full` making it responsive to different screen sizes.\n*   **Logo Centering:** Centers the logo within its container using flexbox.\n"
    },
    {
        "path": "frontend/src/lib/components/HelpButton/HelpButton.tsx",
        "summary": "The `HelpButton` component provides users with quick access to various support and documentation resources within the PostHog application. It utilizes a LemonMenu to display a list of options, including links to the documentation, a community forum, and options to report bugs, provide feedback, or request direct support. The button's visibility is managed by the `helpButtonLogic` kea logic, and it tracks usage events for analytics. The component is customizable with props for placement, a custom component to render inside the button, and whether to show only contact options.\n\nHere's a list of high-level product features:\n\n*   **Contextual Help Menu:** Provides a dropdown menu with links to documentation, community forum, and support options.\n*   **Usage Tracking:** Records user interactions with the help button to understand which resources are most frequently used.\n*   **Customizable Appearance:** Allows developers to customize the button's appearance with a custom component.\n*   **Support Form Integration:** Integrates with a support form to allow users to report bugs, provide feedback, or request support.\n*   **Conditional Support Options:** Conditionally displays support options based on whether the instance is cloud-hosted or self-hosted.\n*   **Documentation Link:** Provides a direct link to the PostHog documentation.\n*   **Community Forum Link:** Provides a direct link to the PostHog community forum.\n"
    },
    {
        "path": "frontend/src/lib/components/HelpButton",
        "summary": "The HelpButton component offers users a centralized access point to support and documentation resources within the PostHog application. It presents a customizable dropdown menu with links to documentation, a community forum, and options to report bugs, provide feedback, or request direct support. The component tracks user interactions for analytics and allows for customization of the button's appearance and conditional display of support options.\n\nHere's a list of high-level product features:\n\n*   Contextual Help Menu\n*   Usage Tracking\n*   Customizable Appearance\n*   Support Form Integration\n*   Conditional Support Options\n*   Documentation Link\n*   Community Forum Link\n"
    },
    {
        "path": "frontend/src/lib/components/MemberSelectMultiple.tsx",
        "summary": "The `MemberSelectMultiple` component provides a multi-select dropdown for choosing team members from a list of available users. It fetches and displays a list of members, allowing users to search and select multiple members based on their email, UUID, or ID. The component utilizes the LemonInputSelect component from `@posthog/lemon-ui` and connects to the `membersLogic` to manage member data. Upon selection, the component calls the `onChange` prop with an array of `UserBasicType` objects representing the selected members.\n\nHere's a list of high-level product features:\n\n*   **Multi-select User Selection:** Allows users to select multiple team members from a dropdown list.\n*   **Member Search:** Provides a search functionality within the dropdown to easily find team members.\n*   **Dynamic Member Loading:** Fetches and updates the member list dynamically.\n*   **ID Key Configuration:** Supports selection based on user email, UUID, or ID.\n*   **Data Binding:** Provides a callback function to handle selected user data.\n"
    },
    {
        "path": "frontend/src/lib/components/ActivityLog/SentenceList.tsx",
        "summary": "The `SentenceList` component takes a list of strings or JSX elements and renders them as a cohesive English sentence, handling commas and the word \"and\" appropriately. It also supports optional prefix and suffix elements to be added to the beginning and end of the sentence. The component is styled using the `SentenceList.scss` stylesheet.\n\nHere's a list of high-level product features:\n\n*   **Sentence Construction:** Automatically formats a list of phrases into a grammatically correct sentence.\n*   **List Element Support:** Accepts a mixed list of strings and JSX elements as input.\n*   **Prefix/Suffix Addition:** Allows adding a prefix or suffix to the generated sentence.\n*   **Conditional Formatting:** Adds commas and \"and\" based on the number of elements in the list.\n*   **Customizable Styling:** Uses SCSS for styling, allowing for customization of the sentence's appearance.\n"
    },
    {
        "path": "frontend/src/lib/components/ActivityLog/activityLogLogic.tsx",
        "summary": "This code defines a Kea logic module for managing and displaying an activity log. It fetches activity log items from an API, paginates the results, and humanizes the log items for display. The logic supports filtering activity logs by scope (e.g., feature flags, insights, persons) and ID, and it integrates with the URL to maintain the current page state. It also uses describers to provide context-specific information for each activity log item.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Activity Log Display:** Fetches and displays a paginated list of activity log items.\n*   **Scoped Activity Logs:** Filters activity logs by scope (e.g., feature flags, insights, persons, plugins, cohorts, etc.).\n*   **ID-Based Filtering:** Filters activity logs by a specific ID within a scope.\n*   **Humanized Activity Descriptions:** Converts raw activity log data into human-readable descriptions.\n*   **Pagination:** Supports pagination of activity log results.\n*   **URL Integration:** Maintains the current page state in the URL.\n*   **Contextual Descriptions:** Uses different describers based on the activity scope to provide context-specific information.\n*   **Real-time Updates:** Fetches activity data on mount and when the page changes.\n"
    },
    {
        "path": "frontend/src/lib/components/ActivityLog/humanizeActivity.tsx",
        "summary": "This code defines the data structures and functions necessary for displaying a human-readable activity log in a PostHog application. It includes interfaces for representing activity log items, changes within those items, and functions for transforming raw activity data into user-friendly descriptions. The core functionality lies in the `humanize` function, which iterates through activity log items and uses a provided \"describer\" function to generate a human-readable description and extended details for each item. It also provides default describers for common actions like deletion and commenting, and utilities for formatting user names and activity scopes.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Activity Logging:** Records user actions and system events within the application.\n*   **Human-Readable Activity Feed:** Presents activity logs in an easily understandable format, replacing technical details with natural language descriptions.\n*   **Detailed Activity Descriptions:** Provides additional context and information related to specific activity log entries, such as changes made to an object or the content of a comment.\n*   **User Attribution:** Identifies the user or system responsible for each activity.\n*   **Customizable Activity Descriptions:** Allows for defining custom \"describer\" functions to tailor the activity descriptions to specific use cases.\n*   **Notification Support:** Flags unread activities and tailors descriptions for use in notifications.\n*   **Markdown Support:** Renders comments with Markdown formatting.\n"
    },
    {
        "path": "frontend/src/lib/components/ActivityLog/ActivityLog.tsx",
        "summary": "The `ActivityLog` component displays a chronological record of activities within a specified scope, such as changes to a feature flag or experiment. It fetches and humanizes activity data, presents it in a user-friendly format with details like the user who performed the action, a description of the change, and a timestamp. Users can expand individual activity log entries to view more details, including an extended description (if available), a visual diff of the changes made (for JSON data), and the raw JSON data of the activity. The component also includes pagination for navigating through large activity logs and a paygate to restrict access based on feature flags.\n\nHere's a list of high-level product features:\n\n*   **Activity Tracking:** Logs and displays a history of actions and changes within the application.\n*   **Humanized Activity Descriptions:** Converts raw activity data into readable descriptions.\n*   **Detailed Activity View:** Allows users to expand activity entries for more information.\n*   **JSON Diff Viewer:** Provides a visual comparison of changes made to JSON data.\n*   **Raw Data Display:** Shows the raw JSON data associated with each activity.\n*   **Pagination:** Enables navigation through large activity logs.\n*   **User Identification:** Displays the user or system responsible for each activity.\n*   **Access Control:** Restricts access to the activity log based on feature flags and user permissions.\n*   **Empty State Handling:** Provides a user-friendly message when no activity is available.\n*   **Loading State:** Displays a loading indicator while activity data is being fetched."
    },
    {
        "path": "frontend/src/lib/components/ActivityLog",
        "summary": "The provided code collectively implements a comprehensive activity logging and display system within the PostHog application. This system captures user actions and system events, transforms them into human-readable descriptions, and presents them in a user-friendly interface. Key features include filtering by scope and ID, pagination for large logs, detailed views with JSON diffing, user attribution, and customizable descriptions, all while integrating with the application's URL structure and access control mechanisms.\n\nHere's a list of high-level product features:\n\n*   Activity Logging: Records user actions and system events.\n*   Human-Readable Activity Feed: Presents activity logs in an easily understandable format.\n*   Detailed Activity Descriptions: Provides additional context and information related to specific activity log entries.\n*   User Attribution: Identifies the user or system responsible for each activity.\n*   Customizable Activity Descriptions: Allows for defining custom descriptions to tailor the activity descriptions to specific use cases.\n*   Scoped Activity Logs: Filters activity logs by scope (e.g., feature flags, insights, persons).\n*   ID-Based Filtering: Filters activity logs by a specific ID within a scope.\n*   Pagination: Supports pagination of activity log results.\n*   URL Integration: Maintains the current page state in the URL.\n*   JSON Diff Viewer: Provides a visual comparison of changes made to JSON data.\n*   Raw Data Display: Shows the raw JSON data associated with each activity.\n*   Access Control: Restricts access to the activity log based on feature flags and user permissions.\n*   Sentence Construction: Automatically formats a list of phrases into a grammatically correct sentence.\n"
    },
    {
        "path": "frontend/src/lib/components/UniversalFilters/utils.ts",
        "summary": "This code provides utility functions for working with universal filters in a product analytics application. It defines type guards and helper functions to identify and categorize different types of filters, including logical groups, event filters, action filters, property filters (event, feature flag, recording, log entry), and cohort property filters. It also provides a function to determine if a filter is editable.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Filtering Events and Actions:** Allows users to filter data based on specific events and actions.\n*   **Filtering by Properties:** Enables filtering based on properties associated with events, feature flags, recordings, and log entries.\n*   **Logical Grouping of Filters:** Supports combining filters using logical operators (AND, OR) for complex filtering scenarios.\n*   **Cohort-Based Filtering:** Integrates with cohort definitions to filter data based on user segments.\n*   **Filter Editability Control:** Provides a mechanism to control which filters can be edited by the user.\n"
    },
    {
        "path": "frontend/src/lib/components/UniversalFilters/universalFiltersLogic.ts",
        "summary": "This code defines a Kea logic module called `universalFiltersLogic` that manages a group of filters, allowing users to create complex filter conditions using logical operators (AND/OR) and various filter types. It provides functionality to add, remove, and modify individual filters within the group, as well as change the logical operator connecting them. The logic is designed to be reusable across different parts of the application, with the `rootKey` prop ensuring unique instances. It also connects to the `propertyDefinitionsModel` to fetch property descriptions for creating default property filters.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Filter Grouping:** Allows users to group filters together under a logical operator (AND/OR).\n*   **Nested Filters:** Supports nesting filter groups within each other for complex filtering logic.\n*   **Dynamic Filter Addition:** Enables adding filters based on taxonomic groups (e.g., event properties, person properties, feature flags).\n*   **Property-Based Filtering:** Supports filtering based on property values with various operators (e.g., exact match, contains).\n*   **Feature Flag Filtering:** Allows filtering based on feature flag status.\n*   **Entity Filtering:** Supports filtering based on entities like actions or events.\n*   **Real-time Updates:** Provides callbacks to notify parent components of filter changes.\n"
    },
    {
        "path": "frontend/src/lib/components/UniversalFilters/UniversalFilterButton.tsx",
        "summary": "The `UniversalFilterButton` component provides a flexible way to display and interact with various types of filters within a user interface. It supports event, action, feature flag, and property filters, rendering them with appropriate icons and labels. The button can be clickable to allow editing of the filter, and it can also include a close button to remove the filter. The component uses other components like `EntityFilterInfo`, `PropertyFilterIcon`, and `IconWithCount` to display filter information and provides visual cues for different filter types.\n\nHere's a list of high-level product features implemented by the code:\n\n*   **Filter Display:** Renders different types of filters (event, action, feature flag, property) with appropriate icons and labels.\n*   **Filter Editing:** Allows users to click on editable filters to modify their settings.\n*   **Filter Removal:** Provides a close button to remove filters from the UI.\n*   **Filter Information:** Displays detailed information about each filter, such as the event name, action name, feature flag key, or property name and value.\n*   **Visual Cues:** Uses icons to visually distinguish between different filter types.\n*   **Property Value Formatting:** Formats property values for display, using property definitions to ensure consistency.\n*   **Truncated Labels:** Prevents long labels from overflowing by truncating them with an ellipsis.\n*   **Event Property Filtering:** Allows filtering of events based on their properties.\n*   **Action Property Filtering:** Allows filtering of actions based on their properties.\n"
    },
    {
        "path": "frontend/src/lib/components/UniversalFilters/UniversalFilters.tsx",
        "summary": "The `UniversalFilters` component provides a flexible way to build and manage filters for various data types. It allows users to create filter groups, add individual filters with customizable properties, and define the type of data they are filtering. The component utilizes popovers and dropdowns for a user-friendly interface, enabling users to easily add, edit, and remove filters. It leverages the `kea` library for state management and provides specialized components for different filter types, such as event properties and taxonomic properties.\n\nHere's a list of high-level product features provided by the code:\n\n*   **Filter Grouping:** Allows users to organize filters into logical groups.\n*   **Taxonomic Filter Support:** Integrates with taxonomic filters for filtering based on predefined categories.\n*   **Event Property Filtering:** Enables filtering based on event properties with a dedicated property filter component.\n*   **Dynamic Filter Addition:** Provides an \"Add Filter\" button with a dropdown to select filter types.\n*   **Editable Filters:** Supports editing existing filters, including properties and values.\n*   **Filter Removal:** Allows users to remove individual filters.\n*   **Customizable Filter Types:** Supports different filter types based on `taxonomicGroupTypes`.\n*   **Popover Interface:** Uses popovers for editing filters, providing a clean and focused editing experience.\n*   **State Management:** Uses `kea` for managing the state of the filters and their configuration.\n*   **Metadata Source:** Supports providing a metadata source for filter options."
    },
    {
        "path": "frontend/src/lib/components/UniversalFilters",
        "summary": "The provided code collectively enables a comprehensive and user-friendly filtering system for a product analytics application. It allows users to create complex filter conditions by combining various filter types, including events, actions, feature flags, and properties, using logical operators. The system provides a visual interface for building and managing filters, with features like filter grouping, dynamic filter addition, editing, and removal. The system also supports filtering based on cohort definitions and taxonomic properties, enhancing the flexibility and power of data analysis.\n\n**Features:**\n\n*   **Event and Action Filtering:** Filter data based on specific events and actions.\n*   **Property-Based Filtering:** Filter data based on properties associated with events, actions, feature flags, recordings, and log entries.\n*   **Logical Filter Grouping:** Combine filters using logical operators (AND, OR) for complex filtering scenarios, including nested groups.\n*   **Cohort-Based Filtering:** Filter data based on user segments defined as cohorts.\n*   **Feature Flag Filtering:** Filter data based on feature flag status.\n*   **Taxonomic Filter Support:** Filter based on predefined categories.\n*   **Dynamic Filter Addition and Removal:** Easily add and remove filters from the UI.\n*   **Editable Filters:** Modify existing filters, including properties and values.\n*   **Visual Filter Representation:** Display filters with appropriate icons and labels for different types.\n*   **State Management:** Manage the state of filters and their configuration.\n"
    },
    {
        "path": "frontend/src/lib/components/TimeSensitiveAuthentication/TimeSensitiveAuthentication.tsx",
        "summary": "This code implements a time-sensitive authentication feature, requiring users to re-authenticate before accessing sensitive settings. It presents a modal prompting users to re-enter their password, use an authenticator token (if two-factor authentication is enabled), or re-authenticate via social login or SSO. The modal is triggered based on the `timeSensitiveAuthenticationRequired` state and provides options tailored to the user's authentication setup, including password-based authentication, two-factor authentication, and SSO. A `TimeSensitiveAuthenticationArea` component conditionally renders a re-authentication prompt if authentication is required, otherwise rendering its children.\n\nHere's a list of high-level product features:\n\n*   **Re-authentication Modal:** Presents a modal requiring users to re-authenticate for security purposes.\n*   **Password-based Re-authentication:** Allows users to re-authenticate by re-entering their password.\n*   **Two-Factor Authentication Support:** Supports re-authentication using an authenticator token when two-factor authentication is enabled.\n*   **Social Login Re-authentication:** Enables users to re-authenticate using social login providers.\n*   **SSO Re-authentication:** Supports re-authentication via Single Sign-On (SSO) providers.\n*   **Conditional Rendering of Re-authentication Prompt:** Displays a re-authentication prompt in specific areas of the application when re-authentication is required.\n*   **Automatic Re-authentication Check:** Automatically checks if re-authentication is required upon component mount.\n"
    },
    {
        "path": "frontend/src/lib/components/TimeSensitiveAuthentication/timeSensitiveAuthenticationLogic.ts",
        "summary": "This code implements the logic for time-sensitive authentication in a PostHog application. It manages the display of a reauthentication modal when a user's sensitive session is about to expire, requiring them to re-enter their password or a 2FA token. The logic handles pre-checking for 2FA requirements, form submission for reauthentication, and actions to dismiss or complete the reauthentication process. It also integrates with the PostHog analytics platform to track modal views and reauthentication completion.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Time-Sensitive Session Management:** Automatically prompts users to reauthenticate when their sensitive session is nearing expiration.\n*   **Reauthentication Modal:** Displays a modal requiring users to re-enter their password or 2FA token.\n*   **2FA Support:** Handles reauthentication with both password and 2FA tokens.\n*   **Error Handling:** Provides specific error messages for incorrect passwords or missing 2FA tokens.\n*   **Session Extension:** Extends the user's sensitive session upon successful reauthentication.\n*   **User Experience Enhancement:** Proactively prompts for reauthentication to avoid unexpected 403 errors.\n*   **Analytics Tracking:** Tracks reauthentication modal views and completion events in PostHog.\n*   **Reauthentication Dismissal:** Allows users to dismiss the reauthentication modal (with potential consequences).\n"
    },
    {
        "path": "frontend/src/lib/components/TimeSensitiveAuthentication",
        "summary": "The time-sensitive authentication feature enhances security by requiring users to re-authenticate before accessing sensitive settings or performing critical actions. This is achieved through a modal that prompts users to re-enter their password, use an authenticator token (if 2FA is enabled), or re-authenticate via social login or SSO. The system automatically checks for re-authentication requirements and extends the user's sensitive session upon successful re-authentication, while also tracking modal views and completion events for analytics purposes.\n\nHere's a list of high-level product features:\n\n*   Re-authentication Modal\n*   Password-based Re-authentication\n*   Two-Factor Authentication Support\n*   Social Login Re-authentication\n*   SSO Re-authentication\n*   Conditional Rendering of Re-authentication Prompt\n*   Automatic Re-authentication Check\n*   Time-Sensitive Session Management\n*   Error Handling\n*   Session Extension\n*   User Experience Enhancement\n*   Analytics Tracking\n*   Reauthentication Dismissal\n"
    },
    {
        "path": "frontend/src/lib/components/ProductIntroduction/ProductIntroduction.tsx",
        "summary": "The `ProductIntroduction` component is designed to guide new users within a product by displaying an introductory message and call to action when a specific product area is empty or when the user hasn't interacted with it before. It provides a welcoming message, a description of the product, and options to create a new item or learn more through documentation. The component also includes a visual element, represented by a hedgehog graphic, to enhance the user experience. It can be dismissed by the user, preventing it from showing again.\n\nHere's a list of high-level product features:\n\n*   **New User Guidance:** Introduces new users to specific product areas.\n*   **Empty State Display:** Shows a helpful message when a product area is empty.\n*   **Customizable Content:** Allows customization of the product name, description, and call to action.\n*   **Visual Aid:** Includes a hedgehog graphic to improve user engagement.\n*   **Dismissable Intro:** Allows users to dismiss the introduction, preventing it from showing again.\n*   **Actionable Button:** Provides a primary button to create a new item.\n*   **Documentation Link:** Offers a link to relevant documentation for further learning.\n*   **Custom Action Override:** Supports overriding the default action button with a custom element.\n"
    },
    {
        "path": "frontend/src/lib/components/ProductIntroduction",
        "summary": "The `ProductIntroduction` component serves as a helpful guide for new users navigating a product, especially when encountering empty states or initial interactions. It delivers a welcoming message, explains the product's purpose, and offers actionable options such as creating a new item or accessing documentation. A hedgehog graphic adds a visual element to enhance user engagement, and users have the option to dismiss the introduction to prevent it from reappearing.\n\nHere's a list of high-level product features:\n\n*   New User Guidance: Introduces new users to specific product areas.\n*   Empty State Display: Shows a helpful message when a product area is empty.\n*   Customizable Content: Allows customization of the product name, description, and call to action.\n*   Visual Aid: Includes a hedgehog graphic to improve user engagement.\n*   Dismissable Intro: Allows users to dismiss the introduction, preventing it from showing again.\n*   Actionable Button: Provides a primary button to create a new item.\n*   Documentation Link: Offers a link to relevant documentation for further learning.\n*   Custom Action Override: Supports overriding the default action button with a custom element.\n"
    },
    {
        "path": "frontend/src/lib/components/Property.tsx",
        "summary": "This React component, `Property`, is designed to display a property value. It handles different data types, including objects (which are stringified to JSON) and strings. If the string value is a valid external link, it renders the value as a clickable link that opens in a new tab. Otherwise, it simply renders the value as a string within a `span` element, with the original value as the title for potential tooltips.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Property Value Display:** Renders property values of various data types.\n*   **JSON Object Handling:** Automatically stringifies JSON objects for display.\n*   **External Link Detection:** Identifies and renders external URLs as clickable links.\n*   **Tooltip Support:** Displays the full property value as a tooltip on hover.\n"
    },
    {
        "path": "frontend/src/lib/components/DateFilter/types.ts",
        "summary": "The code defines types and constants related to a date filter component in a frontend application. It specifies different views for the date filter, including QuickList, DateToNow, FixedRange, and FixedDate. It also defines the properties (props) for the date filter logic, such as `key`, `onChange` handler, `dateFrom`, `dateTo`, `dateOptions`, placeholders and flags for formatting and precision. Constants are defined for custom options and placeholders.\n\nHere's a list of high-level product features that can be inferred from the code:\n\n*   **Date Range Selection:** Allows users to select a date range for filtering data.\n*   **Quick Date Presets:** Offers a list of predefined date ranges (e.g., \"Last 7 days\", \"This month\").\n*   **Relative Date Filtering (\"Date to Now\"):** Enables filtering data from a specific date up to the current time.\n*   **Fixed Date Range Selection:** Allows users to specify a fixed start and end date.\n*   **Single Date Selection:** Enables filtering data based on a specific date.\n*   **Custom Date Ranges:** Supports defining custom date ranges beyond the predefined options.\n*   **Date Formatting:** Provides options for formatting the selected dates.\n*   **Time Precision:** Allows users to specify the precision of the time component in the date range.\n*   **Placeholder Text:** Displays helpful placeholder text in the date input fields.\n*   **Date Range Overriding:** Supports overriding date ranges.\n"
    },
    {
        "path": "frontend/src/lib/components/DateFilter/RollingDateRangeFilter.tsx",
        "summary": "This code defines a `RollingDateRangeFilter` React component that allows users to select a dynamic date range relative to the current date. It provides controls for adjusting the quantity and unit of time (hours, days, weeks, etc.) to define the range. The component can be rendered as a button or inline, and it utilizes Lemon UI components for styling and interactivity. It also leverages kea-logic for state management and actions.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Dynamic Date Range Selection:** Allows users to define a date range relative to the current date (e.g., \"last 7 days\", \"last 3 months\").\n*   **Adjustable Timeframe:** Provides controls to increase or decrease the quantity of the time unit.\n*   **Selectable Time Units:** Offers a dropdown to choose the unit of time (hours, days, weeks, months, quarters, years).\n*   **Customizable Labels:** Supports custom labels for the filter and its components.\n*   **Button or Inline Rendering:** Can be rendered as a button or directly within a form or other UI element.\n*   **Tooltip Support:** Displays a tooltip with a formatted date range when hovering over the filter.\n*   **Configurable Allowed Date Options:** Allows limiting the available date options (e.g., only allow \"days\", \"weeks\", and \"months\").\n*   **Full Width Option:** Allows the button to take up the full width of its container."
    },
    {
        "path": "frontend/src/lib/components/DateFilter/dateFilterLogic.ts",
        "summary": "This code defines a Kea logic module named `dateFilterLogic` that manages the state and behavior of a date filter component. It handles opening and closing the date filter popover, managing different date selection views (Quick List, Fixed Range, Date to Now, Fixed Date), setting and applying date ranges, and formatting the selected date(s) into a human-readable label. The logic also handles persistence of time precision and callbacks to notify parent components of date changes.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Date Range Selection:** Allows users to select a date range using a calendar interface.\n*   **Quick Date Presets:** Offers a list of predefined date ranges (e.g., \"Last 7 days\", \"This month\").\n*   **\"Date to Now\" Functionality:** Enables users to select a start date and view data up to the current time.\n*   **Fixed Date Selection:** Allows users to select a single, specific date.\n*   **Time Precision:** Supports selection of specific times in addition to dates.\n*   **Date Formatting:** Formats the selected date(s) into a user-friendly label.\n*   **External Change Notification:** Notifies parent components when the selected date(s) change.\n*   **Customizable Date Options:** Allows for custom date options to be defined and used in the filter.\n"
    },
    {
        "path": "frontend/src/lib/components/DateFilter/rollingDateRangeFilterLogic.ts",
        "summary": "This code defines a Kea logic module called `rollingDateRangeFilterLogic` that manages the state and behavior of a rolling date range filter component. It allows users to select a dynamic date range relative to the current date, such as \"last 3 days\" or \"last 1 month\". The logic handles the counter (the number in the range), the date option (days, weeks, months, etc.), and the display of the selected date range. It also includes actions to increment/decrement the counter, set the date option, and toggle the date options selector. The logic converts the selected values into a string representation suitable for use as a date filter value.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dynamic Date Range Selection:** Allows users to select a date range relative to the current date (e.g., \"Last 7 days\", \"Last 1 month\").\n*   **Customizable Range:** Users can adjust the number of units (e.g., the \"7\" in \"Last 7 days\") and the unit of time (days, weeks, months, years, hours, quarters).\n*   **Real-time Updates:** The selected date range is updated in real-time as the user adjusts the counter or date option.\n*   **Formatted Date Display:** Provides a human-readable representation of the selected date range.\n*   **Date Range Start Calculation:** Calculates the start date of the selected rolling date range.\n*   **Debounced Updates:** Updates to the parent component are debounced to prevent excessive updates during user interaction.\n"
    },
    {
        "path": "frontend/src/lib/components/DateFilter/DateFilter.tsx",
        "summary": "The `DateFilter` component provides a flexible date selection interface, allowing users to choose from predefined date ranges, rolling date ranges, or custom date ranges. It leverages Lemon UI components for styling and interactivity, and utilizes a Kea logic hook (`dateFilterLogic`) to manage the component's state and actions. The component supports various configurations, including disabling the filter, customizing labels, and controlling the available date options. It also handles different date selection modes, such as fixed dates, date-to-now ranges, and fixed date ranges, providing a comprehensive solution for date filtering needs.\n\nHere's a list of high-level product features provided by the `DateFilter` component:\n\n*   **Predefined Date Ranges:** Offers a selection of common date ranges (e.g., \"Last 7 days\", \"This month\").\n*   **Rolling Date Ranges:** Allows users to select a dynamic date range relative to the current date (e.g., \"Last X days/weeks/months\").\n*   **Custom Date Ranges:** Enables users to specify a custom start and end date.\n*   **Fixed Date Selection:** Supports selecting a single, specific date.\n*   **Date to Now Range:** Allows selecting a start date and automatically sets the end date to the current date.\n*   **Time Precision:** Allows for time granularity when selecting dates.\n*   **Disabled State:** Provides the ability to disable the date filter with a reason.\n*   **Customizable Labels:** Supports customizing the labels displayed in the date filter.\n*   **Popover UI:** Uses a popover to display the date selection options.\n*   **Keyboard Navigation:** Leverages Lemon UI components that support keyboard navigation.\n*   **Accessibility:** Uses Lemon UI components that are built with accessibility in mind."
    },
    {
        "path": "frontend/src/lib/components/DateFilter",
        "summary": "The provided code collectively enables a comprehensive date filtering solution for a frontend application. It offers a variety of date selection methods, including predefined ranges, rolling ranges relative to the current date, custom fixed ranges, and single date selection. The solution also supports time precision, customizable labels, and integration with Lemon UI components for a user-friendly experience. The date filter logic manages the state and behavior of the component, handling date formatting, external change notifications, and persistence of time precision.\n\nHere's a list of high-level product features:\n\n*   **Predefined Date Ranges (Quick List):** Offers a selection of common date ranges (e.g., \"Last 7 days\", \"This month\").\n*   **Rolling Date Ranges:** Allows users to select a dynamic date range relative to the current date (e.g., \"Last X days/weeks/months\").\n*   **Custom Date Ranges (Fixed Range):** Enables users to specify a custom start and end date.\n*   **Fixed Date Selection:** Supports selecting a single, specific date.\n*   **Date to Now Range:** Allows selecting a start date and automatically sets the end date to the current date.\n*   **Time Precision:** Allows for time granularity when selecting dates.\n*   **Customizable Labels:** Supports customizing the labels displayed in the date filter.\n*   **Disabled State:** Provides the ability to disable the date filter with a reason.\n*   **Real-time Updates:** The selected date range is updated in real-time as the user adjusts the counter or date option.\n*   **Formatted Date Display:** Provides a human-readable representation of the selected date range.\n*   **External Change Notification:** Notifies parent components when the selected date(s) change.\n"
    },
    {
        "path": "frontend/src/lib/components/CompactList/CompactList.tsx",
        "summary": "The `CompactList` component is a reusable UI element designed to display a list of items in a compact format. It supports features like a title, a \"View All\" button, loading state with skeleton placeholders, and an empty state message. The component renders items using a provided `renderRow` function, allowing for flexible customization of each row's content. It also includes options for controlling the content's height behavior, either fixed or shrink-to-fit. The component uses Lemon UI components for styling and theming.\n\nHere's a list of high-level product features:\n\n*   **Title and Header:** Displays a title for the list with an optional \"View All\" button/link.\n*   **Loading State:** Shows skeleton placeholders while the list data is loading.\n*   **Empty State:** Displays a customizable message when the list is empty.\n*   **Customizable Rows:** Renders each row using a user-provided function, enabling flexible content display.\n*   **Content Height Control:** Offers options for fixed or shrink-to-fit content height.\n*   **Theming:** Integrates with a theme to provide consistent styling.\n"
    },
    {
        "path": "frontend/src/lib/components/CompactList",
        "summary": "The `CompactList` component is a versatile UI element for displaying lists in a condensed format. It offers a range of features to enhance the user experience, including a customizable title with an optional \"View All\" link, visual cues for loading and empty states, and flexible row rendering via a user-provided function. The component also provides control over the content's height behavior and integrates seamlessly with a theme for consistent styling.\n\nHere's a list of high-level product features:\n\n*   Title and Header: Displays a title for the list with an optional \"View All\" button/link.\n*   Loading State: Shows skeleton placeholders while the list data is loading.\n*   Empty State: Displays a customizable message when the list is empty.\n*   Customizable Rows: Renders each row using a user-provided function, enabling flexible content display.\n*   Content Height Control: Offers options for fixed or shrink-to-fit content height.\n*   Theming: Integrates with a theme to provide consistent styling.\n"
    },
    {
        "path": "frontend/src/lib/components/EditableField/EditableField.tsx",
        "summary": "The `EditableField` component provides an inline editing experience for text fields. It supports single-line and multi-line inputs, Markdown rendering, placeholder text, minimum/maximum length validation, and optional save/cancel buttons. The component can be used in controlled or uncontrolled mode, allowing external control over the editing state. It also features optional paywall integration, tooltips, and visual cues to indicate editing state.\n\nHere's a list of high-level product features:\n\n*   **Inline Editing:** Allows users to edit text directly within a field on the page.\n*   **Markdown Support:** Renders the field's content as Markdown in view mode.\n*   **Multiline Input:** Supports editing of multi-line text with automatic resizing.\n*   **Input Validation:** Enforces minimum and maximum length constraints on the input.\n*   **Controlled/Uncontrolled Mode:** Can be used with or without external control over the editing state.\n*   **Paywall Integration:** Can gate editing functionality behind a paywall.\n*   **Customizable Appearance:** Offers options for compact buttons, editing indication styles (outlined/underlined), and custom CSS styling.\n*   **Save/Cancel Actions:** Provides save and cancel buttons for confirming or discarding changes.\n*   **Placeholder Text:** Displays placeholder text when the field is empty.\n*   **Tooltip Support:** Shows a tooltip with the full text when the content is truncated.\n*   **External Notifications:** Allows for displaying extra information next to the field."
    },
    {
        "path": "frontend/src/lib/components/EditableField",
        "summary": "The `EditableField` component offers a versatile inline editing solution for text fields, enhancing user experience by allowing direct content modification within the page. It supports both single-line and multi-line inputs, renders Markdown, and incorporates validation to ensure data integrity. The component's flexibility extends to controlled and uncontrolled modes, paywall integration, and customizable appearance options, including visual cues for editing state, tooltips, and placeholder text. Save and cancel actions provide clear control over changes, while external notifications can display additional information.\n\nHere's a list of high-level product features:\n\n*   Inline Editing\n*   Markdown Support\n*   Multiline Input\n*   Input Validation\n*   Controlled/Uncontrolled Mode\n*   Paywall Integration\n*   Customizable Appearance\n*   Save/Cancel Actions\n*   Placeholder Text\n*   Tooltip Support\n*   External Notifications\n"
    },
    {
        "path": "frontend/src/lib/components/AnimatedCollapsible.tsx",
        "summary": "The `AnimatedCollapsible` component provides a way to show or hide content with a smooth animation. It uses a ref to measure the height of the content when it's expanded and sets the height to 0 when collapsed. The component utilizes CSS transitions to animate the height change, creating a collapsible effect.\n\nHere's a list of high-level product features:\n\n*   **Collapsible Content:** Allows users to collapse and expand sections of content.\n*   **Animated Transition:** Provides a smooth animation when collapsing or expanding content.\n*   **Dynamic Height Adjustment:** Automatically adjusts the height of the collapsible section based on its content.\n*   **Configurable Collapsed State:** Accepts a `collapsed` prop to control the initial state of the collapsible section.\n"
    },
    {
        "path": "frontend/src/lib/components/FlagSelector.tsx",
        "summary": "The `FlagSelector` component provides a user interface for selecting a feature flag. It uses a popover containing a `TaxonomicFilter` to display and select from a list of feature flags. The selected flag's key is displayed on a button, and clicking the button opens the popover for flag selection. The component also handles read-only states, disabling the button and providing a reason for the disabled state.\n\nHere's a list of high-level product features:\n\n*   **Feature Flag Selection:** Allows users to select a feature flag from a list.\n*   **Taxonomic Filtering:** Uses a taxonomic filter to organize and search for feature flags.\n*   **Popover Interface:** Presents the flag selection options in a popover for a clean UI.\n*   **Read-Only Mode:** Disables flag selection and provides a reason when in read-only mode.\n*   **Display Selected Flag:** Shows the key of the currently selected feature flag on the button.\n"
    },
    {
        "path": "frontend/src/lib/components/PayGateMini/PayGateButton.tsx",
        "summary": "The `PayGateButton` component is a dynamic button that adapts its behavior based on the `feature` and `currentUsage` props, determining the appropriate call-to-action (CTA) and link. It uses feature flags to conditionally render different payment entry flows, including an in-app modal for adding payment information. The button navigates users to upgrade their plan, contact sales, or migrate to PostHog Cloud, depending on the identified `gateVariant`.\n\nHere's a list of high-level product features:\n\n*   **Dynamic Call-to-Action:** The button label and destination URL change based on the user's current plan, feature usage, and feature flags.\n*   **Plan Upgrade Flow:** Facilitates upgrading the user's plan to access specific features.\n*   **Sales Contact Integration:** Provides a direct link to contact the sales team for specific feature inquiries.\n*   **Cloud Migration Assistance:** Guides users to migrate their PostHog instance to PostHog Cloud.\n*   **In-App Payment Entry:** Conditionally displays an in-app modal for users to enter their payment information, controlled by feature flags.\n*   **Billing Page Redirection:** Redirects users to the billing page, potentially highlighting specific products.\n"
    },
    {
        "path": "frontend/src/lib/components/PayGateMini/payGateMiniLogic.tsx",
        "summary": "The `payGateMiniLogic.tsx` file defines the logic for a \"PayGate Mini\" component, which acts as a feature gate, controlling access to certain features based on the user's billing plan and environment. It determines the appropriate \"gate variant\" (e.g., \"add-card\", \"contact-sales\", \"move-to-cloud\") to display to the user when a feature is not available. The logic connects to billing, user, and preflight data to determine feature availability, minimum required plans, and whether the user is on a cloud or development environment. It also handles bypassing the paywall for specific scenarios.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Feature Gating:** Controls access to features based on the user's billing plan and environment.\n*   **Gate Variant Determination:** Dynamically determines the appropriate call-to-action (e.g., add payment method, contact sales) when a feature is unavailable.\n*   **Billing Plan Awareness:** Integrates with billing data to identify the user's current plan and the minimum plan required for a specific feature.\n*   **Environment Detection:** Detects whether the user is on a cloud or development environment to tailor the gate variant accordingly.\n*   **Paywall Bypass:** Allows bypassing the paywall in specific scenarios.\n*   **Feature Information Retrieval:** Fetches detailed information about a specific feature, including its availability and limitations on different plans.\n*   **Add-on Product Detection:** Determines if a feature is part of an add-on product.\n*   **Plan Comparison:** Identifies the next plan that includes a specific feature.\n"
    },
    {
        "path": "frontend/src/lib/components/PayGateMini/PayGateMini.tsx",
        "summary": "The `PayGateMini` component acts as a paywall, controlling access to premium features based on the user's current plan and usage. It dynamically displays upsell UI when a feature is unavailable, prompting users to upgrade or take other actions like adding a credit card or contacting sales. The component adapts its messaging and call-to-actions based on the specific feature, product, and the reason for the paywall (e.g., usage limit reached, feature only available on a higher plan, or feature only available on PostHog Cloud). When the feature is available, it renders its children, providing access to the gated functionality. It also provides bypass functionality for impersonated users and integrates with PostHog analytics to track paywall impressions and CTA clicks.\n\nHere's a list of high-level product features:\n\n*   **Feature Gating:** Restricts access to premium features based on the user's subscription plan and usage.\n*   **Dynamic Upsell UI:** Presents tailored upgrade messages and calls to action based on the specific feature, product, and reason for the paywall.\n*   **Usage Limit Awareness:** Informs users when they've reached their usage limit for a specific feature.\n*   **Plan Comparison:** Displays information about feature availability on different plans.\n*   **Cloud vs. Self-Hosted Differentiation:** Indicates when a feature is only available on PostHog Cloud.\n*   **Addon Support:** Handles features that are part of specific addons.\n*   **Analytics Integration:** Tracks paywall impressions and CTA clicks for performance monitoring.\n*   **Bypass Functionality:** Allows impersonated users to bypass the paywall for testing or demonstration purposes.\n*   **Documentation Links:** Provides direct links to relevant documentation for gated features.\n"
    },
    {
        "path": "frontend/src/lib/components/PayGateMini",
        "summary": "The provided code implements a dynamic paywall system (`PayGateMini`) that restricts access to premium features based on a user's subscription plan, usage, and environment. It dynamically displays tailored upsell messages and calls to action, prompting users to upgrade their plan, add payment information, contact sales, or migrate to PostHog Cloud, depending on the specific feature and the reason for the paywall. The system integrates with billing, user, and preflight data to determine feature availability and adapts its behavior based on feature flags and user context, including bypass functionality for impersonated users and analytics tracking for performance monitoring.\n\nHere's a list of high-level product features:\n\n*   **Dynamic Feature Gating:** Controls access to features based on plan, usage, and environment.\n*   **Personalized Upsell UI:** Presents tailored upgrade messages and CTAs.\n*   **Flexible Call-to-Actions:** Offers options to upgrade, add payment, contact sales, or migrate to the cloud.\n*   **Billing & Usage Integration:** Connects to billing data to determine feature availability.\n*   **Environment Awareness:** Adapts behavior based on cloud or self-hosted environments.\n*   **Analytics Tracking:** Monitors paywall impressions and CTA clicks.\n*   **Bypass Functionality:** Allows bypassing the paywall for specific scenarios.\n*   **In-App Payment Entry:** Provides a modal for users to enter payment information.\n"
    },
    {
        "path": "frontend/src/lib/components/UserActivityIndicator/UserActivityIndicator.tsx",
        "summary": "The `UserActivityIndicator` component displays information about the last modification time and author of a resource. It conditionally renders a message indicating when and by whom the resource was last modified, including a timestamp with timezone information and the author's profile picture and name. The component accepts props for the timestamp, author, a prefix string, and a className for styling.\n\nHere's a list of high-level features:\n\n*   **Displays Last Modification Time:** Shows when a resource was last modified using a timestamp.\n*   **Displays Author Information:** Shows who last modified the resource, including their profile picture and name.\n*   **Customizable Prefix:** Allows for a customizable prefix string (e.g., \"Last modified\", \"Created\").\n*   **Timezone Awareness:** Displays the timestamp with timezone information.\n*   **Conditional Rendering:** Only renders if either the timestamp or author information is available.\n*   **Stylable:** Accepts a className prop for custom styling.\n"
    },
    {
        "path": "frontend/src/lib/components/UserActivityIndicator",
        "summary": "The `UserActivityIndicator` component provides a clear and concise display of the last modification details for a resource. It shows the timestamp of the last modification, the author who made the change, and allows for customization through a prefix string and styling options. The component intelligently handles cases where either the timestamp or author information is missing, ensuring a clean and informative user experience.\n\nHere's a list of high-level features:\n\n*   Displays Last Modification Time\n*   Displays Author Information (profile picture and name)\n*   Customizable Prefix Text\n*   Timezone Awareness in Timestamp\n*   Conditional Rendering based on available data\n*   Customizable Styling\n"
    },
    {
        "path": "frontend/src/lib/components/IntervalFilter/index.ts",
        "summary": "The code exports the `IntervalFilter` component, making it available for use in other parts of the application. This suggests the existence of a user interface element that allows filtering data based on a specified interval or range.\n\nHere's a list of high-level product features based on this:\n\n*   **Interval-based Data Filtering:** Allows users to narrow down data displayed based on a numerical range or time interval.\n*   **Customizable Interval Selection:** Provides a UI component for users to define the start and end points of the desired interval.\n*   **Real-time Filtering:** Dynamically updates the displayed data as the user adjusts the interval.\n"
    },
    {
        "path": "frontend/src/lib/components/IntervalFilter/IntervalFilter.tsx",
        "summary": "This code defines a React component called `IntervalFilter` that allows users to select the interval by which insight data is grouped (e.g., day, week, month). The component uses PostHog's Lemon UI library for styling and interactivity. It dynamically renders either a pinned interval button or a dropdown select, depending on whether the interval is manually set. The component interacts with the `insightVizDataLogic` to manage the selected interval and update the insight query. It also handles disabling options based on `enabledIntervals` from the logic.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Interval Selection:** Allows users to choose the interval for grouping insight data.\n*   **Dynamic UI:** Switches between a pinned button and a dropdown select based on whether the interval is manually set.\n*   **Manual Interval Pinning:** Enables users to \"pin\" a specific interval, preventing it from changing automatically.\n*   **Disabled Interval Options:** Disables interval options that are not applicable to the current insight.\n*   **Real-time Updates:** Updates the insight query and visualization when the interval is changed.\n"
    },
    {
        "path": "frontend/src/lib/components/IntervalFilter/intervals.ts",
        "summary": "This code defines a data structure for specifying time intervals used for filtering data. It exports a type `IntervalKeyType` which is a union of strings representing different time intervals ('minute', 'hour', 'day', 'week', 'month'). It also exports a type `Intervals` which is a dictionary mapping each `IntervalKeyType` to an object containing a label, an optional `newDateFrom` string, an optional `disabledReason` string, and an optional `hidden` boolean. Finally, it exports a constant `intervals` which is a concrete implementation of the `Intervals` type, providing labels and `newDateFrom` values for each time interval. The `newDateFrom` field likely indicates how far back from the current date the interval should start.\n\nHere's a list of high-level product features that can be derived from this code:\n\n*   **Time-based data filtering:** Allows users to filter data based on predefined time intervals.\n*   **Granular interval selection:** Supports filtering by minute, hour, day, week, and month.\n*   **Customizable date ranges:** Enables specifying a relative start date for each interval (e.g., \"week\" starts 30 days ago).\n*   **Disable/Hide Intervals:** Ability to disable or hide certain intervals based on context or configuration.\n*   **Clear Labeling:** Provides user-friendly labels for each interval option.\n"
    },
    {
        "path": "frontend/src/lib/components/IntervalFilter",
        "summary": "The provided code implements a flexible time-based data filtering feature, allowing users to analyze data within specific time intervals. The `IntervalFilter` React component provides a user interface for selecting predefined intervals (minute, hour, day, week, month) or manually setting a custom range. The component dynamically adapts its presentation based on user interaction and context, offering options to pin intervals and disable irrelevant choices, ensuring a streamlined and relevant filtering experience.\n\nHere's a list of high-level product features:\n\n*   Time-based data filtering with predefined intervals (minute, hour, day, week, month).\n*   Customizable date ranges with relative start date specification.\n*   Dynamic UI adapting between pinned button and dropdown select for interval selection.\n*   Manual interval pinning to prevent automatic changes.\n*   Disable/Hide Intervals based on context or configuration.\n*   Real-time updates to insight query and visualization upon interval change.\n*   Clear labeling for interval options.\n"
    },
    {
        "path": "frontend/src/lib/components/IframedToolbarBrowser/IframedToolbarBrowser.tsx",
        "summary": "The `IframedToolbarBrowser` component renders a website within an iframe, providing a sandboxed environment for user interaction. It displays loading and error overlays to provide feedback to the user. The component dynamically adjusts the iframe's width based on its container and constructs the iframe's URL with necessary parameters for the toolbar to function correctly. The component also leverages LemonBanner for displaying error messages.\n\nHere's a list of high-level product features:\n\n*   **Iframe Embedding:** Embeds a website within an iframe for toolbar interaction.\n*   **Dynamic Iframe Resizing:** Adjusts the iframe's width based on the container size.\n*   **Loading Overlay:** Displays a loading indicator while the iframe content is loading.\n*   **Error Handling:** Shows an error banner if the website cannot be loaded in the iframe.\n*   **Sandboxed Environment:** Provides a sandboxed environment for the embedded website using the `sandbox` attribute.\n*   **URL Parameter Injection:** Constructs the iframe URL with necessary parameters, including the user intent.\n"
    },
    {
        "path": "frontend/src/lib/components/IframedToolbarBrowser/utils.ts",
        "summary": "This code defines utilities for an iframed toolbar browser, specifically focusing on heatmap functionality and communication between the toolbar and the application it's embedded in. It defines a set of events (`PostHogAppToolbarEvent`) for communication, default heatmap filter settings, a function to calculate viewport range based on accuracy, and a filtered list of date options suitable for heatmaps.\n\nHere's a list of high-level product features that can be inferred from the code:\n\n*   **Toolbar Initialization and Communication:** Facilitates the initialization and readiness of the toolbar within an iframe, enabling communication with the parent application.\n*   **Heatmap Configuration:** Allows configuration of heatmaps, including setting filters, fixed position mode, color palettes, and common filters.\n*   **Heatmap Loading State Management:** Provides events to track the loading state of heatmaps (loading, loaded, failed).\n*   **Element Selection:** Enables the selection of elements on the page, likely for targeting actions or heatmaps.\n*   **Action Creation:** Supports the creation of new actions, including naming and confirmation.\n*   **Navigation Tracking:** Tracks navigation events within the toolbar.\n*   **Viewport Accuracy Adjustment:** Allows adjusting the viewport accuracy for heatmaps.\n*   **Date Range Filtering for Heatmaps:** Provides a filtered list of date range options suitable for heatmap analysis.\n"
    },
    {
        "path": "frontend/src/lib/components/IframedToolbarBrowser/iframedToolbarBrowserLogic.ts",
        "summary": "This code defines the logic for an iframed toolbar browser component within a PostHog application. It manages the state and interactions between the main application and an embedded iframe, primarily used for features like heatmaps, adding/editing actions and experiments. The logic handles URL authorization, communication with the iframe via `postMessage`, managing heatmap filters and settings, and tracking the loading state of the iframe. It also integrates with PostHog's event capturing to track user interactions within the iframe.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Iframe Communication:** Enables two-way communication between the PostHog application and an embedded iframe.\n*   **URL Authorization:** Manages a list of authorized URLs for the iframe to ensure secure communication.\n*   **Heatmap Integration:** Supports heatmap functionality within the iframe, including configuration of filters, color palettes, and fixed position mode.\n*   **Element Selection:** Facilitates element selection within the iframe for action creation/editing.\n*   **Loading State Management:** Tracks the loading state of the iframe and displays appropriate banners to the user.\n*   **Toolbar Navigation:** Handles navigation events within the iframe and updates the current path in the application.\n*   **User Intent Handling:** Supports different user intents, such as viewing heatmaps or adding actions, and configures the iframe accordingly.\n*   **Error Handling:** Displays error banners if the heatmap fails to load.\n"
    },
    {
        "path": "frontend/src/lib/components/IframedToolbarBrowser",
        "summary": "The code collectively implements an iframed toolbar browser component within a PostHog application, enabling users to interact with a website within a sandboxed iframe environment. This interaction facilitates features like heatmap analysis, action creation, and experiment setup directly on the embedded website. The component manages communication between the main application and the iframe, handles URL authorization, tracks loading states, and provides error handling, ensuring a secure and user-friendly experience.\n\n*   Iframe Embedding and Sandboxing\n*   Two-way Communication Between Application and Iframe\n*   Dynamic Iframe Resizing\n*   Heatmap Configuration and Visualization\n*   Element Selection for Targeting\n*   Action and Experiment Creation/Editing\n*   Loading State Management and Error Handling\n*   URL Authorization and Security\n*   User Intent Handling and Configuration\n*   Toolbar Navigation Tracking\n"
    },
    {
        "path": "frontend/src/lib/components/Errors/stackFrameLogic.ts",
        "summary": "This code defines a Kea logic module named `stackFrameLogic` that manages the loading and display of stack frame records for error tracking. It fetches stack frame data from the API, stores it in a keyed record, and provides actions to control the display, such as showing all frames or reversing the frame order. The logic persists the user's preference for showing all frames and the frame order.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Load Stack Frames by Raw IDs:** Fetches stack frame records from the API based on their raw IDs.\n*   **Load Stack Frames for Symbol Set:** Fetches stack frame records associated with a specific symbol set.\n*   **Toggle Display of All Frames:** Allows users to show or hide non-essential stack frames.\n*   **Reverse Frame Order:** Enables users to reverse the order of stack frames for easier debugging.\n*   **Persistent Display Preferences:** Remembers the user's preferred settings for showing all frames and the frame order across sessions.\n"
    },
    {
        "path": "frontend/src/lib/components/Errors/types.ts",
        "summary": "This code defines the data structures used for error tracking within the frontend application. It includes interfaces for representing exceptions, stack traces (both raw and resolved), stack frames, stack frame records, stack frame context, and symbol sets. These interfaces provide a structured way to handle and display error information, including details about the error's origin, location in the code, and surrounding context.\n\nHere's a list of high-level product features that can be derived from these data structures:\n\n*   **Error Reporting and Tracking:** Capturing and storing error information, including stack traces and exception details.\n*   **Stack Trace Analysis:** Displaying and analyzing stack traces to identify the root cause of errors.\n*   **Source Code Context:** Showing the relevant lines of code surrounding the error location.\n*   **Symbolication:** Resolving mangled names in stack traces to human-readable symbols.\n*   **Error Resolution Assistance:** Providing information to help developers understand and fix errors.\n*   **Error Grouping and Deduplication:** Grouping similar errors together to reduce noise and focus on the most important issues.\n*   **Symbol Set Management:** Managing symbol sets for symbolication.\n"
    },
    {
        "path": "frontend/src/lib/components/Errors/StackTraces.tsx",
        "summary": "This code defines a React component, `ChainedStackTraces`, that displays a series of stack traces for error tracking exceptions. It fetches and organizes stack frame data, allowing users to inspect the context of each frame. The component uses LemonCollapse to create expandable panels for each stack frame, showing the source file, function name, line number, and code context. It also highlights \"in_app\" frames and indicates unresolved frames.\n\nHere's a list of high-level product features:\n\n*   **Displays chained stack traces:** Presents multiple exceptions and their corresponding stack traces in a structured manner.\n*   **Filters stack frames:** Allows users to toggle between showing all stack frames or only \"in_app\" frames.\n*   **Code context display:** Shows the code surrounding the line where the error occurred, aiding in debugging.\n*   **Stack frame details:** Displays source file, function name, and line number for each stack frame.\n*   **Unresolved frame indication:** Flags stack frames that could not be resolved, providing additional context.\n*   **Interactive collapse/expand:** Uses LemonCollapse to allow users to expand and collapse individual stack frames for focused inspection.\n"
    },
    {
        "path": "frontend/src/lib/components/Errors/ErrorDisplay.tsx",
        "summary": "The `ErrorDisplay` component is designed to present detailed error information extracted from event properties. It displays the error type/level, value, and metadata such as the capturing service (Sentry or PostHog), unhandled status, library, browser, and OS. It also renders ingestion errors, if any, using a LemonBanner. If a stack trace is available, it renders a `StackTrace` component, which includes a toggle to show or hide non-application frames. The `StackTrace` component uses the `ChainedStackTraces` component to display the stack trace information.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Error Summary:** Displays a concise summary of the error, including its type/level and value.\n*   **Metadata Display:** Shows relevant metadata about the error, such as the capturing service, unhandled status, library, browser, and OS.\n*   **Ingestion Error Reporting:**  Alerts users to any errors encountered during the ingestion of the error event.\n*   **Stack Trace Visualization:** Renders a stack trace for errors, allowing developers to understand the sequence of function calls leading to the error.\n*   **Stack Frame Filtering:** Provides a toggle to show or hide non-application frames in the stack trace, helping developers focus on relevant code.\n"
    },
    {
        "path": "frontend/src/lib/components/Errors",
        "summary": "The error tracking functionality provides a comprehensive suite of features for identifying, analyzing, and resolving errors within an application. It captures detailed error information, including stack traces, exception details, and metadata, and presents it in a user-friendly interface. Users can filter stack frames, view code context, and toggle display preferences to focus on the most relevant information. The system also supports symbolication, error grouping, and ingestion error reporting, enabling developers to efficiently diagnose and fix issues.\n\nHere's a list of high-level product features:\n\n*   Error Reporting and Tracking\n*   Stack Trace Visualization and Analysis\n*   Code Context Display\n*   Stack Frame Filtering\n*   Symbolication\n*   Error Grouping and Deduplication\n*   Ingestion Error Reporting\n*   Symbol Set Management\n*   Persistent Display Preferences\n*   Error Summary\n*   Metadata Display\n*   Error Resolution Assistance\n*   Interactive collapse/expand of stack frames\n*   Unresolved frame indication\n"
    },
    {
        "path": "frontend/src/lib/components/HoqQLPropertyInfo.tsx",
        "summary": "This React component, `HoqQLPropertyInfo`, displays a string value, likely representing a property, using a monospace font and a muted text color. It truncates the string in the middle if it exceeds 60 characters, adding an ellipsis, and provides the full value as a tooltip on hover. This is useful for displaying long, technical strings in a concise manner while still allowing users to access the full value.\n\nHere's a list of high-level product features:\n\n*   **Property Value Display:** Renders a string value representing a property.\n*   **Text Truncation:** Condenses long strings using middle ellipsis for readability.\n*   **Tooltip Display:** Shows the full string value on hover for complete information access.\n*   **Monospace Font:** Uses a monospace font for consistent character width, improving readability of code-like values.\n*   **Styled Text:** Applies specific text styling (color, size) for visual consistency and emphasis.\n"
    },
    {
        "path": "frontend/src/lib/components/CommandPalette/commandPaletteLogic.tsx",
        "summary": "This code defines the logic for a command palette in a web application. The command palette allows users to quickly access various features and navigate to different parts of the application using a text-based interface. It supports commands with prefixes, fuzzy search, and command flows (multi-step commands). The logic manages the state of the palette, including visibility, input, active command flow, and search results. It also handles command registration, execution, and tracking.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Command Palette:** A central interface for accessing application features via text commands.\n*   **Fuzzy Search:** Allows users to find commands even with typos or incomplete input.\n*   **Command Prefixes:** Supports commands that require a prefix (e.g., \"go to dashboard\").\n*   **Command Flows:** Enables multi-step commands or guided actions.\n*   **Customizable Commands:** Allows registration and deregistration of commands dynamically.\n*   **Scoped Commands:** Organizes commands into different scopes or categories.\n*   **Keyboard Navigation:** Supports navigating the command palette results using arrow keys.\n*   **Analytics Tracking:** Tracks command usage for insights and improvements.\n*   **Dynamic Command Suggestions:** Commands can be suggested based on user input (e.g. searching for a person by name)."
    },
    {
        "path": "frontend/src/lib/components/CommandPalette/DebugCHQueries.tsx",
        "summary": "This code defines a React component, `DebugCHQueries`, which is used to display ClickHouse query debugging information within a modal. It fetches and visualizes recent queries executed for a specific user or insight, along with statistics like total queries, exceptions, and average/max query durations. The component includes a bar chart showing hourly query success and exception rates, a table listing individual queries with details like timestamp, query ID, execution time, and the ability to filter queries by their originating path. It leverages Kea for state management and data fetching, and uses Lemon UI components for the user interface.\n\nHere's a list of high-level product features:\n\n*   **ClickHouse Query Debugging Modal:** Provides a modal interface to view ClickHouse query information.\n*   **Query Statistics:** Displays aggregated statistics about ClickHouse queries, including total queries, exceptions, and duration metrics.\n*   **Hourly Query Visualization:** Presents a bar chart visualizing the hourly success and exception rates of queries.\n*   **Detailed Query Table:** Lists individual ClickHouse queries with details such as timestamp, query ID, execution time, and status.\n*   **Query Filtering by Path:** Allows filtering the displayed queries based on their originating path.\n*   **Cache Key and Insight ID Display:** Shows cache key and insight ID information associated with each query.\n*   **Refresh Functionality:** Enables refreshing the query data to fetch the latest information.\n*   **Integration with Sentry:** Provides a link to Sentry for investigating issues related to specific cache keys."
    },
    {
        "path": "frontend/src/lib/components/CommandPalette",
        "summary": "The provided code snippets detail two key features: a ClickHouse query debugging tool and a command palette. The debugging tool offers a modal interface to visualize and analyze ClickHouse queries, providing statistics, hourly visualizations, and a detailed table of individual queries with filtering capabilities. The command palette provides a central, text-based interface for accessing application features, supporting fuzzy search, command prefixes, multi-step command flows, and dynamic command suggestions.\n\nHere's a list of high-level product features:\n\n*   ClickHouse Query Debugging Modal\n*   Query Statistics (total queries, exceptions, duration metrics)\n*   Hourly Query Visualization (success and exception rates)\n*   Detailed Query Table (timestamp, query ID, execution time, status)\n*   Query Filtering by Path\n*   Command Palette (text-based interface for accessing features)\n*   Fuzzy Search (for commands)\n*   Command Prefixes (e.g., \"go to dashboard\")\n*   Command Flows (multi-step commands)\n*   Dynamic Command Suggestions\n"
    },
    {
        "path": "frontend/src/lib/components/heatmaps/types.ts",
        "summary": "This code defines the data types and interfaces used for heatmaps in the frontend application. It includes types for common filters like date ranges, the kind of heatmap (click, rageclick, mousemove, scrolldepth), request parameters for fetching heatmap data (including URL matching and viewport width), heatmap filters to enable/disable and configure the heatmap, data structures for heatmap data points, and modes for fixed position elements.\n\nHere's a list of high-level product features that can be inferred from this code:\n\n*   **Heatmap Visualization:** Display heatmaps based on user interactions.\n*   **Multiple Heatmap Types:** Support different heatmap types such as click, rage click, mouse movement, and scroll depth.\n*   **Date Range Filtering:** Filter heatmap data by date ranges.\n*   **URL Filtering:** Filter heatmap data based on specific URLs or URL patterns.\n*   **Viewport Size Filtering:** Filter heatmap data based on the viewport size of the user's browser.\n*   **Data Aggregation:** Aggregate heatmap data by total count or unique visitors.\n*   **Heatmap Configuration:** Enable/disable and configure heatmap display settings.\n*   **Fixed Position Mode:** Configure how fixed position elements are handled in the heatmap.\n"
    },
    {
        "path": "frontend/src/lib/components/heatmaps/HeatMapsSettings.tsx",
        "summary": "This React component, `HeatmapsSettings`, provides a user interface for configuring heatmap visualizations. It allows users to adjust various parameters such as the heatmap type (clicks, rageclicks, mouse moves, scroll depth), aggregation method (total count, unique visitors), viewport accuracy, color palette, and how to handle fixed position elements. The component utilizes Lemon UI components for a consistent look and feel and leverages kea logic for managing state related to scroll depth errors.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Heatmap Type Selection:** Allows users to choose the type of heatmap to display (clicks, rageclicks, dead clicks, mouse moves, scroll depth).\n*   **Aggregation Method Selection:** Enables users to aggregate heatmap data by total count or unique visitors.\n*   **Viewport Accuracy Adjustment:** Provides a slider to control the viewport accuracy for filtering heatmap data based on user screen sizes.\n*   **Color Palette Selection:** Allows users to customize the color scheme of the heatmap.\n*   **Fixed Positioning Handling:** Enables users to control how fixed position elements are displayed on the heatmap (show fixed, show scrolled, hide).\n*   **Scroll Depth PostHog JS Version Warning:** Displays a warning message if the user's PostHog JS version is incompatible with scroll depth heatmaps or if scroll properties are disabled.\n"
    },
    {
        "path": "frontend/src/lib/components/heatmaps",
        "summary": "The `HeatmapsSettings` component and associated types provide a comprehensive suite of features for visualizing and analyzing user behavior through heatmaps. Users can select from various heatmap types, aggregation methods, and color palettes, as well as fine-tune the data displayed through viewport accuracy and URL filtering. The system also handles fixed position elements and provides warnings for incompatible configurations, ensuring a robust and customizable heatmap experience.\n\n**Features:**\n\n*   Heatmap Type Selection (clicks, rageclicks, mouse moves, scroll depth)\n*   Aggregation Method Selection (total count, unique visitors)\n*   Viewport Accuracy Adjustment\n*   Color Palette Selection\n*   Fixed Positioning Handling (show fixed, show scrolled, hide)\n*   Date Range Filtering\n*   URL Filtering\n*   Scroll Depth PostHog JS Version Warning\n*   Heatmap Configuration (enable/disable and configure heatmap display settings)\n"
    },
    {
        "path": "frontend/src/lib/components/VerticalNestedDND/VerticalNestedDND.tsx",
        "summary": "The `VerticalNestedDND` component provides a drag-and-drop interface for managing a list of nested items. It allows users to reorder container items and child items within those containers. The component utilizes the `@dnd-kit/core` and `@dnd-kit/sortable` libraries to handle drag and drop functionality, including collision detection and animation. It supports custom rendering of container and child items, as well as adding new items. The component also includes debounced onChange functionality to persist changes.\n\nHere's a list of high-level product features:\n\n*   **Drag and Drop Reordering:** Allows users to reorder container items and child items within containers using drag and drop.\n*   **Nested Structure:** Supports a nested data structure with container items and child items.\n*   **Customizable Rendering:** Provides customizable rendering for both container and child items.\n*   **Add New Items:** Enables users to add new container items and child items to existing containers.\n*   **Change Persistence:** Persists changes to the item order and structure through an `onChange` callback.\n*   **Visual Feedback:** Provides visual feedback during drag and drop operations.\n*   **Remove Container Items:** Enables users to remove container items.\n"
    },
    {
        "path": "frontend/src/lib/components/VerticalNestedDND",
        "summary": "The `VerticalNestedDND` component enables users to manage and reorder nested lists through an intuitive drag-and-drop interface. It supports customizable rendering of both container and child items, allowing for flexible presentation of data. Users can add new items to the list and persist changes, and the component provides visual feedback during drag-and-drop operations to enhance the user experience. Users can also remove container items.\n\nHere's a list of high-level product features:\n\n*   Drag and Drop Reordering\n*   Nested Structure\n*   Customizable Rendering\n*   Add New Items\n*   Change Persistence\n*   Visual Feedback\n*   Remove Container Items\n"
    },
    {
        "path": "frontend/src/lib/components/FallbackCoverImage/FallbackCoverImage.tsx",
        "summary": "The `FallbackCoverImage` component in this code provides a way to display an image, and if the image fails to load (or if no source is provided), it displays a fallback background color. The background color is dynamically determined based on the index prop, utilizing the `getSeriesColor` function. The component handles image loading errors using the `onError` event, switching to the fallback color when an error occurs.\n\nHere's a list of high-level product features:\n\n*   **Image Display:** Displays an image if a valid source is provided.\n*   **Fallback Mechanism:** Provides a fallback background color if the image fails to load or if no source is provided.\n*   **Dynamic Fallback Color:** The fallback background color is dynamically generated based on an index.\n*   **Error Handling:** Gracefully handles image loading errors.\n*   **Customizable Styling:** Allows for custom styling through className and imageClassName props.\n"
    },
    {
        "path": "frontend/src/lib/components/FallbackCoverImage",
        "summary": "The `FallbackCoverImage` component offers a robust solution for displaying images while ensuring a visually consistent user experience even when images fail to load. It dynamically renders an image from a provided source, and in cases where the image fails to load or no source is available, it gracefully falls back to a dynamically generated background color. This fallback color is determined by an index, allowing for visual differentiation. The component also provides customizable styling options through className and imageClassName props.\n\nHere's a list of high-level product features:\n\n*   Image Display: Renders an image from a given source.\n*   Fallback Mechanism: Displays a background color when the image fails to load or the source is missing.\n*   Dynamic Fallback Color: Generates the fallback background color based on an index.\n*   Error Handling: Manages image loading errors gracefully.\n*   Customizable Styling: Offers styling customization through className and imageClassName props.\n"
    },
    {
        "path": "frontend/src/lib/components/HedgehogBuddy/sprites/sprites.tsx",
        "summary": "This code defines the visual assets and animations for a Hedgehog Buddy, including sprites, accessories, and skins. It manages the loading and display of these assets, handling different environments like Storybook and the PostHog toolbar. The code defines various animations like walking, jumping, and waving, along with accessories like hats and glasses, allowing for customization of the Hedgehog Buddy's appearance and behavior.\n\nHere's a list of high-level product features based on the code:\n\n*   **Customizable Hedgehog Buddy Appearance:** Allows users to change the look of their Hedgehog Buddy with different skins and accessories.\n*   **Animated Hedgehog Buddy:** The Hedgehog Buddy can perform various animations like walking, jumping, waving, and other actions.\n*   **Accessory System:** Users can add accessories like hats, glasses, and other items to their Hedgehog Buddy.\n*   **Environment-Aware Asset Loading:** The system can load assets from different locations depending on the environment (e.g., local development, PostHog toolbar, production).\n*   **Overlay Animations:** The system supports overlay animations, such as fire, that can be displayed on top of the Hedgehog Buddy.\n*   **Configurable Animation Behavior:** Animations can be configured with properties like frame count, looping behavior, and random chance of being selected.\n"
    },
    {
        "path": "frontend/src/lib/components/HedgehogBuddy/HedgehogOptions.tsx",
        "summary": "This code defines the `HedgehogOptions` React component, which allows users to customize their Hedgehog Buddy. It provides options to toggle walking, element interaction, keyboard controls, and party mode. Users can also select different skins and colors for their hedgehog, as well as add accessories from various groups. The component displays a preview of the hedgehog with the selected customizations and provides tooltips for each option.\n\nHere's a list of high-level product features:\n\n*   **Hedgehog Customization:**\n    *   Skin selection (default, spiderhog).\n    *   Color selection.\n    *   Accessory selection (hats, glasses, etc.).\n*   **Behavioral Controls:**\n    *   Toggle walking behavior (free movement vs. stationary).\n    *   Toggle interaction with page elements.\n    *   Enable/disable keyboard controls (WASD/arrow keys).\n*   **Party Mode:**\n    *   Enable party mode to display other organization members as hedgehogs.\n*   **Hedgehog Preview:**\n    *   Real-time preview of the hedgehog with selected customizations.\n*   **Accessibility:**\n    *   Tooltips for options.\n    *   Keyboard controls for movement.\n*   **SpiderHog Skin:**\n    *   Special skin that gives the hedgehog spider powers and unique movement controls.\n"
    },
    {
        "path": "frontend/src/lib/components/HedgehogBuddy/hedgehogBuddyLogic.ts",
        "summary": "This code defines the logic for a \"Hedgehog Buddy\" feature, likely a customizable avatar or visual element within the application. It manages the Hedgehog's configuration, including whether it's enabled, its color, accessories, and various behavioral settings. The logic persists the configuration both locally and remotely, allowing users to customize their Hedgehog and have those customizations saved. It also integrates with PostHog for event tracking and early access feature management.\n\nHere's a list of high-level product features:\n\n*   **Enable/Disable Hedgehog Mode:** Allows users to toggle the Hedgehog Buddy feature on or off.\n*   **Customize Hedgehog Appearance:**\n    *   **Color Selection:**  Lets users choose the Hedgehog's color.\n    *   **Accessory Management:**  Enables users to add and remove accessories to personalize their Hedgehog.\n*   **Behavioral Settings:**\n    *   **Walking Enabled:** Toggles the Hedgehog's ability to walk or move around.\n    *   **Interactions Enabled:** Controls whether the Hedgehog interacts with the user or environment.\n    *   **Controls Enabled:** Determines if the user has control over the Hedgehog's actions.\n    *   **Party Mode:** Activates a special \"party mode\" for the Hedgehog.\n*   **Profile Integration:** Option to use the Hedgehog as a profile representation.\n*   **Configuration Persistence:** Saves Hedgehog configurations remotely, ensuring customizations are retained across sessions and devices.\n*   **Toolbar Integration:** Supports usage within a toolbar context, potentially for embedded applications.\n*   **Early Access Feature Management:** Integrates with PostHog's early access feature system to manage the rollout of the Hedgehog Buddy feature.\n"
    },
    {
        "path": "frontend/src/lib/components/HedgehogBuddy/HedgehogBuddy.tsx",
        "summary": "The `HedgehogBuddy` component is a fun, interactive element that adds a customizable hedgehog character to a web page. The hedgehog can be configured with different skins, accessories, and behaviors. It can walk, jump, and react to user interactions like keyboard presses and mouse movements. The component uses sprite sheet animations to bring the hedgehog to life and includes features like gravity, collision detection, and special animations triggered by secret key combinations. The hedgehog's behavior and appearance can be customized through a configuration object, allowing developers to tailor the character to their specific needs.\n\nHere's a list of high-level product features:\n\n*   **Customizable Appearance:** Allows users to change the hedgehog's skin and accessories.\n*   **Interactive Animations:** Provides a variety of animations for the hedgehog, including walking, jumping, and special actions.\n*   **User Interaction:** Responds to keyboard and mouse input, enabling users to control the hedgehog's movements.\n*   **Physics Simulation:** Implements gravity and collision detection for realistic movement and interactions with the environment.\n*   **Configurable Behavior:** Enables developers to customize the hedgehog's behavior through a configuration object.\n*   **Secret Key Combinations:** Includes hidden animations and features triggered by specific key sequences.\n*   **Accessibility Features:** Respects user preferences for reduced motion and input handling.\n*   **Tooltip Support:** Displays a tooltip when the user interacts with the hedgehog.\n*   **Static Mode:** Allows the hedgehog to be displayed as a static image.\n"
    },
    {
        "path": "frontend/src/lib/components/HedgehogBuddy/sprites",
        "summary": "The code provides the foundation for a customizable and animated Hedgehog Buddy, a virtual companion with a range of appearances and behaviors. It handles asset loading based on the environment, supports various animations, and allows users to personalize their buddy with accessories. The system also includes overlay animations and configurable animation behaviors, enhancing the overall user experience.\n\nHere's a list of high-level product features:\n\n*   **Customizable Hedgehog Buddy Appearance:** Users can personalize their Hedgehog Buddy with different skins and accessories.\n*   **Animated Hedgehog Buddy:** The Hedgehog Buddy can perform various animations like walking, jumping, waving, and other actions.\n*   **Accessory System:** Users can add accessories like hats, glasses, and other items to their Hedgehog Buddy.\n*   **Environment-Aware Asset Loading:** The system can load assets from different locations depending on the environment.\n*   **Overlay Animations:** Supports overlay animations, such as fire, that can be displayed on top of the Hedgehog Buddy.\n*   **Configurable Animation Behavior:** Animations can be configured with properties like frame count, looping behavior, and random chance of being selected.\n"
    },
    {
        "path": "frontend/src/lib/components/HedgehogBuddy/HedgehogBuddyRender.tsx",
        "summary": "This code defines two React components, `HedgehogBuddyStatic` and `HedgehogBuddyProfile`, for rendering customizable hedgehog avatars. `HedgehogBuddyStatic` renders a static hedgehog image with configurable skin, color, and accessories.  `HedgehogBuddyProfile` renders a cropped, circular version of the static hedgehog, suitable for profile pictures. Both components allow specifying the size of the rendered image.\n\nHere's a list of high-level product features:\n\n*   **Customizable Hedgehog Avatar:** Allows users to create personalized hedgehog avatars.\n*   **Skin Selection:** Offers different hedgehog skin options.\n*   **Color Customization:** Enables users to change the color of the hedgehog.\n*   **Accessory Selection:** Provides a variety of accessories to add to the hedgehog.\n*   **Size Adjustment:** Allows users to control the size of the rendered avatar.\n*   **Profile Picture Rendering:** Provides a component specifically designed for rendering profile picture style avatars.\n"
    },
    {
        "path": "frontend/src/lib/components/HedgehogBuddy/HedgehogBuddyWithLogic.tsx",
        "summary": "This code implements a \"Hedgehog Buddy\" feature, which appears to be a UI element or set of elements that can be enabled or disabled via a configuration. When enabled, it displays a \"MyHedgehogBuddy\" component and, if \"party mode\" is also enabled, it displays a \"MemberHedgehogBuddy\" component for each member of the organization (excluding the current user) who also has a hedgehog configuration. The component uses kea-logic for state management and actions, and fetches user and member data.\n\nHere's a list of high-level product features:\n\n*   **Enable/Disable Hedgehog Buddy:** Allows users to toggle the Hedgehog Buddy feature on or off.\n*   **My Hedgehog Buddy:** Displays a Hedgehog Buddy component specific to the current user.\n*   **Party Mode:** When enabled, displays Hedgehog Buddy components for other organization members.\n*   **Member Hedgehog Buddies:** Displays a Hedgehog Buddy component for each organization member (excluding the current user) when party mode is enabled.\n*   **Configuration Persistence:** Saves the Hedgehog Buddy configuration (enabled state, party mode state) for the user.\n"
    },
    {
        "path": "frontend/src/lib/components/HedgehogBuddy",
        "summary": "The Hedgehog Buddy feature offers a fun and engaging way for users to personalize their experience with customizable hedgehog avatars. Users can enable or disable the feature, customize their hedgehog's appearance with different skins, colors, and accessories, and control its behavior with options like walking, interaction with page elements, and keyboard controls. A \"party mode\" allows users to see other organization members as hedgehogs, fostering a sense of community. The feature also includes persistence of configurations, accessibility features, and integration with PostHog for event tracking and early access management.\n\nHere's a list of high-level product features:\n\n*   **Hedgehog Buddy Enable/Disable:** Toggles the entire feature on or off.\n*   **Customizable Appearance:**\n    *   Skin Selection (including special skins like SpiderHog).\n    *   Color Selection.\n    *   Accessory Management (hats, glasses, etc.).\n*   **Behavioral Controls:**\n    *   Toggle Walking Behavior.\n    *   Toggle Interaction with Page Elements.\n    *   Enable/Disable Keyboard Controls.\n*   **Party Mode:** Displays other organization members as hedgehogs.\n*   **Profile Integration:** Option to use the Hedgehog as a profile representation.\n*   **Configuration Persistence:** Saves Hedgehog configurations remotely.\n*   **Interactive Animations:** Provides a variety of animations for the hedgehog.\n*   **Accessibility Features:** Tooltips and keyboard controls.\n*   **Physics Simulation:** Implements gravity and collision detection.\n*   **Environment-Aware Asset Loading:** Loads assets based on the environment.\n*   **Early Access Feature Management:** Integrates with PostHog for feature rollout.\n"
    },
    {
        "path": "frontend/src/lib/components/VisibilitySensor/visibilitySensorLogic.tsx",
        "summary": "This code defines a Kea logic module called `visibilitySensorLogic` that detects when an HTML element is visible within the viewport. It uses the `kea-window-values` plugin to track the window's inner height and provides actions to set the visibility state. The logic calculates visibility based on the element's position relative to the viewport, considering an optional offset. It also includes a listener that triggers visibility checks on scrolling events, debouncing the checks to improve performance.\n\nHere's a list of high-level product features:\n\n*   **Visibility Tracking:** Detects when an HTML element enters or exits the user's viewport.\n*   **Offset Configuration:** Allows specifying an offset to adjust the visibility detection threshold.\n*   **Scrolling Event Handling:** Listens for scrolling events to re-evaluate element visibility.\n*   **Debounced Visibility Checks:** Optimizes performance by debouncing visibility checks during scrolling.\n*   **State Management:** Manages the visibility state of the element (visible/not visible).\n"
    },
    {
        "path": "frontend/src/lib/components/VisibilitySensor/VisibilitySensor.tsx",
        "summary": "The `VisibilitySensor` component is a React component that detects when a specific element is visible on the screen during scrolling. It utilizes a unique ID, an optional offset, and the `visibilitySensorLogic` (not shown) to determine visibility. The component attaches a scroll event listener to the document, triggering the `scrolling` action from the logic when the element referenced by the component is scrolled into view. This action likely updates the state managed by `visibilitySensorLogic` to reflect the element's visibility.\n\nHere's a list of high-level product features:\n\n*   **Visibility Detection:** Detects when a specific HTML element becomes visible within the viewport during scrolling.\n*   **Unique Identification:** Requires a unique ID for each `VisibilitySensor` instance to differentiate between elements being tracked.\n*   **Offset Configuration:** Allows specifying an offset to adjust the visibility detection threshold.\n*   **Scroll Event Handling:** Listens for scroll events on the document to trigger visibility checks.\n*   **React Integration:** Seamlessly integrates with React components using refs and useEffect hooks.\n"
    },
    {
        "path": "frontend/src/lib/components/VisibilitySensor",
        "summary": "The provided code implements a visibility sensor component and associated logic for detecting when an HTML element is visible within the user's viewport, primarily during scrolling. It leverages React hooks and a Kea logic module to manage the visibility state and optimize performance. The component allows for configuration of an offset to fine-tune the visibility detection threshold and uses a unique ID to track individual elements.\n\nHere's a list of high-level product features:\n\n*   **Visibility Tracking:** Detects when an HTML element enters or exits the user's viewport.\n*   **Offset Configuration:** Allows specifying an offset to adjust the visibility detection threshold.\n*   **Scrolling Event Handling:** Listens for scrolling events to re-evaluate element visibility.\n*   **Debounced Visibility Checks:** Optimizes performance by debouncing visibility checks during scrolling.\n*   **State Management:** Manages the visibility state of the element (visible/not visible).\n*   **Unique Identification:** Requires a unique ID for each `VisibilitySensor` instance to differentiate between elements being tracked.\n*   **React Integration:** Seamlessly integrates with React components using refs and useEffect hooks.\n"
    },
    {
        "path": "frontend/src/lib/components/AddToDashboard/AddToDashboard.tsx",
        "summary": "This React component, `AddToDashboard`, provides a button that allows users to add a given insight to a dashboard. The button displays an icon indicating the number of dashboards the insight is already on. Clicking the button opens a modal (controlled by the `setOpenModal` prop) that presumably allows the user to manage which dashboards the insight is added to. The component utilizes the `dashboardsModel` to fetch available dashboards and displays a tooltip indicating whether the insight can be added to a dashboard or managed on existing dashboards.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Dashboard Association:** Allows users to associate insights with specific dashboards.\n*   **Dashboard Count Indicator:** Displays the number of dashboards an insight is currently associated with.\n*   **Modal Interface:** Provides a modal interface for managing dashboard associations.\n*   **Tooltip Guidance:** Offers tooltips to guide users on adding to or managing dashboards.\n"
    },
    {
        "path": "frontend/src/lib/components/AddToDashboard/addToDashboardModalLogic.ts",
        "summary": "This code defines the logic for an \"Add to Dashboard\" modal in a web application, likely for an analytics or data visualization platform. It manages the state and actions related to searching for dashboards, adding an insight (presumably a chart or data visualization) to a dashboard, and creating new dashboards from within the modal. The logic handles filtering dashboards based on search queries, managing the list of dashboards the insight is already on, and handling API calls to update the insight with the selected dashboards.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dashboard Search:** Allows users to search for existing dashboards by name, description, or tags.\n*   **Add Insight to Dashboard:** Enables users to add a selected insight to one or more dashboards.\n*   **Remove Insight from Dashboard:** Enables users to remove a selected insight from one or more dashboards.\n*   **Create New Dashboard from Modal:** Allows users to create a new dashboard directly from the \"Add to Dashboard\" modal.\n*   **Visual Feedback:** Provides visual feedback (toast notifications) to the user upon successfully adding or removing an insight from a dashboard.\n*   **Navigation to Dashboard:** Provides a direct link to navigate to the dashboard after adding an insight.\n*   **Dashboard List Filtering:** Filters the list of dashboards to show which dashboards the insight is already on and which are available.\n*   **Dashboard Ordering:** Orders the list of dashboards to show the dashboards the insight is already on first.\n"
    },
    {
        "path": "frontend/src/lib/components/AddToDashboard/AddToDashboardModal.tsx",
        "summary": "This code defines a React component, `AddToDashboardModal`, which is a modal window that allows users to add an insight to existing dashboards or create a new dashboard. It provides a search functionality to filter dashboards, displays a list of dashboards with an indication of whether the insight is already present on each dashboard, and allows users to add or remove the insight from specific dashboards. The modal also indicates primary dashboards and provides tooltips for additional information.\n\nHere's a list of high-level product features:\n\n*   **Dashboard Search:** Allows users to search for dashboards by name.\n*   **Add to Existing Dashboard:** Enables users to add an insight to one or more existing dashboards.\n*   **Remove from Dashboard:** Enables users to remove an insight from a dashboard.\n*   **Create New Dashboard:** Provides the option to create a new dashboard and add the insight to it.\n*   **Dashboard List:** Displays a list of available dashboards.\n*   **Dashboard Status Indication:** Indicates whether an insight is already present on a dashboard.\n*   **Primary Dashboard Identification:** Highlights primary dashboards.\n*   **Permission Handling:** Disables actions based on user permissions to edit insights or dashboards.\n*   **Loading State:** Shows a loading indicator during API calls to add or remove insights from dashboards.\n*   **Accessibility:** Uses tooltips to provide additional information and context.\n"
    },
    {
        "path": "frontend/src/lib/components/AddToDashboard",
        "summary": "The provided code collectively implements a feature that allows users to easily manage the association of insights with dashboards within a data visualization or analytics platform. This functionality is exposed through an \"Add to Dashboard\" button that opens a modal, enabling users to search for existing dashboards, add or remove the insight from selected dashboards, and even create new dashboards directly from the modal. The system provides visual feedback, including the number of dashboards an insight is already on, indicators of primary dashboards, and toast notifications upon successful actions, enhancing the user experience.\n\n*   Dashboard Search\n*   Add Insight to Existing Dashboard\n*   Remove Insight from Dashboard\n*   Create New Dashboard from Modal\n*   Dashboard List and Filtering\n*   Dashboard Association Management\n*   Dashboard Count Indicator\n*   Visual Feedback and Notifications\n*   Primary Dashboard Identification\n*   Tooltip Guidance and Accessibility\n*   Permission Handling\n*   Loading State\n*   Navigation to Dashboard\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyFilters/components/PropertyFiltersDisplay.tsx",
        "summary": "The `PropertyFiltersDisplay` component is responsible for rendering a collection of property filters as interactive buttons. It receives an array of `AnyPropertyFilter` objects as input and dynamically generates a `PropertyFilterButton` component for each filter in the array. These buttons are displayed within a flex container, allowing them to wrap as needed.\n\nHere's a list of high-level product features enabled by this component:\n\n*   **Display of Active Property Filters:** Shows users the filters that are currently applied to a dataset.\n*   **Interactive Filter Representation:** Renders filters as clickable buttons, suggesting the ability to modify or remove them.\n*   **Dynamic Filter List:** Adapts to different sets of filters, displaying only the active ones.\n*   **Responsive Layout:** Wraps filters onto multiple lines when the display area is limited.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyFilters/components/OperandTag.tsx",
        "summary": "This code defines a React component called `OperandTag` that displays either \"AND\" or \"OR\" within a LemonTag component from the `@posthog/lemon-ui` library. The tag's appearance (highlight or completion) is determined by the operand value, with \"AND\" using the highlight style and \"OR\" using the completion style. The component is used to visually represent logical operators within a user interface, likely for filtering or querying data.\n\n**Features:**\n\n*   **Visual Representation of Logical Operators:** Displays \"AND\" or \"OR\" tags.\n*   **Theming:** Uses LemonTag component for consistent UI theming.\n*   **Conditional Styling:** Applies different styles based on the operand type (AND/OR).\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyFilters/components/PropertyFilterDatePicker.tsx",
        "summary": "This component provides a date and time picker for filtering properties, utilizing the Lemon Calendar Select Input. It handles different date formats (with or without time), manages the visibility of the date picker, and updates the filter value based on the selected date. The component also includes a toggle to switch between date-only and date-time formats.\n\n**Features:**\n\n*   **Date and Time Selection:** Allows users to select a specific date and time for filtering properties.\n*   **Format Handling:** Supports both date-only (YYYY-MM-DD) and date-time (YYYY-MM-DD HH:mm:ss) formats.\n*   **Date/Time Toggle:** Provides a toggle to switch between date-only and date-time selection.\n*   **Calendar Visibility Control:** Manages the visibility of the calendar popup.\n*   **Value Update:** Updates the filter value with the selected date and time in the appropriate format.\n*   **Granularity Control:** Allows selection of date with minute or day granularity.\n"
    },
    {
        "path": "frontend/src/lib/components/JSBookmarklet.tsx",
        "summary": "This component provides a JavaScript bookmarklet that allows users to quickly integrate PostHog into any website they are currently browsing. The bookmarklet injects the PostHog tracking code into the page, initializing it with the user's API token and displaying an alert to confirm successful installation. The component renders a draggable link styled as a button, which users can drag to their browser's bookmarks bar. The component also includes instructions for the user on how to install and use the bookmarklet.\n\nHere's a list of high-level product features:\n\n*   **One-click PostHog Integration:** Allows users to quickly add PostHog tracking to any website without manually adding code.\n*   **Automatic Configuration:** Automatically configures PostHog with the user's API token.\n*   **Visual Confirmation:** Provides a visual alert to confirm successful installation of PostHog.\n*   **Drag-and-Drop Installation:** Enables easy installation by dragging the bookmarklet to the browser's bookmarks bar.\n*   **Usage Tracking:** Tracks when the bookmarklet is dragged to understand usage patterns.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyFilters/components/PathItemSelector.tsx",
        "summary": "The `PathItemSelector` component provides a popover-based selector for choosing path items within a taxonomic structure. It leverages the `TaxonomicFilter` component to display and manage a hierarchical list of options, allowing users to select a specific item. The selected item is then passed to a parent component via the `onChange` prop. The component also handles the visibility of the popover and disables interaction based on the `disabled` prop.\n\nHere's a list of high-level features:\n\n*   **Taxonomic Path Selection:** Allows users to select items from a hierarchical taxonomic structure.\n*   **Popover Interface:** Presents the selection options within a popover for a clean and contextual user experience.\n*   **Disabled State:** Enables disabling the selector to prevent user interaction when necessary.\n*   **External Change Handling:** Notifies the parent component when a new path item is selected.\n*   **Wildcard Option Support:** Supports the inclusion of wildcard options within the taxonomic filter.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyFilters/components/PropertyFilterIcon.tsx",
        "summary": "The `PropertyFilterIcon` component in `PropertyFilterIcon.tsx` is a React component that renders an icon based on the `type` prop, which represents the type of property filter. It uses icons from `@posthog/icons` and `lib/lemon-ui/icons` and wraps each icon in a `Tooltip` component to provide a descriptive title. The component supports 'event', 'person', 'cohort', and 'group' filter types, rendering a corresponding icon for each. If the type is not recognized, it returns null.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Event Property Icon:** Displays an icon indicating that the filter is based on an event property.\n*   **Person Property Icon:** Displays an icon indicating that the filter is based on a person property.\n*   **Cohort Filter Icon:** Displays an icon indicating that the filter is based on a cohort.\n*   **Group Filter Icon:** Displays an icon indicating that the filter is based on a group.\n*   **Tooltips:** Provides descriptive tooltips for each icon to clarify the filter type.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyFilters/components/FilterRow.tsx",
        "summary": "The `FilterRow` component is a key part of the property filtering system, providing a row in a list of filters with the ability to add, edit, and remove individual filters. It uses a popover to display the filter editing interface, or a simpler inline display when popovers are disabled. The component handles the logic for displaying existing filters as buttons, or a button to add a new filter. It also manages the visibility of the filter editing interface and triggers the removal of filters.\n\nHere's a list of high-level features provided by the `FilterRow` component:\n\n*   **Adding Filters:** Allows users to add new filters via a button that opens a popover with filter options.\n*   **Editing Filters:** Enables users to modify existing filters by clicking on a filter button, opening a popover with editing controls.\n*   **Removing Filters:** Provides a button to remove individual filters from the list.\n*   **Popover or Inline Display:** Supports displaying the filter editing interface either in a popover or directly inline.\n*   **Visual Indicators:** Displays visual cues such as condition badges and error messages.\n*   **Disabling Filters:** Supports disabling filters and displaying a reason for the disabled state.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyFilters/types.ts",
        "summary": "This code defines the types and interfaces for the Property Filters component in the PostHog frontend. It outlines the props required for different levels of the filter logic, including base properties, property groups, and taxonomic filters. These interfaces manage the state and behavior of the property filters, enabling users to define complex filtering criteria based on various properties and taxonomic groups.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Property Filtering:** Allows users to filter data based on specific properties.\n*   **Taxonomic Filtering:** Enables filtering based on predefined taxonomic groups and values.\n*   **Logical Grouping of Filters:** Supports grouping filters with logical operators (e.g., AND, OR).\n*   **Dynamic Filter Updates:** Provides mechanisms for real-time updates and changes to the filter configuration.\n*   **Schema Awareness:** Integrates with a database schema to provide relevant property options.\n*   **Customizable Filter Options:** Allows customization of filter options based on property types and configurations.\n*   **Exclusion and Inclusion Lists:** Supports defining lists of properties to exclude or include in the filter options.\n*   **Event Name Filtering:** Allows filtering based on specific event names.\n*   **Relative Date Filtering:** Supports filtering based on relative date ranges.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyFilters/components/PropertyFilterButton.tsx",
        "summary": "This React component, `PropertyFilterButton`, renders a button representing a property filter. It displays an icon corresponding to the filter type, a truncated label for the filter, and a close button if the filter is removable. The button can be clickable, triggering a provided `onClick` handler, or disabled with a tooltip explaining the reason. The component utilizes various utility functions and models to format the filter label and property values, and it leverages Lemon UI components for styling and interaction.\n\nHere's a list of high-level features:\n\n*   **Property Filter Representation:** Displays a visual representation of a property filter, including an icon and label.\n*   **Clickable/Non-Clickable Behavior:** Supports both clickable and non-clickable states, triggering an action when clicked.\n*   **Closable Filters:** Allows for the removal of filters via a close button.\n*   **Disabled State with Tooltip:** Indicates when a filter is disabled and provides a reason via a tooltip.\n*   **Dynamic Label Formatting:** Formats the filter label based on the property type and value, using data from cohorts and property definitions.\n*   **Label Truncation:** Truncates long labels to fit within the button.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyFilters/components/OperatorValueSelect.tsx",
        "summary": "This code defines a React component called `OperatorValueSelect` that allows users to select an operator and a value for filtering properties. It dynamically adjusts the available operators based on the property type and handles validation of the input value based on the selected operator. The component uses LemonSelect for the operator selection and a PropertyValue component for inputting the value. It also displays validation errors if the entered value is invalid for the selected operator.\n\nHere's a list of high-level product features:\n\n*   **Dynamic Operator Selection:** Adapts the list of available operators based on the selected property type (e.g., string, number, date).\n*   **Value Input:** Provides a field for users to input a value relevant to the selected operator and property.\n*   **Real-time Validation:** Validates the entered value against the selected operator (e.g., regex validation, numeric range validation).\n*   **Error Handling:** Displays user-friendly error messages when the entered value is invalid.\n*   **Cohort and Flag Support:** Handles specific operators and value inputs for cohort and flag properties.\n*   **Date and Time Handling:** Provides specific operators and validation for date and time properties.\n*   **Mobile Optimization:** Adjusts the component's behavior for mobile devices (e.g., disabling autofocus).\n*   **Relative Date Time Options:** Adds relative date time options for date time properties.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyFilters/components/taxonomicPropertyFilterLogic.ts",
        "summary": "This code defines a Kea logic module called `taxonomicPropertyFilterLogic` that manages the state and behavior of a taxonomic property filter component. It connects to other Kea logics, including `taxonomicFilterLogic` and `propertyDefinitionsModel`, to fetch taxonomic groups and property descriptions. The logic handles user interactions such as selecting items from the taxonomic filter, opening and closing the dropdown, and updating the filter state. It also manages the active taxonomic group based on the current filter. When an item is selected, it creates or updates a property filter based on the selected item's properties and type, and then calls a `setFilter` function passed as a prop to update the filter in the parent component.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Taxonomic Property Filtering:** Allows users to filter data based on properties organized in a taxonomic structure (e.g., categories, groups).\n*   **Dynamic Filter Creation/Update:** Automatically creates or updates property filters based on user selections from the taxonomic filter.\n*   **Integration with Property Definitions:** Leverages property definitions to provide context and validation for filter values.\n*   **Dropdown Management:** Controls the visibility of the taxonomic filter dropdown.\n*   **Cohort Filtering:** Supports filtering based on cohort membership, including displaying cohort names.\n*   **Event Metadata Filtering:** Supports filtering based on event metadata, including displaying labels for group properties.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyFilters/utils.ts",
        "summary": "This code provides utility functions for handling property filters in a PostHog application. It includes functions for converting between different property filter representations (e.g., property groups to arrays), formatting property labels for display, sanitizing filter inputs, parsing properties from various input formats, and validating property filters. Additionally, it defines mappings between property filter types and taxonomic filter group types, enabling the categorization and display of filters in a user-friendly manner. The code also includes functions to determine the type of a property filter and to match filters against event definitions.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Property Filtering:** Allows users to filter data based on various properties of events, people, groups, sessions, and more.\n*   **Filter Grouping:** Supports grouping filters using logical operators (AND/OR) for complex filtering scenarios.\n*   **Taxonomic Categorization:** Categorizes filters into taxonomic groups (e.g., Event Properties, Person Properties) for better organization and discoverability.\n*   **User-Friendly Labels:** Formats property labels in a human-readable way, including cohort names and operator descriptions.\n*   **Input Sanitization:** Sanitizes user input to ensure valid property filters.\n*   **Property Parsing:** Parses properties from different input formats, including old-style dictionaries.\n*   **Filter Validation:** Validates property filters to ensure they are properly configured.\n*   **Filter Type Detection:** Detects the type of a property filter (e.g., Event, Person, Cohort).\n*   **Event Definition Matching:** Matches filters against event definitions to determine if a filter applies to a specific event.\n*   **Breakdown Filtering:** Supports breakdown filtering based on various properties.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyFilters/components/PropertyValue.tsx",
        "summary": "The `PropertyValue` component provides a dynamic input field for property values within a property filter, adapting its behavior based on the property's type and the selected operator. It supports various input methods, including date pickers, duration pickers, and single/multi-select dropdowns with search functionality. The component fetches and displays suggested values, formats them for display, and handles user input to update the property value in the parent filter. It leverages the `propertyDefinitionsModel` to load property values and format them based on the property definition.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Dynamic Input Type:** Adapts the input field based on the property type (date, duration, string, etc.) and operator (equals, contains, etc.).\n*   **Date and Time Input:** Provides a date picker component for date-based properties, with support for relative date ranges (e.g., \"Last 7 days\").\n*   **Duration Input:** Offers a duration picker component for specifying durations.\n*   **Single/Multi-Select Dropdown:** Implements a dropdown for selecting property values, supporting both single and multiple selections.\n*   **Searchable Options:** Allows users to search for property values within the dropdown.\n*   **Suggested Values:** Fetches and displays suggested values for properties, improving user experience and data accuracy.\n*   **Custom Value Input:** Allows users to enter custom values if the property configuration allows it.\n*   **Value Formatting:** Formats property values for display, ensuring consistency and readability.\n*   **Loading State:** Indicates when property values are being loaded.\n*   **Accessibility:** Includes accessibility features such as titles and labels for screen readers.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyFilters/components/TaxonomicPropertyFilter.tsx",
        "summary": "This code defines a `TaxonomicPropertyFilter` component in a React application, likely for a product analytics platform. This component allows users to create and modify filters based on various properties (event, person, cohort, etc.) with a taxonomic search and selection interface. It integrates with a dropdown for property selection, an operator value selector for defining filter conditions, and utilizes Kea logic for state management. The component supports different filter types, operators, and display configurations based on the context in which it is used.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Taxonomic Property Filtering:** Allows users to filter data based on a variety of properties, organized taxonomically.\n*   **Property Type Support:** Supports filtering by event properties, person properties, cohorts, feature flags, elements, and HogQL expressions.\n*   **Operator Selection:** Provides a selection of operators (equals, contains, etc.) for defining filter conditions.\n*   **Value Input:** Allows users to input values for the selected property and operator.\n*   **Dynamic Dropdown Interface:** Uses a dropdown interface for selecting properties and defining filter conditions.\n*   **Contextual Display:** Adapts its display based on the context (e.g., inline search, dropdown mode, operator placement).\n*   **Logical Grouping:** Supports logical grouping of filters with \"AND\" or \"OR\" operators.\n*   **Property Information Display:** Displays information about the selected property, such as its name and type.\n*   **Cohort Filtering:** Supports filtering based on cohort membership.\n*   **Metadata Source:** Allows specifying a metadata source for properties.\n*   **Property Allow/Exclude Lists:** Supports restricting the available properties via allow and exclude lists.\n*   **Relative Date Options:** Allows the use of relative date options in filter values.\n*   **HogQL Expression Support:** Allows filtering based on HogQL expressions."
    },
    {
        "path": "frontend/src/lib/components/PropertyFilters/components",
        "summary": "The code collectively implements a comprehensive property filtering system, enabling users to create and manage complex filters based on various data types and criteria. The system provides a user-friendly interface with dynamic input fields, dropdowns, and date pickers, adapting to the specific property type and selected operator. It supports taxonomic filtering, cohort selection, and even HogQL expressions, offering a flexible and powerful way to refine data analysis.\n\nHere's a list of high-level product features:\n\n*   **Property Filtering:** Allows users to filter data based on various properties (event, person, cohort, etc.).\n*   **Taxonomic Filtering:** Enables filtering based on properties organized in a taxonomic structure.\n*   **Dynamic Input Fields:** Adapts the input method based on the property type and selected operator.\n*   **Operator Selection:** Provides a selection of operators (equals, contains, etc.) for defining filter conditions.\n*   **Date and Time Selection:** Allows users to select specific dates and times for filtering.\n*   **Cohort Filtering:** Supports filtering based on cohort membership.\n*   **HogQL Expression Support:** Enables filtering based on HogQL expressions.\n*   **Filter Management:** Provides the ability to add, edit, and remove individual filters.\n*   **Visual Representation of Filters:** Displays active filters as interactive buttons.\n*   **Logical Grouping:** Supports logical grouping of filters with \"AND\" or \"OR\" operators.\n*   **Real-time Validation:** Validates the entered value against the selected operator.\n*   **Tooltips:** Provides descriptive tooltips for icons and disabled filters.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyFilters/PathItemFilters.tsx",
        "summary": "This code defines a `PathItemFilters` component in a React application, likely for a product analytics platform. It allows users to define filters based on path items (likely representing user navigation or event sequences). The component dynamically renders a list of `PathItemSelector` components, each representing a filter. Users can add new filters, select path items for each filter, and remove existing filters. The component uses Kea logic for state management and interacts with a `propertyFilterLogic` to handle filter updates.\n\nHere's a list of high-level features provided by the `PathItemFilters` component:\n\n*   **Add Path Item Filters:** Allows users to add new filters to refine data based on path items.\n*   **Select Path Items:** Enables users to choose specific path items for each filter using a selector component.\n*   **Remove Path Item Filters:** Provides a way to remove existing filters from the list.\n*   **Dynamic Filter List:** Renders a dynamic list of filters, allowing users to add and remove filters as needed.\n*   **Visual Representation of Filters:** Displays selected path items as buttons with a close option for easy management.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyFilters/propertyFilterLogic.ts",
        "summary": "This code defines a Kea logic module named `propertyFilterLogic` that manages a list of property filters. It provides functionality for updating, setting, and removing individual filters, as well as managing the overall list of filters. The logic also includes selectors for retrieving filled filters and ensuring a new empty filter is added to the list when needed. The logic is initialized with optional property filters and calls a callback function `onChange` with the cleaned filters when the filters are updated.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Property Filter Management:** Allows users to manage a list of property filters.\n*   **Filter Creation:** Enables users to add new property filters to the list.\n*   **Filter Editing:** Allows users to modify existing property filters.\n*   **Filter Removal:** Enables users to remove property filters from the list.\n*   **Filter Validation:** Ensures that only valid property filters are included in the final list.\n*   **Real-time Updates:** Notifies the parent component of changes to the filters through a callback function.\n*   **HogQL Support:** Supports HogQL property filters.\n"
    },
    {
        "path": "frontend/src/lib/components/PropertyFilters/PropertyFilters.tsx",
        "summary": "The `PropertyFilters` component provides a flexible and reusable interface for constructing and managing property-based filters. It leverages the `kea` library for state management and logic separation, allowing for dynamic updates and interactions with the filter set. The component renders a list of `FilterRow` components, each containing a `TaxonomicPropertyFilter` for selecting property values based on a taxonomic structure. It supports various customization options, including disabling the popover, specifying taxonomic group types, providing metadata sources, and handling logical row dividers.\n\nHere's a list of high-level product features provided by the `PropertyFilters` component:\n\n*   **Dynamic Filter Management:** Allows adding, removing, and modifying property filters.\n*   **Taxonomic Property Selection:** Uses a taxonomic structure to guide property selection.\n*   **Customizable Filter Display:** Supports various display options, including nested arrows, condition badges, and logical row dividers.\n*   **Popover Control:** Enables or disables the popover for filter interaction.\n*   **Metadata Integration:** Integrates with metadata sources for enhanced property selection.\n*   **Event and Schema Awareness:** Supports filtering based on event names and schema columns.\n*   **Logical Grouping:** Supports logical grouping of filters with AND/OR operators.\n*   **Error Handling:** Displays error messages for individual filters.\n*   **Controlled Opening:** Allows opening the filter on insert.\n*   **Property Allow/Exclude Lists:** Allows for defining which properties are available for filtering.\n*   **Relative Date Options:** Allows for relative date options in the filter.\n*   **Disable Reason:** Allows for disabling the filter with a reason.\n*   **Behavioral Cohort Hiding:** Allows for hiding behavioral cohorts in the filter."
    },
    {
        "path": "frontend/src/lib/components/PropertyFilters",
        "summary": "The code collectively implements a comprehensive and customizable property filtering system for a product analytics platform, enabling users to create and manage complex filters based on various data types, criteria, and taxonomic structures. The system offers a user-friendly interface with dynamic input fields, dropdowns, and date pickers, adapting to the specific property type and selected operator. It supports taxonomic filtering, cohort selection, HogQL expressions, and logical grouping of filters, offering a flexible and powerful way to refine data analysis and gain deeper insights.\n\nHere's a list of high-level product features:\n\n*   **Property Filtering:** Allows users to filter data based on various properties (event, person, cohort, path items, etc.).\n*   **Taxonomic Filtering:** Enables filtering based on properties organized in a taxonomic structure.\n*   **Dynamic Input Fields:** Adapts the input method based on the property type and selected operator.\n*   **Operator Selection:** Provides a selection of operators (equals, contains, etc.) for defining filter conditions.\n*   **Date and Time Selection:** Allows users to select specific dates and times for filtering, including relative date ranges.\n*   **Cohort Filtering:** Supports filtering based on cohort membership.\n*   **HogQL Expression Support:** Enables filtering based on HogQL expressions.\n*   **Filter Management:** Provides the ability to add, edit, and remove individual filters.\n*   **Visual Representation of Filters:** Displays active filters as interactive elements.\n*   **Logical Grouping:** Supports logical grouping of filters with \"AND\" or \"OR\" operators.\n*   **Real-time Validation:** Validates the entered value against the selected operator.\n*   **Customizable Filter Display:** Supports various display options and customization.\n*   **Metadata Integration:** Integrates with metadata sources for enhanced property selection.\n*   **Event and Schema Awareness:** Supports filtering based on event names and schema columns.\n*   **Path Item Filtering:** Allows users to filter data based on user navigation or event sequences.\n"
    },
    {
        "path": "frontend/src/lib/components/TaxonomicFilter/TaxonomicFilterEmptyState.tsx",
        "summary": "The `TaxonomicFilterEmptyState` component in PostHog's frontend provides empty state views for different taxonomic filter groups, specifically focusing on guiding users to connect external data via data warehouses. When a filter group like `DataWarehouse` is empty, it displays a message prompting the user to create a new data source, along with a link to relevant documentation. It also tracks product intent for cross-selling purposes, specifically between Product Analytics and Data Warehouse features.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Empty State Messaging:** Displays informative messages when a taxonomic filter group is empty, guiding users on the next steps.\n*   **Data Warehouse Integration Onboarding:** Provides a specific empty state for data warehouse connections, encouraging users to import external data.\n*   **Cross-Sell Product Intent Tracking:** Tracks user interactions with the empty state to identify potential cross-selling opportunities between Product Analytics and Data Warehouse features.\n*   **Direct Navigation to Feature Creation:** Includes a button that directly navigates the user to the \"New Source\" creation page for data warehouses.\n*   **Documentation Links:** Provides easy access to relevant documentation for the specific filter group.\n"
    },
    {
        "path": "frontend/src/lib/components/TaxonomicFilter/infiniteListLogic.ts",
        "summary": "This code defines a Kea logic module called `infiniteListLogic` that manages the display and filtering of a potentially large list of items in a taxonomic filter component. It handles fetching items from a remote API, caching the results, and filtering them based on a search query. It also supports local filtering when the items are available locally. The logic manages the state of the list, including the currently selected item, the scroll index, and whether the list is expanded. It also handles swapping the search query for specific cases like URLs and emails.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Remote Data Fetching:** Fetches list items from a remote API endpoint, supporting pagination (offset and limit).\n*   **Local Data Handling:** Supports displaying and filtering items from a local data source.\n*   **Search and Filtering:** Filters list items based on a search query, both remotely and locally using Fuse.js for fuzzy searching.\n*   **Caching:** Caches API responses to improve performance and reduce unnecessary requests.\n*   **Virtualization:** Integrates with `react-virtualized` to efficiently render large lists.\n*   **Expandable Lists:** Supports expandable lists with a \"show more\" button to load additional items from a scoped endpoint.\n*   **Query Swapping:** Automatically swaps search queries for specific input types (e.g., URLs, emails) to improve search accuracy.\n*   **Item Selection:** Manages the currently selected item in the list.\n*   **Configuration:** Allows configuration of the API endpoint, excluded properties, and property allow lists.\n*   **Hiding Behavioral Cohorts:** Supports hiding behavioral cohorts in specific contexts.\n"
    },
    {
        "path": "frontend/src/lib/components/TaxonomicFilter/InfiniteSelectResults.tsx",
        "summary": "This component, `InfiniteSelectResults`, provides a UI for filtering and selecting items from a potentially large, categorized dataset. It displays categories as selectable tags (pills) and renders an infinite list of results for the active category. The component handles loading states, empty states, and custom rendering for specific categories. It adapts its layout (horizontal or vertical) based on the number of categories and provides a way to focus the input field when a category is selected.\n\nHere's a list of high-level product features:\n\n*   **Categorized Filtering:** Allows users to filter items based on predefined categories.\n*   **Infinite Scrolling:** Loads more results as the user scrolls, enabling efficient browsing of large datasets.\n*   **Customizable Rendering:** Supports custom components for rendering items within specific categories.\n*   **Loading and Empty States:** Provides visual feedback during data loading and when no results are found.\n*   **Adaptive Layout:** Dynamically adjusts the layout of categories (horizontal or vertical) based on the number of categories.\n*   **Category Selection:** Enables users to switch between categories to view corresponding results.\n*   **Focus Management:** Automatically focuses the input field when a category is selected for improved usability."
    },
    {
        "path": "frontend/src/lib/components/TaxonomicFilter/InlineHogQLEditor.tsx",
        "summary": "This code defines a component called `InlineHogQLEditor` which provides an inline SQL editor using the `HogQLEditor` component. It allows users to input and edit SQL expressions as part of a taxonomic filter. The component takes a value (TaxonomicFilterValue), an onChange handler, and a metadata source as props. It renders a title \"SQL expression\" and the HogQLEditor component, passing the value, onChange handler, metadata source, and submit text to it. Autofocus is disabled on the HogQLEditor, managed by the parent TaxonomicFilter.\n\n**Features:**\n\n*   **Inline SQL Expression Editing:** Allows users to directly input and modify SQL expressions within a taxonomic filter.\n*   **HogQLEditor Integration:** Leverages the `HogQLEditor` component for SQL editing functionality.\n*   **Value Persistence:** Stores and updates the SQL expression value.\n*   **Metadata Source Support:** Provides metadata to the SQL editor for autocompletion and validation.\n*   **Customizable Submit Text:** Dynamically changes the submit button text based on whether a value exists.\n*   **Controlled Focus:** Manages focus externally, preventing autofocus on component mount.\n"
    },
    {
        "path": "frontend/src/lib/components/TaxonomicFilter/taxonomicFilterLogic.tsx",
        "summary": "This code defines a Kea logic component called `taxonomicFilterLogic` that manages the state and behavior of a taxonomic filter. The filter is used to select items from various data sources, such as events, actions, data warehouse tables, properties, and more. It supports searching, tab-based navigation between different data source groups, and selection of items with associated metadata. The logic connects to other Kea logics and models to fetch data and manage state related to the current team, project, groups, data warehouse, property definitions, and more. It also handles mouse interactions and keyboard navigation within the filter.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Taxonomic Filtering:** Allows users to filter data based on a hierarchical taxonomy of data sources (events, actions, properties, etc.).\n*   **Searchable Data Sources:** Provides a search interface to quickly find specific items within each data source.\n*   **Tabbed Navigation:** Enables users to switch between different data source groups using tabs.\n*   **Data Source Integration:** Connects to various data sources, including PostHog events, actions, data warehouse tables, and more.\n*   **Metadata Display:** Displays metadata associated with selected items, providing additional context.\n*   **Keyboard Navigation:** Supports keyboard navigation for selecting items and switching between tabs.\n*   **Dynamic Data Loading:** Fetches data from APIs and models as needed, ensuring the filter is up-to-date.\n*   **Customizable Display:** Allows customization of the filter's appearance and behavior through props.\n*   **Scoped Filtering:** Allows filtering of properties based on selected events."
    },
    {
        "path": "frontend/src/lib/components/TaxonomicFilter/TaxonomicFilter.tsx",
        "summary": "The `TaxonomicFilter` component provides a flexible and searchable selection interface for various data types within PostHog, such as events, properties, and cohorts. It utilizes Kea logic for state management and offers features like keyboard navigation, tabbed categories, and customizable search. The component is designed to be reusable and adaptable to different contexts within the PostHog application, offering a consistent and efficient way to filter and select data.\n\nHere's a list of high-level product features:\n\n*   **Searchable Selection:** Allows users to search for specific items within a list of options.\n*   **Categorized Filtering (Tabs):** Organizes options into different categories (tabs) for easier navigation.\n*   **Keyboard Navigation:** Enables users to navigate and select options using the keyboard (arrow keys, tab, enter, escape).\n*   **Customizable Data Sources:** Supports various data sources, including events, properties, cohorts, and HogQL expressions.\n*   **Dynamic Placeholder Text:** Displays context-aware placeholder text in the search input.\n*   **Tooltip Help:** Provides helpful tooltips to guide users on keyboard navigation.\n*   **Configurable Display:** Allows customization of width, height, and other display properties.\n*   **Data Warehouse Integration:** Provides popover information related to data warehouse fields.\n*   **Vertical Layout Option:** Supports a vertical layout for the selection results.\n"
    },
    {
        "path": "frontend/src/lib/components/TaxonomicFilter/InfiniteList.tsx",
        "summary": "This code defines an `InfiniteList` component for displaying a scrollable list of items, primarily used within a taxonomic filter. It fetches data in chunks as the user scrolls, displaying items with relevant information like icons, names, and indicators for stale or unused data. The component supports highlighting selected items, displaying a \"show more\" button to load additional items, and rendering skeleton loaders while data is loading. It also integrates with a definition popover to show detailed information about selected items.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Infinite Scrolling:** Loads data dynamically as the user scrolls, allowing for efficient display of large datasets.\n*   **Taxonomic Filtering:** Integrates with a taxonomic filter to display categorized and filterable data.\n*   **Item Highlighting:** Highlights the currently selected or hovered item for improved user experience.\n*   **\"Show More\" Functionality:** Provides a button to load additional items when the list is not fully populated.\n*   **Loading Indicators:** Displays skeleton loaders while data is being fetched.\n*   **Stale/Unused Data Indicators:** Shows visual cues for items that are stale or not actively used.\n*   **Definition Popovers:** Integrates with a popover component to display detailed information about selected items.\n*   **Empty State Handling:** Displays a message when no results are found, with specific messaging for search queries.\n*   **Accessibility:** Uses tooltips and semantic HTML to improve accessibility."
    },
    {
        "path": "frontend/src/lib/components/TaxonomicFilter/types.ts",
        "summary": "This code defines the types and interfaces for a taxonomic filter component used in the PostHog frontend, primarily within the insights and data warehouse features. The component allows users to filter data based on various taxonomic groups like events, properties, actions, cohorts, and data warehouse tables. It supports searching, displaying, and selecting items from these groups, with customizable rendering, data fetching, and filtering options. The code also includes definitions for managing infinite lists of taxonomic definitions and integrating with Fuse.js for fuzzy searching.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Taxonomic Filtering:** Allows users to filter data based on a hierarchical taxonomy of event properties, user properties, actions, cohorts, and other data categories.\n*   **Data Exploration:** Enables users to explore and discover available data points within PostHog, such as event names, property keys, and cohort definitions.\n*   **Customizable Filtering:** Provides options to customize the filter's behavior, including specifying which taxonomic groups to display, excluding specific properties, and using custom rendering components.\n*   **Fuzzy Searching:** Supports fuzzy searching within taxonomic groups to quickly find relevant items.\n*   **Data Warehouse Integration:** Allows filtering based on data warehouse tables and properties.\n*   **Infinite Scrolling:** Supports loading large lists of taxonomic definitions with infinite scrolling.\n*   **HogQL Expression Support:** Enables users to filter using HogQL expressions.\n*   **Metadata Filtering:** Allows filtering based on event and user metadata.\n*   **Layout Customization:** Supports both horizontal and vertical layouts for taxonomic groups.\n"
    },
    {
        "path": "frontend/src/lib/components/TaxonomicFilter",
        "summary": "The provided code snippets collectively define a robust and versatile taxonomic filter component for PostHog, designed to facilitate data exploration and selection across various data sources. This component offers a searchable and categorized interface, allowing users to efficiently filter data based on events, properties, actions, cohorts, data warehouse tables, and more. It incorporates features like infinite scrolling, customizable rendering, keyboard navigation, and integration with external services like data warehouses, enhancing the user experience and enabling powerful data analysis workflows.\n\nHere's a list of high-level product features:\n\n*   Taxonomic Filtering: Enables users to filter data based on a hierarchical taxonomy of data sources.\n*   Searchable Data Sources: Provides a search interface to quickly find specific items within each data source.\n*   Categorized Filtering (Tabs/Pills): Organizes options into different categories for easier navigation.\n*   Infinite Scrolling: Loads data dynamically as the user scrolls, allowing for efficient display of large datasets.\n*   Data Warehouse Integration: Allows users to connect and filter data from external data warehouses.\n*   Inline SQL Editing: Enables users to directly input and modify SQL expressions within the filter.\n*   Keyboard Navigation: Enables users to navigate and select options using the keyboard.\n*   Customizable Display: Allows customization of the filter's appearance and behavior.\n*   Empty State Messaging: Guides users on how to connect data sources when a filter group is empty.\n*   Metadata Display: Displays metadata associated with selected items, providing additional context.\n"
    },
    {
        "path": "frontend/src/lib/components/CodeSnippet/index.ts",
        "summary": "The code snippet defines and exports a `CodeSnippet` component and a `Language` type/enum from the `./CodeSnippet` file. This suggests the existence of a component designed to display code snippets, likely with syntax highlighting and language support.\n\n**Features:**\n\n*   **Code Snippet Display:** Renders code snippets in a visually appealing and readable format.\n*   **Syntax Highlighting:** Highlights code syntax based on the specified programming language.\n*   **Language Support:** Supports various programming languages for syntax highlighting.\n"
    },
    {
        "path": "frontend/src/lib/components/CodeSnippet/theme.ts",
        "summary": "This code defines two themes, light and dark, for syntax highlighting in a code snippet component. Each theme specifies the colors for different elements of code, such as comments, punctuation, tags, keywords, strings, numbers, and operators. It also includes styling for bold and italic text.\n\nHere's a list of high-level product features related to this code:\n\n*   **Syntax Highlighting:** Automatically applies colors and styles to code based on its syntax, improving readability.\n*   **Light Theme:** Offers a light color scheme for code snippets, suitable for bright environments.\n*   **Dark Theme:** Provides a dark color scheme for code snippets, ideal for low-light environments or user preference.\n*   **Customizable Code Styling:** Allows customization of the appearance of different code elements (e.g., comments, keywords, strings) through theme configuration.\n*   **Theming Support:** Enables switching between different themes to suit user preferences or environmental conditions.\n"
    },
    {
        "path": "frontend/src/lib/components/CodeSnippet/CodeSnippet.tsx",
        "summary": "This code defines a `CodeSnippet` component for displaying syntax-highlighted code. It supports various languages, including JavaScript, Python, Java, and others, using the `react-syntax-highlighter` library. The component provides features like copying the code to the clipboard, word wrapping, and expanding/collapsing the code snippet if it exceeds a certain number of lines. It also adapts to the application's dark/light theme.\n\nHere's a list of high-level product features:\n\n*   **Syntax Highlighting:** Displays code with syntax highlighting for various languages.\n*   **Language Support:** Supports a wide range of programming languages.\n*   **Copy to Clipboard:** Allows users to easily copy the code snippet to their clipboard.\n*   **Word Wrapping:** Provides an option to wrap long lines of code.\n*   **Expand/Collapse:** Enables users to expand or collapse long code snippets for better readability.\n*   **Theme Integration:** Adapts to the application's dark or light theme.\n*   **Compact Mode:** Offers a compact display mode for smaller code snippets.\n*   **Custom Actions:** Supports adding custom actions/buttons to the code snippet component."
    },
    {
        "path": "frontend/src/lib/components/CodeSnippet",
        "summary": "The `CodeSnippet` component provides a user-friendly way to display and interact with code snippets within the application. It offers syntax highlighting for various programming languages, allowing users to easily read and understand code. The component also includes features like copy-to-clipboard functionality, word wrapping, and expand/collapse options for long snippets, enhancing usability. Furthermore, it seamlessly integrates with the application's theme, offering both light and dark modes for optimal viewing in different environments, and supports custom actions.\n\nHere's a list of high-level product features:\n\n*   Syntax Highlighting: Displays code with syntax highlighting for various languages.\n*   Language Support: Supports a wide range of programming languages.\n*   Copy to Clipboard: Allows users to easily copy the code snippet to their clipboard.\n*   Word Wrapping: Provides an option to wrap long lines of code.\n*   Expand/Collapse: Enables users to expand or collapse long code snippets for better readability.\n*   Theme Integration: Adapts to the application's dark or light theme.\n*   Customizable Code Styling: Allows customization of the appearance of different code elements.\n*   Custom Actions: Supports adding custom actions/buttons to the code snippet component.\n"
    },
    {
        "path": "frontend/src/lib/components/Hogfetti/Hogfetti.tsx",
        "summary": "This code defines a `useHogfetti` hook that provides a way to trigger a confetti-like animation using various hedgehog images. The hook manages the state of the particles, their movement, and their eventual fade-out. It returns a `trigger` function to initiate the animation and a `HogfettiComponent` which renders the animated hedgehogs on the screen. The animation is customizable with options for the number of hedgehogs, the power of their initial velocity, the duration of the animation, and the maximum size of the hedgehogs.\n\nHere's a list of high-level product features:\n\n*   **Hogfetti Animation:** Display an animated burst of hedgehog images on the screen.\n*   **Customizable Animation:** Control the number of hedgehogs, their speed, animation duration, and size.\n*   **Variety of Hedgehog Images:** Use a predefined set of hedgehog images for the animation.\n*   **Trigger Function:** Programmatically trigger the animation.\n*   **Component Rendering:** Render the animation as a React component.\n*   **Gravity and Air Resistance:** Simulate realistic particle movement with gravity and air resistance effects.\n*   **Opacity Fade-Out:** Gradually fade out the hedgehogs during the animation.\n*   **Responsive Design:** Adapt the animation to different screen sizes.\n"
    },
    {
        "path": "frontend/src/lib/components/Hogfetti",
        "summary": "The `useHogfetti` hook provides a simple way to add a fun, customizable confetti-like animation to a React application using hedgehog images. It manages the animation state, particle movement, and rendering, offering control over the number of hedgehogs, their velocity, animation duration, and size, while simulating realistic physics with gravity and air resistance. The animation is triggered programmatically and rendered as a React component with a fade-out effect.\n\nHere's a list of high-level product features:\n\n*   **Hogfetti Animation:** Display an animated burst of hedgehog images on the screen.\n*   **Customizable Animation:** Control the number of hedgehogs, their speed, animation duration, and size.\n*   **Variety of Hedgehog Images:** Use a predefined set of hedgehog images for the animation.\n*   **Trigger Function:** Programmatically trigger the animation.\n*   **Component Rendering:** Render the animation as a React component.\n*   **Gravity and Air Resistance:** Simulate realistic particle movement with gravity and air resistance effects.\n*   **Opacity Fade-Out:** Gradually fade out the hedgehogs during the animation.\n*   **Responsive Design:** Adapt the animation to different screen sizes.\n"
    },
    {
        "path": "frontend/src/lib/components/SmoothingFilter/SmoothingFilter.tsx",
        "summary": "The `SmoothingFilter` component is a UI element that allows users to apply smoothing to trend insights in PostHog. It dynamically renders a LemonSelect dropdown based on the selected interval and available smoothing options. The component uses kea-based logic to access and update insight filters, specifically the `smoothingIntervals` property. The dropdown options are populated based on the current interval, and the selected option is indicated with an icon. The component is only rendered when the insight is a trend and an interval is selected.\n\nHere's a list of high-level product features provided by this component:\n\n*   **Trend Smoothing:** Applies a smoothing algorithm to trend insights for clearer visualization.\n*   **Interval-Based Smoothing Options:** Provides different smoothing options based on the selected time interval.\n*   **Real-time Filter Updates:** Updates the insight filter with the selected smoothing interval.\n*   **Visual Indication of Selection:** Displays an icon next to the currently selected smoothing option in the dropdown.\n*   **Dynamic Option Rendering:** Only renders smoothing options applicable to the current interval.\n"
    },
    {
        "path": "frontend/src/lib/components/SmoothingFilter/smoothings.ts",
        "summary": "This code defines the available smoothing options for different interval types (minute, hour, day, week, and month). It exports a `smoothingOptions` object that maps each interval type to an array of smoothing options, where each option has a label and a value representing the smoothing factor. The smoothing options include \"No smoothing\" and various averaging periods (e.g., 5-minute, 24-hour, 7-day, 28-day averages).\n\nHere's a list of high-level product features based on this code:\n\n*   **Data Smoothing:** Allows users to smooth data displayed in charts or reports.\n*   **Interval-Based Smoothing:** Provides different smoothing options based on the selected time interval (minute, hour, day).\n*   **Averaging:** Implements smoothing by averaging data points over specified periods.\n*   **No Smoothing Option:** Gives users the option to disable smoothing and view raw data.\n*   **Configurable Smoothing Intervals:** Defines specific averaging periods (e.g., 5-minute, 24-hour, 7-day, 28-day) for smoothing.\n"
    },
    {
        "path": "frontend/src/lib/components/SmoothingFilter",
        "summary": "The code implements a smoothing filter for trend insights, allowing users to apply different levels of smoothing to data displayed in charts. The filter dynamically adjusts available smoothing options based on the selected time interval (minute, hour, day, week, month) and provides a clear visual indication of the selected smoothing level. Users can choose from various averaging periods or disable smoothing entirely to view raw data.\n\nHere's a list of high-level product features:\n\n*   Data Smoothing for Trend Insights\n*   Interval-Based Smoothing Options\n*   Configurable Smoothing Intervals (e.g., 5-minute, 24-hour, 7-day averages)\n*   No Smoothing Option\n*   Real-time Filter Updates\n*   Visual Indication of Selection\n*   Dynamic Option Rendering\n"
    },
    {
        "path": "frontend/src/lib/components/DefinitionPopover/utils.ts",
        "summary": "This code provides utility functions for converting operators, property values, and taxonomic filter types into human-readable strings. These functions are primarily used for displaying information in the DefinitionPopover component, making it easier for users to understand the meaning of different filters and properties. The code handles various cases, including different operators (e.g., \"gte\", \"lte\", \"in\"), empty string values, and taxonomic filter group types (e.g., actions, cohorts, events, properties).\n\nHere's a list of high-level product features that utilize this code:\n\n*   **Human-readable filter descriptions:** Displaying filter criteria in a user-friendly format within the DefinitionPopover.\n*   **Dynamic operator labels:** Converting operators like \"gte\" or \"lte\" into more understandable phrases like \"at least\" or \"at most\".\n*   **Property value interpretation:** Presenting property values in a clear way, including special handling for empty strings.\n*   **Taxonomic filter type clarification:** Translating internal filter types (e.g., `TaxonomicFilterGroupType.Actions`) into user-facing labels (e.g., \"action\").\n*   **Cohort matching descriptions:** Displaying cohort matching criteria in a user-friendly format.\n"
    },
    {
        "path": "frontend/src/lib/components/DefinitionPopover/CohortPopoverInfo.tsx",
        "summary": "The `CohortPopoverInfo` component displays detailed information about a cohort's definition within a popover. It parses and presents the cohort's filter criteria, including both behavioral criteria (e.g., \"performed event X more than Y times\") and property-based criteria (e.g., \"has property Z equal to W\"). The component handles different types of criteria groups (AND/OR logic) and limits the number of criteria and groups displayed for brevity, with options to indicate the presence of additional hidden criteria. It leverages other components like `PropertyKeyInfo` to display property keys and values in a user-friendly manner and uses helper functions to translate operators and values into human-readable strings.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Cohort Definition Display:** Shows a summary of how a cohort is defined.\n*   **Behavioral Criteria Support:** Displays criteria based on user behavior (e.g., event counts).\n*   **Property-Based Criteria Support:** Displays criteria based on user properties.\n*   **AND/OR Logic Handling:** Visualizes the logical relationships between different criteria groups.\n*   **Concise Display with Expansion:** Limits the number of displayed criteria and groups, with indicators for hidden items.\n*   **Human-Readable Descriptions:** Translates technical criteria into user-friendly sentences.\n*   **Property Key Information:** Displays property keys with their associated types.\n"
    },
    {
        "path": "frontend/src/lib/components/DefinitionPopover/DefinitionPopover.tsx",
        "summary": "The `DefinitionPopover` component provides a structured way to display detailed information about data definitions within the PostHog application. It offers a consistent UI for viewing and editing descriptions, examples, and metadata associated with various data types like events, properties, and feature flags. The component includes features for displaying creation and modification timestamps, user attribution, and links to view full details or edit the definition. It leverages Lemon UI components for styling and layout, and integrates with the eventUsageLogic to track user interactions with the definitions.\n\nHere's a list of high-level product features provided by the `DefinitionPopover` component:\n\n*   **Display Data Definition Details:** Shows the title, description, and examples for a given data definition (e.g., event, property).\n*   **Edit Data Definitions:** Allows users to edit the description of a data definition.\n*   **View Full Details:** Provides a link to view the full details of a data definition in a separate page or tab.\n*   **Display Creation/Modification Metadata:** Shows when the definition was created or last modified, and by whom.\n*   **User Attribution:** Displays the user who created or last modified the definition, including their profile picture.\n*   **Structured Layout:** Uses a grid-based layout to organize definition details into sections and cards.\n*   **Markdown Support:** Renders descriptions using Markdown for rich text formatting.\n*   **Example Display:** Shows example values for the data definition.\n*   **Tracking User Interactions:** Tracks user clicks on \"Edit\" and \"View\" actions for data management definitions.\n"
    },
    {
        "path": "frontend/src/lib/components/DefinitionPopover/DefinitionPopoverContents.tsx",
        "summary": "This code defines the `DefinitionPopoverContents` component, which is responsible for displaying detailed information about various PostHog entities like events, actions, properties, and cohorts within a popover. It leverages the `definitionPopoverLogic` and `taxonomicFilterLogic` to manage the state and interactions within the popover. The component dynamically renders different views based on the type of entity being displayed, showing relevant metadata, descriptions, examples, and related information. It also includes features for verifying and hiding properties, displaying tags, and showing creation/update timestamps.\n\nHere's a list of high-level product features implemented by this code:\n\n*   **Detailed Entity Information Display:** Shows comprehensive details for events, actions, properties, and cohorts.\n*   **Dynamic Content Rendering:** Adapts the displayed information based on the type of entity selected.\n*   **Property Verification and Hiding:** Allows users to verify or hide properties to prioritize or deprecate them.\n*   **Metadata Display:** Shows creation and update timestamps, authors, and tags.\n*   **Integration with Taxonomic Filters:** Connects with taxonomic filters to display and manage entity definitions.\n*   **Data Warehouse Integration:** Displays information about data warehouse tables and fields.\n*   **Actionable Information:** Provides links to edit or view the entity in more detail.\n*   **Cohort Statistics:** Displays the number of persons in a cohort and the last calculation time.\n*   **Customizable Definition Display:** Allows for local overrides of definitions.\n"
    },
    {
        "path": "frontend/src/lib/components/DefinitionPopover/definitionPopoverLogic.ts",
        "summary": "This code defines the logic for a Definition Popover component, which allows users to view and edit definitions of various PostHog entities like actions, events, properties, and cohorts. It manages the popover's state (view/edit), local and remote definitions, and saving/canceling changes. The logic handles API calls to update definitions, updates relevant models, and displays success/error messages. It also tracks user interactions for usage analysis.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **View Definition:** Display detailed information about actions, events, properties, and cohorts in a popover.\n*   **Edit Definition:** Allow users to modify the definitions of actions, events, properties, and cohorts.\n*   **Save Definition:** Persist changes made to definitions via API calls.\n*   **Cancel Definition Edit:** Discard changes made to definitions and revert to the original state.\n*   **Data Warehouse Table Configuration:** Pre-populate data warehouse table settings for insights, including ID, distinct ID, and timestamp fields.\n*   **Real-time Updates:** Update relevant models (actions, cohorts, property definitions) upon saving a definition.\n*   **Error Handling:** Display error messages for failed save attempts.\n*   **Usage Tracking:** Track user interactions (hover, save, cancel) for usage analysis.\n*   **Navigation to Full Detail:** Provide a link to view the full details of a definition in a separate tab.\n*   **State Management:** Manage the popover's state (view/edit) and local/remote definitions.\n"
    },
    {
        "path": "frontend/src/lib/components/DefinitionPopover/ActionPopoverInfo.tsx",
        "summary": "The `ActionPopoverInfo` component displays detailed information about an action, specifically its steps, within a `DefinitionPopover`. Each step represents a match group and includes details about the event, CSS selector, text, href, URL, and properties. The component iterates through the steps, displaying each one in a card format, and indicates the matching logic (equals, contains, regex) for text, href, and URL. It also shows the properties associated with each step, along with their operators and values. The component uses `PropertyKeyInfo` to display property keys and `genericOperatorToHumanName` and `propertyValueToHumanName` to display property operators and values in a human-readable format. \"OR\" separators are added between steps if there are multiple steps.\n\nHere's a list of high-level product features:\n\n*   **Action Definition Display:** Shows the definition of an action, including its individual steps.\n*   **Match Group Details:** Displays details for each match group within an action, including the event that triggers the group.\n*   **CSS Selector Matching:** Shows the CSS selector used for matching elements in a step.\n*   **Text Matching:** Displays the text matching criteria (equals, contains, regex) for a step.\n*   **Href Matching:** Displays the href matching criteria (equals, contains, regex) for a step.\n*   **URL Matching:** Displays the URL matching criteria (equals, contains, regex) for a step.\n*   **Property Matching:** Shows the properties used for matching in a step, including the key, operator, and value.\n*   **Human-Readable Formatting:** Formats property operators and values into a human-readable format.\n*   **Step Separation:** Visually separates multiple steps with an \"OR\" indicator.\n*   **Property Key Information:** Displays property keys with type information."
    },
    {
        "path": "frontend/src/lib/components/DefinitionPopover",
        "summary": "The Definition Popover component provides a comprehensive and user-friendly way to view, understand, and manage definitions of various entities within PostHog, such as events, actions, properties, and cohorts. It offers detailed information, including descriptions, examples, metadata, and related criteria, presented in a structured and human-readable format. Users can also edit definitions, with changes persisted via API calls and reflected in real-time updates across the application, while user interactions are tracked for usage analysis and improvements.\n\nHere's a list of high-level product features:\n\n*   **Detailed Entity Information Display:** Shows comprehensive details for events, actions, properties, and cohorts, including descriptions, examples, and metadata.\n*   **Edit Data Definitions:** Allows users to modify the definitions of various entities.\n*   **Action Definition Display:** Shows the definition of an action, including its individual steps and matching criteria.\n*   **Cohort Definition Display:** Shows a summary of how a cohort is defined, including behavioral and property-based criteria.\n*   **Human-Readable Descriptions:** Translates technical criteria and operators into user-friendly sentences and labels.\n*   **Dynamic Content Rendering:** Adapts the displayed information based on the type of entity selected.\n*   **Property Verification and Hiding:** Allows users to verify or hide properties to prioritize or deprecate them.\n*   **Data Warehouse Integration:** Displays information about data warehouse tables and fields.\n*   **Real-time Updates:** Updates relevant models upon saving a definition.\n*   **Usage Tracking:** Tracks user interactions for usage analysis.\n"
    },
    {
        "path": "frontend/src/lib/components/TimelineSeekbar/index.ts",
        "summary": "The code exports the `TimelineSeekbar` component, making it available for use in other parts of the application. This suggests the existence of a visual component that allows users to navigate and control a timeline.\n\n**Features:**\n\n*   **Timeline Navigation:** Enables users to move through a timeline.\n*   **Seek Functionality:** Allows users to jump to specific points in the timeline.\n*   **Visual Representation:** Provides a visual interface for interacting with the timeline.\n"
    },
    {
        "path": "frontend/src/lib/components/SignupReferralSource.tsx",
        "summary": "This React component provides a user interface element for capturing the referral source during the signup process. It utilizes LemonInput and LemonField components from the Lemon UI library to render a text input field with a label \"Where did you hear about us?\". The input field is optional and can be disabled based on the `disabled` prop. The component is designed to be integrated into a signup form to collect information about how users discovered the product.\n\nHere's a list of high-level product features:\n\n*   **Referral Source Capture:** Allows capturing the source from which a user heard about the product during signup.\n*   **Optional Input:** The referral source field is optional, allowing users to skip it if they prefer.\n*   **Disable Input:** The referral source field can be disabled, likely for specific signup flows or user segments.\n*   **UI Integration:** Seamlessly integrates with the Lemon UI library for a consistent user experience.\n"
    },
    {
        "path": "frontend/src/lib/components/TimelineSeekbar/TimelineSeekbar.tsx",
        "summary": "The `TimelineSeekbar` component provides a visual representation of data points over time, allowing users to select a specific point in time to view the state of the data at that moment. It displays a timeline with points representing data snapshots, a note providing context, and the currently selected time. Users can interact with the timeline to select different points, triggering an update to the displayed data. The component also includes tooltips to provide detailed information about each data point and the overall time range.\n\nHere's a list of high-level product features:\n\n*   **Visual Timeline:** Displays data points along a timeline.\n*   **Point Selection:** Allows users to select a specific point in time on the timeline.\n*   **Data Snapshot:** Shows the state of the data at the selected point in time.\n*   **Tooltips:** Provides detailed information about each data point, including timestamp and event count.\n*   **Time Range Display:** Indicates the start and end of the data range.\n*   **Loading Indicator:** Displays a loading spinner while data is being fetched.\n*   **Current Time Display:** Shows the currently selected time.\n*   **Note/Contextual Information:** Displays a note to provide context about the timeline data.\n"
    },
    {
        "path": "frontend/src/lib/components/TimelineSeekbar",
        "summary": "The `TimelineSeekbar` component offers a user-friendly interface for navigating and exploring data points across a timeline. It visually represents data snapshots, enabling users to select specific points in time and view the corresponding data state. Tooltips provide detailed information about each data point, enhancing the user experience.\n\nHere's a list of high-level product features:\n\n*   Visual Timeline: Displays data points along a timeline.\n*   Point Selection: Allows users to select a specific point in time on the timeline.\n*   Data Snapshot: Shows the state of the data at the selected point in time.\n*   Tooltips: Provides detailed information about each data point, including timestamp and event count.\n*   Time Range Display: Indicates the start and end of the data range.\n*   Loading Indicator: Displays a loading spinner while data is being fetched.\n*   Current Time Display: Shows the currently selected time.\n*   Note/Contextual Information: Displays a note to provide context about the timeline data.\n*   Timeline Navigation: Enables users to move through a timeline.\n*   Seek Functionality: Allows users to jump to specific points in the timeline.\n"
    },
    {
        "path": "frontend/src/lib/components/AnnotationsOverlay/index.ts",
        "summary": "The code defines an index file that exports all components and logic related to the AnnotationsOverlay feature. This suggests the existence of a React component called `AnnotationsOverlay` and associated logic encapsulated in `annotationsOverlayLogic`. This feature likely provides a way to display and manage annotations on top of some other content.\n\n**Features:**\n\n*   **AnnotationsOverlay Component:** A React component for rendering annotations.\n*   **Annotations Overlay Logic:** Manages the state and behavior of the annotation overlay, including data fetching, updates, and user interactions.\n"
    },
    {
        "path": "frontend/src/lib/components/AnnotationsOverlay/useAnnotationsPositioning.ts",
        "summary": "This code defines a React hook, `useAnnotationsPositioning`, that calculates the pixel positions of ticks on the x-axis of a Chart.js chart. It determines the spacing between ticks (`tickIntervalPx`) and the position of the first tick (`firstTickLeftPx`) based on the chart's scales and data points. This information is crucial for accurately positioning annotations on the chart, ensuring they align with the data being visualized. The hook memoizes the calculations to optimize performance, recalculating only when the chart instance, width, or height changes.\n\nHere's a list of high-level product features that could utilize this code:\n\n*   **Data Point Annotations:** Allows users to add annotations (text, icons, etc.) directly to specific data points on a chart.\n*   **Event/Milestone Highlighting:** Enables the visual highlighting of significant events or milestones on a time-series chart.\n*   **Trend Line Labels:** Supports the labeling of trend lines or other chart overlays with relevant information.\n*   **Customizable Chart Overlays:** Provides a framework for adding custom graphical elements to charts, such as regions of interest or thresholds.\n"
    },
    {
        "path": "frontend/src/lib/components/AnnotationsOverlay/annotationsOverlayLogic.ts",
        "summary": "This code defines a Kea logic module called `annotationsOverlayLogic` that manages the display and interaction of annotations on a chart overlay within the PostHog application. It handles fetching, filtering, and grouping annotations based on the chart's date range, interval, and scope (insight or dashboard). The logic also manages the state of a popover that displays annotations for a selected date, including actions for activating, deactivating, locking, and unlocking the date selection. It connects to other logic modules like `insightLogic`, `insightVizDataLogic`, `annotationsModel`, and `teamLogic` to access necessary data and actions.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Annotation Display:** Display annotations on charts within insights and dashboards.\n*   **Annotation Filtering:** Filter annotations based on scope (insight, dashboard, global) and date range.\n*   **Annotation Grouping:** Group annotations by date for easier visualization.\n*   **Annotation Popover:** Show a popover with annotations for a specific date when selected.\n*   **Annotation Creation:** Allow users to create new annotations directly from the chart overlay.\n*   **Annotation Editing:** Allow users to edit existing annotations.\n*   **Annotation Deletion:** Allow users to delete annotations.\n*   **Date Locking:** Allow users to lock a date selection to prevent accidental changes.\n"
    },
    {
        "path": "frontend/src/lib/components/AnnotationsOverlay/AnnotationsOverlay.tsx",
        "summary": "This code implements an interactive annotation overlay for charts in PostHog. It allows users to create, view, edit, and delete annotations associated with specific data points on a chart. The overlay displays badges on the chart that indicate the presence of annotations for a given date or time period. Clicking on a badge opens a popover displaying the annotations for that period, with options to add new annotations or edit/delete existing ones. The component uses various Lemon UI components for styling and interactivity, and leverages kea-logic for state management.\n\nHere's a list of high-level product features:\n\n*   **Annotation Creation:** Allows users to create annotations for specific data points on a chart.\n*   **Annotation Viewing:** Displays existing annotations on the chart via badges and popovers.\n*   **Annotation Editing:** Enables users to modify existing annotations.\n*   **Annotation Deletion:** Allows users to remove annotations.\n*   **Date Locking:** Allows users to lock a date to prevent accidental changes to the selected date.\n*   **Visual Indication of Annotations:** Uses badges to visually represent the presence of annotations on the chart.\n*   **User Attribution:** Displays the creator and creation time of each annotation.\n*   **Git Annotation Support:** Supports annotations created automatically via Git commits.\n"
    },
    {
        "path": "frontend/src/lib/components/AnnotationsOverlay",
        "summary": "The provided code collectively implements a comprehensive annotation system for charts within the PostHog application. This system allows users to create, view, edit, and delete annotations directly on charts, enhancing data visualization and collaboration. The system features visual indicators for annotations, date locking, user attribution, and Git annotation support. The underlying logic manages data fetching, filtering, grouping, and positioning of annotations, ensuring accurate and interactive display.\n\nHere's a list of high-level product features:\n\n*   **Annotation Display:** Display annotations on charts within insights and dashboards.\n*   **Annotation Creation:** Allows users to create annotations for specific data points on a chart.\n*   **Annotation Viewing:** Displays existing annotations on the chart via badges and popovers.\n*   **Annotation Editing:** Enables users to modify existing annotations.\n*   **Annotation Deletion:** Allows users to remove annotations.\n*   **Annotation Filtering:** Filter annotations based on scope (insight, dashboard, global) and date range.\n*   **Annotation Grouping:** Group annotations by date for easier visualization.\n*   **Annotation Popover:** Show a popover with annotations for a specific date when selected.\n*   **Date Locking:** Allows users to lock a date to prevent accidental changes to the selected date.\n*   **Visual Indication of Annotations:** Uses badges to visually represent the presence of annotations on the chart.\n*   **User Attribution:** Displays the creator and creation time of each annotation.\n*   **Git Annotation Support:** Supports annotations created automatically via Git commits.\n*   **Data Point Annotations:** Allows users to add annotations (text, icons, etc.) directly to specific data points on a chart.\n*   **Event/Milestone Highlighting:** Enables the visual highlighting of significant events or milestones on a time-series chart.\n"
    },
    {
        "path": "frontend/src/lib/components/AccessDenied/index.tsx",
        "summary": "The `AccessDenied` component displays a message indicating that the user does not have access to a specific object. It includes an image, a heading, and a paragraph explaining the situation. The component also provides a link to open a support form, allowing users to report potential access issues.\n\nHere's a list of high-level product features:\n\n*   **Access Denied Display:** Shows a user-friendly message when access to a resource is restricted.\n*   **Contextual Object Mention:** Dynamically displays the type of object the user is trying to access.\n*   **Support Link:** Provides a direct link to a support form for reporting access issues.\n"
    },
    {
        "path": "frontend/src/lib/components/RestrictedArea.tsx",
        "summary": "The `RestrictedArea` component provides a mechanism to restrict access to certain areas of the application based on the user's membership level within either the current organization or the current project (environment). It uses the `organizationLogic` and `teamLogic` to determine the user's access level and compares it against a specified minimum access level. If the user's access level is insufficient, a restriction reason message is generated, explaining why the area is restricted. The `useRestrictedArea` hook encapsulates this logic, returning the restriction reason, which can then be used to conditionally render content or display a message.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Role-Based Access Control (RBAC):** Restrict access to features based on user roles (membership levels) within an organization or project.\n*   **Organization-Level Permissions:** Define access restrictions that apply across the entire organization.\n*   **Project-Level Permissions:** Define access restrictions that apply to specific projects (environments).\n*   **Dynamic Restriction Messages:** Display informative messages to users explaining why they lack access to certain features.\n*   **Conditional Rendering:** Enable or disable UI elements based on the user's permissions.\n"
    },
    {
        "path": "frontend/src/lib/components/AccessDenied",
        "summary": "The AccessDenied component provides a user-friendly interface to inform users when they lack the necessary permissions to access a specific resource. It enhances the user experience by clearly communicating the access restriction, specifying the type of object they are trying to access, and offering a direct link to a support form for reporting potential issues or requesting access.\n\nHere's a list of high-level product features:\n\n*   **Access Denied Display:** Shows a user-friendly message when access to a resource is restricted.\n*   **Contextual Object Mention:** Dynamically displays the type of object the user is trying to access.\n*   **Support Link:** Provides a direct link to a support form for reporting access issues.\n"
    },
    {
        "path": "frontend/src/lib/components/Metalytics/MetalyticsSummary.tsx",
        "summary": "The `MetalyticsSummary` component displays a button that, when clicked, opens a side panel displaying PostHog instance activity metrics. The button shows a pulse icon and a tooltip summarizing the total views and unique users who have viewed the instance. The component fetches the instance ID, view count, and loading state from the `metalyticsLogic`. It only renders the button if the instance ID is available and the view count is not loading.\n\nHere's a list of high-level product features:\n\n*   **Activity Tracking:** Tracks views and unique users of a PostHog instance.\n*   **Summary Display:** Displays a summary of view count and unique users in a tooltip.\n*   **Side Panel Integration:** Opens a side panel with detailed activity metrics upon button click.\n*   **Loading State Handling:** Displays a loading state while fetching view count data.\n"
    },
    {
        "path": "frontend/src/lib/components/Metalytics/metalyticsLogic.ts",
        "summary": "This code defines the `metalyticsLogic` Kea logic hook, responsible for fetching and processing data related to Metalytics usage within PostHog. It retrieves view counts and recent users for a specific instance, identified by its ID. The logic also tracks when a specific instance is viewed by sending a request to the PostHog API. It connects to other logic hooks like `sidePanelContextLogic` and `membersLogic` to access the current side panel context and organization members, respectively, and provides selectors to derive relevant information such as the instance ID, scope, and recent user members.\n\n**Features:**\n\n*   **View Count Tracking:** Tracks the number of views and unique users for a specific Metalytics instance.\n*   **Recent User Retrieval:** Fetches a list of users who have recently interacted with a specific Metalytics instance within the last 30 days.\n*   **User Membership Filtering:** Filters the list of recent users to only include those who are also members of the organization.\n*   **Instance Identification:** Derives the Metalytics instance ID from the side panel context.\n*   **Viewed Event Tracking:** Sends an event to the PostHog API when a Metalytics instance is viewed.\n"
    },
    {
        "path": "frontend/src/lib/components/Metalytics",
        "summary": "The provided code implements a Metalytics feature within PostHog that tracks and displays usage metrics for specific instances. It provides a summary of views and unique users, allows users to view detailed activity metrics in a side panel, and tracks when an instance is viewed. The system fetches and processes data related to Metalytics usage, including view counts and recent users, and integrates with other PostHog components to provide a comprehensive view of instance activity.\n\n**Features:**\n\n*   Activity Tracking: Tracks views and unique users of a PostHog instance.\n*   Summary Display: Displays a summary of view count and unique users in a tooltip.\n*   Side Panel Integration: Opens a side panel with detailed activity metrics upon button click.\n*   Loading State Handling: Displays a loading state while fetching view count data.\n*   Recent User Retrieval: Fetches a list of users who have recently interacted with a specific Metalytics instance.\n*   User Membership Filtering: Filters the list of recent users to only include those who are also members of the organization.\n*   Instance Identification: Derives the Metalytics instance ID from the side panel context.\n*   Viewed Event Tracking: Sends an event to the PostHog API when a Metalytics instance is viewed.\n"
    },
    {
        "path": "frontend/src/lib/components/BillingUpgradeCTA.tsx",
        "summary": "The `BillingUpgradeCTA` component is a call-to-action button that encourages users to upgrade their billing plan. It's a wrapper around the `LemonButton` component from the Lemon UI library, inheriting all its properties. The component also uses the `eventUsageLogic` to track when the button is displayed, reporting the `BillingCTAShown` event for usage analysis.\n\nHere's a list of high-level product features:\n\n*   **Billing Upgrade Call-to-Action:** Displays a button prompting users to upgrade their billing plan.\n*   **Lemon UI Integration:** Leverages the `LemonButton` component for consistent styling and behavior.\n*   **Usage Tracking:** Reports when the billing upgrade CTA is shown to track effectiveness.\n"
    },
    {
        "path": "frontend/src/lib/components/TitledSnack.tsx",
        "summary": "The `TitledSnack` component is a React component that displays a title and a value side-by-side within a snackbar-like element. It allows for customization of the title suffix and the overall style based on a type property, which can be either 'default' or 'success'. The component uses `clsx` for conditional styling and ensures that both the title and value are truncated with an ellipsis if they overflow their container.\n\nHere's a list of high-level product features:\n\n*   **Displays a title and value pair:** Shows a title and corresponding value in a visually grouped manner.\n*   **Customizable title suffix:** Allows modification of the character(s) appended to the title (defaults to a colon).\n*   **Themed styling:** Supports different styling based on a 'success' or 'default' type.\n*   **Text Overflow Handling:** Truncates long titles and values with an ellipsis to prevent layout issues.\n"
    },
    {
        "path": "frontend/src/lib/components/TaxonomicPopover/TaxonomicPopover.tsx",
        "summary": "The `TaxonomicPopover` component provides a user-friendly way to select taxonomic values within a dropdown. It leverages the `TaxonomicFilter` component to display and manage the selection options based on a specified group type. The component allows for customization of the displayed value, placeholder text, and styling, and supports clearing the selected value. It's designed to be flexible and reusable across different parts of the application where taxonomic selection is needed, such as filtering events or properties.\n\nHere's a list of high-level product features provided by the code:\n\n*   **Taxonomic Value Selection:** Allows users to select values from a predefined taxonomy.\n*   **Dropdown Interface:** Presents the taxonomic filter within a dropdown for a clean UI.\n*   **Customizable Display:** Offers options to customize the displayed value and placeholder text.\n*   **Clear Selection:** Provides a button to clear the selected value.\n*   **Filtering Options:** Supports filtering the taxonomic options based on various criteria.\n*   **Group Type Specification:** Allows specifying the type of taxonomic group to filter.\n*   **Event Name Filtering:** Enables filtering based on event names.\n*   **Schema Column Support:** Integrates with database schema columns for relevant suggestions.\n*   **Data Warehouse Field Support:** Integrates with data warehouse fields for relevant suggestions.\n*   **Excluded Properties:** Allows excluding specific properties from the selection.\n*   **Numerical Properties Only:** Allows showing only numerical properties.\n"
    },
    {
        "path": "frontend/src/lib/components/TaxonomicPopover",
        "summary": "The `TaxonomicPopover` component offers a user-friendly dropdown interface for selecting taxonomic values, enabling users to easily filter and refine data based on predefined taxonomies. It provides customizable display options, including value representation and placeholder text, along with a clear selection feature for easy reset. The component supports various filtering options based on group type, event names, schema columns, data warehouse fields, and property exclusions, making it a versatile tool for taxonomic selection across different application contexts.\n\nHere's a list of high-level product features:\n\n*   Taxonomic Value Selection via Dropdown\n*   Customizable Display and Placeholder Text\n*   Clear Selection Functionality\n*   Taxonomic Filtering by Group Type\n*   Event Name Filtering\n*   Schema Column Integration\n*   Data Warehouse Field Integration\n*   Property Exclusion\n*   Numerical Properties Only Option\n"
    },
    {
        "path": "frontend/src/lib/components",
        "summary": "The provided code encompasses a wide array of frontend components designed to enhance user experience and provide robust functionality within the PostHog application. These components facilitate tasks ranging from data visualization and analysis to user management, feature flagging, and system configuration. They offer features such as interactive editing, dynamic filtering, customizable displays, and seamless integration with various data sources and external services. The components prioritize user-friendliness, accessibility, and performance, ensuring a cohesive and efficient workflow for users interacting with the PostHog platform.\n\nHere's a list of high-level product features:\n\n*   **Data Visualization and Analysis:** Interactive charts, heatmaps, timelines, and property tables for exploring and understanding data.\n*   **Filtering and Segmentation:** Comprehensive filtering options based on events, properties, cohorts, feature flags, and taxonomic structures.\n*   **User Management and Access Control:** Role-based access control, member selection, and test account filtering.\n*   **Feature Flag Management:** Dynamic feature flag selection and conditional rendering of UI elements.\n*   **System Configuration and Monitoring:** Reverse proxy detection, version checking, and billing alerts.\n*   **User Interface Enhancements:** Customizable layouts, animated transitions, tooltips, and responsive design.\n*   **Integration with External Services:** Data warehouse connections, social login, and support form integration.\n*   **Collaboration and Sharing:** Public sharing, embed code generation, and annotation systems.\n*   **Onboarding and Guidance:** Product introductions, help buttons, and debug notices.\n*   **Customization and Theming:** Customizable styling options, theme integration, and hedgehog buddy personalization.\n*   **Data Export:** Export data in various formats.\n*   **Activity Logging:** Track user actions and system events.\n*   **Command Bar:** A central interface for search, actions, and shortcuts.\n*   **Subscription Management:** Schedule and deliver reports or insights to various destinations.\n*   **Time-Sensitive Authentication:** Enhance security by requiring users to re-authenticate before accessing sensitive settings.\n*   **Error Tracking:** Identify, analyze, and resolve errors within an application.\n"
    },
    {
        "path": "frontend/src/lib/hooks/useAnchor.ts",
        "summary": "This code defines a React hook called `useAnchor` that enables smooth scrolling and highlighting to specific sections within a webpage based on the URL hash. When the hash changes, the hook waits briefly for the page to render, then locates the corresponding element, scrolls it into view, and adds a 'highlighted' class to it. This provides a visual cue to the user about the section they've navigated to.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Smooth Scrolling to Anchors:** Enables navigation to specific sections of a page using URL hashes with a smooth scrolling effect.\n*   **Section Highlighting:** Visually highlights the target section after scrolling, providing user feedback.\n*   **Delayed Execution:** Introduces a delay to ensure proper layout before scrolling, improving accuracy.\n"
    },
    {
        "path": "frontend/src/lib/hooks/usePeriodicRerender.ts",
        "summary": "This code defines a custom React hook called `usePeriodicRerender`. This hook forces a component to re-render at a specified interval (in milliseconds). It achieves this by using the `useState` hook to create a state variable (tick) and the `useEffect` hook to set up a `setInterval` timer. The timer increments the `tick` state, causing a re-render. The `useEffect` hook also includes a cleanup function to clear the interval when the component unmounts, preventing memory leaks.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Periodic UI Updates:** Enables components to refresh their display at regular intervals.\n*   **Real-time Data Visualization:** Supports the display of data that changes frequently, such as sensor readings or stock prices.\n*   **Animation and Effects:** Facilitates the creation of simple animations or visual effects by triggering re-renders.\n*   **Automatic Polling:** Allows components to automatically poll for new data from an external source.\n"
    },
    {
        "path": "frontend/src/lib/Chart.ts",
        "summary": "This code defines a custom Chart class that extends the base Chart.js library, disabling rendering during Storybook tests to avoid flaky snapshots. It also registers the CrosshairPlugin and sets the default animation duration to 0. Additionally, it creates a custom tooltip positioner that places the tooltip at the cursor's location. The code exports various types and interfaces from Chart.js for use throughout the application.\n\nHere's a list of high-level product features:\n\n*   **Chart Rendering:** Renders interactive charts using Chart.js.\n*   **Crosshair Plugin:** Integrates a crosshair plugin for precise data point selection.\n*   **Custom Tooltip Positioning:** Provides a custom tooltip positioner that places the tooltip at the cursor's location.\n*   **Storybook Integration:** Disables chart rendering during Storybook tests to prevent flaky snapshots.\n*   **Animation Control:** Sets the default animation duration to 0 for faster rendering.\n"
    },
    {
        "path": "frontend/src/lib/hooks/useWhyDidIRender.ts",
        "summary": "The `useWhyDidIRender` hook is a debugging tool that helps developers understand why a React component re-renders. It leverages the `DEBUG_REACT_RENDERS` feature flag to conditionally log the changes in props between renders to the console. The hook compares the current props with the previous props stored in a ref, and if any prop has changed, it logs the names of the changed props to the console. This allows developers to identify unnecessary re-renders and optimize component performance.\n\nHere's a list of high-level product features:\n\n*   **Component Re-render Debugging:** Identifies and logs prop changes that trigger re-renders.\n*   **Conditional Logging:** Controlled by a feature flag (`DEBUG_REACT_RENDERS`) to enable/disable logging.\n*   **Prop Comparison:** Compares current and previous props to detect changes.\n*   **Console Output:** Logs the names of changed props to the console for inspection.\n"
    },
    {
        "path": "frontend/src/lib/hooks/useIsHovering.ts",
        "summary": "This code defines a custom React hook called `useIsHovering`. This hook takes a React ref object as input and returns a boolean value indicating whether the element referenced by the ref is currently being hovered over by the mouse. It uses event listeners for `mouseover` and `mouseout` to track the hover state and updates the state accordingly. The hook also includes a cleanup function to remove the event listeners when the component unmounts or the ref changes, preventing memory leaks.\n\nHere's a list of high-level features provided by this code:\n\n*   **Hover State Detection:** Detects when the mouse cursor is hovering over a specific HTML element.\n*   **React Hook Implementation:** Provides a reusable React hook for managing hover state.\n*   **Event Listener Management:** Adds and removes event listeners for `mouseover` and `mouseout` events.\n*   **Ref Object Integration:** Accepts a React ref object to target the specific element for hover detection.\n*   **Cleanup Function:** Includes a cleanup function to remove event listeners on unmount or ref change.\n"
    },
    {
        "path": "frontend/src/lib/hooks/useAsyncHandler.ts",
        "summary": "The `useAsyncHandler` hook simplifies handling asynchronous operations triggered by UI events in React components. It takes an event handler function as input and returns a wrapped event handler along with a boolean loading state. When the wrapped handler is triggered, it sets the loading state to true before executing the original handler. If the original handler returns a promise, the loading state remains true until the promise resolves or rejects, ensuring that UI elements can reflect the ongoing operation. This prevents race conditions and provides visual feedback to the user.\n\nHere's a list of high-level product features enabled by this hook:\n\n*   **Asynchronous Event Handling:** Simplifies the management of asynchronous operations triggered by UI events.\n*   **Loading State Management:** Provides a boolean loading state that can be used to indicate when an asynchronous operation is in progress.\n*   **UI Feedback:** Enables visual feedback to the user during asynchronous operations, improving the user experience.\n*   **Race Condition Prevention:** Prevents race conditions by disabling UI elements or preventing multiple submissions during asynchronous operations.\n*   **Promise Handling:** Automatically handles promises returned by event handlers, ensuring that the loading state is updated correctly.\n"
    },
    {
        "path": "frontend/src/lib/hooks/useKeyHeld.tsx",
        "summary": "This code defines a custom React hook called `useKeyHeld` that detects whether a specific key is currently being held down. It utilizes the `useEventListener` hook to listen for `keydown` and `keyup` events, maintaining a set of currently pressed keys in a ref. The hook updates a state variable `keyHeld` to reflect whether the target key is present in the set of held keys, triggering re-renders when the key's held state changes. It also accepts an optional dependency array to allow for re-evaluation of the held state based on external factors.\n\nHere's a list of high-level features provided by the `useKeyHeld` hook:\n\n*   **Key Press Detection:** Detects when a specific key is pressed down.\n*   **Key Release Detection:** Detects when a specific key is released.\n*   **Real-time Key State:** Provides a boolean value indicating whether the key is currently held down.\n*   **Dependency Management:** Allows for re-evaluation of the held state based on external dependencies.\n*   **Integration with React Components:** Seamlessly integrates with React components, triggering re-renders when the key's held state changes.\n"
    },
    {
        "path": "frontend/src/lib/hooks/useInterval.js",
        "summary": "This code defines a custom React hook called `useInterval`. This hook allows you to set up a recurring function call (like `setInterval` in JavaScript) within a React component, but in a way that correctly handles component re-renders and avoids stale closures. It takes a callback function and a delay in milliseconds as arguments. The hook ensures that the latest version of the callback is always used, even if the component re-renders and the callback changes. It also provides a cleanup function to clear the interval when the component unmounts or the delay changes.\n\nHere's a list of high-level features provided by the `useInterval` hook:\n\n*   **Recurring Function Execution:** Executes a provided callback function repeatedly at a specified interval.\n*   **Dynamic Interval Control:** Allows the interval delay to be changed dynamically, restarting the interval with the new delay.\n*   **Stale Closure Prevention:** Ensures the callback function always has access to the latest state and props, preventing issues with stale closures.\n*   **Automatic Cleanup:** Clears the interval when the component unmounts or the delay changes, preventing memory leaks.\n*   **React Integration:** Seamlessly integrates with React components, managing the interval lifecycle within the component's lifecycle.\n"
    },
    {
        "path": "frontend/src/lib/hooks/useWindowSize.ts",
        "summary": "The `useWindowSize` hook provides information about the current window size (width and height) and a utility function to check if the window width is less than a specified Tailwind CSS breakpoint. It leverages `useState` and `useEffect` to track window size changes and updates the state accordingly. The hook is designed to be used in React components to create responsive layouts and behaviors based on the screen size.\n\nHere's a list of high-level product features enabled by this hook:\n\n*   **Responsive Layout:** Adapts the layout of the application based on the screen size.\n*   **Breakpoint Detection:** Allows components to determine if the screen size is below a specific Tailwind CSS breakpoint.\n*   **Dynamic Content Rendering:** Enables rendering different content or components based on the screen size.\n*   **Mobile-Friendly Design:** Facilitates the creation of mobile-friendly user interfaces.\n*   **Adaptive UI Elements:** Modifies the behavior or appearance of UI elements based on screen size.\n"
    },
    {
        "path": "frontend/src/lib/hooks/useSecondRender.js",
        "summary": "This code defines a custom React hook called `useSecondRender`. This hook utilizes the `useState` and `useEffect` hooks from React to manage a boolean state variable `secondRender`. The hook's primary purpose is to execute a provided callback function only after the component has rendered for the first time. It leverages `requestAnimationFrame` to ensure the callback is executed in the next browser repaint, after the initial render. The hook returns a boolean value indicating whether it is the second render or not.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Delayed Callback Execution:** Allows executing a function after the initial component render, useful for animations or interactions that depend on the component being fully mounted.\n*   **Animation Triggering:** Enables triggering animations or transitions after the initial render, providing a smoother user experience.\n*   **Post-Render Logic:** Facilitates running logic that relies on the component's initial state or DOM structure after it has been rendered.\n*   **Performance Optimization:** Using `requestAnimationFrame` optimizes the execution of the callback, ensuring it runs in the next browser repaint and avoids blocking the main thread.\n"
    },
    {
        "path": "frontend/src/lib/hooks/useD3.ts",
        "summary": "This code defines a React hook called `useD3` that simplifies the integration of D3.js visualizations into React components. It takes a rendering function (`renderChartFn`) and a dependency array as input. The hook creates a reference to a DOM element, and when the component mounts or the dependencies change, it calls the rendering function, passing in a D3 selection of the DOM element. This allows developers to use D3 to manipulate the DOM element and create visualizations. The hook returns the reference to the DOM element, allowing the React component to access it.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **D3.js Integration:** Simplifies the process of using D3.js for data visualization within React applications.\n*   **Lifecycle Management:** Automatically handles the rendering and updating of D3 visualizations based on component lifecycle and dependency changes.\n*   **DOM Manipulation:** Provides a D3 selection of a DOM element for direct manipulation and visualization creation.\n*   **React Compatibility:** Seamlessly integrates D3.js with React's component-based architecture.\n*   **Abstraction:** Hides the complexities of D3.js setup and update logic, allowing developers to focus on visualization design.\n"
    },
    {
        "path": "frontend/src/lib/hooks/useScrollable.ts",
        "summary": "This code defines a `useScrollable` hook that detects whether a given HTML element is scrollable in any direction (left, right, top, or bottom). It utilizes `useRef` to maintain a reference to the target element and `useState` to track the scrollable status in each direction. The hook employs `useResizeObserver` to monitor changes in the element's dimensions and updates the scrollable status accordingly. It also listens for scroll events on the element to dynamically adjust the scrollable status. The hook returns an object containing boolean flags indicating scrollability in each direction, along with a ref to the HTML element.\n\nHere's a list of high-level product features enabled by this hook:\n\n*   **Scrollable Content Detection:** Determines if an element's content exceeds its visible area, enabling scrolling.\n*   **Directional Scrollability Indicators:** Provides boolean flags to indicate scrollability in left, right, top, and bottom directions.\n*   **Dynamic Scrollability Updates:** Reacts to changes in element size and content to update scrollability status in real-time.\n*   **Ref Binding:** Exposes a ref to the target HTML element for easy integration and manipulation.\n"
    },
    {
        "path": "frontend/src/lib/hooks/useThemedHtml.ts",
        "summary": "This hook, `useThemedHtml`, manages the application's theme by dynamically updating the HTML document based on the current theme settings. It sets the body's `theme` attribute to either \"dark\" or \"light\" based on the `isDarkModeOn` value. It also injects custom CSS into the head of the document if `customCss` is provided, and removes any previously injected custom CSS. Additionally, it toggles the `overflow-hidden` class on the body and sets the theme-color meta tag based on the current theme and project-based configuration.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Dark/Light Theme Switching:** Allows users to switch between a dark and light theme.\n*   **Custom CSS Injection:** Enables the application to apply custom CSS styles, likely for branding or user-specific customizations.\n*   **Address Bar Theming:** Sets the theme color of the browser's address bar to match the application's theme.\n*   **Scroll Management:** Controls the `overflow-hidden` class on the body to manage scrolling behavior across different sections of the application.\n"
    },
    {
        "path": "frontend/src/lib/hooks/useFloatingContainerContext.ts",
        "summary": "This code defines a React Context, `FloatingContainerContext`, that allows specifying a specific HTML element as a container for floating UI elements like popovers and tooltips. This is useful when these elements need to be rendered within a specific part of the DOM, such as inside a fullscreen player, rather than always being portaled to the root of the document. The `useFloatingContainer` hook provides a way to access the current container element from within components that need to render floating elements.\n\nHere's a list of high-level features enabled by this code:\n\n*   **Customizable Portal Container:** Allows developers to specify a target HTML element for portaling floating UI elements.\n*   **Context-Based Configuration:** Uses React Context to provide the container element to descendant components.\n*   **Hook for Easy Access:** Provides a `useFloatingContainer` hook for components to easily access the configured container element.\n*   **Dynamic Updates:** Reacts to changes in the container element reference.\n"
    },
    {
        "path": "frontend/src/lib/hooks/useKeyboardHotkeys.tsx",
        "summary": "This code defines a React hook, `useKeyboardHotkeys`, that enables the registration of keyboard shortcuts (hotkeys) and their associated actions within a component. It listens for `keydown` events and triggers the corresponding action when a registered hotkey is pressed. The hook allows for disabling specific hotkeys, ignoring input fields (except for the Escape key), and preventing default browser behavior for the triggered hotkey. It also handles edge cases like toolbar inputs and exceptions where hotkeys should be blocked.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Register Keyboard Shortcuts:** Allows developers to define keyboard shortcuts and link them to specific actions within the application.\n*   **Disable Hotkeys:** Provides the ability to temporarily disable certain hotkeys based on application state.\n*   **Input Field Exclusion:** Automatically ignores hotkeys when typing in input fields (except for Escape), preventing unintended actions.\n*   **Custom Event Handling:** Supports custom event handling, allowing actions to manage the event and prevent default behavior.\n*   **Toolbar Input Handling:** Correctly identifies and handles input fields within toolbars, preventing hotkey conflicts.\n*   **Hotkey Blocking:** Provides a mechanism to block hotkeys in specific areas of the application.\n"
    },
    {
        "path": "frontend/src/lib/hooks/useUploadFiles.ts",
        "summary": "This code provides a React hook, `useUploadFiles`, that handles the uploading of image files to a media endpoint. It optimizes image uploads by compressing them before sending, using the `image-blob-reduce` library for supported image types (PNG, JPEG, WEBP). The hook manages the uploading state, processes files sequentially, and provides callbacks for successful uploads and errors. It returns functions to set the files to upload and provides the current uploading status.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Image Uploading:** Allows users to upload image files.\n*   **Image Compression:** Automatically compresses images before uploading to reduce file size and improve upload speed.\n*   **Asynchronous Uploading:** Handles file uploads in the background without blocking the user interface.\n*   **Upload Status Indication:** Provides a mechanism to indicate whether an upload is in progress.\n*   **Error Handling:** Catches and reports errors that occur during the upload process.\n*   **Upload Success Callback:** Executes a callback function upon successful upload, providing the URL, file name, and media ID of the uploaded image.\n"
    },
    {
        "path": "frontend/src/lib/hooks/useResizeObserver.ts",
        "summary": "This code provides React hooks for observing the size of an HTML element and triggering actions based on its dimensions. It utilizes the `resize-observer-polyfill` to ensure compatibility across different browsers and exports the `useResizeObserver` hook from the `use-resize-observer` library. Additionally, it introduces a custom hook, `useResizeBreakpoints`, which allows defining breakpoints based on the element's width and dynamically setting a size value based on these breakpoints. This enables responsive behavior by triggering updates when the element's size crosses predefined thresholds.\n\nHere's a list of high-level product features:\n\n*   **Cross-browser Resize Observation:** Provides a consistent way to observe element size changes across different browsers using a polyfill.\n*   **Basic Resize Hook:** Exports the `useResizeObserver` hook for simple size observation.\n*   **Breakpoint-based Size Management:** Introduces the `useResizeBreakpoints` hook to manage a size value based on predefined width breakpoints.\n*   **Responsive Behavior:** Enables responsive UI updates by triggering actions when the observed element's width crosses specified breakpoints.\n"
    },
    {
        "path": "frontend/src/lib/hooks/useFeatureFlag.ts",
        "summary": "This code defines a React hook called `useFeatureFlag` that allows components to easily check the status of feature flags. It utilizes the `kea` library for state management and retrieves feature flag values from the `featureFlagLogic`. The hook takes a feature flag key and an optional match string as input. If a match string is provided, the hook returns true only if the feature flag's value matches the string. Otherwise, it returns true if the feature flag is enabled (i.e., has any value).\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Feature Flag Management:** Allows developers to enable or disable features remotely without deploying new code.\n*   **Conditional Feature Activation:** Enables features based on specific criteria (e.g., user segment, experiment group).\n*   **A/B Testing:** Supports A/B testing by enabling different feature variations for different user groups.\n*   **Gradual Feature Rollout:** Facilitates gradual feature rollout by enabling features for a small percentage of users initially and then gradually increasing the rollout.\n*   **Kill Switch:** Provides a kill switch to quickly disable problematic features in production.\n"
    },
    {
        "path": "frontend/src/lib/hooks/usePageVisibility.ts",
        "summary": "This code provides two React hooks, `usePageVisibilityCb` and `usePageVisibility`, that leverage the Page Visibility API to detect when a webpage is visible or hidden. The `usePageVisibilityCb` hook takes a callback function that is executed whenever the page's visibility changes, passing a boolean indicating whether the page is currently visible. The `usePageVisibility` hook builds upon this by providing a state variable `isVisible` that reflects the current visibility status of the page, making it easy to react to visibility changes within React components.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Detecting Page Visibility Changes:** Provides the ability to detect when a user switches tabs, minimizes the browser window, or otherwise causes the webpage to become hidden or visible.\n*   **Callback on Visibility Change:** Allows executing custom logic when the page visibility changes via a callback function.\n*   **React State for Visibility:** Offers a React hook that provides a state variable indicating the current visibility status of the page.\n*   **Cross-Browser Compatibility:** Handles browser-specific prefixes for the Page Visibility API to ensure compatibility across different browsers.\n"
    },
    {
        "path": "frontend/src/lib/hooks/useEventListener.ts",
        "summary": "This code defines a custom React hook called `useEventListener`. This hook allows developers to easily subscribe to and unsubscribe from DOM events within React components. It takes an event name, a handler function, an optional element to listen on (defaults to the window), and an optional dependency array. The hook ensures that the handler function is always the latest version, even after re-renders, and it automatically cleans up the event listener when the component unmounts or the dependencies change. This simplifies event handling in React components and prevents memory leaks.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **DOM Event Handling:** Enables React components to listen for and respond to various DOM events (e.g., keyboard, mouse, touch events).\n*   **Automatic Listener Management:** Automatically adds and removes event listeners, preventing memory leaks and simplifying component lifecycle management.\n*   **Stable Handler References:** Ensures that the event handler function is always up-to-date, even after re-renders, without requiring the handler to be included in the dependency array.\n*   **Configurable Target Element:** Allows specifying the target element for the event listener, defaulting to the window if no element is provided.\n*   **Dependency-Based Updates:** Re-subscribes to the event listener when specified dependencies change, ensuring that the component responds to relevant updates.\n"
    },
    {
        "path": "frontend/src/lib/hooks/useOutsideClickHandler.ts",
        "summary": "This React hook, `useOutsideClickHandler`, provides a mechanism to detect clicks or touches outside of a specified set of React refs. It accepts an array of refs, a callback function to execute when an outside click/touch occurs, an array of extra dependencies for the `useEffect` hook, and an optional array of tag names to exclude from triggering the callback. The hook attaches global `mouseup` and `touchend` event listeners to the document, and within the event handler, it checks if the click/touch originated from within any of the specified refs, or if it matches any of the exception selectors (elements with the class `click-outside-block`). If the click/touch is indeed outside the refs and not on an excluded tag, the provided callback function is executed.\n\nHere's a list of high-level product features enabled by this hook:\n\n*   **Click Outside Detection:** Detects when a user clicks or touches outside of a specified component or set of components.\n*   **Exclusion Zones:** Allows defining areas (via CSS class `click-outside-block`) where clicks should be ignored, even if outside the target components.\n*   **Tag Name Exclusion:** Allows specifying HTML tag names that should be excluded from triggering the outside click handler.\n*   **Shadow DOM Support:** Correctly handles click detection within components that utilize Shadow DOM.\n*   **Customizable Callback:** Executes a user-defined callback function when an outside click is detected, enabling custom actions.\n*   **Dependency Management:** Accepts extra dependencies to control when the event listeners are attached and detached, ensuring proper behavior with dynamic components.\n"
    },
    {
        "path": "frontend/src/lib/hooks",
        "summary": "This collection of React hooks provides a suite of tools for enhancing and optimizing web application development. They offer solutions for debugging re-renders, managing UI themes, handling keyboard shortcuts, observing element sizes, detecting outside clicks, managing asynchronous operations, and integrating with external libraries like D3.js. These hooks promote code reusability, simplify complex tasks, and improve the overall user experience by enabling responsive layouts, smooth navigation, and efficient data handling.\n\nHere's a list of high-level product features enabled by these hooks:\n\n*   **Component Re-render Debugging:** Identifies and logs prop changes that trigger re-renders.\n*   **Smooth Scrolling to Anchors:** Enables navigation to specific sections of a page using URL hashes with a smooth scrolling effect.\n*   **Keyboard Shortcut Management:** Allows developers to define and manage keyboard shortcuts for application actions.\n*   **Dark/Light Theme Switching:** Allows users to switch between a dark and light theme.\n*   **Responsive Layout:** Adapts the layout of the application based on the screen size and element dimensions.\n*   **Click Outside Detection:** Detects when a user clicks or touches outside of a specified component or set of components.\n*   **Periodic UI Updates:** Enables components to refresh their display at regular intervals.\n*   **Asynchronous Event Handling:** Simplifies the management of asynchronous operations triggered by UI events.\n*   **Customizable Portal Container:** Allows developers to specify a target HTML element for portaling floating UI elements.\n*   **Scrollable Content Detection:** Determines if an element's content exceeds its visible area, enabling scrolling.\n*   **Image Uploading with Compression:** Allows users to upload and automatically compress image files.\n*   **Delayed Callback Execution:** Allows executing a function after the initial component render.\n*   **D3.js Integration:** Simplifies the process of using D3.js for data visualization within React applications.\n*   **Feature Flag Management:** Allows developers to enable or disable features remotely without deploying new code.\n*   **Key Press Detection:** Detects when a specific key is pressed down.\n*   **Hover State Detection:** Detects when the mouse cursor is hovering over a specific HTML element.\n*   **Detecting Page Visibility Changes:** Provides the ability to detect when a user switches tabs or minimizes the browser window.\n*   **Recurring Function Execution:** Executes a provided callback function repeatedly at a specified interval.\n*   **DOM Event Handling:** Enables React components to listen for and respond to various DOM events.\n"
    },
    {
        "path": "frontend/src/lib/monaco/domUtils.ts",
        "summary": "This code provides utility functions for navigating focusable elements within the DOM. It includes a function to determine if an element is focusable based on its tag name, attributes (like `tabindex`, `disabled`, and `aria-hidden`), and style properties (like `display` and `visibility`).  The code also provides functions to find the next and previous focusable elements relative to a given starting element by traversing the DOM tree.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Focus Management:** Enables programmatic control of focus within the application.\n*   **Keyboard Navigation:** Supports keyboard navigation by allowing users to move focus between interactive elements using the Tab key (or other custom keybindings).\n*   **Accessibility:** Improves accessibility by ensuring that users can navigate the application using assistive technologies that rely on focus order.\n*   **Custom UI Components:** Facilitates the creation of custom UI components with specific focus behavior.\n*   **Modal/Dialog Focus Trapping:** Can be used to trap focus within a modal or dialog window, preventing users from accidentally focusing elements outside the modal.\n"
    },
    {
        "path": "frontend/src/lib/sortable.ts",
        "summary": "This code defines a custom collision detection algorithm for vertical sortable lists, addressing an issue in the `dnd-kit` library where variable height items weren't always triggering collisions correctly. It prioritizes finding the droppable container that is at least 50% covered by the dragging item, either from the top or bottom edge, depending on the dragging direction. The algorithm sorts droppable containers by their top position to determine the closest container based on the drag direction.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Vertical Sortable Lists:** Enables users to create and interact with vertically arranged lists where items can be reordered through drag-and-drop.\n*   **Improved Collision Detection:** Provides a more accurate collision detection mechanism for sortable lists, especially when dealing with items of varying heights.\n*   **Drag and Drop Functionality:** Allows users to drag and drop items within the list to change their order.\n*   **Variable Height Item Support:** Ensures that the sorting functionality works correctly even when list items have different heights.\n*   **Enhanced User Experience:** Improves the overall user experience by providing a smoother and more reliable drag-and-drop interaction.\n"
    },
    {
        "path": "frontend/src/lib/monaco/CodeEditorInline.tsx",
        "summary": "The `CodeEditorInline` component is a specialized version of the `CodeEditorResizeable` component, designed for inline code editing. It inherits most of its properties from `CodeEditorResizableProps`, excluding the `height` property, and introduces an optional `minHeight` property. It configures the underlying Monaco editor with specific options tailored for inline use, such as disabling line numbers, minimap, and folding, enabling word wrap, and customizing the scrollbar and overview ruler. It also merges any additional options provided by the user with these default inline-specific options.\n\nHere's a list of high-level product features:\n\n*   **Inline Code Editing:** Provides a code editor component suitable for inline use within other components or text.\n*   **Resizable Editor:** Inherits resizing capabilities from the base `CodeEditorResizeable` component.\n*   **Configurable Minimum Height:** Allows setting a minimum height for the editor.\n*   **Customizable Monaco Editor Options:** Enables customization of the underlying Monaco editor through props, with specific defaults optimized for inline editing.\n*   **Simplified UI:** Hides elements like line numbers and the minimap to provide a cleaner, more compact interface.\n"
    },
    {
        "path": "frontend/src/lib/monaco/languages/hogTemplate.ts",
        "summary": "This code defines a language configuration for `hogTemplate` within the Monaco editor, extending the base HogQL language with template string support. It configures syntax highlighting, tokenization, and autocompletion for the `hogTemplate` language, enabling users to write and edit HogQL code with embedded template expressions. The code also registers the language with Monaco, sets its configuration, and registers completion and code action providers.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Syntax Highlighting for HogQL Templates:** Provides color-coded syntax highlighting for HogQL code with embedded template strings, improving readability and code understanding.\n*   **Tokenization for HogQL Templates:** Defines how the code is broken down into tokens, enabling accurate syntax highlighting and other language features.\n*   **Autocompletion for HogQL Templates:** Offers suggestions for keywords, functions, and variables as the user types, speeding up development and reducing errors.\n*   **Code Actions and Metadata for HogQL Templates:** Provides context-aware actions and metadata, such as function definitions and usage examples, to assist the user in writing correct and efficient code.\n*   **Template String Support:** Enables the embedding of dynamic values within HogQL queries using template strings, allowing for more flexible and parameterized queries.\n"
    },
    {
        "path": "frontend/src/lib/monaco/languages/hogJson.ts",
        "summary": "This code defines a language configuration for \"hogJson\" within the Monaco editor, extending the base \"hog\" language with JSON-specific features. It configures syntax highlighting, tokenization, and autocompletion for a language that blends HogQL with JSON. The code also registers the \"hogJson\" language with Monaco, associating it with the \"application/hog+json\" MIME type and providing completion items and code actions.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Syntax Highlighting for HogQL within JSON:** Provides color-coded syntax highlighting for HogQL code embedded within JSON structures, improving readability and code comprehension.\n*   **JSON Syntax Support:** Includes standard JSON syntax highlighting and validation, such as for strings, numbers, booleans, and null values.\n*   **Autocompletion:** Offers intelligent autocompletion suggestions for HogQL keywords, functions, and identifiers within the JSON context, speeding up development and reducing errors.\n*   **Code Actions and Metadata:** Provides code actions and metadata information, such as function definitions and parameter types, to assist developers in writing correct and efficient HogQL queries.\n*   **Language Registration:** Registers \"hogJson\" as a distinct language within the Monaco editor, allowing it to be recognized and handled appropriately.\n*   **MIME Type Association:** Associates the \"application/hog+json\" MIME type with the \"hogJson\" language, enabling proper handling of files with this MIME type.\n"
    },
    {
        "path": "frontend/src/lib/monaco/languages/hogQL.ts",
        "summary": "This code defines the HogQL language configuration for the Monaco editor, providing syntax highlighting, code completion, and other language-specific features. It specifies keywords, operators, built-in functions, and bracket configurations to enhance the editing experience for HogQL code within the Monaco editor. The configuration is adapted from a MySQL language definition and extended with HogQL-specific elements.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Syntax Highlighting:** Provides color-coding for keywords, operators, and other language elements, improving code readability.\n*   **Code Completion:** Suggests keywords, functions, and other valid syntax elements as the user types, speeding up development.\n*   **Bracket Matching:** Automatically closes brackets and highlights matching pairs, reducing syntax errors.\n*   **Language Configuration:** Defines the language's structure, including comments, brackets, and auto-closing pairs.\n*   **HogQL Support:** Enables the Monaco editor to understand and properly handle HogQL syntax.\n*   **Error Prevention:** Helps prevent syntax errors by providing real-time feedback and suggestions.\n*   **Code Readability:** Improves the overall readability and maintainability of HogQL code.\n*   **Metadata Integration:** Provides access to HogQL metadata, such as table and column names, for code completion and validation.\n"
    },
    {
        "path": "frontend/src/lib/monaco/languages/hog.ts",
        "summary": "This code defines the language configuration and tokenizer for the HogQL language within the Monaco editor. It specifies syntax highlighting rules, code completion, and other language-specific features to enhance the user experience when writing HogQL code. The code adapts existing TypeScript language features from the Monaco editor and extends them to support HogQL's unique syntax and keywords. It also registers the language with Monaco, enabling it to be used within the editor.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Syntax Highlighting:** Provides color-coded syntax highlighting for HogQL code, improving readability and making it easier to identify different code elements.\n*   **Code Completion:** Offers intelligent code completion suggestions as the user types, speeding up development and reducing errors.\n*   **Language Configuration:** Configures language-specific settings such as word patterns, comments, brackets, and auto-closing pairs.\n*   **Code Folding:** Allows users to collapse and expand code blocks, improving code organization and navigation.\n*   **Error Detection:** Identifies and highlights syntax errors in HogQL code.\n*   **HogQL Support:** Registers the HogQL language with the Monaco editor, enabling it to be used for editing HogQL files.\n*   **Metadata Provider:** Provides metadata about HogQL elements for code actions and other editor features.\n*   **Automatic Comment Insertion:** Automatically inserts comment prefixes when starting a new line within a comment block.\n"
    },
    {
        "path": "frontend/src/lib/monaco/languages",
        "summary": "This collection of code files configures the Monaco editor to provide a rich editing experience for various HogQL-related languages, including standard HogQL, HogQL templates, and HogQL embedded within JSON. The configurations enable syntax highlighting, code completion, error detection, and other language-specific features to enhance the user experience when writing and editing HogQL code. The system also supports template strings within HogQL and the combination of HogQL and JSON formats.\n\nHere's a list of high-level product features enabled by this code:\n\n*   Syntax Highlighting for HogQL, HogQL Templates, and HogQL within JSON\n*   Code Completion for HogQL, HogQL Templates, and HogQL within JSON\n*   Language Configuration for HogQL, HogQL Templates, and HogQL within JSON (word patterns, comments, brackets, auto-closing pairs)\n*   Code Folding\n*   Error Detection\n*   HogQL Language Support\n*   HogQL Template Support\n*   HogQL and JSON Support\n*   Metadata Provider for code actions and other editor features\n*   Automatic Comment Insertion\n*   Bracket Matching\n*   MIME Type Association for \"application/hog+json\"\n"
    },
    {
        "path": "frontend/src/lib/monaco/hogQLMetadataProvider.tsx",
        "summary": "This code defines a Monaco editor code action provider for HogQL. It merges markers (errors/warnings) from Monaco's built-in analysis with markers obtained from HogQL metadata queries. The provider then generates \"quick fix\" code actions based on the HogQL metadata, allowing users to automatically replace problematic code snippets with suggested fixes. This enhances the code editing experience by providing real-time error detection and automated correction suggestions.\n\nHere's a list of high-level product features:\n\n*   **HogQL Syntax Validation:** Provides real-time error and warning detection in the HogQL editor.\n*   **Automated Code Fixes:** Offers quick fix suggestions to automatically correct HogQL code based on metadata analysis.\n*   **Integration with Monaco Editor:** Seamlessly integrates with the Monaco editor to provide a familiar and enhanced code editing experience.\n*   **Metadata-Driven Suggestions:** Leverages HogQL metadata to provide accurate and context-aware code suggestions.\n"
    },
    {
        "path": "frontend/src/lib/monaco/CodeEditorResizable.tsx",
        "summary": "The `CodeEditorResizable` component provides a resizable code editor built on top of the `CodeEditor` component. It allows users to dynamically adjust the height of the editor using a drag handle, with configurable minimum and maximum height constraints. The component utilizes `react-virtualized`'s `AutoSizer` to ensure the underlying `CodeEditor` adapts to the available height. The component also calculates an initial height based on the number of lines in the code.\n\nHere's a list of high-level product features:\n\n*   **Resizable Code Editor:** Allows users to dynamically adjust the height of the code editor.\n*   **Configurable Height Constraints:** Supports setting minimum and maximum height limits for the editor.\n*   **Automatic Height Adjustment:** Calculates an initial height based on the content of the code.\n*   **Embedded Mode:** Supports an embedded mode without borders.\n*   **Adaptable to Available Space:** Uses `AutoSizer` to ensure the editor adapts to the available height.\n"
    },
    {
        "path": "frontend/src/lib/monaco/CodeEditor.tsx",
        "summary": "The `CodeEditor` component provides a rich code editing experience using the Monaco Editor. It supports syntax highlighting for various languages including HogQL, autocompletion, theming, and keyboard shortcuts for actions like running queries. The component can also display a diff editor for comparing two versions of code. It integrates with kea-logic for state management and provides callbacks for handling metadata, errors, and editor lifecycle events.\n\nHere's a list of high-level product features:\n\n*   **Code Editing:** Provides a Monaco-based code editor with syntax highlighting and autocompletion.\n*   **Language Support:** Supports multiple languages including HogQL, HogTemplate, and JSON.\n*   **Diff Editor:** Enables comparison of two code versions with a diff view.\n*   **Theming:** Adapts to dark and light themes.\n*   **Keyboard Shortcuts:** Supports custom keyboard shortcuts for actions like running queries.\n*   **Autocomplete:** Provides autocomplete suggestions based on the language and context.\n*   **Error Handling:** Exposes callbacks for handling and displaying code errors.\n*   **Metadata Handling:** Provides callbacks for handling metadata related to the code.\n*   **Focus Management:** Manages focus within the editor and allows tabbing to other elements.\n*   **Schema Validation:** Validates JSON code against a provided schema."
    },
    {
        "path": "frontend/src/lib/monaco/codeEditorLogic.tsx",
        "summary": "This code defines a Kea logic module named `codeEditorLogic` that manages the behavior of a code editor component, specifically for HogQL. It handles fetching and displaying metadata for the code, including errors, warnings, and notices, and updates the editor with these markers. The logic also provides information about the validity of the code and any errors present, communicating these to parent components via callbacks. It uses the Monaco editor to provide code editing functionality.\n\nHere's a list of high-level product features provided by this code:\n\n*   **Code Editor Integration:** Integrates with the Monaco code editor to provide a rich code editing experience.\n*   **HogQL Support:** Provides specific support for the HogQL language, including syntax highlighting and validation.\n*   **Metadata Fetching:** Fetches metadata for the code, including errors, warnings, and notices.\n*   **Error/Warning/Notice Display:** Displays errors, warnings, and notices directly in the code editor.\n*   **Real-time Validation:** Validates the code in real-time as the user types.\n*   **Code Completion/Suggestions:** Potentially provides code completion and suggestions based on the fetched metadata (though not explicitly stated, metadata is used).\n*   **Error Reporting:** Reports errors and validity status to parent components.\n*   **Feature Flag Integration:** Integrates with feature flags to enable or disable certain features.\n*   **Asynchronous Operations:** Handles asynchronous operations such as metadata fetching with debouncing.\n"
    },
    {
        "path": "frontend/src/lib/monaco/hogQLAutocompleteProvider.ts",
        "summary": "This code defines an autocompletion provider for the HogQL language within the Monaco editor. It leverages the PostHog API to fetch autocompletion suggestions based on the current query, cursor position, and context (metadata filters, globals, source query). The provider translates HogQL-specific completion item kinds to Monaco's completion item kinds and provides sorted suggestions with labels, documentation, and appropriate insert text. It also includes a command to move the cursor left after inserting a function.\n\nHere's a list of high-level product features:\n\n*   **HogQL Autocompletion:** Provides intelligent code completion suggestions for the HogQL language within the Monaco editor.\n*   **Context-Aware Suggestions:** Autocompletion suggestions are tailored to the current query context, including metadata filters, global variables, and source query.\n*   **API-Driven Autocompletion:** Fetches autocompletion suggestions from the PostHog API, ensuring up-to-date and accurate suggestions.\n*   **Monaco Editor Integration:** Seamlessly integrates with the Monaco editor, providing a native autocompletion experience.\n*   **Sorted Suggestions:** Autocompletion suggestions are sorted based on their kind and label, prioritizing relevant suggestions.\n*   **Detailed Information:** Displays labels, details, and documentation for each autocompletion suggestion.\n*   **Function Autocompletion Enhancement:** Automatically moves the cursor left after inserting a function, improving the user experience.\n"
    },
    {
        "path": "frontend/src/lib/monaco",
        "summary": "This collection of code files implements a powerful and feature-rich code editing experience, primarily focused on HogQL but also supporting other languages and formats. The core functionality revolves around a Monaco-based code editor with syntax highlighting, autocompletion, and real-time validation. The system provides context-aware suggestions fetched from the PostHog API, automated code fixes based on metadata analysis, and customizable editor options. The editor is also resizable and supports inline usage, catering to various UI needs.\n\nHere's a list of high-level product features:\n\n*   Code Editing with Monaco Editor\n*   HogQL Language Support (Syntax Highlighting, Autocompletion, Validation)\n*   HogQL Template Support\n*   JSON Support (including HogQL embedded within JSON)\n*   Real-time Error Detection and Automated Code Fixes\n*   Context-Aware Autocompletion Suggestions (API-Driven)\n*   Resizable and Inline Code Editor Components\n*   Diff Editor for Code Comparison\n*   Theming Support (Dark/Light)\n*   Keyboard Shortcut Customization\n*   Focus Management and Accessibility\n*   Schema Validation for JSON\n"
    },
    {
        "path": "frontend/src/lib/introductions/GroupsIntroductionOption.tsx",
        "summary": "The `GroupsIntroductionOption` component displays a message about unique groups, accompanied by a lock icon indicating a potential feature limitation or access control. It includes a link to the PostHog documentation on group analytics, encouraging users to learn more about this feature.\n\nHere's a list of high-level product features suggested by this component:\n\n*   **Group Analytics:** Analyzing data based on groups of users or entities.\n*   **Unique Groups:** Identifying and managing distinct groups within the dataset.\n*   **Documentation Access:** Providing in-app links to external documentation for feature education.\n*   **Feature Access Control:** Indicating potential limitations or access restrictions on certain features (implied by the lock icon).\n"
    },
    {
        "path": "frontend/src/lib/actionUtils.ts",
        "summary": "This code defines utility functions and constants for generating CSS selectors for elements on a webpage, primarily used for identifying click targets and elements for experimentation. It includes lists of HTML tags considered click targets and experiment targets, as well as tags to ignore. The code provides functions to match data attributes and convert an element to a CSS selector based on its attributes like ID, class, tag name, href, and nth-child/nth-of-type. The `cssEscape` function is used to properly escape CSS selector strings.\n\nHere's a list of high-level product features that can be derived from this code:\n\n*   **Click Target Identification:** Identifies HTML elements that are likely click targets (e.g., links, buttons).\n*   **Experiment Target Identification:** Identifies a broader set of HTML elements suitable for A/B testing or other experiments.\n*   **CSS Selector Generation:** Generates CSS selectors for specific HTML elements based on their attributes.\n*   **Data Attribute Matching:** Matches elements based on custom data attributes.\n*   **CSS Escaping:** Ensures that generated CSS selectors are properly escaped to avoid conflicts or errors.\n"
    },
    {
        "path": "frontend/src/lib/introductions/groupsAccessLogic.ts",
        "summary": "The `groupsAccessLogic` Kea logic module manages the access status and visibility of group analytics features within the PostHog application. It determines the user's access level to group analytics based on factors like feature availability, team configuration (specifically, whether the team has group types defined), and instance-level preferences (e.g., whether paid features are disabled). The logic then exposes selectors to determine the user's `groupsAccessStatus`, whether an upgrade is needed to use groups, and whether the user can start using groups immediately. This logic is used to toggle various introduction views related to groups.\n\nHere's a list of high-level product features enabled by this logic:\n\n*   **Feature Access Control:** Determines whether a user has access to group analytics features based on their plan and team configuration.\n*   **Introduction View Management:** Controls the visibility of introductory views related to group analytics based on the user's access status.\n*   **Upgrade Prompting:** Identifies when a user needs to upgrade their plan to access group analytics features and prompts them accordingly.\n*   **\"Get Started\" Guidance:** Determines when a user can start using group analytics and provides guidance on how to do so.\n*   **Paid Feature Disabling:** Respects instance-level preferences for disabling paid features, hiding group analytics options when necessary.\n"
    },
    {
        "path": "frontend/src/lib/constants.tsx",
        "summary": "This code defines various constants and enums used throughout the PostHog frontend, primarily related to feature flags, chart display types, user permissions, and data properties. It includes mappings between display types and categories, lists of display types with specific behaviors (e.g., those that don't support breakdowns or only work with single series), and definitions for organization and team membership levels. The code also specifies constants for person identification, experiment configurations, event tracking, retention analysis, webhook services, and a comprehensive list of feature flags that control the availability and behavior of different features within the application.\n\nHere's a list of high-level product features that can be inferred from the constants:\n\n*   **Data Visualization:** Supports various chart types (line graphs, bar charts, pie charts, tables, world maps) for displaying actions and events, with categorization and specific behaviors for each type.\n*   **User and Access Management:** Defines different levels of membership and permissions for organizations, teams, and dashboards, controlling access and editing rights.\n*   **Feature Flags and Experimentation:** Implements a robust feature flagging system to enable/disable features, run experiments with variants, and control the user experience.\n*   **Event and User Tracking:** Defines constants related to event types, user properties, and distinct IDs for tracking user behavior and identifying individuals.\n*   **Retention Analysis:** Supports recurring and first-time retention analysis to understand user engagement over time.\n*   **Integrations:** Provides support for webhook integrations with services like Slack, Discord, and Teams.\n*   **Session Replay:** Includes features related to session replay, such as exporting mobile data, AI-powered summaries, and filtering capabilities.\n*   **Data Warehousing:** Integrates with data warehouses like BigQuery for advanced analytics and data modeling.\n*   **Web Analytics:** Offers web analytics capabilities, including revenue tracking, path analysis, and improved data cleaning.\n*   **Messaging:** Supports messaging features, including automation and a messaging library.\n*   **Surveys:** Includes features for creating and managing surveys, with adaptive limits, custom fonts, and partial response handling.\n*   **Role Based Access Control:** Implements role based access control for managing user permissions.\n*   **Remote Configuration:** Supports remote configuration for managing application settings.\n*   **AI Powered Features:** Includes AI powered features such as session summaries, survey response summaries, and AI filters for recordings.\n*   **Dashboards:** Supports dashboard templates and collaboration features.\n*   **Data Transformations:** Supports data transformations with filters.\n*   **Onboarding:** Includes various onboarding steps and wizards to guide new users."
    },
    {
        "path": "frontend/src/lib/introductions",
        "summary": "The `groupsAccessLogic` and `GroupsIntroductionOption` files work together to manage user access to group analytics features within PostHog. The logic determines access status based on factors like feature availability, team configuration, and instance-level preferences, controlling the visibility of introductory views and prompting upgrades when necessary. The component displays information about unique groups, links to documentation, and indicates potential feature limitations, guiding users through the process of understanding and utilizing group analytics.\n\nHere's a list of high-level product features:\n\n*   Feature Access Control\n*   Introduction View Management\n*   Upgrade Prompting\n*   \"Get Started\" Guidance\n*   Paid Feature Disabling\n*   Group Analytics\n*   Unique Groups\n*   Documentation Access\n"
    },
    {
        "path": "frontend/src/lib/animations/animations.ts",
        "summary": "This code defines and manages Lottie animations for a frontend application. It imports two specific animations, `musichog` and `sportshog`, and provides a mechanism to fetch and cache these animations for efficient use. The code uses an enum `AnimationType` to represent the available animations and a record `animations` to store their URLs, widths, and heights. It employs a double-cache strategy (`animationCache` and `fetchCache`) to avoid redundant network requests and parsing of the JSON animation files. The `getAnimationSource` function retrieves the animation source, fetching it from the network only if it's not already cached.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Animation Display:** Allows displaying Lottie animations within the application.\n*   **Animation Selection:** Provides a way to select from a predefined set of animations (e.g., `musichog`, `sportshog`).\n*   **Animation Caching:** Implements caching to improve performance by storing fetched animations.\n*   **Dynamic Animation Loading:** Enables loading animation data from external `.lottie` files.\n*   **Configuration of Animation Properties:** Allows setting width and height properties for each animation.\n"
    },
    {
        "path": "frontend/src/lib/utils.tsx",
        "summary": "This file provides a collection of utility functions used throughout the PostHog frontend. These functions cover a wide range of tasks, including generating unique IDs, manipulating strings, converting data formats, comparing objects, handling URL parameters, and formatting numbers. They aim to simplify common operations and ensure consistency across the application.\n\nHere's a list of high-level product features that leverage these utilities:\n\n*   **Unique ID Generation:** Used for creating unique identifiers for various entities within the application.\n*   **Data Formatting and Conversion:** Functions to convert file sizes to human-readable formats, format numbers and currencies, and convert between different data types.\n*   **String Manipulation:** Utilities for converting strings to sentence case, splitting kebab case strings, capitalizing/lowercasing the first letter, and slugifying text.\n*   **Object Comparison and Manipulation:** Functions for deep object comparison, cleaning objects (removing undefined or empty values), and calculating object differences.\n*   **URL Parameter Handling:** Utilities for converting objects to URL parameters and extracting parameters from URLs.\n*   **Operator Mapping:** Functions to map operators to human-readable strings for filtering and querying data.\n*   **Number Formatting:** Functions to format numbers as percentages and human-friendly numbers with commas.\n"
    },
    {
        "path": "frontend/src/lib/animations",
        "summary": "This code enables the display of Lottie animations within the frontend application, providing a mechanism to select from a predefined set of animations like `musichog` and `sportshog`. It employs a double-cache strategy to efficiently manage and load animation data from external `.lottie` files, avoiding redundant network requests and parsing. The code also allows for the configuration of animation properties such as width and height.\n\nHere's a list of high-level product features enabled by this code:\n\n*   Animation Display\n*   Animation Selection\n*   Animation Caching\n*   Dynamic Animation Loading\n*   Configuration of Animation Properties\n"
    },
    {
        "path": "frontend/src/lib/dayjs.ts",
        "summary": "This code configures and extends the Day.js library for date and time manipulation. It imports Day.js and several plugins, including duration, isSameOrAfter, isSameOrBefore, localizedFormat, quarterOfYear, relativeTime, timezone, and utc. These plugins add functionalities like formatting, relative time calculations, date comparisons, timezone conversions, and working with durations. The code also defines functions `dayjsUtcToTimezone` and `dayjsLocalToTimezone` to handle timezone conversions between UTC and local times, addressing potential edge cases. Finally, it exports the configured Day.js instance, a function to get the current time, and type definitions to improve TypeScript integration.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Date and Time Formatting:** Allows dates and times to be displayed in various formats based on locale.\n*   **Relative Time Display:** Enables displaying time differences in human-readable formats (e.g., \"2 hours ago\").\n*   **Date Comparison:** Provides functionality to compare dates to determine if one is before, after, or the same as another.\n*   **Timezone Conversion:** Supports converting dates and times between different timezones, including handling UTC conversions.\n*   **Duration Calculations:** Enables calculations involving time durations.\n*   **Quarter of Year Calculations:** Adds support for determining the quarter of the year for a given date.\n*   **Consistent Date Handling:** Provides a consistent and reliable way to handle dates and times throughout the application, addressing potential timezone and formatting issues.\n"
    },
    {
        "path": "frontend/src/lib",
        "summary": "The PostHog frontend encompasses a wide array of features designed to provide comprehensive product analytics and user insights. These features range from data visualization and user interface enhancements to advanced capabilities like HogQL execution, feature flag management, and integrations with third-party services. The frontend prioritizes user experience, accessibility, and performance, offering a customizable and efficient platform for tracking, analyzing, and optimizing user behavior.\n\nHere's a list of high-level product features:\n\n*   Data Visualization and Analysis (Charts, Heatmaps, Timelines, Tables)\n*   User Interface Components (Buttons, Inputs, Menus, Modals)\n*   HogQL Execution and Querying\n*   Feature Flag Management and Experimentation\n*   Third-Party Integrations (Slack, Google Ads, LinkedIn Ads)\n*   User and Access Management (RBAC, Permissions)\n*   Event and User Tracking\n*   Session Recording and Replay\n*   Cohort Management and Segmentation\n*   Data Warehousing Integration\n*   Error Tracking and Monitoring\n*   Performance Monitoring and Telemetry\n*   Real-time Event Streaming\n*   Customizable Themes and Styling\n*   Accessibility Support (ARIA, Keyboard Navigation)\n*   Onboarding and Guidance\n*   API Management and Access\n*   Code Editing and Validation (HogQL, JSON)\n*   Animation Display\n*   Date and Time Manipulation\n*   Sortable Lists\n*   Data Export\n*   Activity Logging\n*   Command Bar\n*   Subscription Management\n*   Time-Sensitive Authentication\n*   Surveys\n*   AI Powered Features\n*   Dashboards\n*   Data Transformations\n*   Role Based Access Control\n*   Remote Configuration\n*   Click Target Identification\n*   Introduction View Management\n*   Unique ID Generation\n*   Dynamic UI Switching\n*   Lettermark Generation\n*   Snackbar/Notification Display\n*   Alert Display\n*   Informative Tooltips\n*   Customizable Dialogs\n*   Text Truncation\n*   Styling Options\n*   Basic Skeleton Display\n*   Versatile Profile Picture Display\n*   Collapsible Panels\n*   Toggle Functionality\n*   Checkbox with Label\n*   Click or Hover Trigger\n*   Internet Connection Issue Detection\n*   Time-Sensitive Authentication Handling\n*   Unauthorized Access Handling\n*   API Error Monitoring\n*   Hide PostHog Properties in Tables\n*   Hide Null Values\n*   Persistent User Preferences\n*   Feature Flag Usage Tracking\n*   Dynamic Feature Flag Updates\n*   Environment-Specific Feature Flags\n*   Role-Based Access Control (RBAC)\n*   Permission Management\n*   Product Intent Tracking\n*   Onboarding Guidance\n*   Cross-Sell Recommendations\n*   Feature Discovery\n*   Contextual Help & Empty State Guidance\n*   Experimentation Tracking\n*   Error Tracking Insights\n*   Web Analytics Insights\n*   Recording View Tracking\n*   Copy to Clipboard Functionality\n*   Conditional Class Application\n*   Tailwind CSS Conflict Resolution\n*   Autocaptured Image Extraction\n*   Regular Expression Validation\n*   Concurrency Limiting\n*   CSS Identifier Escaping\n*   Animated Transitions\n*   Text Wrapping\n*   Persistent Logic Mounting\n*   Regional Data Hosting\n*   File Selection\n*   Project-Specific Routing\n*   Data Staleness Indicator\n*   Element Chain Parsing\n*   Semantic Version Parsing\n*   Soft Delete\n*   Undo Deletion\n*   Conditional Logging\n*   Automatic Word Break Insertion\n*   Currency Selection & Display\n*   Geolocation Support\n*   Language Selection\n*   User Interaction Tracking\n*   Access to Application Context\n*   Team and Organization Awareness\n*   Component Re-render Debugging\n*   Smooth Scrolling to Anchors\n*   Keyboard Shortcut Management\n*   Dark/Light Theme Switching\n*   Responsive Layout\n*   Click Outside Detection\n*   Periodic UI Updates\n*   Asynchronous Event Handling\n*   Customizable Portal Container\n*   Scrollable Content Detection\n*   Image Uploading with Compression\n*   Delayed Callback Execution\n*   D3.js Integration\n*   Key Press Detection\n*   Hover State Detection\n*   Detecting Page Visibility Changes\n*   Recurring Function Execution\n*   DOM Event Handling\n"
    },
    {
        "path": "frontend/src/exporter/index.tsx",
        "summary": "This code initializes and renders the PostHog exporter application within a designated HTML element (`<div id=\"root\" />`). It sets up the environment by importing styles, polyfilling country flag emojis for consistent rendering, initializing Kea (a state management library), and loading PostHog's JavaScript library (although tracking is disabled for exports and embeds). The application then renders the `Exporter` component, passing in exported data received from the `POSTHOG_EXPORTED_DATA` global variable, wrapped in an `ErrorBoundary` for graceful error handling.\n\nHere's a list of high-level product features:\n\n*   **Data Export:** Exports data from PostHog.\n*   **Embeddable Application:** Can be embedded as an iframe.\n*   **Consistent Emoji Rendering:** Ensures consistent rendering of country flag emojis across different platforms.\n*   **Error Handling:** Provides error boundaries for graceful error handling.\n*   **Configuration via Global Variable:** Receives configuration data through a global JavaScript variable (`POSTHOG_EXPORTED_DATA`).\n*   **Tracking Disabled:** Disables tracking for exports and embeds.\n"
    },
    {
        "path": "frontend/src/exporter/types.ts",
        "summary": "This code defines the data structures and enumerations related to exporting data from the application. It introduces an `ExportType` enum specifying the possible export formats (Image, Embed, Scene) and an `ExportOptions` interface that encapsulates various boolean flags to customize the export, such as whitelabeling, header visibility, legend display, and detail level. The `ExportedData` interface combines these options with the export type, access token, and the actual data to be exported, which can be a dashboard, insight, color themes, or session recording.\n\n**Features:**\n\n*   **Data Export:** Allows users to export data in various formats (Image, Embed, Scene).\n*   **Whitelabel Export:** Option to remove branding from exported data.\n*   **Header Control:** Option to hide or show headers in exported data.\n*   **Legend Control:** Option to display or hide legends in exported data.\n*   **Detailed Export:** Option to include detailed information in the export.\n*   **Session Recording Export Options:** Specific options for exporting session recordings, such as showing the inspector.\n*   **Theming Support:** Exports can include data color themes.\n*   **Dashboard Export:** Supports exporting entire dashboards.\n*   **Insight Export:** Supports exporting individual insights.\n*   **Session Recording Export:** Supports exporting session recordings.\n"
    },
    {
        "path": "frontend/src/exporter/ExportedInsight/ExportedInsight.tsx",
        "summary": "The `ExportedInsight` component is designed to render an insight for exporting or sharing, offering customization options such as whitelabeling, header visibility, legend display, and detailed results inclusion. It leverages existing components like `TopHeading`, `InsightLegend`, `InsightsTable`, and `Query` to display the insight's title, description, visualization, legend, and detailed data table. The component dynamically adjusts its presentation based on the insight's query type and the specified export options, ensuring a tailored and informative output.\n\nHere's a list of high-level product features implemented by the code:\n\n*   **Insight Exporting:** Enables exporting insights with customizable options.\n*   **Whitelabeling:** Supports removing PostHog branding from exported insights.\n*   **Header Control:** Allows hiding or showing the header in exported insights.\n*   **Legend Display:** Controls the visibility of the insight legend.\n*   **Detailed Results Table:** Includes or excludes a detailed data table in the export.\n*   **Watermark:** Adds a PostHog watermark when the header is hidden and whitelabeling is disabled.\n*   **Dynamic Presentation:** Adapts the displayed components based on the insight's query type and export options.\n*   **Read-Only Mode:** Renders the insight in a read-only mode, preventing modifications.\n*   **Data Table Export:** Exports the data table associated with the insight.\n"
    },
    {
        "path": "frontend/src/exporter/ExportedInsight",
        "summary": "The `ExportedInsight` component provides a comprehensive solution for exporting and sharing insights, offering a range of customization options to tailor the output to specific needs. It dynamically renders the insight, including its title, description, visualization, and data, while allowing users to control elements like whitelabeling, header visibility, legend display, and the inclusion of a detailed results table. This ensures that exported insights are both informative and aligned with the desired branding and presentation.\n\nHere's a list of high-level product features:\n\n*   Insight Exporting with Customizable Options\n*   Whitelabeling Support\n*   Header Visibility Control\n*   Legend Display Management\n*   Detailed Results Table Inclusion/Exclusion\n*   Dynamic Presentation Based on Query Type\n*   Read-Only Mode for Exported Insights\n*   Data Table Export Functionality\n*   Watermark Feature\n"
    },
    {
        "path": "frontend/src/exporter/exporterViewLogic.ts",
        "summary": "This code defines a Kea logic module named `exporterViewLogic` in a React frontend application. This logic module serves as a central point for storing and accessing exported data within the Exporter view and its nested components. It utilizes Kea's state management features to hold the `ExportedData` as props and provides a selector to retrieve this data. The `getCurrentExporterData` function allows components to easily access the exported data by finding a mounted instance of the logic.\n\nHere's a list of high-level product features enabled by this code:\n\n*   **Data Export:** Facilitates the export of data from the application.\n*   **Centralized Data Access:** Provides a central location for components within the Exporter view to access exported data.\n*   **State Management:** Uses Kea to manage the state of the exported data.\n*   **Sharing Access Token:** Enables the sharing of access tokens related to the exported data.\n"
    },
    {
        "path": "frontend/src/exporter/Exporter.tsx",
        "summary": "The `Exporter` component in `Exporter.tsx` is a versatile React component designed to display exported PostHog data, including insights, dashboards, and session recordings. It dynamically renders content based on the `ExportType` and the data provided, offering different layouts for scenes, embedded views, and images. The component also handles theming, resizing, and communication with parent windows for embedded views. It includes options for whitelabeling and displaying an inspector for session recordings.\n\nHere's a list of high-level product features implemented by this component:\n\n*   **Insight Export:** Renders a single exported insight.\n*   **Dashboard Export:** Renders an entire dashboard with multiple insights.\n*   **Session Recording Export:** Renders a session recording player.\n*   **Theming:** Applies themes to the exported content.\n*   **Whitelabeling:** Option to remove PostHog branding.\n*   **Embedding Support:** Handles resizing and communication for embedded views.\n*   **Different Export Types:** Supports different layouts for scenes, embedded views, and images.\n*   **Session Recording Inspector:** Option to show or hide the session recording inspector.\n"
    },
    {
        "path": "frontend/src/exporter",
        "summary": "The PostHog exporter application provides a comprehensive solution for exporting and sharing data, including insights, dashboards, and session recordings, in various formats such as images, embeddable views, and scenes. It offers extensive customization options, including whitelabeling, header and legend visibility control, and detailed results tables, allowing users to tailor the output to their specific needs. The application also supports theming, consistent emoji rendering, and graceful error handling, ensuring a polished and reliable user experience. A Kea logic module provides centralized data access and state management for the exported data. Tracking is disabled for exports and embeds.\n\nHere's a list of high-level product features:\n\n*   Data Export (Insights, Dashboards, Session Recordings)\n*   Multiple Export Formats (Image, Embed, Scene)\n*   Customizable Export Options (Whitelabeling, Header/Legend Visibility, Detail Level)\n*   Embeddable Application\n*   Theming Support\n*   Consistent Emoji Rendering\n*   Error Handling\n*   Centralized Data Access and State Management\n*   Session Recording Inspector\n*   Data Table Export\n*   Watermark Feature\n"
    },
    {
        "path": "frontend/src/products.tsx",
        "summary": "This code defines the routing and configuration for various product features within the PostHog application. It automatically generates routes, URLs, and configurations for features like Early Access Features, LLM Observability, and Messaging (Automations, Broadcasts, Providers, and Library). It also includes definitions for file system types and tree items, which are likely used for navigation and organization within the application.\n\nHere's a list of high-level product features based on the code:\n\n*   **Early Access Features:** Management of features in early access.\n*   **LLM Observability:** Tools for observing and analyzing the performance of Large Language Models.\n*   **Messaging:**\n    *   **Automations:** Automated messaging workflows.\n    *   **Broadcasts:** Sending messages to a large audience.\n    *   **Providers:** Management of messaging service providers.\n    *   **Library:** A repository of reusable messaging templates.\n*   **Dashboards:** Customizable dashboards for visualizing data.\n*   **Experiments:** A/B testing and experimentation platform.\n*   **Feature Flags:** Control the release of features to specific users or groups.\n*   **Groups:** Management of user groups.\n*   **Notebooks:** Collaborative notebooks for data analysis.\n*   **Canvas:** A visual workspace for data exploration.\n*   **Persons:** User management and profiles.\n*   **Insights:** Data analysis and visualization tools.\n*   **Replay:** Session recording and replay functionality.\n*   **Web Analytics:** Website analytics and performance monitoring.\n*   **Actions:** Definition and management of user actions."
    },
    {
        "path": "frontend/src",
        "summary": "The PostHog frontend encompasses a comprehensive suite of features for product analytics, experimentation, data management, and user engagement. It provides tools for data visualization, user interface enhancements, and advanced capabilities like HogQL execution, feature flag management, and integrations with third-party services. The frontend prioritizes user experience, accessibility, and performance, offering a customizable and efficient platform for tracking, analyzing, and optimizing user behavior, while also ensuring robust testing and development workflows through comprehensive mocking and state management.\n\nHere's a list of high-level product features:\n\n*   Product Analytics (Trends, Funnels, Retention, Paths, Session Recordings, Heatmaps, Web Analytics, User Cohorts)\n*   Experimentation (A/B testing, Feature Flags, Holdout Groups, Experiment Analysis)\n*   Data Management (Data Warehouse Integration, Data Pipelines, Event and Property Definitions, Data Governance, Data Quality Monitoring)\n*   AI Assistant (Natural Language Querying, Automated Analysis, Data Visualization Generation)\n*   User Management (User Profiles, Authentication, Roles, Permissions, and Notification Settings)\n*   Organization and Team Management (Structure for managing multiple projects and users within an organization)\n*   Feature Flag Management (Control and Rollout of New Features)\n*   Session Recording (Record and Playback User Sessions)\n*   Data Export (Insights, Dashboards, Session Recordings)\n*   Integrations (Support for Integrations with Other Platforms)\n*   Dashboards (Customizable Dashboards for Visualizing Data)\n*   Notebooks (Collaborative Notebooks for Data Analysis)\n*   Messaging (Automated Messaging Workflows, Broadcasts, Messaging Service Provider Management)\n*   Toolbar (In-Page Debugging and Experimentation)\n*   API Mocking and Interception (Testing and Development Support)\n*   State Management (Centralized State Management Using Kea Logic)\n*   Error Handling (Display User-Friendly Error Messages and Log Errors to Sentry)\n*   Theming (Customizable Themes and Styling)\n*   Global Styling (Consistent and Branded Visual Appearance)\n*   Dynamic Module Loading (Ability to Load JavaScript Modules on Demand)\n*   Data Model Visualization (Displaying a Data Model as a Graph of Interconnected Nodes)\n"
    }
]
