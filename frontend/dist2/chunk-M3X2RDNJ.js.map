{
  "version": 3,
  "sources": ["../src/scenes/data-management/definition/definitionLogic.ts"],
  "sourcesContent": ["import { actions, afterMount, connect, kea, key, path, props, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { router } from 'kea-router'\nimport api from 'lib/api'\nimport { TaxonomicFilterGroupType } from 'lib/components/TaxonomicFilter/types'\nimport { getFilterLabel } from 'lib/taxonomy'\nimport { Scene } from 'scenes/sceneTypes'\nimport { urls } from 'scenes/urls'\nimport { userLogic } from 'scenes/userLogic'\n\nimport { updatePropertyDefinitions } from '~/models/propertyDefinitionsModel'\nimport { AvailableFeature, Breadcrumb, Definition, PropertyDefinition } from '~/types'\n\nimport { DataManagementTab } from '../DataManagementScene'\nimport { eventDefinitionsTableLogic } from '../events/eventDefinitionsTableLogic'\nimport { propertyDefinitionsTableLogic } from '../properties/propertyDefinitionsTableLogic'\nimport type { definitionLogicType } from './definitionLogicType'\n\nexport const createNewDefinition = (isEvent: boolean): Definition => ({\n    id: 'new',\n    name: `New ${isEvent ? 'Event' : 'Event property'}`,\n})\n\nexport interface SetDefinitionProps {\n    merge?: boolean\n}\n\nexport interface DefinitionLogicProps {\n    id?: Definition['id']\n}\n\nexport const definitionLogic = kea<definitionLogicType>([\n    path(['scenes', 'data-management', 'definition', 'definitionViewLogic']),\n    props({} as DefinitionLogicProps),\n    key((props) => props.id || 'new'),\n    actions({\n        setDefinition: (definition: Partial<Definition>, options: SetDefinitionProps = {}) => ({ definition, options }),\n        loadDefinition: (id: Definition['id']) => ({ id }),\n        setDefinitionMissing: true,\n    }),\n    connect(() => ({\n        values: [userLogic, ['hasAvailableFeature']],\n    })),\n    reducers(() => ({\n        definitionMissing: [\n            false,\n            {\n                setDefinitionMissing: () => true,\n            },\n        ],\n    })),\n    loaders(({ values, actions }) => ({\n        definition: [\n            createNewDefinition(values.isEvent),\n            {\n                setDefinition: ({ definition, options: { merge } }) =>\n                    (merge ? { ...values.definition, ...definition } : definition) as Definition,\n                loadDefinition: async ({ id }, breakpoint) => {\n                    let definition = { ...values.definition }\n                    try {\n                        if (values.isEvent) {\n                            // Event Definition\n                            definition = await api.eventDefinitions.get({\n                                eventDefinitionId: id,\n                            })\n                        } else {\n                            // Event Property Definition\n                            definition = await api.propertyDefinitions.get({\n                                propertyDefinitionId: id,\n                            })\n                            updatePropertyDefinitions({\n                                [`event/${definition.name}`]: definition as PropertyDefinition,\n                            })\n                        }\n                        breakpoint()\n                    } catch (response: any) {\n                        actions.setDefinitionMissing()\n                        throw response\n                    }\n\n                    return definition\n                },\n                deleteDefinition: async () => {\n                    if (values.isEvent) {\n                        await api.eventDefinitions.delete({ eventDefinitionId: values.definition.id })\n                    } else {\n                        await api.propertyDefinitions.delete({ propertyDefinitionId: values.definition.id })\n                    }\n                    router.actions.push(values.isEvent ? urls.eventDefinitions() : urls.propertyDefinitions())\n                    if (values.isEvent) {\n                        eventDefinitionsTableLogic.findMounted()?.actions.loadEventDefinitions()\n                    } else {\n                        propertyDefinitionsTableLogic.findMounted()?.actions.loadPropertyDefinitions()\n                    }\n                    return values.definition\n                },\n            },\n        ],\n    })),\n    selectors({\n        hasTaxonomyFeatures: [\n            (s) => [s.hasAvailableFeature],\n            (hasAvailableFeature) =>\n                hasAvailableFeature(AvailableFeature.INGESTION_TAXONOMY) ||\n                hasAvailableFeature(AvailableFeature.TAGGING),\n        ],\n        isEvent: [() => [router.selectors.location], ({ pathname }) => pathname.includes(urls.eventDefinitions())],\n        isProperty: [(s) => [s.isEvent], (isEvent) => !isEvent],\n        singular: [(s) => [s.isEvent], (isEvent): string => (isEvent ? 'event' : 'property')],\n        breadcrumbs: [\n            (s) => [s.definition, s.isEvent],\n            (definition, isEvent): Breadcrumb[] => {\n                return [\n                    {\n                        key: Scene.DataManagement,\n                        name: `Data management`,\n                        path: isEvent ? urls.eventDefinitions() : urls.propertyDefinitions(),\n                    },\n                    {\n                        key: isEvent ? DataManagementTab.EventDefinitions : DataManagementTab.PropertyDefinitions,\n                        name: isEvent ? 'Events' : 'Properties',\n                        path: isEvent ? urls.eventDefinitions() : urls.propertyDefinitions(),\n                    },\n                    {\n                        key: [isEvent ? Scene.EventDefinition : Scene.PropertyDefinition, definition?.id || 'new'],\n                        name:\n                            definition?.id !== 'new'\n                                ? getFilterLabel(\n                                      definition?.name,\n                                      isEvent\n                                          ? TaxonomicFilterGroupType.Events\n                                          : TaxonomicFilterGroupType.EventProperties\n                                  ) || 'Untitled'\n                                : 'Untitled',\n                    },\n                ]\n            },\n        ],\n    }),\n    afterMount(({ actions, values, props }) => {\n        if (!props.id || props.id === 'new') {\n            actions.setDefinition(createNewDefinition(values.isEvent))\n        } else {\n            actions.loadDefinition(props.id)\n        }\n    }),\n])\n"],
  "mappings": "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",
  "names": ["init_dirname", "init_buffer", "init_process", "import_kea", "import_kea_loaders", "import_kea_router", "createNewDefinition", "isEvent", "definitionLogic", "props", "definition", "options", "id", "userLogic", "values", "actions", "merge", "breakpoint", "api_default", "updatePropertyDefinitions", "response", "urls", "eventDefinitionsTableLogic", "propertyDefinitionsTableLogic", "s", "hasAvailableFeature", "pathname", "getFilterLabel"]
}
