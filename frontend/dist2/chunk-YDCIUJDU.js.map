{
  "version": 3,
  "sources": ["../src/scenes/experiments/ExperimentMetricForm.tsx", "../src/scenes/experiments/Metrics/Selectors.tsx"],
  "sourcesContent": ["import { DataWarehousePopoverField } from 'lib/components/TaxonomicFilter/types'\nimport { LemonRadio } from 'lib/lemon-ui/LemonRadio'\nimport { ActionFilter } from 'scenes/insights/filters/ActionFilter/ActionFilter'\n\nimport { Query } from '~/queries/Query/Query'\nimport { ExperimentMetric, ExperimentMetricType, NodeKind } from '~/queries/schema/schema-general'\nimport { FilterType } from '~/types'\n\nimport { commonActionFilterProps } from './Metrics/Selectors'\nimport {\n    filterToMetricConfig,\n    getAllowedMathTypes,\n    getMathAvailability,\n    metricConfigToFilter,\n    metricToQuery,\n} from './utils'\n\nconst dataWarehousePopoverFields: DataWarehousePopoverField[] = [\n    {\n        key: 'timestamp_field',\n        label: 'Timestamp Field',\n    },\n    {\n        key: 'data_warehouse_join_key',\n        label: 'Data Warehouse Join Key',\n        allowHogQL: true,\n    },\n    {\n        key: 'events_join_key',\n        label: 'Events Join Key',\n        allowHogQL: true,\n        hogQLOnly: true,\n        tableName: 'events',\n    },\n]\n\nexport function ExperimentMetricForm({\n    metric,\n    handleSetMetric,\n}: {\n    metric: ExperimentMetric\n    handleSetMetric: any\n}): JSX.Element {\n    const mathAvailability = getMathAvailability(metric.metric_type)\n    const allowedMathTypes = getAllowedMathTypes(metric.metric_type)\n\n    const isDataWarehouseMetric = metric.metric_config.kind === NodeKind.ExperimentDataWarehouseMetricConfig\n\n    return (\n        <div className=\"space-y-4\">\n            <div>\n                <h4 className=\"mb-2\">Metric type</h4>\n                <LemonRadio\n                    data-attr=\"metrics-selector\"\n                    value={metric.metric_type}\n                    onChange={(newMetricType: ExperimentMetricType) => {\n                        const newAllowedMathTypes = getAllowedMathTypes(newMetricType)\n                        handleSetMetric({\n                            newMetric: {\n                                ...metric,\n                                metric_type: newMetricType,\n                                metric_config: {\n                                    ...metric.metric_config,\n                                    math: newAllowedMathTypes[0],\n                                },\n                            },\n                        })\n                    }}\n                    options={[\n                        {\n                            value: ExperimentMetricType.BINOMIAL,\n                            label: 'Binomial',\n                            description:\n                                'Tracks whether an event happens for each user, useful for measuring conversion rates.',\n                        },\n                        {\n                            value: ExperimentMetricType.COUNT,\n                            label: 'Count',\n                            description:\n                                'Tracks how many times an event happens, useful for click counts or page views.',\n                        },\n                        {\n                            value: ExperimentMetricType.CONTINUOUS,\n                            label: 'Continuous',\n                            description: 'Measures numerical values like revenue or session length.',\n                        },\n                    ]}\n                />\n            </div>\n            <ActionFilter\n                bordered\n                filters={metricConfigToFilter(metric.metric_config)}\n                setFilters={({ actions, events, data_warehouse }: Partial<FilterType>): void => {\n                    // We only support one event/action for experiment metrics\n                    const entity = events?.[0] || actions?.[0] || data_warehouse?.[0]\n                    const metricConfig = filterToMetricConfig(entity)\n                    if (metricConfig) {\n                        handleSetMetric({\n                            newMetric: {\n                                ...metric,\n                                metric_config: metricConfig,\n                            },\n                        })\n                    }\n                }}\n                typeKey=\"experiment-metric\"\n                buttonCopy=\"Add graph series\"\n                showSeriesIndicator={false}\n                hideRename={true}\n                entitiesLimit={1}\n                showNumericalPropsOnly={true}\n                mathAvailability={mathAvailability}\n                allowedMathTypes={allowedMathTypes}\n                dataWarehousePopoverFields={dataWarehousePopoverFields}\n                {...commonActionFilterProps}\n            />\n            {/* :KLUDGE: Query chart type is inferred from the initial state, so need to render Trends and Funnels separately */}\n            {(metric.metric_type === ExperimentMetricType.COUNT ||\n                metric.metric_type === ExperimentMetricType.CONTINUOUS) &&\n                !isDataWarehouseMetric && (\n                    <Query\n                        query={{\n                            kind: NodeKind.InsightVizNode,\n                            source: metricToQuery(metric),\n                            showTable: false,\n                            showLastComputation: true,\n                            showLastComputationRefresh: false,\n                        }}\n                        readOnly\n                    />\n                )}\n            {metric.metric_type === ExperimentMetricType.BINOMIAL && !isDataWarehouseMetric && (\n                <Query\n                    query={{\n                        kind: NodeKind.InsightVizNode,\n                        source: metricToQuery(metric),\n                        showTable: false,\n                        showLastComputation: true,\n                        showLastComputationRefresh: false,\n                    }}\n                    readOnly\n                />\n            )}\n        </div>\n    )\n}\n", "import { IconInfo } from '@posthog/icons'\nimport { LemonInput, LemonSelect, LemonSelectOption, LemonSelectSection, Link } from '@posthog/lemon-ui'\nimport { useValues } from 'kea'\nimport { HogQLEditor } from 'lib/components/HogQLEditor/HogQLEditor'\nimport { TaxonomicFilterGroupType } from 'lib/components/TaxonomicFilter/types'\nimport { groupsAccessLogic } from 'lib/introductions/groupsAccessLogic'\nimport { Tooltip } from 'lib/lemon-ui/Tooltip'\nimport { capitalizeFirstLetter, pluralize } from 'lib/utils'\nimport { GroupIntroductionFooter } from 'scenes/groups/GroupsIntroduction'\nimport { FUNNEL_STEP_COUNT_LIMIT } from 'scenes/insights/EditorFilters/FunnelsQuerySteps'\nimport { TIME_INTERVAL_BOUNDS } from 'scenes/insights/views/Funnels/FunnelConversionWindowFilter'\n\nimport { groupsModel } from '~/models/groupsModel'\nimport { BreakdownAttributionType, FunnelConversionWindowTimeUnit, StepOrderValue } from '~/types'\n\nexport const commonActionFilterProps = {\n    actionsTaxonomicGroupTypes: [\n        TaxonomicFilterGroupType.Events,\n        TaxonomicFilterGroupType.Actions,\n        TaxonomicFilterGroupType.DataWarehouse,\n    ],\n    propertiesTaxonomicGroupTypes: [\n        TaxonomicFilterGroupType.EventProperties,\n        TaxonomicFilterGroupType.PersonProperties,\n        TaxonomicFilterGroupType.EventFeatureFlags,\n        TaxonomicFilterGroupType.Cohorts,\n        TaxonomicFilterGroupType.Elements,\n        TaxonomicFilterGroupType.SessionProperties,\n        TaxonomicFilterGroupType.HogQLExpression,\n        TaxonomicFilterGroupType.DataWarehouseProperties,\n        TaxonomicFilterGroupType.DataWarehousePersonProperties,\n    ],\n}\n\n// Forked from https://github.com/PostHog/posthog/blob/master/frontend/src/scenes/insights/filters/AggregationSelect.tsx\nexport function FunnelAggregationSelect({\n    value,\n    onChange,\n}: {\n    value: string\n    onChange: (value: string) => void\n}): JSX.Element {\n    const { groupTypes, aggregationLabel } = useValues(groupsModel)\n    const { needsUpgradeForGroups, canStartUsingGroups } = useValues(groupsAccessLogic)\n\n    const UNIQUE_USERS = 'person_id'\n    const baseValues = [UNIQUE_USERS]\n    const optionSections: LemonSelectSection<string>[] = [\n        {\n            title: 'Event Aggregation',\n            options: [\n                {\n                    value: UNIQUE_USERS,\n                    label: 'Unique users',\n                },\n            ],\n        },\n    ]\n    if (needsUpgradeForGroups || canStartUsingGroups) {\n        // if (false) {\n        optionSections[0].footer = <GroupIntroductionFooter needsUpgrade={needsUpgradeForGroups} />\n    } else {\n        Array.from(groupTypes.values()).forEach((groupType) => {\n            baseValues.push(`$group_${groupType.group_type_index}`)\n            optionSections[0].options.push({\n                value: `$group_${groupType.group_type_index}`,\n                label: `Unique ${aggregationLabel(groupType.group_type_index).plural}`,\n            })\n        })\n    }\n\n    baseValues.push(`properties.$session_id`)\n    optionSections[0].options.push({\n        value: 'properties.$session_id',\n        label: `Unique sessions`,\n    })\n    optionSections[0].options.push({\n        label: 'Custom SQL expression',\n        options: [\n            {\n                // This is a bit of a hack so that the HogQL option is only highlighted as active when the user has\n                // set a custom value (because actually _all_ the options are HogQL)\n                value: !value || baseValues.includes(value) ? '' : value,\n                label: <span className=\"font-mono\">{value}</span>,\n                labelInMenu: function CustomHogQLOptionWrapped({ onSelect }) {\n                    return (\n                        // eslint-disable-next-line react/forbid-dom-props\n                        <div className=\"w-120\" style={{ maxWidth: 'max(60vw, 20rem)' }}>\n                            <HogQLEditor\n                                onChange={onSelect}\n                                value={value}\n                                placeholder={\n                                    \"Enter SQL expression, such as:\\n- distinct_id\\n- properties.$session_id\\n- concat(distinct_id, ' ', properties.$session_id)\\n- if(1 < 2, 'one', 'two')\"\n                                }\n                            />\n                        </div>\n                    )\n                },\n            },\n        ],\n    })\n\n    return (\n        <div className=\"flex items-center w-full gap-2\">\n            <span>Aggregating by</span>\n            <LemonSelect\n                className=\"flex-1\"\n                value={value}\n                onChange={onChange}\n                options={optionSections}\n                dropdownMatchSelectWidth={false}\n            />\n        </div>\n    )\n}\n\n// Forked from https://github.com/PostHog/posthog/blob/master/frontend/src/scenes/insights/views/Funnels/FunnelConversionWindowFilter.tsx\nexport function FunnelConversionWindowFilter({\n    funnelWindowInterval,\n    funnelWindowIntervalUnit,\n    onFunnelWindowIntervalChange,\n    onFunnelWindowIntervalUnitChange,\n}: {\n    funnelWindowInterval: number | undefined\n    funnelWindowIntervalUnit: FunnelConversionWindowTimeUnit | undefined\n    onFunnelWindowIntervalChange: (funnelWindowInterval: number | undefined) => void\n    onFunnelWindowIntervalUnitChange: (funnelWindowIntervalUnit: FunnelConversionWindowTimeUnit) => void\n}): JSX.Element {\n    const options: LemonSelectOption<FunnelConversionWindowTimeUnit>[] = Object.keys(TIME_INTERVAL_BOUNDS).map(\n        (unit) => ({\n            label: capitalizeFirstLetter(pluralize(funnelWindowInterval ?? 7, unit, `${unit}s`, false)),\n            value: unit as FunnelConversionWindowTimeUnit,\n        })\n    )\n    const intervalBounds = TIME_INTERVAL_BOUNDS[funnelWindowIntervalUnit ?? FunnelConversionWindowTimeUnit.Day]\n\n    return (\n        <div className=\"flex items-center gap-2\">\n            <span className=\"flex whitespace-nowrap\">\n                Conversion window limit\n                <Tooltip\n                    title={\n                        <>\n                            <b>Recommended!</b> Limit to participants that converted within a specific time frame.\n                            Participants that do not convert in this time frame will be considered as drop-offs.\n                        </>\n                    }\n                >\n                    <IconInfo className=\"w-4 info-indicator\" />\n                </Tooltip>\n            </span>\n            <div className=\"flex items-center gap-2\">\n                <LemonInput\n                    type=\"number\"\n                    className=\"max-w-20\"\n                    fullWidth={false}\n                    min={intervalBounds[0]}\n                    max={intervalBounds[1]}\n                    value={funnelWindowInterval}\n                    onChange={onFunnelWindowIntervalChange}\n                />\n                <LemonSelect\n                    dropdownMatchSelectWidth={false}\n                    value={funnelWindowIntervalUnit}\n                    onChange={onFunnelWindowIntervalUnitChange}\n                    options={options}\n                />\n            </div>\n        </div>\n    )\n}\n\n// Forked from https://github.com/PostHog/posthog/blob/master/frontend/src/scenes/insights/EditorFilters/AttributionFilter.tsx\nexport function FunnelAttributionSelect({\n    value,\n    onChange,\n    stepsLength,\n}: {\n    value: BreakdownAttributionType | `${BreakdownAttributionType.Step}/${number}`\n    onChange: (value: BreakdownAttributionType | `${BreakdownAttributionType.Step}/${number}`) => void\n    stepsLength: number\n}): JSX.Element {\n    const funnelOrderType = undefined\n\n    return (\n        <div className=\"flex items-center w-full gap-2\">\n            <div className=\"flex\">\n                <span>Attribution type</span>\n                <Tooltip\n                    closeDelayMs={200}\n                    title={\n                        <div className=\"space-y-2\">\n                            <div>\n                                When breaking down funnels, it's possible that the same properties don't exist on every\n                                event. For example, if you want to break down by browser on a funnel that contains both\n                                frontend and backend events.\n                            </div>\n                            <div>\n                                In this case, you can choose from which step the properties should be selected from by\n                                modifying the attribution type. There are four modes to choose from:\n                            </div>\n                            <ul className=\"list-disc pl-4\">\n                                <li>First touchpoint: the first property value seen in any of the steps is chosen.</li>\n                                <li>Last touchpoint: the last property value seen from all steps is chosen.</li>\n                                <li>\n                                    All steps: the property value must be seen in all steps to be considered in the\n                                    funnel.\n                                </li>\n                                <li>Specific step: only the property value seen at the selected step is chosen.</li>\n                            </ul>\n                            <div>\n                                Read more in the{' '}\n                                <Link to=\"https://posthog.com/docs/product-analytics/funnels#attribution-types\">\n                                    documentation.\n                                </Link>\n                            </div>\n                        </div>\n                    }\n                >\n                    <IconInfo className=\"text-xl text-secondary shrink-0 ml-1\" />\n                </Tooltip>\n            </div>\n            <LemonSelect\n                value={value}\n                placeholder=\"Attribution\"\n                options={[\n                    { value: BreakdownAttributionType.FirstTouch, label: 'First touchpoint' },\n                    { value: BreakdownAttributionType.LastTouch, label: 'Last touchpoint' },\n                    { value: BreakdownAttributionType.AllSteps, label: 'All steps' },\n                    {\n                        value: BreakdownAttributionType.Step,\n                        label: 'Any step',\n                        hidden: funnelOrderType !== StepOrderValue.UNORDERED,\n                    },\n                    {\n                        label: 'Specific step',\n                        options: Array(FUNNEL_STEP_COUNT_LIMIT)\n                            .fill(null)\n                            .map((_, stepIndex) => ({\n                                value: `${BreakdownAttributionType.Step}/${stepIndex}` as const,\n                                label: `Step ${stepIndex + 1}`,\n                                hidden: stepIndex >= stepsLength,\n                            })),\n                        hidden: funnelOrderType === StepOrderValue.UNORDERED,\n                    },\n                ]}\n                onChange={onChange}\n                dropdownMaxContentWidth={true}\n                data-attr=\"breakdown-attributions\"\n            />\n        </div>\n    )\n}\n"],
  "mappings": "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",
  "names": ["init_dirname", "init_buffer", "init_process", "init_dirname", "init_buffer", "init_process", "import_kea", "import_jsx_runtime", "commonActionFilterProps", "FunnelAggregationSelect", "value", "onChange", "groupTypes", "aggregationLabel", "groupsModel", "needsUpgradeForGroups", "canStartUsingGroups", "groupsAccessLogic", "UNIQUE_USERS", "baseValues", "optionSections", "GroupIntroductionFooter", "groupType", "onSelect", "HogQLEditor", "LemonSelect", "FunnelConversionWindowFilter", "funnelWindowInterval", "funnelWindowIntervalUnit", "onFunnelWindowIntervalChange", "onFunnelWindowIntervalUnitChange", "options", "TIME_INTERVAL_BOUNDS", "unit", "capitalizeFirstLetter", "pluralize", "intervalBounds", "Tooltip", "IconInfo", "LemonInput", "FunnelAttributionSelect", "stepsLength", "Link", "FUNNEL_STEP_COUNT_LIMIT", "_", "stepIndex", "import_jsx_runtime", "dataWarehousePopoverFields", "ExperimentMetricForm", "metric", "handleSetMetric", "mathAvailability", "getMathAvailability", "allowedMathTypes", "getAllowedMathTypes", "isDataWarehouseMetric", "LemonRadio", "newMetricType", "newAllowedMathTypes", "ActionFilter", "metricConfigToFilter", "actions", "events", "data_warehouse", "entity", "metricConfig", "filterToMetricConfig", "commonActionFilterProps", "Query", "metricToQuery"]
}
