{
  "version": 3,
  "sources": ["../src/scenes/session-recordings/playlist/SessionRecordingsPlaylistScene.tsx", "../src/scenes/session-recordings/playlist/sessionRecordingsPlaylistSceneLogic.ts"],
  "sourcesContent": ["import { LemonButton, LemonDivider } from '@posthog/lemon-ui'\nimport { useActions, useValues } from 'kea'\nimport { EditableField } from 'lib/components/EditableField/EditableField'\nimport { NotFound } from 'lib/components/NotFound'\nimport { PageHeader } from 'lib/components/PageHeader'\nimport { UserActivityIndicator } from 'lib/components/UserActivityIndicator/UserActivityIndicator'\nimport { More } from 'lib/lemon-ui/LemonButton/More'\nimport { LemonSkeleton } from 'lib/lemon-ui/LemonSkeleton'\nimport { SceneExport } from 'scenes/sceneTypes'\nimport { playerSettingsLogic } from 'scenes/session-recordings/player/playerSettingsLogic'\n\nimport { isUniversalFilters } from '../utils'\nimport { SessionRecordingsPlaylist } from './SessionRecordingsPlaylist'\nimport { convertLegacyFiltersToUniversalFilters } from './sessionRecordingsPlaylistLogic'\nimport { sessionRecordingsPlaylistSceneLogic } from './sessionRecordingsPlaylistSceneLogic'\n\nexport const scene: SceneExport = {\n    component: SessionRecordingsPlaylistScene,\n    logic: sessionRecordingsPlaylistSceneLogic,\n    paramsToProps: ({ params: { id } }) => {\n        return { shortId: id as string }\n    },\n}\n\nexport function SessionRecordingsPlaylistScene(): JSX.Element {\n    const { playlist, playlistLoading, pinnedRecordings, hasChanges } = useValues(sessionRecordingsPlaylistSceneLogic)\n    const { setFilters, updatePlaylist, duplicatePlaylist, deletePlaylist, onPinnedChange } = useActions(\n        sessionRecordingsPlaylistSceneLogic\n    )\n\n    const { showFilters } = useValues(playerSettingsLogic)\n    const { setShowFilters } = useActions(playerSettingsLogic)\n\n    if (!playlist && playlistLoading) {\n        return (\n            <div className=\"space-y-4 mt-6\">\n                <LemonSkeleton className=\"h-10 w-1/4\" />\n                <LemonSkeleton className=\"h-4 w-1/3\" />\n                <LemonSkeleton className=\"h-4 w-1/4\" />\n\n                <div className=\"flex justify-between mt-4\">\n                    <LemonSkeleton.Button />\n                    <div className=\"flex gap-4\">\n                        <LemonSkeleton.Button />\n                        <LemonSkeleton.Button />\n                    </div>\n                </div>\n\n                <div className=\"flex justify-between gap-4 mt-8\">\n                    <div className=\"space-y-8 w-1/4\">\n                        <LemonSkeleton className=\"h-10\" repeat={10} />\n                    </div>\n                    <div className=\"flex-1\" />\n                </div>\n            </div>\n        )\n    }\n\n    if (!playlist) {\n        return <NotFound object=\"Recording Playlist\" />\n    }\n\n    return (\n        // Margin bottom hacks the fact that our wrapping container has an annoyingly large padding\n        <div className=\"-mb-14\">\n            <PageHeader\n                buttons={\n                    <div className=\"flex justify-between items-center gap-2\">\n                        <More\n                            overlay={\n                                <>\n                                    <LemonButton\n                                        onClick={() => duplicatePlaylist()}\n                                        fullWidth\n                                        data-attr=\"duplicate-playlist\"\n                                    >\n                                        Duplicate\n                                    </LemonButton>\n                                    <LemonButton\n                                        onClick={() =>\n                                            updatePlaylist({\n                                                short_id: playlist.short_id,\n                                                pinned: !playlist.pinned,\n                                            })\n                                        }\n                                        fullWidth\n                                    >\n                                        {playlist.pinned ? 'Unpin playlist' : 'Pin playlist'}\n                                    </LemonButton>\n                                    <LemonDivider />\n\n                                    <LemonButton status=\"danger\" onClick={() => deletePlaylist()} fullWidth>\n                                        Delete playlist\n                                    </LemonButton>\n                                </>\n                            }\n                        />\n\n                        <LemonDivider vertical />\n                        <LemonButton\n                            type=\"primary\"\n                            disabledReason={showFilters && !hasChanges ? 'No changes to save' : undefined}\n                            loading={hasChanges && playlistLoading}\n                            onClick={() => {\n                                showFilters ? updatePlaylist() : setShowFilters(!showFilters)\n                            }}\n                        >\n                            {showFilters ? <>Save changes</> : <>Edit</>}\n                        </LemonButton>\n                    </div>\n                }\n                caption={\n                    <>\n                        <EditableField\n                            multiline\n                            name=\"description\"\n                            markdown\n                            value={playlist.description || ''}\n                            placeholder=\"Description (optional)\"\n                            onSave={(value) => updatePlaylist({ description: value })}\n                            saveOnBlur={true}\n                            maxLength={400}\n                            data-attr=\"playlist-description\"\n                            compactButtons\n                        />\n                        <UserActivityIndicator\n                            at={playlist.last_modified_at}\n                            by={playlist.last_modified_by}\n                            className=\"mt-2\"\n                        />\n                    </>\n                }\n            />\n            {playlist.short_id && pinnedRecordings !== null ? (\n                <div className=\"SessionRecordingPlaylistHeightWrapper\">\n                    <SessionRecordingsPlaylist\n                        logicKey={playlist.short_id}\n                        // backwards compatibilty for legacy filters\n                        filters={\n                            playlist.filters && isUniversalFilters(playlist.filters)\n                                ? playlist.filters\n                                : convertLegacyFiltersToUniversalFilters({}, playlist.filters)\n                        }\n                        onFiltersChange={setFilters}\n                        onPinnedChange={onPinnedChange}\n                        pinnedRecordings={pinnedRecordings ?? []}\n                        updateSearchParams={true}\n                    />\n                </div>\n            ) : null}\n        </div>\n    )\n}\n", "import { lemonToast } from '@posthog/lemon-ui'\nimport equal from 'fast-deep-equal'\nimport { actions, afterMount, connect, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { beforeUnload, router } from 'kea-router'\nimport api from 'lib/api'\nimport { sceneLogic } from 'scenes/sceneLogic'\nimport { Scene } from 'scenes/sceneTypes'\nimport {\n    deletePlaylist,\n    duplicatePlaylist,\n    getPlaylist,\n    summarizePlaylistFilters,\n    updatePlaylist,\n} from 'scenes/session-recordings/playlist/playlistUtils'\nimport { urls } from 'scenes/urls'\n\nimport { cohortsModel } from '~/models/cohortsModel'\nimport {\n    Breadcrumb,\n    LegacyRecordingFilters,\n    RecordingUniversalFilters,\n    ReplayTabs,\n    SessionRecordingPlaylistType,\n    SessionRecordingType,\n} from '~/types'\n\nimport { addRecordingToPlaylist, removeRecordingFromPlaylist } from '../player/utils/playerUtils'\nimport { filtersFromUniversalFilterGroups, isUniversalFilters } from '../utils'\nimport { convertLegacyFiltersToUniversalFilters, PINNED_RECORDINGS_LIMIT } from './sessionRecordingsPlaylistLogic'\nimport type { sessionRecordingsPlaylistSceneLogicType } from './sessionRecordingsPlaylistSceneLogicType'\n\nexport interface SessionRecordingsPlaylistLogicProps {\n    shortId: string\n}\n\nexport const sessionRecordingsPlaylistSceneLogic = kea<sessionRecordingsPlaylistSceneLogicType>([\n    path((key) => ['scenes', 'session-recordings', 'playlist', 'sessionRecordingsPlaylistSceneLogic', key]),\n    props({} as SessionRecordingsPlaylistLogicProps),\n    key((props) => props.shortId),\n    connect({\n        values: [cohortsModel, ['cohortsById'], sceneLogic, ['activeScene']],\n    }),\n    actions({\n        updatePlaylist: (properties?: Partial<SessionRecordingPlaylistType>, silent = false) => ({\n            properties,\n            silent,\n        }),\n        setFilters: (filters: LegacyRecordingFilters | RecordingUniversalFilters | null) => ({ filters }),\n        loadPinnedRecordings: true,\n        onPinnedChange: (recording: SessionRecordingType, pinned: boolean) => ({ pinned, recording }),\n    }),\n    loaders(({ values, props }) => ({\n        playlist: [\n            null as SessionRecordingPlaylistType | null,\n            {\n                getPlaylist: async () => {\n                    return getPlaylist(props.shortId)\n                },\n                updatePlaylist: async ({ properties, silent }) => {\n                    if (!values.playlist?.short_id) {\n                        return values.playlist\n                    }\n                    return updatePlaylist(\n                        values.playlist?.short_id,\n                        properties ?? { filters: values.filters || undefined },\n                        silent\n                    )\n                },\n                duplicatePlaylist: async () => {\n                    return duplicatePlaylist(values.playlist ?? {}, true)\n                },\n                deletePlaylist: async () => {\n                    if (values.playlist) {\n                        return deletePlaylist(values.playlist, () => {\n                            router.actions.replace(urls.replay(ReplayTabs.Playlists))\n                        })\n                    }\n                    return null\n                },\n            },\n        ],\n\n        pinnedRecordings: [\n            null as SessionRecordingType[] | null,\n            {\n                loadPinnedRecordings: async (_, breakpoint) => {\n                    if (!props.shortId) {\n                        return null\n                    }\n\n                    await breakpoint(100)\n                    const response = await api.recordings.listPlaylistRecordings(props.shortId, {\n                        limit: PINNED_RECORDINGS_LIMIT,\n                    })\n                    breakpoint()\n                    return response.results\n                },\n\n                onPinnedChange: async ({ recording, pinned }) => {\n                    let newResults = values.pinnedRecordings ?? []\n\n                    newResults = newResults.filter((r) => r.id !== recording.id)\n\n                    if (pinned) {\n                        await addRecordingToPlaylist(props.shortId, recording.id)\n                        newResults.push(recording)\n                    } else {\n                        await removeRecordingFromPlaylist(props.shortId, recording.id)\n                    }\n\n                    return newResults\n                },\n            },\n        ],\n    })),\n    reducers(() => ({\n        filters: [\n            null as LegacyRecordingFilters | RecordingUniversalFilters | null,\n            {\n                getPlaylistSuccess: (_, { playlist }) => playlist?.filters || null,\n                updatePlaylistSuccess: (_, { playlist }) => playlist?.filters || null,\n                setFilters: (_, { filters }) => filters,\n            },\n        ],\n    })),\n\n    listeners(({ actions, values }) => ({\n        getPlaylistSuccess: () => {\n            if (values.playlist?.derived_name !== values.derivedName) {\n                // This keeps the derived name up to date if the playlist changes\n                actions.updatePlaylist({ derived_name: values.derivedName }, true)\n            }\n        },\n    })),\n\n    beforeUnload(({ values, actions }) => ({\n        enabled: (newLocation) =>\n            values.activeScene === Scene.ReplayPlaylist &&\n            values.hasChanges &&\n            newLocation?.pathname !== router.values.location.pathname,\n        message: 'Leave playlist?\\nChanges you made will be discarded.',\n        onConfirm: () => {\n            actions.setFilters(values.playlist?.filters || null)\n        },\n    })),\n\n    selectors(({ asyncActions }) => ({\n        breadcrumbs: [\n            (s) => [s.playlist],\n            (playlist): Breadcrumb[] => [\n                {\n                    key: Scene.Replay,\n                    name: 'Replay',\n                    path: urls.replay(),\n                },\n                {\n                    key: ReplayTabs.Playlists,\n                    name: 'Playlists',\n                    path: urls.replay(ReplayTabs.Playlists),\n                },\n                {\n                    key: [Scene.ReplayPlaylist, playlist?.short_id || 'new'],\n                    name: playlist?.name || playlist?.derived_name || 'Unnamed',\n                    onRename: async (name: string) => {\n                        if (!playlist) {\n                            lemonToast.error('Cannot rename unsaved playlist')\n                            return\n                        }\n                        await asyncActions.updatePlaylist({ short_id: playlist.short_id, name })\n                    },\n                },\n            ],\n        ],\n        hasChanges: [\n            (s) => [s.playlist, s.filters],\n            (playlist, filters): boolean => {\n                return !equal(playlist?.filters, filters)\n            },\n        ],\n        derivedName: [\n            (s) => [s.filters, s.cohortsById],\n            (filters, cohortsById) => {\n                if (!filters) {\n                    return 'Unnamed'\n                }\n\n                const universalFilters = isUniversalFilters(filters)\n                    ? filters\n                    : convertLegacyFiltersToUniversalFilters({}, filters)\n\n                return (\n                    summarizePlaylistFilters(filtersFromUniversalFilterGroups(universalFilters), cohortsById)?.slice(\n                        0,\n                        400\n                    ) || 'Unnamed'\n                )\n            },\n        ],\n    })),\n\n    afterMount(({ actions }) => {\n        actions.getPlaylist()\n        actions.loadPinnedRecordings()\n    }),\n])\n"],
  "mappings": "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",
  "names": ["init_dirname", "init_buffer", "init_process", "import_kea", "init_dirname", "init_buffer", "init_process", "import_fast_deep_equal", "import_kea", "import_kea_loaders", "import_kea_router", "sessionRecordingsPlaylistSceneLogic", "key", "props", "cohortsModel", "sceneLogic", "properties", "silent", "filters", "recording", "pinned", "values", "getPlaylist", "updatePlaylist", "duplicatePlaylist", "deletePlaylist", "urls", "_", "breakpoint", "response", "api_default", "PINNED_RECORDINGS_LIMIT", "newResults", "r", "addRecordingToPlaylist", "removeRecordingFromPlaylist", "playlist", "actions", "newLocation", "asyncActions", "s", "name", "lemonToast", "equal", "cohortsById", "universalFilters", "isUniversalFilters", "convertLegacyFiltersToUniversalFilters", "summarizePlaylistFilters", "filtersFromUniversalFilterGroups", "import_jsx_runtime", "scene", "SessionRecordingsPlaylistScene", "sessionRecordingsPlaylistSceneLogic", "id", "playlist", "playlistLoading", "pinnedRecordings", "hasChanges", "setFilters", "updatePlaylist", "duplicatePlaylist", "deletePlaylist", "onPinnedChange", "showFilters", "playerSettingsLogic", "setShowFilters", "LemonSkeleton", "PageHeader", "More", "LemonButton", "LemonDivider", "EditableField", "value", "UserActivityIndicator", "SessionRecordingsPlaylist", "isUniversalFilters", "convertLegacyFiltersToUniversalFilters", "NotFound"]
}
