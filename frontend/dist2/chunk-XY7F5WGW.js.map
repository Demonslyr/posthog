{
  "version": 3,
  "sources": ["../src/scenes/surveys/surveyLogic.tsx"],
  "sourcesContent": ["import { lemonToast } from '@posthog/lemon-ui'\nimport { actions, afterMount, connect, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { actionToUrl, router, urlToAction } from 'kea-router'\nimport api from 'lib/api'\nimport { dayjs } from 'lib/dayjs'\nimport { featureFlagLogic as enabledFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { allOperatorsMapping, debounce, hasFormErrors, isObject } from 'lib/utils'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport { Scene } from 'scenes/sceneTypes'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { urls } from 'scenes/urls'\n\nimport { activationLogic, ActivationTask } from '~/layout/navigation-3000/sidepanel/panels/activation/activationLogic'\nimport { CompareFilter, DataTableNode, HogQLQuery, InsightVizNode, NodeKind } from '~/queries/schema/schema-general'\nimport { hogql } from '~/queries/utils'\nimport {\n    AnyPropertyFilter,\n    BaseMathType,\n    Breadcrumb,\n    EventPropertyFilter,\n    FeatureFlagFilters,\n    IntervalType,\n    MultipleSurveyQuestion,\n    PropertyFilterType,\n    PropertyOperator,\n    RatingSurveyQuestion,\n    Survey,\n    SurveyMatchType,\n    SurveyQuestionBase,\n    SurveyQuestionBranchingType,\n    SurveyQuestionType,\n    SurveySchedule,\n} from '~/types'\n\nimport { defaultSurveyAppearance, defaultSurveyFieldValues, NEW_SURVEY, NewSurvey } from './constants'\nimport type { surveyLogicType } from './surveyLogicType'\nimport { surveysLogic } from './surveysLogic'\nimport { getSurveyResponseKey, sanitizeHTML, sanitizeSurveyAppearance, validateColor } from './utils'\n\nconst DEFAULT_OPERATORS: Record<SurveyQuestionType, { label: string; value: PropertyOperator }> = {\n    [SurveyQuestionType.Open]: {\n        label: allOperatorsMapping[PropertyOperator.IContains],\n        value: PropertyOperator.IContains,\n    },\n    [SurveyQuestionType.Rating]: {\n        label: allOperatorsMapping[PropertyOperator.Exact],\n        value: PropertyOperator.Exact,\n    },\n    [SurveyQuestionType.SingleChoice]: {\n        label: allOperatorsMapping[PropertyOperator.Exact],\n        value: PropertyOperator.Exact,\n    },\n    [SurveyQuestionType.MultipleChoice]: {\n        label: allOperatorsMapping[PropertyOperator.IContains],\n        value: PropertyOperator.IContains,\n    },\n    [SurveyQuestionType.Link]: {\n        label: allOperatorsMapping[PropertyOperator.Exact],\n        value: PropertyOperator.Exact,\n    },\n}\n\nexport enum SurveyEditSection {\n    Steps = 'steps',\n    Widget = 'widget',\n    Presentation = 'presentation',\n    Appearance = 'appearance',\n    Customization = 'customization',\n    DisplayConditions = 'DisplayConditions',\n    Scheduling = 'scheduling',\n    CompletionConditions = 'CompletionConditions',\n}\nexport interface SurveyLogicProps {\n    /** Either a UUID or 'new'. */\n    id: string\n}\n\nexport interface SurveyMetricsQueries {\n    surveysShown: DataTableNode\n    surveysDismissed: DataTableNode\n}\n\nexport interface SurveyUserStats {\n    seen: number\n    dismissed: number\n    sent: number\n}\n\nexport interface SurveyRatingResults {\n    [key: number]: {\n        data: number[]\n        total: number\n    }\n}\n\nexport interface SurveyRecurringNPSResults {\n    [key: number]: {\n        data: number[]\n        total: number\n    }\n}\n\ntype SurveyNPSResult = {\n    Promoters: number\n    Detractors: number\n    Passives: number\n}\n\nexport interface SurveySingleChoiceResults {\n    [key: number]: {\n        labels: string[]\n        data: number[]\n        total: number\n    }\n}\n\nexport interface SurveyMultipleChoiceResults {\n    [key: number]: {\n        labels: string[]\n        data: number[]\n    }\n}\n\nexport interface SurveyOpenTextResults {\n    [key: number]: {\n        events: { distinct_id: string; properties: Record<string, any>; personProperties: Record<string, any> }[]\n    }\n}\n\nexport interface QuestionResultsReady {\n    [key: string]: boolean\n}\n\nexport type DataCollectionType = 'until_stopped' | 'until_limit' | 'until_adaptive_limit'\n\nexport interface SurveyDateRange {\n    date_from: string | null\n    date_to: string | null\n}\n\nconst getResponseField = (i: number): string => (i === 0 ? '$survey_response' : `$survey_response_${i}`)\n\nfunction duplicateExistingSurvey(survey: Survey | NewSurvey): Partial<Survey> {\n    return {\n        ...survey,\n        id: NEW_SURVEY.id,\n        name: `${survey.name} (copy)`,\n        archived: false,\n        start_date: null,\n        end_date: null,\n        targeting_flag_filters: survey.targeting_flag?.filters ?? NEW_SURVEY.targeting_flag_filters,\n        linked_flag_id: survey.linked_flag?.id ?? NEW_SURVEY.linked_flag_id,\n    }\n}\n\nconst DATE_FORMAT = 'YYYY-MM-DD HH:mm:ss'\n\nfunction getSurveyEndDateForQuery(survey: Survey): string {\n    return survey.end_date\n        ? dayjs(survey.end_date).endOf('day').format(DATE_FORMAT)\n        : dayjs().endOf('day').format(DATE_FORMAT)\n}\n\nexport const surveyLogic = kea<surveyLogicType>([\n    props({} as SurveyLogicProps),\n    key(({ id }) => id),\n    path((key) => ['scenes', 'surveys', 'surveyLogic', key]),\n    connect(() => ({\n        actions: [\n            surveysLogic,\n            ['loadSurveys'],\n            eventUsageLogic,\n            [\n                'reportSurveyCreated',\n                'reportSurveyEdited',\n                'reportSurveyArchived',\n                'reportSurveyViewed',\n                'reportSurveyCycleDetected',\n            ],\n        ],\n        values: [enabledFlagLogic, ['featureFlags as enabledFlags'], surveysLogic, ['surveys']],\n    })),\n    actions({\n        setSurveyMissing: true,\n        editingSurvey: (editing: boolean) => ({ editing }),\n        setDefaultForQuestionType: (\n            idx: number,\n            type: SurveyQuestionType,\n            isEditingQuestion: boolean,\n            isEditingDescription: boolean,\n            isEditingThankYouMessage: boolean\n        ) => ({\n            idx,\n            type,\n            isEditingQuestion,\n            isEditingDescription,\n            isEditingThankYouMessage,\n        }),\n        setQuestionBranchingType: (questionIndex, type, specificQuestionIndex) => ({\n            questionIndex,\n            type,\n            specificQuestionIndex,\n        }),\n        setResponseBasedBranchingForQuestion: (questionIndex, responseValue, nextStep, specificQuestionIndex) => ({\n            questionIndex,\n            responseValue,\n            nextStep,\n            specificQuestionIndex,\n        }),\n        setDataCollectionType: (dataCollectionType: DataCollectionType) => ({\n            dataCollectionType,\n        }),\n        resetBranchingForQuestion: (questionIndex) => ({ questionIndex }),\n        deleteBranchingLogic: true,\n        archiveSurvey: true,\n        setWritingHTMLDescription: (writingHTML: boolean) => ({ writingHTML }),\n        setSurveyTemplateValues: (template: any) => ({ template }),\n        setSelectedPageIndex: (idx: number | null) => ({ idx }),\n        setSelectedSection: (section: SurveyEditSection | null) => ({ section }),\n        resetTargeting: true,\n        resetSurveyAdaptiveSampling: true,\n        resetSurveyResponseLimits: true,\n        setFlagPropertyErrors: (errors: any) => ({ errors }),\n        setPropertyFilters: (propertyFilters: AnyPropertyFilter[]) => ({ propertyFilters }),\n        setAnswerFilters: (filters: EventPropertyFilter[], reloadResults: boolean = true) => ({\n            filters,\n            reloadResults,\n        }),\n        setDateRange: (dateRange: SurveyDateRange) => ({ dateRange }),\n        setInterval: (interval: IntervalType) => ({ interval }),\n        setCompareFilter: (compareFilter: CompareFilter | null) => ({ compareFilter }),\n    }),\n    loaders(({ props, actions, values }) => ({\n        responseSummary: {\n            summarize: async ({ questionIndex }: { questionIndex?: number }) => {\n                return api.surveys.summarize_responses(props.id, questionIndex)\n            },\n        },\n        survey: {\n            loadSurvey: async () => {\n                if (props.id && props.id !== 'new') {\n                    try {\n                        const survey = await api.surveys.get(props.id)\n                        actions.reportSurveyViewed(survey)\n                        // Initialize answer filters for all questions\n                        actions.setAnswerFilters(\n                            survey.questions.map((question, index) => ({\n                                key: getSurveyResponseKey(index),\n                                operator: DEFAULT_OPERATORS[question.type].value,\n                                type: PropertyFilterType.Event as const,\n                                value: [],\n                            })),\n                            false\n                        )\n                        return survey\n                    } catch (error: any) {\n                        if (error.status === 404) {\n                            actions.setSurveyMissing()\n                            return { ...NEW_SURVEY }\n                        }\n                        throw error\n                    }\n                }\n                if (props.id === 'new' && router.values.hashParams.fromTemplate) {\n                    const templatedSurvey = values.survey\n                    templatedSurvey.appearance = {\n                        ...defaultSurveyAppearance,\n                        ...teamLogic.values.currentTeam?.survey_config?.appearance,\n                        ...templatedSurvey.appearance,\n                    }\n                    return templatedSurvey\n                }\n\n                const newSurvey = NEW_SURVEY\n                newSurvey.appearance = {\n                    ...defaultSurveyAppearance,\n                    ...teamLogic.values.currentTeam?.survey_config?.appearance,\n                    ...newSurvey.appearance,\n                }\n\n                return newSurvey\n            },\n            createSurvey: async (surveyPayload: Partial<Survey>) => {\n                return await api.surveys.create(sanitizeQuestions(surveyPayload))\n            },\n            updateSurvey: async (surveyPayload: Partial<Survey>) => {\n                return await api.surveys.update(props.id, sanitizeQuestions(surveyPayload))\n            },\n            launchSurvey: async () => {\n                const startDate = dayjs()\n                return await api.surveys.update(props.id, { start_date: startDate.toISOString() })\n            },\n            stopSurvey: async () => {\n                return await api.surveys.update(props.id, { end_date: dayjs().toISOString() })\n            },\n            resumeSurvey: async () => {\n                return await api.surveys.update(props.id, { end_date: null })\n            },\n        },\n        duplicatedSurvey: {\n            duplicateSurvey: async () => {\n                const { survey } = values\n                const payload = duplicateExistingSurvey(survey)\n                const createdSurvey = await api.surveys.create(sanitizeQuestions(payload))\n\n                lemonToast.success('Survey duplicated.', {\n                    toastId: `survey-duplicated-${createdSurvey.id}`,\n                    button: {\n                        label: 'View Survey',\n                        action: () => {\n                            router.actions.push(urls.survey(createdSurvey.id))\n                        },\n                    },\n                })\n\n                actions.reportSurveyCreated(createdSurvey, true)\n                return survey\n            },\n        },\n        surveyUserStats: {\n            loadSurveyUserStats: async (): Promise<SurveyUserStats> => {\n                const survey: Survey = values.survey as Survey\n                const startDate = dayjs(survey.start_date || survey.created_at).format(DATE_FORMAT)\n                const endDate = getSurveyEndDateForQuery(survey)\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: hogql`\n                        SELECT\n                            (SELECT COUNT(DISTINCT person_id)\n                                FROM events\n                                WHERE event = 'survey shown'\n                                    AND properties.$survey_id = ${props.id}\n                                    AND timestamp >= ${startDate}\n                                    AND timestamp <= ${endDate}\n                                    AND {filters}),\n                            (SELECT COUNT(DISTINCT person_id)\n                                FROM events\n                                WHERE event = 'survey dismissed'\n                                    AND properties.$survey_id = ${props.id}\n                                    AND timestamp >= ${startDate}\n                                    AND timestamp <= ${endDate}\n                                    AND {filters}),\n                            (SELECT COUNT(DISTINCT person_id)\n                                FROM events\n                                WHERE event = 'survey sent'\n                                    AND properties.$survey_id = ${props.id}\n                                    AND timestamp >= ${startDate}\n                                    AND timestamp <= ${endDate}\n                                    AND {filters})\n                    `,\n                    filters: {\n                        properties: [...values.propertyFilters, ...values.answerFilters],\n                    },\n                }\n\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n                if (results && results[0]) {\n                    const [totalSeen, dismissed, sent] = results[0]\n                    const onlySeen = totalSeen - dismissed - sent\n                    return { seen: onlySeen < 0 ? 0 : onlySeen, dismissed, sent }\n                }\n                return { seen: 0, dismissed: 0, sent: 0 }\n            },\n        },\n        surveyRatingResults: {\n            loadSurveyRatingResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveyRatingResults> => {\n                const question = values.survey.questions[questionIndex]\n                if (question.type !== SurveyQuestionType.Rating) {\n                    throw new Error(`Survey question type must be ${SurveyQuestionType.Rating}`)\n                }\n\n                const survey: Survey = values.survey as Survey\n                const startDate = dayjs(survey.start_date || survey.created_at).format(DATE_FORMAT)\n                const endDate = getSurveyEndDateForQuery(survey)\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        SELECT\n                            JSONExtractString(properties, '${getResponseField(questionIndex)}') AS survey_response,\n                            COUNT(survey_response)\n                        FROM events\n                        WHERE event = 'survey sent'\n                            AND properties.$survey_id = '${props.id}'\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                            AND {filters}\n                        GROUP BY survey_response\n                    `,\n                    filters: {\n                        properties: [...values.propertyFilters, ...values.answerFilters],\n                    },\n                }\n\n                const responseJSON = await api.query(query)\n                // TODO:Dylan - I don't like how we lose our types here\n                // would be cool if we could parse this in a more type-safe way\n                const { results } = responseJSON\n\n                let total = 0\n                const dataSize = question.scale === 10 ? 11 : question.scale\n                const data = new Array(dataSize).fill(0)\n                results?.forEach(([value, count]) => {\n                    total += count\n\n                    const index = question.scale === 10 ? value : value - 1\n                    data[index] = count\n                })\n\n                return { ...values.surveyRatingResults, [questionIndex]: { total, data } }\n            },\n        },\n        surveyRecurringNPSResults: {\n            loadSurveyRecurringNPSResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveyRecurringNPSResults> => {\n                const question = values.survey.questions[questionIndex]\n                if (question.type !== SurveyQuestionType.Rating) {\n                    throw new Error(`Survey question type must be ${SurveyQuestionType.Rating}`)\n                }\n\n                const survey: Survey = values.survey as Survey\n                const startDate = dayjs(survey.start_date || survey.created_at).format(DATE_FORMAT)\n                const endDate = getSurveyEndDateForQuery(survey)\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        SELECT\n                            JSONExtractString(properties, '$survey_iteration') AS survey_iteration,\n                            JSONExtractString(properties, '${getResponseField(questionIndex)}') AS survey_response,\n                            COUNT(survey_response)\n                        FROM events\n                        WHERE event = 'survey sent'\n                            AND properties.$survey_id = '${survey.id}'\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                            AND {filters}\n                        GROUP BY survey_response, survey_iteration\n                    `,\n                    filters: {\n                        properties: [...values.propertyFilters, ...values.answerFilters],\n                    },\n                }\n\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n                let total = 100\n                const data = new Array(survey.iteration_count).fill(0)\n\n                const iterations = new Map<string, SurveyNPSResult>()\n\n                results?.forEach(([iteration, response, count]) => {\n                    let promoters = 0\n                    let passives = 0\n                    let detractors = 0\n\n                    if (parseInt(response) >= 9) {\n                        // a Promoter is someone who gives a survey response of 9 or 10\n                        promoters += parseInt(count)\n                    } else if (parseInt(response) > 6) {\n                        // a Passive is someone who gives a survey response of 7 or 8\n                        passives += parseInt(count)\n                    } else {\n                        // a Detractor is someone who gives a survey response of 0 - 6\n                        detractors += parseInt(count)\n                    }\n\n                    if (iterations.has(iteration)) {\n                        const currentValue = iterations.get(iteration)\n                        if (currentValue !== undefined) {\n                            currentValue.Detractors += detractors\n                            currentValue.Promoters += promoters\n                            currentValue.Passives += passives\n                        }\n                    } else {\n                        iterations.set(iteration, {\n                            Detractors: detractors,\n                            Passives: passives,\n                            Promoters: promoters,\n                        })\n                    }\n                })\n\n                iterations.forEach((value: SurveyNPSResult, key: string) => {\n                    // NPS score is calculated with this formula\n                    // (Promoters / (Promoters + Passives + Detractors) * 100) - (Detractors / (Promoters + Passives + Detractors)* 100)\n                    const totalResponses = value.Promoters + value.Passives + value.Detractors\n                    const npsScore =\n                        (value.Promoters / totalResponses) * 100 - (value.Detractors / totalResponses) * 100\n                    data[parseInt(key) - 1] = npsScore\n                    total += 100\n                })\n\n                return { ...values.surveyRecurringNPSResults, [questionIndex]: { total, data } }\n            },\n        },\n        surveySingleChoiceResults: {\n            loadSurveySingleChoiceResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveySingleChoiceResults> => {\n                const survey: Survey = values.survey as Survey\n                const startDate = dayjs(survey.start_date || survey.created_at).format(DATE_FORMAT)\n                const endDate = getSurveyEndDateForQuery(survey)\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        SELECT\n                            JSONExtractString(properties, '${getResponseField(questionIndex)}') AS survey_response,\n                            COUNT(survey_response)\n                        FROM events\n                        WHERE event = 'survey sent'\n                            AND properties.$survey_id = '${props.id}'\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                            AND {filters}\n                        GROUP BY survey_response\n                    `,\n                    filters: {\n                        properties: [...values.propertyFilters, ...values.answerFilters],\n                    },\n                }\n\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n\n                const labels = results?.map((r) => r[0])\n                const data = results?.map((r) => r[1])\n                const total = data?.reduce((a, b) => a + b, 0)\n\n                return { ...values.surveySingleChoiceResults, [questionIndex]: { labels, data, total } }\n            },\n        },\n        surveyMultipleChoiceResults: {\n            loadSurveyMultipleChoiceResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveyMultipleChoiceResults> => {\n                const question = values.survey.questions[questionIndex]\n                if (question.type !== SurveyQuestionType.MultipleChoice) {\n                    throw new Error(`Survey question type must be ${SurveyQuestionType.MultipleChoice}`)\n                }\n\n                const survey: Survey = values.survey as Survey\n                const startDate = dayjs(survey.start_date || survey.created_at).format(DATE_FORMAT)\n                const endDate = getSurveyEndDateForQuery(survey)\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        SELECT\n                            count(),\n                            arrayJoin(JSONExtractArrayRaw(properties, '${getResponseField(questionIndex)}')) AS choice\n                        FROM events\n                        WHERE event == 'survey sent'\n                            AND properties.$survey_id == '${survey.id}'\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                            AND {filters}\n                        GROUP BY choice\n                        ORDER BY count() DESC\n                    `,\n                    filters: {\n                        properties: [...values.propertyFilters, ...values.answerFilters],\n                    },\n                }\n\n                const responseJSON = await api.query(query)\n                let { results } = responseJSON\n\n                // Remove outside quotes\n                results = results?.map((r) => {\n                    return [r[0], r[1].slice(1, r[1].length - 1)]\n                })\n\n                // Zero-fill choices that are not open-ended\n                question.choices.forEach((choice, idx) => {\n                    const isOpenChoice = idx == question.choices.length - 1 && question?.hasOpenChoice\n                    if (results?.length && !isOpenChoice && !results.some((r) => r[1] === choice)) {\n                        results.push([0, choice])\n                    }\n                })\n\n                const data = results?.map((r) => r[0])\n                const labels = results?.map((r) => r[1])\n\n                return { ...values.surveyMultipleChoiceResults, [questionIndex]: { labels, data } }\n            },\n        },\n        surveyOpenTextResults: {\n            loadSurveyOpenTextResults: async ({\n                questionIndex,\n            }: {\n                questionIndex: number\n            }): Promise<SurveyOpenTextResults> => {\n                const question = values.survey.questions[questionIndex]\n                if (question.type !== SurveyQuestionType.Open) {\n                    throw new Error(`Survey question type must be ${SurveyQuestionType.Open}`)\n                }\n\n                const survey: Survey = values.survey as Survey\n                const startDate = dayjs(survey.start_date || survey.created_at).format(DATE_FORMAT)\n                const endDate = getSurveyEndDateForQuery(survey)\n\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: `\n                        SELECT distinct_id, properties, person.properties\n                        FROM events\n                        WHERE event == 'survey sent'\n                            AND properties.$survey_id == '${survey.id}'\n                            AND trim(JSONExtractString(properties, '${getResponseField(questionIndex)}')) != ''\n                            AND timestamp >= '${startDate}'\n                            AND timestamp <= '${endDate}'\n                            AND {filters}\n                        LIMIT 20\n                    `,\n                    filters: {\n                        properties: [...values.propertyFilters, ...values.answerFilters],\n                    },\n                }\n\n                const responseJSON = await api.query(query)\n                const { results } = responseJSON\n\n                const events =\n                    results?.map((r) => {\n                        const distinct_id = r[0]\n                        const properties = JSON.parse(r[1])\n                        const personProperties = JSON.parse(r[2])\n                        return { distinct_id, properties, personProperties }\n                    }) || []\n\n                return { ...values.surveyOpenTextResults, [questionIndex]: { events } }\n            },\n        },\n    })),\n    listeners(({ actions, values }) => {\n        const reloadAllSurveyResults = debounce((): void => {\n            // Load survey user stats\n            actions.loadSurveyUserStats()\n\n            // Load results for each question\n            values.survey.questions.forEach((question, index) => {\n                switch (question.type) {\n                    case SurveyQuestionType.Rating:\n                        actions.loadSurveyRatingResults({\n                            questionIndex: index,\n                        })\n                        if (values.survey.iteration_count && values.survey.iteration_count > 0) {\n                            actions.loadSurveyRecurringNPSResults({ questionIndex: index })\n                        }\n                        break\n                    case SurveyQuestionType.SingleChoice:\n                        actions.loadSurveySingleChoiceResults({ questionIndex: index })\n                        break\n                    case SurveyQuestionType.MultipleChoice:\n                        actions.loadSurveyMultipleChoiceResults({ questionIndex: index })\n                        break\n                    case SurveyQuestionType.Open:\n                        actions.loadSurveyOpenTextResults({ questionIndex: index })\n                        break\n                }\n            })\n        }, 1000)\n\n        return {\n            createSurveySuccess: ({ survey }) => {\n                lemonToast.success(<>Survey {survey.name} created</>)\n                actions.loadSurveys()\n                router.actions.replace(urls.survey(survey.id))\n                actions.reportSurveyCreated(survey)\n            },\n            updateSurveySuccess: ({ survey }) => {\n                lemonToast.success(<>Survey {survey.name} updated</>)\n                actions.editingSurvey(false)\n                actions.reportSurveyEdited(survey)\n                actions.loadSurveys()\n            },\n            duplicateSurveySuccess: () => {\n                actions.loadSurveys()\n            },\n            launchSurveySuccess: ({ survey }) => {\n                lemonToast.success(<>Survey {survey.name} launched</>)\n                actions.loadSurveys()\n            },\n            stopSurveySuccess: () => {\n                actions.loadSurveys()\n            },\n            resumeSurveySuccess: () => {\n                actions.loadSurveys()\n            },\n            archiveSurvey: () => {\n                actions.updateSurvey({ archived: true })\n            },\n            loadSurveySuccess: () => {\n                actions.loadSurveyUserStats()\n\n                if (values.survey.start_date) {\n                    activationLogic.findMounted()?.actions.markTaskAsCompleted(ActivationTask.LaunchSurvey)\n                }\n\n                // Initialize date range based on survey dates when survey is loaded\n                if ('created_at' in values.survey) {\n                    const dateRange = {\n                        date_from: dayjs(values.survey.created_at).startOf('day').format(DATE_FORMAT),\n                        date_to: getSurveyEndDateForQuery(values.survey),\n                    }\n                    actions.setDateRange(dateRange)\n                }\n            },\n            resetSurveyResponseLimits: () => {\n                actions.setSurveyValue('responses_limit', null)\n            },\n\n            resetSurveyAdaptiveSampling: () => {\n                actions.setSurveyValues({\n                    response_sampling_interval: null,\n                    response_sampling_interval_type: null,\n                    response_sampling_limit: null,\n                    response_sampling_start_date: null,\n                    response_sampling_daily_limits: null,\n                })\n            },\n            resetTargeting: () => {\n                actions.setSurveyValue('linked_flag_id', NEW_SURVEY.linked_flag_id)\n                actions.setSurveyValue('targeting_flag_filters', NEW_SURVEY.targeting_flag_filters)\n                actions.setSurveyValue('linked_flag', NEW_SURVEY.linked_flag)\n                actions.setSurveyValue('targeting_flag', NEW_SURVEY.targeting_flag)\n                actions.setSurveyValue('conditions', NEW_SURVEY.conditions)\n                actions.setSurveyValue('remove_targeting_flag', true)\n                actions.setSurveyValue('responses_limit', NEW_SURVEY.responses_limit)\n                actions.setSurveyValues({\n                    iteration_count: NEW_SURVEY.iteration_count,\n                    iteration_frequency_days: NEW_SURVEY.iteration_frequency_days,\n                })\n                actions.setFlagPropertyErrors(null)\n            },\n            submitSurveyFailure: async () => {\n                // When errors occur, scroll to the error, but wait for errors to be set in the DOM first\n                if (hasFormErrors(values.flagPropertyErrors) || values.urlMatchTypeValidationError) {\n                    actions.setSelectedSection(SurveyEditSection.DisplayConditions)\n                } else if (hasFormErrors(values.survey.appearance)) {\n                    actions.setSelectedSection(SurveyEditSection.Customization)\n                } else {\n                    actions.setSelectedSection(SurveyEditSection.Steps)\n                }\n                setTimeout(\n                    () =>\n                        document\n                            .querySelector(`.Field--error`)\n                            ?.scrollIntoView({ block: 'center', behavior: 'smooth' }),\n                    5\n                )\n            },\n            setPropertyFilters: () => {\n                reloadAllSurveyResults()\n            },\n            setAnswerFilters: ({ reloadResults }) => {\n                if (reloadResults) {\n                    reloadAllSurveyResults()\n                }\n            },\n        }\n    }),\n    reducers({\n        isEditingSurvey: [\n            false,\n            {\n                editingSurvey: (_, { editing }) => editing,\n            },\n        ],\n        surveyMissing: [\n            false,\n            {\n                setSurveyMissing: () => true,\n            },\n        ],\n        dataCollectionType: [\n            'until_stopped' as DataCollectionType,\n            {\n                setDataCollectionType: (_, { dataCollectionType }) => dataCollectionType,\n            },\n        ],\n        propertyFilters: [\n            [] as AnyPropertyFilter[],\n            {\n                setPropertyFilters: (_, { propertyFilters }) => propertyFilters,\n            },\n        ],\n        survey: [\n            { ...NEW_SURVEY } as NewSurvey | Survey,\n            {\n                setDefaultForQuestionType: (\n                    state,\n                    { idx, type, isEditingQuestion, isEditingDescription, isEditingThankYouMessage }\n                ) => {\n                    const question = isEditingQuestion\n                        ? state.questions[idx].question\n                        : defaultSurveyFieldValues[type].questions[0].question\n                    const description = isEditingDescription\n                        ? state.questions[idx].description\n                        : defaultSurveyFieldValues[type].questions[0].description\n                    const thankYouMessageHeader = isEditingThankYouMessage\n                        ? state.appearance?.thankYouMessageHeader\n                        : defaultSurveyFieldValues[type].appearance.thankYouMessageHeader\n                    const newQuestions = [...state.questions]\n                    newQuestions[idx] = {\n                        ...state.questions[idx],\n                        ...(defaultSurveyFieldValues[type].questions[0] as SurveyQuestionBase),\n                        question,\n                        description,\n                    }\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                        appearance: {\n                            ...state.appearance,\n                            ...defaultSurveyFieldValues[type].appearance,\n                            thankYouMessageHeader,\n                        },\n                    }\n                },\n                setSurveyTemplateValues: (_, { template }) => {\n                    const newTemplateSurvey = { ...NEW_SURVEY, ...template }\n                    return newTemplateSurvey\n                },\n                setQuestionBranchingType: (state, { questionIndex, type, specificQuestionIndex }) => {\n                    const newQuestions = [...state.questions]\n                    const question = newQuestions[questionIndex]\n\n                    if (type === SurveyQuestionBranchingType.NextQuestion) {\n                        delete question.branching\n                    } else if (type === SurveyQuestionBranchingType.End) {\n                        question.branching = {\n                            type: SurveyQuestionBranchingType.End,\n                        }\n                    } else if (type === SurveyQuestionBranchingType.ResponseBased) {\n                        if (\n                            question.type !== SurveyQuestionType.Rating &&\n                            question.type !== SurveyQuestionType.SingleChoice\n                        ) {\n                            throw new Error(\n                                `Survey question type must be ${SurveyQuestionType.Rating} or ${SurveyQuestionType.SingleChoice}`\n                            )\n                        }\n\n                        question.branching = {\n                            type: SurveyQuestionBranchingType.ResponseBased,\n                            responseValues: {},\n                        }\n                    } else if (type === SurveyQuestionBranchingType.SpecificQuestion) {\n                        question.branching = {\n                            type: SurveyQuestionBranchingType.SpecificQuestion,\n                            index: specificQuestionIndex,\n                        }\n                    }\n\n                    newQuestions[questionIndex] = question\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                    }\n                },\n                setResponseBasedBranchingForQuestion: (\n                    state,\n                    { questionIndex, responseValue, nextStep, specificQuestionIndex }\n                ) => {\n                    const newQuestions = [...state.questions]\n                    const question = newQuestions[questionIndex]\n\n                    if (\n                        question.type !== SurveyQuestionType.Rating &&\n                        question.type !== SurveyQuestionType.SingleChoice\n                    ) {\n                        throw new Error(\n                            `Survey question type must be ${SurveyQuestionType.Rating} or ${SurveyQuestionType.SingleChoice}`\n                        )\n                    }\n\n                    if (question.branching?.type !== SurveyQuestionBranchingType.ResponseBased) {\n                        throw new Error(\n                            `Survey question branching type must be ${SurveyQuestionBranchingType.ResponseBased}`\n                        )\n                    }\n\n                    if ('responseValues' in question.branching) {\n                        if (nextStep === SurveyQuestionBranchingType.NextQuestion) {\n                            delete question.branching.responseValues[responseValue]\n                        } else if (nextStep === SurveyQuestionBranchingType.End) {\n                            question.branching.responseValues[responseValue] = SurveyQuestionBranchingType.End\n                        } else if (nextStep === SurveyQuestionBranchingType.SpecificQuestion) {\n                            question.branching.responseValues[responseValue] = specificQuestionIndex\n                        }\n                    }\n\n                    newQuestions[questionIndex] = question\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                    }\n                },\n                resetBranchingForQuestion: (state, { questionIndex }) => {\n                    const newQuestions = [...state.questions]\n                    const question = newQuestions[questionIndex]\n                    delete question.branching\n\n                    newQuestions[questionIndex] = question\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                    }\n                },\n                deleteBranchingLogic: (state) => {\n                    const newQuestions = [...state.questions]\n                    newQuestions.forEach((question) => {\n                        delete question.branching\n                    })\n\n                    return {\n                        ...state,\n                        questions: newQuestions,\n                    }\n                },\n            },\n        ],\n        selectedPageIndex: [\n            0 as number | null,\n            {\n                setSelectedPageIndex: (_, { idx }) => idx,\n            },\n        ],\n        selectedSection: [\n            SurveyEditSection.Steps as SurveyEditSection | null,\n            {\n                setSelectedSection: (_, { section }) => section,\n            },\n        ],\n        surveyRatingResultsReady: [\n            {},\n            {\n                loadSurveyRatingResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        surveyRecurringNPSResultsReady: [\n            {},\n            {\n                loadSurveyRecurringNPSResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        surveySingleChoiceResultsReady: [\n            {},\n            {\n                loadSurveySingleChoiceResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        surveyMultipleChoiceResultsReady: [\n            {},\n            {\n                loadSurveyMultipleChoiceResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        surveyOpenTextResultsReady: [\n            {},\n            {\n                loadSurveyOpenTextResultsSuccess: (state, { payload }) => {\n                    if (!payload || !payload.hasOwnProperty('questionIndex')) {\n                        return { ...state }\n                    }\n                    return { ...state, [payload.questionIndex]: true }\n                },\n            },\n        ],\n        writingHTMLDescription: [\n            false,\n            {\n                setWritingHTMLDescription: (_, { writingHTML }) => writingHTML,\n            },\n        ],\n        flagPropertyErrors: [\n            null as any,\n            {\n                setFlagPropertyErrors: (_, { errors }) => errors,\n            },\n        ],\n        answerFilters: [\n            [] as EventPropertyFilter[],\n            {\n                setAnswerFilters: (_, { filters }) => filters,\n            },\n        ],\n        dateRange: [\n            null as SurveyDateRange | null,\n            {\n                setDateRange: (_, { dateRange }) => dateRange,\n            },\n        ],\n        interval: [\n            null as IntervalType | null,\n            {\n                setInterval: (_, { interval }) => interval,\n            },\n        ],\n        compareFilter: [\n            null as CompareFilter | null,\n            {\n                setCompareFilter: (_, { compareFilter }) => compareFilter,\n            },\n        ],\n    }),\n    selectors({\n        isAnyResultsLoading: [\n            (s) => [\n                s.surveyUserStatsLoading,\n                s.surveyRatingResultsReady,\n                s.surveySingleChoiceResultsReady,\n                s.surveyMultipleChoiceResultsReady,\n                s.surveyOpenTextResultsReady,\n                s.surveyRecurringNPSResultsReady,\n            ],\n            (\n                surveyUserStatsLoading: boolean,\n                surveyRatingResultsReady: boolean,\n                surveySingleChoiceResultsReady: boolean,\n                surveyMultipleChoiceResultsReady: boolean,\n                surveyOpenTextResultsReady: boolean,\n                surveyRecurringNPSResultsReady: boolean\n            ) => {\n                return (\n                    surveyUserStatsLoading ||\n                    !surveyRatingResultsReady ||\n                    !surveySingleChoiceResultsReady ||\n                    !surveyMultipleChoiceResultsReady ||\n                    !surveyOpenTextResultsReady ||\n                    !surveyRecurringNPSResultsReady\n                )\n            },\n        ],\n        isSurveyRunning: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return !!(survey.start_date && !survey.end_date)\n            },\n        ],\n        surveyUsesLimit: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return !!(survey.responses_limit && survey.responses_limit > 0)\n            },\n        ],\n        surveyUsesAdaptiveLimit: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return !!(\n                    survey.response_sampling_interval &&\n                    survey.response_sampling_interval > 0 &&\n                    survey.response_sampling_interval_type !== '' &&\n                    survey.response_sampling_limit &&\n                    survey.response_sampling_limit > 0\n                )\n            },\n        ],\n        surveyShufflingQuestionsAvailable: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                return survey.questions.length > 1\n            },\n        ],\n        showSurveyRepeatSchedule: [(s) => [s.survey], (survey: Survey) => survey.schedule === SurveySchedule.Recurring],\n        descriptionContentType: [\n            (s) => [s.survey],\n            (survey: Survey) => (questionIndex: number) => {\n                return survey.questions[questionIndex].descriptionContentType\n            },\n        ],\n        surveyRepeatedActivationAvailable: [\n            (s) => [s.survey],\n            (survey: Survey): boolean =>\n                survey.conditions?.events?.values != undefined && survey.conditions?.events?.values?.length > 0,\n        ],\n        hasTargetingSet: [\n            (s) => [s.survey],\n            (survey: Survey): boolean => {\n                const hasLinkedFlag =\n                    !!survey.linked_flag_id || (survey.linked_flag && Object.keys(survey.linked_flag).length > 0)\n                const hasTargetingFlag =\n                    (survey.targeting_flag && Object.keys(survey.targeting_flag).length > 0) ||\n                    (survey.targeting_flag_filters && Object.keys(survey.targeting_flag_filters).length > 0)\n                const hasOtherConditions = survey.conditions && Object.keys(survey.conditions).length > 0\n                return !!hasLinkedFlag || !!hasTargetingFlag || !!hasOtherConditions\n            },\n        ],\n        breadcrumbs: [\n            (s) => [s.survey],\n            (survey: Survey): Breadcrumb[] => [\n                {\n                    key: Scene.Surveys,\n                    name: 'Surveys',\n                    path: urls.surveys(),\n                },\n                { key: [Scene.Survey, survey?.id || 'new'], name: survey.name },\n            ],\n        ],\n        dataTableQuery: [\n            (s) => [s.survey, s.propertyFilters, s.answerFilters],\n            (survey, propertyFilters, answerFilters): DataTableNode | null => {\n                if (survey.id === 'new') {\n                    return null\n                }\n                const surveyWithResults = survey as Survey\n                const startDate = dayjs(surveyWithResults.start_date || surveyWithResults.created_at).format(\n                    'YYYY-MM-DD'\n                )\n\n                return {\n                    kind: NodeKind.DataTableNode,\n                    source: {\n                        kind: NodeKind.EventsQuery,\n                        select: [\n                            '*',\n                            ...survey.questions.map((q, i) => {\n                                if (q.type === SurveyQuestionType.MultipleChoice) {\n                                    // Join array items into a string\n                                    return `coalesce(arrayStringConcat(JSONExtractArrayRaw(properties, '${getResponseField(\n                                        i\n                                    )}'), ', ')) -- ${q.question}`\n                                }\n                                return `coalesce(JSONExtractString(properties, '${getResponseField(i)}')) -- ${\n                                    q.question\n                                }`\n                            }),\n                            'timestamp',\n                            'person',\n                            `coalesce(JSONExtractString(properties, '$lib_version')) -- Library Version`,\n                            `coalesce(JSONExtractString(properties, '$lib')) -- Library`,\n                            `coalesce(JSONExtractString(properties, '$current_url')) -- URL`,\n                        ],\n                        orderBy: ['timestamp DESC'],\n                        where: [`event == 'survey sent'`],\n                        after: startDate,\n                        properties: [\n                            {\n                                type: PropertyFilterType.Event,\n                                key: '$survey_id',\n                                operator: PropertyOperator.Exact,\n                                value: survey.id,\n                            },\n                            ...propertyFilters,\n                            ...answerFilters,\n                        ],\n                    },\n                    propertiesViaUrl: true,\n                    showExport: true,\n                    showReload: true,\n                    showEventFilter: false,\n                    showPropertyFilter: false,\n                    showTimings: false,\n                }\n            },\n        ],\n        targetingFlagFilters: [\n            (s) => [s.survey],\n            (survey): FeatureFlagFilters | undefined => {\n                if (survey.targeting_flag_filters) {\n                    return {\n                        ...survey.targeting_flag_filters,\n                        groups: survey.targeting_flag_filters.groups,\n                        multivariate: null,\n                        payloads: {},\n                        super_groups: undefined,\n                    }\n                }\n                return survey.targeting_flag?.filters || undefined\n            },\n        ],\n        urlMatchTypeValidationError: [\n            (s) => [s.survey],\n            (survey): string | null => {\n                if (\n                    survey.conditions?.url &&\n                    [SurveyMatchType.Regex, SurveyMatchType.NotRegex].includes(\n                        survey.conditions?.urlMatchType || SurveyMatchType.Exact\n                    )\n                ) {\n                    try {\n                        new RegExp(survey.conditions.url)\n                    } catch (e: any) {\n                        return e.message\n                    }\n                }\n                return null\n            },\n        ],\n        deviceTypesMatchTypeValidationError: [\n            (s) => [s.survey],\n            (survey: Survey): string | null => {\n                if (\n                    survey.conditions?.deviceTypes &&\n                    [SurveyMatchType.Regex, SurveyMatchType.NotRegex].includes(\n                        survey.conditions?.deviceTypesMatchType || SurveyMatchType.Exact\n                    )\n                ) {\n                    try {\n                        new RegExp(survey.conditions.deviceTypes?.at(0) || '')\n                    } catch (e: any) {\n                        return e.message\n                    }\n                }\n                return null\n            },\n        ],\n\n        surveyNPSScore: [\n            (s) => [s.surveyRatingResults],\n            (surveyRatingResults) => {\n                if (surveyRatingResults) {\n                    const questionIdx = Object.keys(surveyRatingResults)[0]\n                    const questionResults = surveyRatingResults[questionIdx]\n\n                    // If we don't have any results, return 'No data available' instead of NaN.\n                    if (questionResults.total === 0) {\n                        return 'No data available'\n                    }\n\n                    const data: number[] = questionResults.data\n                    if (data.length === 11) {\n                        const promoters = data.slice(9, 11).reduce((a, b) => a + b, 0)\n                        const passives = data.slice(7, 9).reduce((a, b) => a + b, 0)\n                        const detractors = data.slice(0, 7).reduce((a, b) => a + b, 0)\n                        const npsScore = ((promoters - detractors) / (promoters + passives + detractors)) * 100\n                        return npsScore.toFixed(1)\n                    }\n                }\n            },\n        ],\n        getBranchingDropdownValue: [\n            (s) => [s.survey],\n            (survey) => (questionIndex: number, question: RatingSurveyQuestion | MultipleSurveyQuestion) => {\n                if (question.branching?.type) {\n                    const { type } = question.branching\n\n                    if (type === SurveyQuestionBranchingType.SpecificQuestion) {\n                        const nextQuestionIndex = question.branching.index\n                        return `${SurveyQuestionBranchingType.SpecificQuestion}:${nextQuestionIndex}`\n                    }\n\n                    return type\n                }\n\n                // No branching specified, default to Next question / Confirmation message\n                if (questionIndex < survey.questions.length - 1) {\n                    return SurveyQuestionBranchingType.NextQuestion\n                }\n\n                return SurveyQuestionBranchingType.End\n            },\n        ],\n        getResponseBasedBranchingDropdownValue: [\n            (s) => [s.survey],\n            (survey) => (questionIndex: number, question: RatingSurveyQuestion | MultipleSurveyQuestion, response) => {\n                if (!question.branching || !('responseValues' in question.branching)) {\n                    return SurveyQuestionBranchingType.NextQuestion\n                }\n\n                // If a value is mapped onto an integer, we're redirecting to a specific question\n                if (Number.isInteger(question.branching.responseValues[response])) {\n                    const nextQuestionIndex = question.branching.responseValues[response]\n                    return `${SurveyQuestionBranchingType.SpecificQuestion}:${nextQuestionIndex}`\n                }\n\n                // If any other value is present (practically only Confirmation message), return that value\n                if (question.branching?.responseValues?.[response]) {\n                    return question.branching.responseValues[response]\n                }\n\n                // No branching specified, default to Next question / Confirmation message\n                if (questionIndex < survey.questions.length - 1) {\n                    return SurveyQuestionBranchingType.NextQuestion\n                }\n\n                return SurveyQuestionBranchingType.End\n            },\n        ],\n        hasCycle: [\n            (s) => [s.survey],\n            (survey) => {\n                const graph = new Map()\n                survey.questions.forEach((question, fromIndex: number) => {\n                    if (!graph.has(fromIndex)) {\n                        graph.set(fromIndex, new Set())\n                    }\n\n                    if (question.branching?.type === SurveyQuestionBranchingType.End) {\n                        return\n                    } else if (\n                        question.branching?.type === SurveyQuestionBranchingType.SpecificQuestion &&\n                        Number.isInteger(question.branching.index)\n                    ) {\n                        const toIndex = question.branching.index\n                        graph.get(fromIndex).add(toIndex)\n                        return\n                    } else if (\n                        question.branching?.type === SurveyQuestionBranchingType.ResponseBased &&\n                        isObject(question.branching?.responseValues)\n                    ) {\n                        for (const [_, toIndex] of Object.entries(question.branching?.responseValues)) {\n                            if (Number.isInteger(toIndex)) {\n                                graph.get(fromIndex).add(toIndex)\n                            }\n                        }\n                    }\n\n                    // No branching - still need to connect the next question\n                    if (fromIndex < survey.questions.length - 1) {\n                        const toIndex = fromIndex + 1\n                        graph.get(fromIndex).add(toIndex)\n                    }\n                })\n\n                let cycleDetected = false\n                function dfs(node: number, seen: number[]): void {\n                    if (cycleDetected) {\n                        return\n                    }\n\n                    for (const neighbor of graph.get(node) || []) {\n                        if (seen.includes(neighbor)) {\n                            cycleDetected = true\n                            return\n                        }\n                        dfs(neighbor, seen.concat(neighbor))\n                    }\n                }\n                dfs(0, [0])\n\n                return cycleDetected\n            },\n        ],\n        hasBranchingLogic: [\n            (s) => [s.survey],\n            (survey) =>\n                survey.questions.some((question) => question.branching && Object.keys(question.branching).length > 0),\n        ],\n        surveyAsInsightURL: [\n            (s) => [s.survey],\n            (survey) => {\n                const query: InsightVizNode = {\n                    kind: NodeKind.InsightVizNode,\n                    source: {\n                        kind: NodeKind.TrendsQuery,\n                        properties: [\n                            {\n                                key: '$survey_id',\n                                value: survey.id,\n                                operator: PropertyOperator.Exact,\n                                type: PropertyFilterType.Event,\n                            },\n                        ],\n                        series: [\n                            {\n                                kind: NodeKind.EventsNode,\n                                event: 'survey sent',\n                                name: 'survey sent',\n                                math: BaseMathType.TotalCount,\n                            },\n                            {\n                                kind: NodeKind.EventsNode,\n                                event: 'survey shown',\n                                name: 'survey shown',\n                                math: BaseMathType.TotalCount,\n                            },\n                            {\n                                kind: NodeKind.EventsNode,\n                                event: 'survey dismissed',\n                                name: 'survey dismissed',\n                                math: BaseMathType.TotalCount,\n                            },\n                        ],\n                    },\n                }\n\n                return urls.insightNew({ query })\n            },\n        ],\n        defaultInterval: [\n            (s) => [s.survey],\n            (survey: Survey): IntervalType => {\n                const start = dayjs(survey.start_date || survey.created_at)\n                const end = survey.end_date ? dayjs(survey.end_date) : dayjs()\n                const diffInWeeks = end.diff(start, 'weeks')\n\n                if (diffInWeeks <= 4) {\n                    return 'day'\n                } else if (diffInWeeks <= 12) {\n                    return 'week'\n                }\n                return 'month'\n            },\n        ],\n    }),\n    forms(({ actions, props, values }) => ({\n        survey: {\n            defaults: { ...NEW_SURVEY } as NewSurvey | Survey,\n            errors: ({ name, questions, appearance }) => {\n                const sanitizedAppearance = sanitizeSurveyAppearance(appearance)\n                return {\n                    name: !name && 'Please enter a name.',\n                    questions: questions.map((question) => {\n                        const questionErrors = {\n                            question: !question.question && 'Please enter a question label.',\n                        }\n\n                        if (question.type === SurveyQuestionType.Link) {\n                            if (question.link) {\n                                if (question.link.startsWith('mailto:')) {\n                                    const emailRegex = /^mailto:[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/\n                                    if (!emailRegex.test(question.link)) {\n                                        return {\n                                            ...questionErrors,\n                                            link: 'Please enter a valid mailto link (e.g., mailto:example@domain.com).',\n                                        }\n                                    }\n                                } else {\n                                    try {\n                                        const url = new URL(question.link)\n                                        if (url.protocol !== 'https:') {\n                                            return {\n                                                ...questionErrors,\n                                                link: 'Only HTTPS links are supported for security reasons.',\n                                            }\n                                        }\n                                    } catch {\n                                        return {\n                                            ...questionErrors,\n                                            link: 'Please enter a valid HTTPS URL.',\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        if (question.type === SurveyQuestionType.Rating) {\n                            return {\n                                ...questionErrors,\n                                display: !question.display && 'Please choose a display type.',\n                                scale: !question.scale && 'Please choose a scale.',\n                                lowerBoundLabel: !question.lowerBoundLabel && 'Please enter a lower bound label.',\n                                upperBoundLabel: !question.upperBoundLabel && 'Please enter an upper bound label.',\n                            }\n                        } else if (\n                            question.type === SurveyQuestionType.SingleChoice ||\n                            question.type === SurveyQuestionType.MultipleChoice\n                        ) {\n                            return {\n                                ...questionErrors,\n                                choices: question.choices.some((choice) => !choice.trim())\n                                    ? 'Please ensure all choices are non-empty.'\n                                    : undefined,\n                            }\n                        }\n\n                        return questionErrors\n                    }),\n                    // release conditions controlled using a PureField in the form\n                    targeting_flag_filters: values.flagPropertyErrors,\n                    // controlled using a PureField in the form\n                    urlMatchType: values.urlMatchTypeValidationError,\n                    appearance: sanitizedAppearance && {\n                        backgroundColor: validateColor(sanitizedAppearance.backgroundColor, 'background color'),\n                        borderColor: validateColor(sanitizedAppearance.borderColor, 'border color'),\n                        ratingButtonActiveColor: validateColor(\n                            sanitizedAppearance.ratingButtonActiveColor,\n                            'rating button active color'\n                        ),\n                        ratingButtonColor: validateColor(sanitizedAppearance.ratingButtonColor, 'rating button color'),\n                        submitButtonColor: validateColor(sanitizedAppearance.submitButtonColor, 'button color'),\n                        submitButtonTextColor: validateColor(\n                            sanitizedAppearance.submitButtonTextColor,\n                            'button text color'\n                        ),\n                    },\n                }\n            },\n            submit: (surveyPayload) => {\n                if (values.hasCycle) {\n                    actions.reportSurveyCycleDetected(values.survey)\n\n                    return lemonToast.error(\n                        'Your survey contains an endless cycle. Please revisit your branching rules.'\n                    )\n                }\n\n                const payload = {\n                    ...surveyPayload,\n                    appearance: sanitizeSurveyAppearance(surveyPayload.appearance),\n                }\n\n                // when the survey is being submitted, we should turn off editing mode\n                actions.editingSurvey(false)\n                if (props.id && props.id !== 'new') {\n                    actions.updateSurvey(payload)\n                } else {\n                    actions.createSurvey(payload)\n                }\n            },\n        },\n    })),\n    urlToAction(({ actions, props }) => ({\n        [urls.survey(props.id ?? 'new')]: (_, { edit }, __, { method }) => {\n            // We always set the editingSurvey to true when we create a new survey\n            if (props.id === 'new') {\n                actions.editingSurvey(true)\n            }\n            // If the URL was pushed (user clicked on a link), reset the scene's data.\n            // This avoids resetting form fields if you click back/forward.\n            if (method === 'PUSH') {\n                if (props.id) {\n                    actions.loadSurvey()\n                } else {\n                    actions.resetSurvey()\n                }\n            }\n\n            if (edit) {\n                actions.editingSurvey(true)\n            }\n        },\n    })),\n    actionToUrl(({ values }) => ({\n        setSurveyTemplateValues: () => {\n            const hashParams = router.values.hashParams\n            hashParams['fromTemplate'] = true\n\n            return [urls.survey(values.survey.id), router.values.searchParams, hashParams]\n        },\n        editingSurvey: ({ editing }) => {\n            const searchParams = router.values.searchParams\n            if (editing) {\n                searchParams['edit'] = true\n            } else {\n                delete searchParams['edit']\n            }\n\n            return [router.values.location.pathname, router.values.searchParams, router.values.hashParams]\n        },\n    })),\n    afterMount(({ props, actions }) => {\n        if (props.id !== 'new') {\n            actions.loadSurvey()\n        }\n        if (props.id === 'new') {\n            actions.resetSurvey()\n        }\n    }),\n])\n\nfunction sanitizeQuestions(surveyPayload: Partial<Survey>): Partial<Survey> {\n    if (!surveyPayload.questions) {\n        return surveyPayload\n    }\n\n    const sanitizedThankYouHeader = sanitizeHTML(surveyPayload.appearance?.thankYouMessageHeader || '')\n    const sanitizedThankYouDescription = sanitizeHTML(surveyPayload.appearance?.thankYouMessageDescription || '')\n\n    const appearance = {\n        ...surveyPayload.appearance,\n        ...(sanitizedThankYouHeader && { thankYouMessageHeader: sanitizedThankYouHeader }),\n        ...(sanitizedThankYouDescription && { thankYouMessageDescription: sanitizedThankYouDescription }),\n    }\n\n    // Remove widget-specific fields if survey type is not Widget\n    if (surveyPayload.type !== 'widget') {\n        delete appearance.widgetType\n        delete appearance.widgetLabel\n        delete appearance.widgetColor\n    }\n\n    return {\n        ...surveyPayload,\n        questions: surveyPayload.questions?.map((rawQuestion) => {\n            return {\n                ...rawQuestion,\n                description: sanitizeHTML(rawQuestion.description || ''),\n                question: sanitizeHTML(rawQuestion.question || ''),\n            }\n        }),\n        appearance,\n    }\n}\n"],
  "mappings": "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",
  "names": ["init_dirname", "init_buffer", "init_process", "import_kea", "import_kea_forms", "import_kea_loaders", "import_kea_router", "import_jsx_runtime", "DEFAULT_OPERATORS", "allOperatorsMapping", "getResponseField", "i", "duplicateExistingSurvey", "survey", "NEW_SURVEY", "DATE_FORMAT", "getSurveyEndDateForQuery", "dayjs", "surveyLogic", "id", "key", "surveysLogic", "eventUsageLogic", "featureFlagLogic", "editing", "idx", "type", "isEditingQuestion", "isEditingDescription", "isEditingThankYouMessage", "questionIndex", "specificQuestionIndex", "responseValue", "nextStep", "dataCollectionType", "writingHTML", "template", "section", "errors", "propertyFilters", "filters", "reloadResults", "dateRange", "interval", "compareFilter", "props", "actions", "values", "api_default", "question", "index", "getSurveyResponseKey", "DEFAULT_OPERATORS", "error", "templatedSurvey", "defaultSurveyAppearance", "teamLogic", "newSurvey", "surveyPayload", "sanitizeQuestions", "startDate", "payload", "createdSurvey", "lemonToast", "urls", "endDate", "query", "hogql", "responseJSON", "results", "totalSeen", "dismissed", "sent", "onlySeen", "total", "dataSize", "data", "value", "count", "iterations", "iteration", "response", "promoters", "passives", "detractors", "currentValue", "totalResponses", "npsScore", "labels", "r", "a", "b", "choice", "isOpenChoice", "events", "distinct_id", "properties", "personProperties", "reloadAllSurveyResults", "debounce", "activationLogic", "hasFormErrors", "_", "state", "defaultSurveyFieldValues", "description", "thankYouMessageHeader", "newQuestions", "s", "surveyUserStatsLoading", "surveyRatingResultsReady", "surveySingleChoiceResultsReady", "surveyMultipleChoiceResultsReady", "surveyOpenTextResultsReady", "surveyRecurringNPSResultsReady", "hasLinkedFlag", "hasTargetingFlag", "hasOtherConditions", "answerFilters", "surveyWithResults", "q", "e", "surveyRatingResults", "questionIdx", "questionResults", "nextQuestionIndex", "graph", "fromIndex", "toIndex", "isObject", "cycleDetected", "dfs", "node", "seen", "neighbor", "start", "diffInWeeks", "name", "questions", "appearance", "sanitizedAppearance", "sanitizeSurveyAppearance", "questionErrors", "validateColor", "edit", "__", "method", "hashParams", "searchParams", "sanitizedThankYouHeader", "sanitizeHTML", "sanitizedThankYouDescription", "rawQuestion"]
}
