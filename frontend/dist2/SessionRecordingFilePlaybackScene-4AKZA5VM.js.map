{
  "version": 3,
  "sources": ["../src/scenes/session-recordings/file-playback/SessionRecordingFilePlaybackScene.tsx", "../src/scenes/session-recordings/file-playback/sessionRecordingFilePlaybackSceneLogic.ts"],
  "sourcesContent": ["import { useActions, useValues } from 'kea'\nimport { PayGateMini } from 'lib/components/PayGateMini/PayGateMini'\nimport { IconUploadFile } from 'lib/lemon-ui/icons'\nimport { LemonBanner } from 'lib/lemon-ui/LemonBanner'\nimport { LemonFileInput } from 'lib/lemon-ui/LemonFileInput'\nimport { SpinnerOverlay } from 'lib/lemon-ui/Spinner/Spinner'\nimport { useRef } from 'react'\nimport { SceneExport } from 'scenes/sceneTypes'\nimport { userLogic } from 'scenes/userLogic'\n\nimport { AvailableFeature } from '~/types'\n\nimport { SessionRecordingPlayer } from '../player/SessionRecordingPlayer'\nimport { sessionRecordingFilePlaybackSceneLogic } from './sessionRecordingFilePlaybackSceneLogic'\n\nexport const scene: SceneExport = {\n    component: SessionRecordingFilePlaybackScene,\n    logic: sessionRecordingFilePlaybackSceneLogic,\n}\n\nexport function SessionRecordingFilePlaybackScene(): JSX.Element {\n    const { loadFromFile, resetSessionRecording } = useActions(sessionRecordingFilePlaybackSceneLogic)\n    const { sessionRecording, sessionRecordingLoading, playerKey } = useValues(sessionRecordingFilePlaybackSceneLogic)\n    const { hasAvailableFeature } = useValues(userLogic)\n    const filePlaybackEnabled = hasAvailableFeature(AvailableFeature.RECORDINGS_FILE_EXPORT)\n\n    const dropRef = useRef<HTMLDivElement>(null)\n\n    if (!filePlaybackEnabled) {\n        return (\n            <PayGateMini\n                feature={AvailableFeature.RECORDINGS_FILE_EXPORT}\n                className=\"py-8\"\n                docsLink=\"https://posthog.com/docs/user-guides/session-recordings\"\n            />\n        )\n    }\n\n    return (\n        <div>\n            {sessionRecordingLoading ? (\n                <SpinnerOverlay />\n            ) : sessionRecording ? (\n                <div className=\"flex flex-col gap-2 h-screen pb-4\">\n                    <LemonBanner\n                        type=\"info\"\n                        action={{\n                            onClick: () => resetSessionRecording(),\n                            children: 'Load a different recording',\n                        }}\n                    >\n                        You are viewing a recording loaded from a file.\n                    </LemonBanner>\n                    <SessionRecordingPlayer sessionRecordingId=\"\" playerKey={playerKey} />\n                </div>\n            ) : (\n                <div\n                    ref={dropRef}\n                    className=\"w-full border rounded p-20 text-secondary flex flex-col items-center justify-center\"\n                >\n                    <LemonFileInput\n                        accept=\"application/json\"\n                        multiple={false}\n                        onChange={(files) => loadFromFile(files[0])}\n                        alternativeDropTargetRef={dropRef}\n                        callToAction={\n                            <div className=\"flex flex-col items-center justify-center space-y-2\">\n                                <span className=\"flex items-center gap-2 font-semibold\">\n                                    <IconUploadFile className=\"text-2xl\" /> Load recording\n                                </span>\n                                <div>Drag and drop your exported recording here or click to open the file browser.</div>\n                            </div>\n                        }\n                    />\n                </div>\n            )}\n        </div>\n    )\n}\n", "import { lemonToast } from '@posthog/lemon-ui'\nimport { BuiltLogic, connect, kea, listeners, path, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { beforeUnload } from 'kea-router'\nimport { dayjs } from 'lib/dayjs'\nimport { featureFlagLogic } from 'lib/logic/featureFlagLogic'\nimport { uuid } from 'lib/utils'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport { Scene } from 'scenes/sceneTypes'\nimport { urls } from 'scenes/urls'\n\nimport { Breadcrumb } from '~/types'\n\nimport {\n    deduplicateSnapshots,\n    parseEncodedSnapshots,\n    sessionRecordingDataLogic,\n} from '../player/sessionRecordingDataLogic'\nimport type { sessionRecordingDataLogicType } from '../player/sessionRecordingDataLogicType'\nimport type { sessionRecordingFilePlaybackSceneLogicType } from './sessionRecordingFilePlaybackSceneLogicType'\nimport { ExportedSessionRecordingFileV1, ExportedSessionRecordingFileV2 } from './types'\n\nexport const parseExportedSessionRecording = (fileData: string): ExportedSessionRecordingFileV2 => {\n    const data = JSON.parse(fileData) as ExportedSessionRecordingFileV1 | ExportedSessionRecordingFileV2\n\n    if (!data.version || !data.data) {\n        throw new Error('File does not appear to be a valid session recording export')\n    }\n\n    if (data.version === '2023-04-28') {\n        return data\n    } else if (data.version === '2022-12-02') {\n        return {\n            version: '2023-04-28',\n            data: {\n                id: '', // This wasn't available in previous version\n                person: data.data.person || undefined,\n                snapshots: Object.entries(data.data.snapshotsByWindowId)\n                    .flatMap(([windowId, snapshots]) => {\n                        return snapshots.map((snapshot) => ({\n                            ...snapshot,\n                            windowId,\n                        }))\n                    })\n                    .sort((a, b) => a.timestamp - b.timestamp),\n            },\n        }\n    }\n    throw new Error('File version is not supported')\n}\n\n/**\n * There's a race between loading the file causing the React component to be rendered that mounts the dataLogic\n * and this logic loading the file and wanting to tell the logic about it\n *\n * This method waits for the dataLogic to be mounted and returns it\n *\n * in practice, it will only wait for 1-2 retries\n * but a timeout is provided to avoid waiting forever when something breaks\n */\nconst waitForDataLogic = async (playerKey: string): Promise<BuiltLogic<sessionRecordingDataLogicType>> => {\n    const maxRetries = 20 // 2 seconds / 100 ms per retry\n    let retries = 0\n    let dataLogic = null\n\n    while (retries < maxRetries) {\n        dataLogic = sessionRecordingDataLogic.findMounted({\n            sessionRecordingId: '',\n            playerKey: playerKey,\n        })\n\n        if (dataLogic !== null) {\n            // eslint-disable-next-line no-console\n            console.log('found after retries', retries)\n            return dataLogic\n        }\n\n        // Wait for a short period before trying again\n        await new Promise((resolve) => setTimeout(resolve, 1))\n        retries++\n    }\n\n    throw new Error('Timeout reached: dataLogic is still null after 2 seconds')\n}\n\nexport const sessionRecordingFilePlaybackSceneLogic = kea<sessionRecordingFilePlaybackSceneLogicType>([\n    path(['scenes', 'session-recordings', 'detail', 'sessionRecordingFilePlaybackSceneLogic']),\n    connect({\n        actions: [eventUsageLogic, ['reportRecordingLoadedFromFile']],\n        values: [featureFlagLogic, ['featureFlags']],\n    }),\n\n    loaders(({ actions }) => ({\n        sessionRecording: {\n            __default: null as ExportedSessionRecordingFileV2['data'] | null,\n            loadFromFile: async (file: File) => {\n                try {\n                    const loadedFile: string = await new Promise((resolve, reject) => {\n                        const filereader = new FileReader()\n                        filereader.onload = (e) => {\n                            resolve(e.target?.result as string)\n                        }\n                        filereader.onerror = (e) => {\n                            reject(e)\n                        }\n                        filereader.readAsText(file)\n                    })\n\n                    const data = parseExportedSessionRecording(loadedFile)\n\n                    actions.reportRecordingLoadedFromFile({ success: true })\n                    return data.data\n                } catch (error) {\n                    actions.reportRecordingLoadedFromFile({ success: false, error: `${error}` })\n                    lemonToast.error(`File import failed: ${error}`)\n                    return null\n                }\n            },\n\n            resetSessionRecording: () => null,\n        },\n    })),\n\n    reducers({\n        playerKey: [\n            'file-playback',\n            {\n                loadFromFileSuccess: () => `file-playback-${uuid()}`,\n                resetSessionRecording: () => 'file-playback',\n            },\n        ],\n    }),\n\n    listeners(({ values }) => ({\n        loadFromFileSuccess: async () => {\n            const dataLogic = await waitForDataLogic(values.playerKey)\n\n            if (!dataLogic || !values.sessionRecording) {\n                return\n            }\n\n            const snapshots = deduplicateSnapshots(\n                await parseEncodedSnapshots(values.sessionRecording.snapshots, values.sessionRecording.id)\n            )\n\n            // Simulate a loaded source and sources so that nothing extra gets loaded\n            dataLogic.actions.loadSnapshotsForSourceSuccess({\n                snapshots: snapshots,\n                untransformed_snapshots: snapshots,\n                source: { source: 'file' },\n            })\n            dataLogic.actions.loadSnapshotSourcesSuccess([{ source: 'file' }])\n\n            dataLogic.actions.loadRecordingMetaSuccess({\n                id: values.sessionRecording.id,\n                viewed: false,\n                recording_duration: snapshots[snapshots.length - 1].timestamp - snapshots[0].timestamp,\n                person: values.sessionRecording.person || undefined,\n                start_time: dayjs(snapshots[0].timestamp).toISOString(),\n                end_time: dayjs(snapshots[snapshots.length - 1].timestamp).toISOString(),\n                snapshot_source: 'unknown', // TODO: we should be able to detect this from the file\n            })\n        },\n    })),\n\n    beforeUnload(({ values, actions }) => ({\n        enabled: () => !!values.sessionRecording,\n        message: 'The loaded session recording will be lost. Are you sure you want to leave?',\n        onConfirm: () => {\n            actions.resetSessionRecording()\n        },\n    })),\n\n    selectors({\n        breadcrumbs: [\n            () => [],\n            (): Breadcrumb[] => [\n                {\n                    key: Scene.Replay,\n                    name: 'Replay',\n                    path: urls.replay(),\n                },\n                {\n                    key: Scene.ReplayFilePlayback,\n                    name: 'File playback',\n                    path: urls.replayFilePlayback(),\n                },\n            ],\n        ],\n    }),\n])\n"],
  "mappings": "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",
  "names": ["init_dirname", "init_buffer", "init_process", "import_kea", "import_react", "init_dirname", "init_buffer", "init_process", "import_kea", "import_kea_loaders", "import_kea_router", "parseExportedSessionRecording", "fileData", "data", "windowId", "snapshots", "snapshot", "a", "b", "waitForDataLogic", "playerKey", "retries", "dataLogic", "sessionRecordingDataLogic", "resolve", "sessionRecordingFilePlaybackSceneLogic", "eventUsageLogic", "featureFlagLogic", "actions", "file", "loadedFile", "reject", "filereader", "e", "error", "lemonToast", "uuid", "values", "deduplicateSnapshots", "parseEncodedSnapshots", "dayjs", "urls", "import_jsx_runtime", "scene", "SessionRecordingFilePlaybackScene", "sessionRecordingFilePlaybackSceneLogic", "loadFromFile", "resetSessionRecording", "sessionRecording", "sessionRecordingLoading", "playerKey", "hasAvailableFeature", "userLogic", "filePlaybackEnabled", "dropRef", "SpinnerOverlay", "LemonBanner", "SessionRecordingPlayer", "LemonFileInput", "files", "IconUploadFile", "PayGateMini"]
}
