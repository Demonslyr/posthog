{
  "version": 3,
  "sources": ["../src/scenes/session-recordings/saved-playlists/savedSessionRecordingPlaylistsLogic.ts"],
  "sourcesContent": ["import { lemonToast } from '@posthog/lemon-ui'\nimport { actions, afterMount, connect, kea, key, listeners, path, props, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport { actionToUrl, router, urlToAction } from 'kea-router'\nimport api, { PaginatedResponse } from 'lib/api'\nimport { dayjs } from 'lib/dayjs'\nimport { Sorting } from 'lib/lemon-ui/LemonTable'\nimport { PaginationManual } from 'lib/lemon-ui/PaginationControl'\nimport { objectClean, objectsEqual, toParams } from 'lib/utils'\nimport { eventUsageLogic } from 'lib/utils/eventUsageLogic'\nimport { removeProjectIdIfPresent } from 'lib/utils/router-utils'\nimport { urls } from 'scenes/urls'\n\nimport { ReplayTabs, SessionRecordingPlaylistType } from '~/types'\n\nimport { createPlaylist, deletePlaylist } from '../playlist/playlistUtils'\nimport type { savedSessionRecordingPlaylistsLogicType } from './savedSessionRecordingPlaylistsLogicType'\n\nexport const PLAYLISTS_PER_PAGE = 30\n\nexport interface SavedSessionRecordingPlaylistsResult extends PaginatedResponse<SessionRecordingPlaylistType> {\n    count: number\n    /** not in the API response */\n    filters?: SavedSessionRecordingPlaylistsFilters | null\n}\n\nexport interface SavedSessionRecordingPlaylistsFilters {\n    order: string\n    search: string\n    createdBy: number | 'All users'\n    dateFrom: string | dayjs.Dayjs | undefined | null\n    dateTo: string | dayjs.Dayjs | undefined | null\n    page: number\n    pinned: boolean\n}\n\nexport interface SavedSessionRecordingPlaylistsLogicProps {\n    tab: ReplayTabs\n}\n\nexport const DEFAULT_PLAYLIST_FILTERS = {\n    createdBy: 'All users',\n    page: 1,\n    dateFrom: 'all',\n}\n\nexport const savedSessionRecordingPlaylistsLogic = kea<savedSessionRecordingPlaylistsLogicType>([\n    path((key) => ['scenes', 'session-recordings', 'saved-playlists', 'savedSessionRecordingPlaylistsLogic', key]),\n    props({} as SavedSessionRecordingPlaylistsLogicProps),\n    key((props) => props.tab),\n    connect({\n        actions: [eventUsageLogic, ['reportRecordingPlaylistCreated']],\n    }),\n\n    actions(() => ({\n        setSavedPlaylistsFilters: (filters: Partial<SavedSessionRecordingPlaylistsFilters>) => ({\n            filters,\n        }),\n        loadPlaylists: true,\n        updatePlaylist: (\n            shortId: SessionRecordingPlaylistType['short_id'],\n            properties: Partial<SessionRecordingPlaylistType>\n        ) => ({ shortId, properties }),\n        deletePlaylist: (playlist: SessionRecordingPlaylistType) => ({ playlist }),\n        duplicatePlaylist: (playlist: SessionRecordingPlaylistType) => ({ playlist }),\n    })),\n    reducers(() => ({\n        filters: [\n            DEFAULT_PLAYLIST_FILTERS as SavedSessionRecordingPlaylistsFilters | Record<string, any>,\n            {\n                setSavedPlaylistsFilters: (state, { filters }) =>\n                    objectClean({\n                        ...(state || {}),\n                        ...filters,\n                        // Reset page on filter change EXCEPT if it's page that's being updated\n                        ...('page' in filters ? {} : { page: 1 }),\n                    }),\n            },\n        ],\n        loadPlaylistsFailed: [\n            false,\n            {\n                loadPlaylists: () => false,\n                loadPlaylistsSuccess: () => false,\n                loadPlaylistsFailure: () => true,\n            },\n        ],\n    })),\n    loaders(({ values, actions }) => ({\n        playlists: {\n            __default: { results: [], count: 0, filters: null } as SavedSessionRecordingPlaylistsResult,\n            loadPlaylists: async (_, breakpoint) => {\n                if (values.playlists.filters !== null) {\n                    await breakpoint(300)\n                }\n\n                const filters = { ...values.filters }\n                const createdBy = filters.createdBy === 'All users' ? undefined : filters.createdBy\n\n                const params = {\n                    limit: PLAYLISTS_PER_PAGE,\n                    offset: Math.max(0, (filters.page - 1) * PLAYLISTS_PER_PAGE),\n                    order: filters.order ?? '-last_modified_at', // Sync with `sorting` selector\n                    created_by: createdBy ?? undefined,\n                    search: filters.search || undefined,\n                    date_from: filters.dateFrom && filters.dateFrom != 'all' ? filters.dateFrom : undefined,\n                    date_to: filters.dateTo ?? undefined,\n                    pinned: filters.pinned ? true : undefined,\n                }\n\n                const response = await api.recordings.listPlaylists(toParams(params))\n                breakpoint()\n\n                return response\n            },\n            updatePlaylist: async ({ shortId, properties }, breakpoint) => {\n                await breakpoint(100)\n                const updatedPlaylist = await api.recordings.updatePlaylist(shortId, properties)\n                breakpoint()\n\n                const index = values.playlists.results.findIndex((x) => x.short_id === updatedPlaylist.short_id)\n                if (index > -1) {\n                    values.playlists.results[index] = updatedPlaylist\n                }\n\n                return { ...values.playlists, results: [...values.playlists.results] }\n            },\n            deletePlaylist: async ({ playlist }) => {\n                await deletePlaylist(playlist, () => actions.loadPlaylists())\n                values.playlists.results = values.playlists.results.filter((x) => x.short_id !== playlist.short_id)\n                return values.playlists\n            },\n\n            duplicatePlaylist: async ({ playlist }, breakpoint) => {\n                await breakpoint(100)\n\n                const { id, short_id, ...partialPlaylist } = playlist\n                partialPlaylist.name = partialPlaylist.name ? partialPlaylist.name + ' (copy)' : ''\n\n                const newPlaylist = await createPlaylist(partialPlaylist)\n                actions.reportRecordingPlaylistCreated('duplicate')\n\n                breakpoint()\n                if (!newPlaylist) {\n                    return values.playlists\n                }\n\n                lemonToast.success('Playlist duplicated successfully')\n\n                values.playlists.results = [newPlaylist, ...values.playlists.results]\n\n                return values.playlists\n            },\n        },\n    })),\n    listeners(({ actions }) => ({\n        setSavedPlaylistsFilters: () => {\n            actions.loadPlaylists()\n        },\n    })),\n\n    selectors(({ actions }) => ({\n        sorting: [\n            (s) => [s.filters],\n            (filters): Sorting | null => {\n                if (!filters.order) {\n                    // Sync with `cleanFilters` function\n                    return {\n                        columnKey: 'last_modified_at',\n                        order: -1,\n                    }\n                }\n                return filters.order.startsWith('-')\n                    ? {\n                          columnKey: filters.order.slice(1),\n                          order: -1,\n                      }\n                    : {\n                          columnKey: filters.order,\n                          order: 1,\n                      }\n            },\n        ],\n        pagination: [\n            (s) => [s.filters, s.playlists],\n            (filters, playlists): PaginationManual => {\n                return {\n                    controlled: true,\n                    pageSize: PLAYLISTS_PER_PAGE,\n                    currentPage: filters.page,\n                    entryCount: playlists.count,\n                    onBackward: playlists.previous\n                        ? () =>\n                              actions.setSavedPlaylistsFilters({\n                                  page: filters.page - 1,\n                              })\n                        : undefined,\n                    onForward: playlists.next\n                        ? () =>\n                              actions.setSavedPlaylistsFilters({\n                                  page: filters.page + 1,\n                              })\n                        : undefined,\n                }\n            },\n        ],\n    })),\n    actionToUrl(({ values }) => {\n        const changeUrl = ():\n            | [\n                  string,\n                  Record<string, any>,\n                  Record<string, any>,\n                  {\n                      replace: boolean\n                  }\n              ]\n            | void => {\n            if (removeProjectIdIfPresent(router.values.location.pathname) === urls.replay(ReplayTabs.Playlists)) {\n                const nextValues = values.filters\n                const urlValues = objectClean(router.values.searchParams)\n                if (!objectsEqual(nextValues, urlValues)) {\n                    return [urls.replay(ReplayTabs.Playlists), nextValues, {}, { replace: false }]\n                }\n            }\n        }\n        return {\n            loadPlaylists: changeUrl,\n            setSavedPlaylistsFilters: changeUrl,\n        }\n    }),\n    urlToAction(({ actions, values }) => ({\n        [urls.replay(ReplayTabs.Playlists)]: (_, searchParams) => {\n            const currentFilters = values.filters\n            const nextFilters = objectClean(searchParams)\n            if (!objectsEqual(currentFilters, nextFilters)) {\n                actions.setSavedPlaylistsFilters(nextFilters)\n            }\n        },\n    })),\n    afterMount(({ actions }) => {\n        actions.loadPlaylists()\n    }),\n])\n"],
  "mappings": "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",
  "names": ["init_dirname", "init_buffer", "init_process", "import_kea", "import_kea_loaders", "import_kea_router", "PLAYLISTS_PER_PAGE", "DEFAULT_PLAYLIST_FILTERS", "savedSessionRecordingPlaylistsLogic", "key", "props", "eventUsageLogic", "filters", "shortId", "properties", "playlist", "state", "objectClean", "values", "actions", "_", "breakpoint", "createdBy", "params", "response", "api_default", "toParams", "updatedPlaylist", "index", "x", "deletePlaylist", "id", "short_id", "partialPlaylist", "newPlaylist", "createPlaylist", "lemonToast", "playlists", "changeUrl", "removeProjectIdIfPresent", "urls", "nextValues", "urlValues", "objectsEqual", "searchParams", "currentFilters", "nextFilters"]
}
