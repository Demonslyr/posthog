{
  "version": 3,
  "sources": ["../src/lib/components/Sparkline.tsx"],
  "sourcesContent": ["import clsx from 'clsx'\nimport { Chart, ChartItem } from 'lib/Chart'\nimport { getColorVar } from 'lib/colors'\nimport { Popover } from 'lib/lemon-ui/Popover/Popover'\nimport { humanFriendlyNumber } from 'lib/utils'\nimport { useEffect, useRef, useState } from 'react'\nimport { InsightTooltip } from 'scenes/insights/InsightTooltip/InsightTooltip'\n\nimport { LemonSkeleton } from '../lemon-ui/LemonSkeleton'\n\nexport interface SparklineTimeSeries {\n    name: string\n    values: number[]\n    /** Check vars.scss for available colors. @default 'muted' */\n    color?: string\n}\n\ninterface SparklineProps {\n    /** Optional labels for the X axis. */\n    labels?: string[]\n    /** Either a list of numbers for a muted graph or an array of time series */\n    data: number[] | SparklineTimeSeries[]\n    /** @default 'bar' */\n    type?: 'bar' | 'line'\n    /** Whether the Y-axis maximum should be indicated in the graph. @default true */\n    maximumIndicator?: boolean\n    /** A skeleton is shown during loading. */\n    loading?: boolean\n    className?: string\n}\n\nexport function Sparkline({\n    labels,\n    data,\n    type = 'bar',\n    maximumIndicator = true,\n    loading = false,\n    className,\n}: SparklineProps): JSX.Element {\n    const canvasRef = useRef<HTMLCanvasElement | null>(null)\n    const tooltipRef = useRef<HTMLDivElement | null>(null)\n\n    const [isTooltipShown, setIsTooltipShown] = useState(false)\n    const [popoverContent, setPopoverContent] = useState<JSX.Element | null>(null)\n\n    const adjustedData: SparklineTimeSeries[] = !isSparkLineTimeSeries(data)\n        ? [{ name: 'Data', color: 'muted', values: data }]\n        : data\n\n    useEffect(() => {\n        // data should always be provided but React can render this without it,\n        // so, fall back to an empty array for safety\n        if (data === undefined || data.length === 0) {\n            return\n        }\n\n        let chart: Chart\n        if (canvasRef.current) {\n            chart = new Chart(canvasRef.current.getContext('2d') as ChartItem, {\n                type,\n                data: {\n                    labels: labels || adjustedData[0].values.map((_, i) => `Entry ${i}`),\n                    datasets: adjustedData.map((timeseries) => {\n                        const color = getColorVar(timeseries.color || 'muted')\n                        return {\n                            label: timeseries.name,\n                            data: timeseries.values,\n                            minBarLength: 0,\n                            categoryPercentage: 0.9, // Slightly tighter bar spacing than the default 0.8\n                            backgroundColor: color,\n                            borderColor: color,\n                            borderWidth: type === 'line' ? 2 : 0,\n                            pointRadius: 0,\n                        }\n                    }),\n                },\n                options: {\n                    scales: {\n                        x: {\n                            // X axis not needed in line charts without indicators\n                            display: type === 'bar' || maximumIndicator,\n                            bounds: 'data',\n                            stacked: true,\n                            ticks: {\n                                display: false,\n                            },\n                            grid: {\n                                drawTicks: false,\n                                display: false,\n                            },\n                            alignToPixels: true,\n                        },\n                        y: {\n                            // We use the Y axis for the maximum indicator\n                            display: maximumIndicator,\n                            bounds: 'data',\n                            min: 0, // Always starting at 0\n                            suggestedMax: 1,\n                            stacked: true,\n                            ticks: {\n                                includeBounds: true,\n                                autoSkip: true,\n                                maxTicksLimit: 1, // Only the max\n                                align: 'start',\n                                callback: (tickValue) =>\n                                    typeof tickValue === 'number' && tickValue > 0 // Hide the zero tick\n                                        ? humanFriendlyNumber(tickValue)\n                                        : null,\n                                font: {\n                                    size: 10,\n                                    lineHeight: 1,\n                                },\n                            },\n                            grid: {\n                                tickBorderDash: [2],\n                                display: true,\n                                tickLength: 0,\n                            },\n                            alignToPixels: true,\n                            afterFit: (axis) => {\n                                // Remove unneccessary padding\n                                axis.paddingTop = 1 // 1px and not 0 to avoid clipping of the grid\n                                axis.paddingBottom = 1\n                            },\n                        },\n                    },\n                    plugins: {\n                        // @ts-expect-error Types of library are out of date\n                        crosshair: false,\n                        legend: {\n                            display: false,\n                        },\n                        tooltip: {\n                            enabled: false, // Using external tooltip\n                            external({ tooltip }) {\n                                setIsTooltipShown(tooltip.opacity > 0)\n                                setPopoverContent(\n                                    <InsightTooltip\n                                        embedded\n                                        hideInspectActorsSection\n                                        showHeader={!!labels}\n                                        altTitle={tooltip.dataPoints[0].label}\n                                        seriesData={tooltip.dataPoints.map((dp, i) => ({\n                                            id: i,\n                                            dataIndex: 0,\n                                            datasetIndex: 0,\n                                            label: dp.dataset.label,\n                                            color: dp.dataset.borderColor as string,\n                                            count: (dp.dataset.data?.[dp.dataIndex] as number) || 0,\n                                        }))}\n                                        renderSeries={(value) => value}\n                                        renderCount={(count) => humanFriendlyNumber(count)}\n                                    />\n                                )\n                            },\n                        },\n                    },\n                    maintainAspectRatio: false,\n                    interaction: {\n                        mode: 'index',\n                        axis: 'x',\n                        intersect: false,\n                    },\n                },\n            })\n        }\n        return () => {\n            chart?.destroy()\n        }\n    }, [labels, data])\n\n    const dataPointCount = adjustedData[0].values.length\n    const finalClassName = clsx(\n        dataPointCount > 16 ? 'w-64' : dataPointCount > 8 ? 'w-48' : dataPointCount > 4 ? 'w-32' : 'w-24',\n        className\n    )\n\n    return !loading ? (\n        <div className={finalClassName}>\n            <canvas ref={canvasRef} />\n            <Popover visible={isTooltipShown} overlay={popoverContent} placement=\"bottom-start\" padded={false}>\n                <div ref={tooltipRef} />\n            </Popover>\n        </div>\n    ) : (\n        <LemonSkeleton className={finalClassName} />\n    )\n}\n\nfunction isSparkLineTimeSeries(data: number[] | SparklineTimeSeries[]): data is SparklineTimeSeries[] {\n    return typeof data[0] !== 'number'\n}\n"],
  "mappings": "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",
  "names": ["init_dirname", "init_buffer", "init_process", "import_clsx", "import_react", "import_jsx_runtime", "Sparkline", "labels", "data", "type", "maximumIndicator", "loading", "className", "canvasRef", "tooltipRef", "isTooltipShown", "setIsTooltipShown", "popoverContent", "setPopoverContent", "adjustedData", "isSparkLineTimeSeries", "chart", "Chart", "_", "i", "timeseries", "color", "getColorVar", "tickValue", "humanFriendlyNumber", "axis", "tooltip", "InsightTooltip", "dp", "value", "count", "dataPointCount", "finalClassName", "clsx", "LemonSkeleton", "Popover"]
}
