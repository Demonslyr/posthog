{
  "version": 3,
  "sources": ["../src/lib/components/AuthorizedUrlList/authorizedUrlListLogic.ts"],
  "sourcesContent": ["import Fuse from 'fuse.js'\nimport {\n    actions,\n    afterMount,\n    connect,\n    kea,\n    key,\n    listeners,\n    path,\n    props,\n    reducers,\n    selectors,\n    sharedListeners,\n} from 'kea'\nimport { forms } from 'kea-forms'\nimport { loaders } from 'kea-loaders'\nimport { encodeParams, urlToAction } from 'kea-router'\nimport { subscriptions } from 'kea-subscriptions'\nimport api from 'lib/api'\nimport { lemonToast } from 'lib/lemon-ui/LemonToast'\nimport { isDomain, isURL } from 'lib/utils'\nimport { apiHostOrigin } from 'lib/utils/apiHost'\nimport { copyToClipboard } from 'lib/utils/copyToClipboard'\nimport { teamLogic } from 'scenes/teamLogic'\nimport { urls } from 'scenes/urls'\n\nimport { HogQLQuery, NodeKind } from '~/queries/schema/schema-general'\nimport { hogql } from '~/queries/utils'\nimport { ExperimentIdType, ToolbarParams, ToolbarUserIntent } from '~/types'\n\nimport type { authorizedUrlListLogicType } from './authorizedUrlListLogicType'\n\nexport interface ProposeNewUrlFormType {\n    url: string\n}\n\nexport enum AuthorizedUrlListType {\n    TOOLBAR_URLS = 'TOOLBAR_URLS',\n    RECORDING_DOMAINS = 'RECORDING_DOMAINS',\n    WEB_EXPERIMENTS = 'WEB_EXPERIMENTS',\n}\n\n/**\n * Firefox does not allow you construct a new URL with e.g. https://*.example.com (which is to be fair more standards compliant than Chrome)\n * when used to probe for e.g. for authorized urls we only care if the proposed URL has a path so we can safely replace the wildcard with a character\n * NB this changes its input and shouldn't be used for general purpose URL parsing\n */\nexport function sanitizePossibleWildCardedURL(url: string): URL {\n    const deWildCardedURL = url.replace(/\\*/g, 'x')\n    return new URL(deWildCardedURL)\n}\n\n/**\n * Checks if the URL has a wildcard (*) in the port position e.g. http://localhost:*\n */\nexport function hasPortWildcard(input: unknown): boolean {\n    if (!input || typeof input !== 'string') {\n        return false\n    }\n    // This regex matches URLs with a wildcard (*) in the port position\n    const portWildcardRegex = /^(https?:\\/\\/[^:/]+):\\*(.*)$/\n    return portWildcardRegex.test(input.trim())\n}\n\nexport const validateProposedUrl = (\n    proposedUrl: string,\n    currentUrls: string[],\n    onlyAllowDomains: boolean = false,\n    allowWildCards: boolean = true\n): string | undefined => {\n    if (!isURL(proposedUrl)) {\n        return 'Please enter a valid URL'\n    }\n\n    if (hasPortWildcard(proposedUrl)) {\n        return 'Wildcards are not allowed in the port position'\n    }\n\n    if (onlyAllowDomains && !isDomain(sanitizePossibleWildCardedURL(proposedUrl))) {\n        return \"Please enter a valid domain (URLs with a path aren't allowed)\"\n    }\n\n    const hasWildCard = proposedUrl.indexOf('*') > -1\n    if (hasWildCard && allowWildCards === false) {\n        return 'Wildcards are not allowed'\n    }\n\n    if (\n        hasWildCard &&\n        !/^https?:\\/\\/((\\*\\.)?localhost|localhost)(:\\d+)?$/.test(proposedUrl) && // Allow http://*.localhost and localhost with ports\n        !proposedUrl.match(/^(.*)\\*[^*]*\\.[^*]+\\.[^*]+$/)\n    ) {\n        return 'Wildcards can only be used for subdomains'\n    }\n\n    if (currentUrls.indexOf(proposedUrl) > -1) {\n        return `This ${onlyAllowDomains ? 'domains' : 'URL'} already is registered`\n    }\n\n    return\n}\n\nfunction buildToolbarParams(options?: {\n    actionId?: number | null\n    experimentId?: ExperimentIdType\n    userIntent?: ToolbarUserIntent\n}): ToolbarParams {\n    return {\n        userIntent:\n            options?.userIntent ??\n            (options?.actionId ? 'edit-action' : options?.experimentId ? 'edit-experiment' : 'add-action'),\n        // Make sure to pass the app url, otherwise the api_host will be used by\n        // the toolbar, which isn't correct when used behind a reverse proxy as\n        // we require e.g. SSO login to the app, which will not work when placed\n        // behind a proxy unless we register each domain with the OAuth2 client.\n        apiURL: apiHostOrigin(),\n        ...(options?.actionId ? { actionId: options.actionId } : {}),\n        ...(options?.experimentId ? { experimentId: options.experimentId } : {}),\n    }\n}\n\n/** defaultIntent: whether to launch with empty intent (i.e. toolbar mode is default) */\nexport function appEditorUrl(\n    appUrl: string,\n    options?: {\n        actionId?: number | null\n        experimentId?: ExperimentIdType\n        userIntent?: ToolbarUserIntent\n        generateOnly?: boolean\n    }\n): string {\n    const params = buildToolbarParams(options)\n    // See https://github.com/PostHog/posthog-js/blob/f7119c/src/extensions/toolbar.ts#L52 for where these params\n    // are passed. `appUrl` is an extra `redirect_to_site` param.\n    params['appUrl'] = appUrl\n    params['generateOnly'] = options?.generateOnly\n    return '/api/user/redirect_to_site/' + encodeParams(params, '?')\n}\n\nexport const checkUrlIsAuthorized = (url: string | URL, authorizedUrls: string[]): boolean => {\n    try {\n        const parsedUrl = typeof url === 'string' ? sanitizePossibleWildCardedURL(url) : url\n        const urlWithoutPath = parsedUrl.protocol + '//' + parsedUrl.host\n        // Is this domain already in the list of urls?\n        const exactMatch =\n            authorizedUrls.filter((authorizedUrl) => authorizedUrl.indexOf(urlWithoutPath) > -1).length > 0\n\n        if (exactMatch) {\n            return true\n        }\n\n        const wildcardMatch = !!authorizedUrls.find((authorizedUrl) => {\n            // Matches something like `https://*.example.com` against the urlWithoutPath\n            const regex = new RegExp(authorizedUrl.replace(/\\./g, '\\\\.').replace(/\\*/g, '.*'))\n            return urlWithoutPath.match(regex)\n        })\n\n        if (wildcardMatch) {\n            return true\n        }\n    } catch (error) {\n        // Ignore invalid URLs\n    }\n\n    return false\n}\n\nexport interface SuggestedDomain {\n    url: string\n    count: number\n}\n\nexport const filterNotAuthorizedUrls = (\n    suggestions: SuggestedDomain[],\n    authorizedUrls: string[]\n): SuggestedDomain[] => {\n    const suggestedDomains: SuggestedDomain[] = []\n\n    suggestions.forEach(({ url, count }) => {\n        const parsedUrl = sanitizePossibleWildCardedURL(url)\n        const urlWithoutPath = parsedUrl.protocol + '//' + parsedUrl.host\n        // Have we already added this domain?\n        if (suggestedDomains.some((sd) => sd.url === urlWithoutPath)) {\n            return\n        }\n\n        if (!checkUrlIsAuthorized(parsedUrl, authorizedUrls)) {\n            suggestedDomains.push({ url: urlWithoutPath, count })\n        }\n    })\n\n    return suggestedDomains\n}\n\nexport const NEW_URL = 'https://'\n\nexport interface KeyedAppUrl {\n    url: string\n    type: 'authorized' | 'suggestion'\n    originalIndex: number\n    // how many seen in the last three days\n    count?: number\n}\n\nexport interface AuthorizedUrlListLogicProps {\n    actionId: number | null\n    experimentId: ExperimentIdType | null\n    type: AuthorizedUrlListType\n    allowWildCards?: boolean\n}\n\nexport const defaultAuthorizedUrlProperties = {\n    actionId: null,\n    experimentId: null,\n}\n\nexport const authorizedUrlListLogic = kea<authorizedUrlListLogicType>([\n    path((key) => ['lib', 'components', 'AuthorizedUrlList', 'authorizedUrlListLogic', key]),\n    key((props) => `${props.type}-${props.experimentId}-${props.actionId}`), // Some will be undefined but that's ok, this avoids experiment/action with same ID sharing same store\n    props({} as AuthorizedUrlListLogicProps),\n    connect({\n        values: [teamLogic, ['currentTeam', 'currentTeamId']],\n        actions: [teamLogic, ['updateCurrentTeam']],\n    }),\n    actions(() => ({\n        setAuthorizedUrls: (authorizedUrls: string[]) => ({ authorizedUrls }),\n        addUrl: (url: string, launch?: boolean) => ({ url, launch }),\n        newUrl: true,\n        removeUrl: (index: number) => ({ index }),\n        updateUrl: (index: number, url: string) => ({ index, url }),\n        launchAtUrl: (url: string) => ({ url }),\n        setSearchTerm: (term: string) => ({ term }),\n        setEditUrlIndex: (originalIndex: number | null) => ({ originalIndex }),\n        cancelProposingUrl: true,\n        copyLaunchCode: (url: string) => ({ url }),\n    })),\n    loaders(({ values, props }) => ({\n        suggestions: {\n            __default: [] as SuggestedDomain[],\n            loadSuggestions: async () => {\n                const query: HogQLQuery = {\n                    kind: NodeKind.HogQLQuery,\n                    query: hogql`select properties.$current_url, count()\n                        from events\n                           where event = '$pageview'\n                           and timestamp >= now() - interval 3 day \n                            and timestamp <= now()\n                           and properties.$current_url is not null\n                         group by properties.$current_url\n                         order by count() desc\n                        limit 25`,\n                }\n\n                const response = await api.query(query)\n                const result = response.results as [string, number][]\n\n                if (result && result.length === 0) {\n                    return []\n                }\n\n                const suggestedDomains = filterNotAuthorizedUrls(\n                    result.map(([url, count]) => ({ url, count })),\n                    values.authorizedUrls\n                )\n\n                return suggestedDomains.slice(0, 20)\n            },\n        },\n        manualLaunchParams: {\n            loadManualLaunchParams: async (url: string): Promise<string | undefined> => {\n                const response = await api.get(\n                    appEditorUrl(url, {\n                        ...(props?.actionId ? { actionId: props.actionId } : {}),\n                        ...(props?.experimentId ? { experimentId: props.experimentId } : {}),\n                        generateOnly: true,\n                    })\n                )\n\n                let decoded: string | undefined = undefined\n                try {\n                    if (response?.toolbarParams) {\n                        decoded = decodeURIComponent(response.toolbarParams)\n                    }\n                } catch {\n                    lemonToast.error('Failed to generate toolbar params')\n                }\n                return decoded\n            },\n        },\n    })),\n    subscriptions(({ props, actions }) => ({\n        currentTeam: (currentTeam) => {\n            actions.setAuthorizedUrls(\n                (props.type === AuthorizedUrlListType.RECORDING_DOMAINS\n                    ? currentTeam.recording_domains\n                    : currentTeam.app_urls) || []\n            )\n        },\n    })),\n    afterMount(({ actions }) => {\n        actions.loadSuggestions()\n    }),\n    forms(({ values, actions, props }) => ({\n        proposedUrl: {\n            defaults: { url: '' } as ProposeNewUrlFormType,\n            errors: ({ url }) => ({\n                // default to allowing wildcards because that was the original behavior\n                url: validateProposedUrl(\n                    url,\n                    values.authorizedUrls,\n                    values.onlyAllowDomains,\n                    props.allowWildCards ?? true\n                ),\n            }),\n            submit: async ({ url }) => {\n                if (values.editUrlIndex !== null && values.editUrlIndex >= 0) {\n                    actions.updateUrl(values.editUrlIndex, url)\n                } else {\n                    actions.addUrl(url)\n                }\n            },\n        },\n    })),\n    reducers(() => ({\n        showProposedURLForm: [\n            false as boolean,\n            {\n                newUrl: () => true,\n                submitProposedUrlSuccess: () => false,\n                cancelProposingUrl: () => false,\n            },\n        ],\n        authorizedUrls: [\n            [] as string[],\n            {\n                setAuthorizedUrls: (_, { authorizedUrls }) => authorizedUrls,\n                addUrl: (state, { url }) => (!state.includes(url) ? state.concat([url]) : state),\n                updateUrl: (state, { index, url }) => Object.assign([...state], { [index]: url }),\n                removeUrl: (state, { index }) => {\n                    const newUrls = [...state]\n                    newUrls.splice(index, 1)\n                    return newUrls\n                },\n            },\n        ],\n        suggestions: [\n            [],\n            {\n                addUrl: (state, { url }) => [...state].filter((sd) => url !== sd.url),\n            },\n        ],\n        searchTerm: [\n            '',\n            {\n                setSearchTerm: (_, { term }) => term,\n            },\n        ],\n        editUrlIndex: [\n            null as number | null,\n            {\n                setEditUrlIndex: (_, { originalIndex }) => originalIndex,\n                removeUrl: (editUrlIndex, { index }) =>\n                    editUrlIndex && index < editUrlIndex\n                        ? editUrlIndex - 1\n                        : index === editUrlIndex\n                        ? null\n                        : editUrlIndex,\n                newUrl: () => -1,\n                updateUrl: () => null,\n                addUrl: () => null,\n                cancelProposingUrl: () => null,\n            },\n        ],\n    })),\n    sharedListeners(({ values, props }) => ({\n        saveUrls: async () => {\n            if (props.type === AuthorizedUrlListType.RECORDING_DOMAINS) {\n                await teamLogic.asyncActions.updateCurrentTeam({ recording_domains: values.authorizedUrls })\n            } else {\n                await teamLogic.asyncActions.updateCurrentTeam({ app_urls: values.authorizedUrls })\n            }\n        },\n    })),\n    listeners(({ sharedListeners, values, actions }) => ({\n        setEditUrlIndex: () => {\n            actions.setProposedUrlValue('url', values.urlToEdit)\n        },\n        newUrl: () => {\n            actions.setProposedUrlValue('url', NEW_URL)\n        },\n        addUrl: [\n            sharedListeners.saveUrls,\n            ({ url, launch }) => {\n                if (launch) {\n                    actions.launchAtUrl(url)\n                }\n            },\n        ],\n        removeUrl: sharedListeners.saveUrls,\n        updateUrl: sharedListeners.saveUrls,\n        launchAtUrl: ({ url }) => {\n            window.location.href = values.launchUrl(url)\n        },\n        cancelProposingUrl: () => {\n            actions.resetProposedUrl()\n        },\n        submitProposedUrlSuccess: () => {\n            actions.setEditUrlIndex(null)\n            actions.resetProposedUrl()\n        },\n        copyLaunchCode: ({ url }) => {\n            actions.loadManualLaunchParams(url)\n        },\n        loadManualLaunchParamsSuccess: async ({ manualLaunchParams }) => {\n            if (manualLaunchParams) {\n                const templateScript = `\n                if (!window?.posthog) {\n                    console.warn('PostHog must be added to the window object on this page, for this to work. This is normally done in the loaded callback of your posthog init code.')\n                } else {\n                    window.posthog.loadToolbar(${manualLaunchParams})\n                }\n                `\n                await copyToClipboard(templateScript, 'code to paste into the console')\n            }\n        },\n    })),\n    selectors({\n        urlToEdit: [\n            (s) => [s.authorizedUrls, s.editUrlIndex],\n            (authorizedUrls, editUrlIndex) => {\n                if (editUrlIndex === null || editUrlIndex === -1) {\n                    return NEW_URL\n                }\n                return authorizedUrls[editUrlIndex]\n            },\n        ],\n        urlsKeyed: [\n            (s) => [s.authorizedUrls, s.suggestions, s.searchTerm],\n            (authorizedUrls, suggestions, searchTerm): KeyedAppUrl[] => {\n                const keyedUrls = authorizedUrls\n                    .map((url, index) => ({\n                        url,\n                        type: 'authorized',\n                        originalIndex: index,\n                    }))\n                    .concat(\n                        suggestions.map(({ url, count }, index) => ({\n                            url,\n                            type: 'suggestion',\n                            originalIndex: index,\n                            count,\n                        }))\n                    ) as KeyedAppUrl[]\n\n                if (!searchTerm) {\n                    return keyedUrls\n                }\n\n                return new Fuse(keyedUrls, {\n                    keys: ['url'],\n                    threshold: 0.3,\n                })\n                    .search(searchTerm)\n                    .map((result) => result.item)\n            },\n        ],\n        launchUrl: [\n            (_, p) => [p.actionId, p.experimentId],\n            (actionId, experimentId) => (url: string) => {\n                if (experimentId) {\n                    return appEditorUrl(url, {\n                        experimentId,\n                    })\n                }\n\n                return appEditorUrl(url, {\n                    actionId,\n                })\n            },\n        ],\n        isAddUrlFormVisible: [(s) => [s.editUrlIndex], (editUrlIndex) => editUrlIndex === -1],\n        onlyAllowDomains: [(_, p) => [p.type], (type) => type === AuthorizedUrlListType.RECORDING_DOMAINS],\n\n        checkUrlIsAuthorized: [\n            (s) => [s.authorizedUrls],\n            (authorizedUrls) => (url: string) => {\n                return checkUrlIsAuthorized(url, authorizedUrls)\n            },\n        ],\n    }),\n    urlToAction(({ actions }) => ({\n        [urls.toolbarLaunch()]: (_, searchParams) => {\n            if (searchParams.addNew) {\n                actions.newUrl()\n            }\n        },\n    })),\n])\n"],
  "mappings": "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",
  "names": ["init_dirname", "init_buffer", "init_process", "import_kea", "import_kea_forms", "import_kea_loaders", "import_kea_router", "import_kea_subscriptions", "sanitizePossibleWildCardedURL", "url", "deWildCardedURL", "hasPortWildcard", "input", "validateProposedUrl", "proposedUrl", "currentUrls", "onlyAllowDomains", "allowWildCards", "isURL", "isDomain", "hasWildCard", "buildToolbarParams", "options", "apiHostOrigin", "appEditorUrl", "appUrl", "params", "checkUrlIsAuthorized", "authorizedUrls", "parsedUrl", "urlWithoutPath", "authorizedUrl", "regex", "filterNotAuthorizedUrls", "suggestions", "suggestedDomains", "count", "sd", "NEW_URL", "defaultAuthorizedUrlProperties", "authorizedUrlListLogic", "key", "props", "teamLogic", "launch", "index", "term", "originalIndex", "values", "query", "hogql", "result", "api_default", "response", "decoded", "lemonToast", "actions", "currentTeam", "_", "state", "newUrls", "editUrlIndex", "sharedListeners", "manualLaunchParams", "templateScript", "copyToClipboard", "s", "searchTerm", "keyedUrls", "Fuse", "p", "actionId", "experimentId", "type", "urls", "searchParams"]
}
