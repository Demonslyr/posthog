{
  "version": 3,
  "sources": ["../src/scenes/pipeline/transformationsLogic.tsx"],
  "sourcesContent": ["import { actions, afterMount, connect, kea, listeners, path, reducers, selectors } from 'kea'\nimport { loaders } from 'kea-loaders'\nimport api from 'lib/api'\nimport { projectLogic } from 'scenes/projectLogic'\nimport { userLogic } from 'scenes/userLogic'\n\nimport { PipelineStage, PluginConfigTypeNew, PluginConfigWithPluginInfoNew, PluginType } from '~/types'\n\nimport type { pipelineTransformationsLogicType } from './transformationsLogicType'\nimport { convertToPipelineNode, Transformation } from './types'\nimport { capturePluginEvent, checkPermissions, loadPluginsFromUrl } from './utils'\n\nexport const pipelineTransformationsLogic = kea<pipelineTransformationsLogicType>([\n    path(['scenes', 'pipeline', 'transformationsLogic']),\n    connect({\n        values: [projectLogic, ['currentProjectId'], userLogic, ['user']],\n    }),\n    actions({\n        loadPluginConfigs: true,\n        openReorderModal: true,\n        closeReorderModal: true,\n        setTemporaryOrder: (tempOrder: Record<number, number>) => ({\n            tempOrder,\n        }),\n        savePluginConfigsOrder: (newOrders: Record<number, number>) => ({ newOrders }),\n        updatePluginConfig: (pluginConfig: PluginConfigTypeNew) => ({ pluginConfig }),\n    }),\n    loaders(({ values }) => ({\n        plugins: [\n            {} as Record<number, PluginType>,\n            {\n                loadPlugins: async () => {\n                    return loadPluginsFromUrl('api/organizations/@current/pipeline_transformations')\n                },\n            },\n        ],\n        temporaryOrder: [\n            // empty or all enabled plugins map: plugin-id to order\n            {} as Record<number, number>,\n            {\n                setTemporaryOrder: async ({ tempOrder }) => tempOrder,\n                closeReorderModal: async () => ({}),\n            },\n        ],\n        pluginConfigs: [\n            {} as Record<number, PluginConfigTypeNew>,\n            {\n                loadPluginConfigs: async () => {\n                    const res = await api.loadPaginatedResults<PluginConfigTypeNew>(\n                        `api/projects/${values.currentProjectId}/pipeline_transformation_configs`\n                    )\n\n                    return Object.fromEntries(res.map((pluginConfig) => [pluginConfig.id, pluginConfig]))\n                },\n                savePluginConfigsOrder: async ({ newOrders }) => {\n                    if (!checkPermissions(PipelineStage.Transformation, false)) {\n                        return values.pluginConfigs\n                    }\n                    // Plugin-server sorts by order and runs the plugins in that order\n                    // we assume that there are no two enabled transformation plugins that have the same order value\n                    // But that's not true, see http://metabase-prod-us/question/341-processevent-plugins-ran-in-undetermined-order\n                    // We have races across enabling (ui and django admin) and reorder modal,\n                    // where parallel requests can result in the same order used for multiple plugins\n                    // TODO: maybe show warning if order match exist and allow to resolve them\n                    const { pluginConfigs } = values\n                    const response: PluginConfigTypeNew[] = await api.update(`api/plugin_config/rearrange`, {\n                        orders: newOrders,\n                    })\n\n                    const newPluginConfigs: Record<number, PluginConfigTypeNew> = { ...pluginConfigs }\n                    for (const pluginConfig of response) {\n                        // Rearrange currently returns all plugins not just processEvent plugins\n                        // so we need to filter out the non processEvent plugins, which is easiest done if we filter by\n                        // plugins loaded, alternatively we could just load plugin configs again from scratch.\n                        if (Object.keys(values.plugins).map(Number).includes(pluginConfig.plugin)) {\n                            newPluginConfigs[pluginConfig.id] = pluginConfig\n                        }\n                    }\n                    return newPluginConfigs\n                },\n                toggleEnabled: async ({ id, enabled }) => {\n                    if (!checkPermissions(PipelineStage.Transformation, enabled)) {\n                        return values.pluginConfigs\n                    }\n                    const { pluginConfigs, plugins } = values\n                    const pluginConfig = pluginConfigs[id]\n                    const plugin = plugins[pluginConfig.plugin]\n                    capturePluginEvent(`plugin ${enabled ? 'enabled' : 'disabled'}`, plugin, pluginConfig)\n                    // Update order if enabling to be at the end of current enabled plugins\n                    // See comment in savePluginConfigsOrder about races\n                    let order = {}\n                    if (enabled) {\n                        order = { order: values.nextAvailableOrder }\n                    }\n                    const response = await api.update(`api/plugin_config/${id}`, {\n                        enabled,\n                        ...order,\n                    })\n                    return { ...pluginConfigs, [id]: response }\n                },\n                updatePluginConfig: ({ pluginConfig }) => {\n                    return {\n                        ...values.pluginConfigs,\n                        [pluginConfig.id]: pluginConfig,\n                    }\n                },\n            },\n        ],\n    })),\n    selectors({\n        loading: [\n            (s) => [s.pluginsLoading, s.pluginConfigsLoading],\n            (pluginsLoading, pluginConfigsLoading) => pluginsLoading || pluginConfigsLoading,\n        ],\n        transformations: [\n            (s) => [s.pluginConfigs, s.plugins],\n            (pluginConfigs, plugins): Transformation[] => {\n                const rawTransformations: PluginConfigWithPluginInfoNew[] = Object.values(\n                    pluginConfigs\n                ).map<PluginConfigWithPluginInfoNew>((pluginConfig) => ({\n                    ...pluginConfig,\n                    plugin_info: plugins[pluginConfig.plugin] || null,\n                }))\n                const convertedTransformations = rawTransformations.map((t) =>\n                    convertToPipelineNode(t, PipelineStage.Transformation)\n                )\n                return convertedTransformations\n            },\n        ],\n        sortedEnabledTransformations: [\n            (s) => [s.transformations, s.temporaryOrder],\n            (transformations, temporaryOrder) => {\n                transformations = transformations.filter((t) => t.enabled)\n                if (temporaryOrder && Object.keys(temporaryOrder).length > 0) {\n                    transformations = Object.entries(temporaryOrder)\n                        .sort(([, aIdx], [, bIdx]) => aIdx - bIdx)\n                        .map(([pluginId]) => transformations.find((t) => t.id === Number(pluginId)) as Transformation)\n                } else {\n                    transformations = transformations.sort((a, b) => a.order - b.order)\n                }\n                return transformations\n            },\n        ],\n        sortedTransformations: [\n            (s) => [s.transformations, s.sortedEnabledTransformations],\n            (transformations, sortedEnabledTransformations) => {\n                return sortedEnabledTransformations.concat(\n                    transformations.filter((t) => !t.enabled).sort((a, b) => a.id - b.id)\n                )\n            },\n        ],\n        nextAvailableOrder: [\n            (s) => [s.transformations],\n            (transformations): number => {\n                const enabledTransformations = transformations.filter((t) => t.enabled)\n                return enabledTransformations.length > 0\n                    ? Math.max(...enabledTransformations.map((t) => t.order), 0) + 1\n                    : 0\n            },\n        ],\n    }),\n    reducers({\n        reorderModalOpen: [\n            false,\n            {\n                openReorderModal: () => true,\n                closeReorderModal: () => false,\n            },\n        ],\n    }),\n    listeners(({ actions }) => ({\n        savePluginConfigsOrderSuccess: () => {\n            actions.closeReorderModal()\n        },\n    })),\n    afterMount(({ actions }) => {\n        actions.loadPlugins()\n        actions.loadPluginConfigs()\n    }),\n])\n"],
  "mappings": "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",
  "names": ["init_dirname", "init_buffer", "init_process", "import_kea", "import_kea_loaders", "pipelineTransformationsLogic", "projectLogic", "userLogic", "tempOrder", "newOrders", "pluginConfig", "values", "loadPluginsFromUrl", "res", "api_default", "checkPermissions", "pluginConfigs", "response", "newPluginConfigs", "id", "enabled", "plugins", "plugin", "capturePluginEvent", "order", "s", "pluginsLoading", "pluginConfigsLoading", "t", "convertToPipelineNode", "transformations", "temporaryOrder", "aIdx", "bIdx", "pluginId", "a", "b", "sortedEnabledTransformations", "enabledTransformations", "actions"]
}
